var ckeditor =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 287);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = attachLinkToDocumentation;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/ckeditorerror
 */

/**
 * URL to the documentation with error codes.
 */
const DOCUMENTATION_URL =
	'https://ckeditor5.github.io/docs/nightly/ckeditor5/latest/framework/guides/support/error-codes.html';
/* unused harmony export DOCUMENTATION_URL */


/**
 * The CKEditor error class.
 *
 * All errors will be shortened during the minification process in order to reduce the code size.
 * Therefore, all error messages should be documented in the same way as those in {@link module:utils/log}.
 *
 * Read more in the {@link module:utils/log} module.
 *
 * @extends Error
 */
class CKEditorError extends Error {
	/**
	 * Creates an instance of the CKEditorError class.
	 *
	 * Read more about error logging in the {@link module:utils/log} module.
	 *
	 * @param {String} message The error message in an `error-name: Error message.` format.
	 * During the minification process the "Error message" part will be removed to limit the code size
	 * and a link to this error documentation will be added to the `message`.
	 * @param {Object} [data] Additional data describing the error. A stringified version of this object
	 * will be appended to the error message, so the data are quickly visible in the console. The original
	 * data object will also be later available under the {@link #data} property.
	 */
	constructor( message, data ) {
		message = attachLinkToDocumentation( message );

		if ( data ) {
			message += ' ' + JSON.stringify( data );
		}

		super( message );

		/**
		 * @member {String}
		 */
		this.name = 'CKEditorError';

		/**
		 * The additional error data passed to the constructor.
		 *
		 * @member {Object}
		 */
		this.data = data;
	}

	/**
	 * Checks if error is an instance of CKEditorError class.
	 *
	 * @param {Object} error Object to check.
	 * @returns {Boolean}
	 */
	static isCKEditorError( error ) {
		return error instanceof CKEditorError;
	}
}
/* harmony export (immutable) */ __webpack_exports__["b"] = CKEditorError;


/**
 * Attaches link to the documentation at the end of the error message.
 *
 * @param {String} message Message to be logged.
 * @returns {String}
 */
function attachLinkToDocumentation( message ) {
	const matchedErrorName = message.match( /^([^:]+):/ );

	if ( !matchedErrorName ) {
		return message;
	}

	return message + ` Read more: ${ DOCUMENTATION_URL }#${ matchedErrorName[ 1 ] }\n`;
}


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__treewalker__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_lib_lodash_last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_comparearrays__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__text__ = __webpack_require__(27);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/position
 */







/**
 * Represents a position in the model tree.
 *
 * **Note:** Position is based on offsets, not indexes. This means that position in element containing two text nodes
 * with data `foo` and `bar`, position between them has offset `3`, not `1`.
 * See {@link module:engine/model/position~Position#path} for more.
 *
 * Since position in a model is represented by a {@link module:engine/model/position~Position#root position root} and
 * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing elements.
 * This requirement is important for {@link module:engine/model/operation/transform~transform operational transformation}.
 *
 * Also, {@link module:engine/model/operation/operation~Operation operations}
 * kept in {@link module:engine/model/document~Document#history document history}
 * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct
 * after document got changed.
 *
 * When changes are applied to model, it may also happen that {@link module:engine/model/position~Position#parent position parent}
 * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,
 * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.
 *
 * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.
 */
class Position {
	/**
	 * Creates a position.
	 *
	 * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.
	 * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.
	 */
	constructor( root, path ) {
		if ( !root.is( 'element' ) && !root.is( 'documentFragment' ) ) {
			/**
			 * Position root is invalid.
			 *
			 * Positions can only be anchored in elements or document fragments.
			 *
			 * @error model-position-root-invalid
			 */
			throw new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-position-root-invalid: Position root invalid.' );
		}

		if ( !( path instanceof Array ) || path.length === 0 ) {
			/**
			 * Position path must be an array with at least one item.
			 *
			 * @error model-position-path-incorrect
			 * @param path
			 */
			throw new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-position-path-incorrect: Position path must be an array with at least one item.', { path } );
		}

		// Normalize the root and path (if element was passed).
		path = root.getPath().concat( path );
		root = root.root;

		/**
		 * Root of the position path.
		 *
		 * @readonly
		 * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}
		 * module:engine/model/position~Position#root
		 */
		this.root = root;

		/**
		 * Position of the node in the tree. **Path contains offsets, not indexes.**
		 *
		 * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has
		 * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are
		 * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,
		 * down to the position offset in it's parent.
		 *
		 *		 ROOT
		 *		  |- P            before: [ 0 ]         after: [ 1 ]
		 *		  |- UL           before: [ 1 ]         after: [ 2 ]
		 *		     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]
		 *		     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]
		 *		     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]
		 *		        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]
		 *
		 * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size
		 * greater than `1` you can place position offset between their start and end:
		 *
		 *		 ROOT
		 *		  |- P
		 *		  |- UL
		 *		     |- LI
		 *		     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]
		 *		     |- LI
		 *		        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]
		 *
		 * @member {Array.<Number>} module:engine/model/position~Position#path
		 */
		this.path = path;
	}

	/**
	 * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal
	 * to the last item in position {@link module:engine/model/position~Position#path path}.
	 *
	 * @type {Number}
	 */
	get offset() {
		return Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_lib_lodash_last__["a" /* default */])( this.path );
	}

	/**
	 * @param {Number} newOffset
	 */
	set offset( newOffset ) {
		this.path[ this.path.length - 1 ] = newOffset;
	}

	/**
	 * Parent element of this position.
	 *
	 * Keep in mind that `parent` value is calculated when the property is accessed.
	 * If {@link module:engine/model/position~Position#path position path}
	 * leads to a non-existing element, `parent` property will throw error.
	 *
	 * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).
	 *
	 * @readonly
	 * @type {module:engine/model/element~Element}
	 */
	get parent() {
		let parent = this.root;

		for ( let i = 0; i < this.path.length - 1; i++ ) {
			parent = parent.getChild( parent.offsetToIndex( this.path[ i ] ) );
		}

		return parent;
	}

	/**
	 * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is
	 * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed
	 * in text node, position index is equal to the index of that text node.
	 *
	 * @readonly
	 * @type {Number}
	 */
	get index() {
		return this.parent.offsetToIndex( this.offset );
	}

	/**
	 * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this
	 * position is not in a text node.
	 *
	 * @readonly
	 * @type {module:engine/model/text~Text|null}
	 */
	get textNode() {
		const node = this.parent.getChild( this.index );

		return ( node instanceof __WEBPACK_IMPORTED_MODULE_4__text__["a" /* default */] && node.startOffset < this.offset ) ? node : null;
	}

	/**
	 * Node directly after this position or `null` if this position is in text node.
	 *
	 * @readonly
	 * @type {module:engine/model/node~Node|null}
	 */
	get nodeAfter() {
		return this.textNode === null ? this.parent.getChild( this.index ) : null;
	}

	/**
	 * Node directly before this position or `null` if this position is in text node.
	 *
	 * @readonly
	 * @type {Node}
	 */
	get nodeBefore() {
		return this.textNode === null ? this.parent.getChild( this.index - 1 ) : null;
	}

	/**
	 * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isAtStart() {
		return this.offset === 0;
	}

	/**
	 * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isAtEnd() {
		return this.offset == this.parent.maxOffset;
	}

	/**
	 * Checks whether this position is before or after given position.
	 *
	 * @param {module:engine/model/position~Position} otherPosition Position to compare with.
	 * @returns {module:engine/model/position~PositionRelation}
	 */
	compareWith( otherPosition ) {
		if ( this.root != otherPosition.root ) {
			return 'different';
		}

		const result = Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( this.path, otherPosition.path );

		switch ( result ) {
			case 'same':
				return 'same';

			case 'prefix':
				return 'before';

			case 'extension':
				return 'after';

			default:
				if ( this.path[ result ] < otherPosition.path[ result ] ) {
					return 'before';
				} else {
					return 'after';
				}
		}
	}

	/**
	 * Gets the farthest position which matches the callback using
	 * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.
	 *
	 * For example:
	 *
	 * 		getLastMatchingPosition( value => value.type == 'text' );
	 * 		// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
	 *
	 * 		getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );
	 * 		// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>
	 *
	 * 		getLastMatchingPosition( value => false );
	 * 		// Do not move the position.
	 *
	 * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
	 * return `true` if the value should be skipped or `false` if not.
	 * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
	 *
	 * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.
	 */
	getLastMatchingPosition( skip, options = {} ) {
		options.startPosition = this;

		const treeWalker = new __WEBPACK_IMPORTED_MODULE_0__treewalker__["a" /* default */]( options );
		treeWalker.skip( skip );

		return treeWalker.position;
	}

	/**
	 * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}
	 * but without the last item.
	 *
	 * This method returns the parent path even if the parent does not exists.
	 *
	 * @returns {Array.<Number>} Path to the parent.
	 */
	getParentPath() {
		return this.path.slice( 0, -1 );
	}

	/**
	 * Returns ancestors array of this position, that is this position's parent and its ancestors.
	 *
	 * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.
	 */
	getAncestors() {
		if ( this.parent.is( 'documentFragment' ) ) {
			return [ this.parent ];
		} else {
			return this.parent.getAncestors( { includeSelf: true } );
		}
	}

	/**
	 * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}
	 * of these two paths must be identical.
	 *
	 * @param {module:engine/model/position~Position} position The second position.
	 * @returns {Array.<Number>} The common path.
	 */
	getCommonPath( position ) {
		if ( this.root != position.root ) {
			return [];
		}

		// We find on which tree-level start and end have the lowest common ancestor
		const cmp = Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( this.path, position.path );
		// If comparison returned string it means that arrays are same.
		const diffAt = ( typeof cmp == 'string' ) ? Math.min( this.path.length, position.path.length ) : cmp;

		return this.path.slice( 0, diffAt );
	}

	/**
	 * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
	 * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.
	 *
	 * @param {module:engine/model/position~Position} position The second position.
	 * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}
	 */
	getCommonAncestor( position ) {
		const ancestorsA = this.getAncestors();
		const ancestorsB = position.getAncestors();

		let i = 0;

		while ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {
			i++;
		}

		return i === 0 ? null : ancestorsA[ i - 1 ];
	}

	/**
	 * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset
	 * is shifted by `shift` value (can be a negative value).
	 *
	 * @param {Number} shift Offset shift. Can be a negative value.
	 * @returns {module:engine/model/position~Position} Shifted position.
	 */
	getShiftedBy( shift ) {
		const shifted = Position.createFromPosition( this );

		const offset = shifted.offset + shift;
		shifted.offset = offset < 0 ? 0 : offset;

		return shifted;
	}

	/**
	 * Checks whether this position is after given position.
	 *
	 * @see module:engine/model/position~Position#isBefore
	 *
	 * @param {module:engine/model/position~Position} otherPosition Position to compare with.
	 * @returns {Boolean} True if this position is after given position.
	 */
	isAfter( otherPosition ) {
		return this.compareWith( otherPosition ) == 'after';
	}

	/**
	 * Checks whether this position is before given position.
	 *
	 * **Note:** watch out when using negation of the value returned by this method, because the negation will also
	 * be `true` if positions are in different roots and you might not expect this. You should probably use
	 * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
	 * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
	 *
	 *		if ( a.isBefore( b ) && c.isAfter( d ) ) {
	 *			// do A.
	 *		} else {
	 *			// do B.
	 *		}
	 *
	 * or, if you have only one if-branch:
	 *
	 *		if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
	 *			// do B.
	 *		}
	 *
	 * rather than:
	 *
	 *		if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
	 *			// do B.
	 *		} else {
	 *			// do A.
	 *		}
	 *
	 * @param {module:engine/model/position~Position} otherPosition Position to compare with.
	 * @returns {Boolean} True if this position is before given position.
	 */
	isBefore( otherPosition ) {
		return this.compareWith( otherPosition ) == 'before';
	}

	/**
	 * Checks whether this position is equal to given position.
	 *
	 * @param {module:engine/model/position~Position} otherPosition Position to compare with.
	 * @returns {Boolean} True if positions are same.
	 */
	isEqual( otherPosition ) {
		return this.compareWith( otherPosition ) == 'same';
	}

	/**
	 * Checks whether this position is touching given position. Positions touch when there are no text nodes
	 * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
	 * they are very similar or even indistinguishable.
	 *
	 * **Note:** this method traverses model document so it can be only used when range is up-to-date with model document.
	 *
	 * @param {module:engine/model/position~Position} otherPosition Position to compare with.
	 * @returns {Boolean} True if positions touch.
	 */
	isTouching( otherPosition ) {
		let left = null;
		let right = null;
		const compare = this.compareWith( otherPosition );

		switch ( compare ) {
			case 'same':
				return true;

			case 'before':
				left = Position.createFromPosition( this );
				right = Position.createFromPosition( otherPosition );
				break;

			case 'after':
				left = Position.createFromPosition( otherPosition );
				right = Position.createFromPosition( this );
				break;

			default:
				return false;
		}

		// Cached for optimization purposes.
		let leftParent = left.parent;

		while ( left.path.length + right.path.length ) {
			if ( left.isEqual( right ) ) {
				return true;
			}

			if ( left.path.length > right.path.length ) {
				if ( left.offset !== leftParent.maxOffset ) {
					return false;
				}

				left.path = left.path.slice( 0, -1 );
				leftParent = leftParent.parent;
				left.offset++;
			} else {
				if ( right.offset !== 0 ) {
					return false;
				}

				right.path = right.path.slice( 0, -1 );
			}
		}
	}

	/**
	 * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.
	 * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
	 *
	 * @protected
	 * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.
	 * @param {Number} howMany How many nodes are removed.
	 * @returns {module:engine/model/position~Position|null} Transformed position or `null`.
	 */
	_getTransformedByDeletion( deletePosition, howMany ) {
		const transformed = Position.createFromPosition( this );

		// This position can't be affected if deletion was in a different root.
		if ( this.root != deletePosition.root ) {
			return transformed;
		}

		if ( Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( deletePosition.getParentPath(), this.getParentPath() ) == 'same' ) {
			// If nodes are removed from the node that is pointed by this position...
			if ( deletePosition.offset < this.offset ) {
				// And are removed from before an offset of that position...
				if ( deletePosition.offset + howMany > this.offset ) {
					// Position is in removed range, it's no longer in the tree.
					return null;
				} else {
					// Decrement the offset accordingly.
					transformed.offset -= howMany;
				}
			}
		} else if ( Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( deletePosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {
			// If nodes are removed from a node that is on a path to this position...
			const i = deletePosition.path.length - 1;

			if ( deletePosition.offset <= this.path[ i ] ) {
				// And are removed from before next node of that path...
				if ( deletePosition.offset + howMany > this.path[ i ] ) {
					// If the next node of that path is removed return null
					// because the node containing this position got removed.
					return null;
				} else {
					// Otherwise, decrement index on that path.
					transformed.path[ i ] -= howMany;
				}
			}
		}

		return transformed;
	}

	/**
	 * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.
	 *
	 * @protected
	 * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.
	 * @param {Number} howMany How many nodes are inserted.
	 * @param {Boolean} insertBefore Flag indicating whether nodes are inserted before or after `insertPosition`.
	 * This is important only when `insertPosition` and this position are same. If that is the case and the flag is
	 * set to `true`, this position will get transformed. If the flag is set to `false`, it won't.
	 * @returns {module:engine/model/position~Position} Transformed position.
	 */
	_getTransformedByInsertion( insertPosition, howMany, insertBefore ) {
		const transformed = Position.createFromPosition( this );

		// This position can't be affected if insertion was in a different root.
		if ( this.root != insertPosition.root ) {
			return transformed;
		}

		if ( Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( insertPosition.getParentPath(), this.getParentPath() ) == 'same' ) {
			// If nodes are inserted in the node that is pointed by this position...
			if ( insertPosition.offset < this.offset || ( insertPosition.offset == this.offset && insertBefore ) ) {
				// And are inserted before an offset of that position...
				// "Push" this positions offset.
				transformed.offset += howMany;
			}
		} else if ( Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( insertPosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {
			// If nodes are inserted in a node that is on a path to this position...
			const i = insertPosition.path.length - 1;

			if ( insertPosition.offset <= this.path[ i ] ) {
				// And are inserted before next node of that path...
				// "Push" the index on that path.
				transformed.path[ i ] += howMany;
			}
		}

		return transformed;
	}

	/**
	 * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
	 *
	 * @protected
	 * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.
	 * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.
	 * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.
	 * @param {Boolean} insertBefore Flag indicating whether moved nodes are pasted before or after `insertPosition`.
	 * This is important only when `targetPosition` and this position are same. If that is the case and the flag is
	 * set to `true`, this position will get transformed by range insertion. If the flag is set to `false`, it won't.
	 * @param {Boolean} [sticky] Flag indicating whether this position "sticks" to range, that is if it should be moved
	 * with the moved range if it is equal to one of range's boundaries.
	 * @returns {module:engine/model/position~Position} Transformed position.
	 */
	_getTransformedByMove( sourcePosition, targetPosition, howMany, insertBefore, sticky ) {
		// Moving a range removes nodes from their original position. We acknowledge this by proper transformation.
		let transformed = this._getTransformedByDeletion( sourcePosition, howMany );

		// Then we update target position, as it could be affected by nodes removal too.
		targetPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );

		if ( transformed === null || ( sticky && transformed.isEqual( sourcePosition ) ) ) {
			// This position is inside moved range (or sticks to it).
			// In this case, we calculate a combination of this position, move source position and target position.
			transformed = this._getCombined( sourcePosition, targetPosition );
		} else {
			// This position is not inside a removed range.
			// In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.
			transformed = transformed._getTransformedByInsertion( targetPosition, howMany, insertBefore );
		}

		return transformed;
	}

	/**
	 * Returns a new position that is a combination of this position and given positions.
	 *
	 * The combined position is a copy of this position transformed by moving a range starting at `source` position
	 * to the `target` position. It is expected that this position is inside the moved range.
	 *
	 * Example:
	 *
	 *		let original = new Position( root, [ 2, 3, 1 ] );
	 *		let source = new Position( root, [ 2, 2 ] );
	 *		let target = new Position( otherRoot, [ 1, 1, 3 ] );
	 *		original._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`
	 *
	 * Explanation:
	 *
	 * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
	 * was inside moved nodes and now should point to the new place. The moved nodes will be after
	 * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
	 * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
	 * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
	 * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
	 *
	 * @protected
	 * @param {module:engine/model/position~Position} source Beginning of the moved range.
	 * @param {module:engine/model/position~Position} target Position where the range is moved.
	 * @returns {module:engine/model/position~Position} Combined position.
	 */
	_getCombined( source, target ) {
		const i = source.path.length - 1;

		// The first part of a path to combined position is a path to the place where nodes were moved.
		const combined = Position.createFromPosition( target );

		// Then we have to update the rest of the path.

		// Fix the offset because this position might be after `from` position and we have to reflect that.
		combined.offset = combined.offset + this.path[ i ] - source.offset;

		// Then, add the rest of the path.
		// If this position is at the same level as `from` position nothing will get added.
		combined.path = combined.path.concat( this.path.slice( i + 1 ) );

		return combined;
	}

	/**
	 * Creates position at the given location. The location can be specified as:
	 *
	 * * a {@link module:engine/model/position~Position position},
	 * * parent element and offset (offset defaults to `0`),
	 * * parent element and `'end'` (sets position at the end of that element),
	 * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).
	 *
	 * This method is a shortcut to other constructors such as:
	 *
	 * * {@link module:engine/model/position~Position.createBefore},
	 * * {@link module:engine/model/position~Position.createAfter},
	 * * {@link module:engine/model/position~Position.createFromParentAndOffset},
	 * * {@link module:engine/model/position~Position.createFromPosition}.
	 *
	 * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
	 * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
	 * first parameter is a {@link module:engine/model/item~Item model item}.
	 */
	static createAt( itemOrPosition, offset ) {
		if ( itemOrPosition instanceof Position ) {
			return this.createFromPosition( itemOrPosition );
		} else {
			const node = itemOrPosition;

			if ( offset == 'end' ) {
				offset = node.maxOffset;
			} else if ( offset == 'before' ) {
				return this.createBefore( node );
			} else if ( offset == 'after' ) {
				return this.createAfter( node );
			} else if ( !offset ) {
				offset = 0;
			}

			return this.createFromParentAndOffset( node, offset );
		}
	}

	/**
	 * Creates a new position, after given {@link module:engine/model/item~Item model item}.
	 *
	 * @param {module:engine/model/item~Item} item Item after which the position should be placed.
	 * @returns {module:engine/model/position~Position}
	 */
	static createAfter( item ) {
		if ( !item.parent ) {
			/**
			 * You can not make a position after a root element.
			 *
			 * @error model-position-after-root
			 * @param {module:engine/model/item~Item} root
			 */
			throw new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-position-after-root: You cannot make a position after root.', { root: item } );
		}

		return this.createFromParentAndOffset( item.parent, item.endOffset );
	}

	/**
	 * Creates a new position, before the given {@link module:engine/model/item~Item model item}.
	 *
	 * @param {module:engine/model/item~Item} item Item before which the position should be placed.
	 * @returns {module:engine/model/position~Position}
	 */
	static createBefore( item ) {
		if ( !item.parent ) {
			/**
			 * You can not make a position before a root element.
			 *
			 * @error model-position-before-root
			 * @param {module:engine/model/item~Item} root
			 */
			throw new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-position-before-root: You cannot make a position before root.', { root: item } );
		}

		return this.createFromParentAndOffset( item.parent, item.startOffset );
	}

	/**
	 * Creates a new position from the parent element and an offset in that element.
	 *
	 * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent Position's parent.
	 * @param {Number} offset Position's offset.
	 * @returns {module:engine/model/position~Position}
	 */
	static createFromParentAndOffset( parent, offset ) {
		if ( !parent.is( 'element' ) && !parent.is( 'documentFragment' ) ) {
			/**
			 * Position parent have to be a model element or model document fragment.
			 *
			 * @error model-position-parent-incorrect
			 */
			throw new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-position-parent-incorrect: Position parent have to be a element or document fragment.' );
		}

		const path = parent.getPath();

		path.push( offset );

		return new this( parent.root, path );
	}

	/**
	 * Creates a new position, which is equal to passed position.
	 *
	 * @param {module:engine/model/position~Position} position Position to be cloned.
	 * @returns {module:engine/model/position~Position}
	 */
	static createFromPosition( position ) {
		return new this( position.root, position.path.slice() );
	}

	/**
	 * Creates a `Position` instance from given plain object (i.e. parsed JSON string).
	 *
	 * @param {Object} json Plain object to be converted to `Position`.
	 * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.
	 */
	static fromJSON( json, doc ) {
		if ( json.root === '$graveyard' ) {
			return new Position( doc.graveyard, json.path );
		}

		if ( !doc.hasRoot( json.root ) ) {
			/**
			 * Cannot create position for document. Root with specified name does not exist.
			 *
			 * @error model-position-fromjson-no-root
			 * @param {String} rootName
			 */
			throw new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.',
				{ rootName: json.root }
			);
		}

		return new Position( doc.getRoot( json.root ), json.path );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Position;


/**
 * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.
 * If positions are in different roots `'different'` flag is returned.
 *
 * @typedef {String} module:engine/model/position~PositionRelation
 */


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__treewalker__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/range
 */





/**
 * Range class. Range is iterable.
 */
class Range {
	/**
	 * Creates a range spanning from `start` position to `end` position.
	 *
	 * **Note:** Constructor creates it's own {@link module:engine/model/position~Position Position} instances basing on passed values.
	 *
	 * @param {module:engine/model/position~Position} start Start position.
	 * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.
	 */
	constructor( start, end = null ) {
		/**
		 * Start position.
		 *
		 * @readonly
		 * @member {module:engine/model/position~Position}
		 */
		this.start = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( start );

		/**
		 * End position.
		 *
		 * @readonly
		 * @member {module:engine/model/position~Position}
		 */
		this.end = end ? __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( end ) : __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( start );
	}

	/**
	 * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
	 * them together with additional information like length or {@link module:engine/model/position~Position positions},
	 * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.
	 * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range
	 * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.
	 *
	 * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range
	 * and `ignoreElementEnd` option set to `true`.
	 *
	 * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}
	 */
	* [ Symbol.iterator ]() {
		yield* new __WEBPACK_IMPORTED_MODULE_1__treewalker__["a" /* default */]( { boundaries: this, ignoreElementEnd: true } );
	}

	/**
	 * Returns whether the range is collapsed, that is if {@link #start} and
	 * {@link #end} positions are equal.
	 *
	 * @type {Boolean}
	 */
	get isCollapsed() {
		return this.start.isEqual( this.end );
	}

	/**
	 * Returns whether this range is flat, that is if {@link #start} position and
	 * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.
	 *
	 * @type {Boolean}
	 */
	get isFlat() {
		return this.start.parent === this.end.parent;
	}

	/**
	 * Range root element.
	 *
	 * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}
	 */
	get root() {
		return this.start.root;
	}

	/**
	 * Checks whether this range contains given {@link module:engine/model/position~Position position}.
	 *
	 * @param {module:engine/model/position~Position} position Position to check.
	 * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained
	 * in this range,`false` otherwise.
	 */
	containsPosition( position ) {
		return position.isAfter( this.start ) && position.isBefore( this.end );
	}

	/**
	 * Checks whether this range contains given {@link ~Range range}.
	 *
	 * @param {module:engine/model/range~Range} otherRange Range to check.
	 * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
	 * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
	 * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
	 * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.
	 */
	containsRange( otherRange, loose = false ) {
		if ( otherRange.isCollapsed ) {
			loose = false;
		}

		const containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );
		const containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );

		return containsStart && containsEnd;
	}

	/**
	 * Checks whether given {@link module:engine/model/item~Item} is inside this range.
	 *
	 * @param {module:engine/model/item~Item} item Model item to check.
	 */
	containsItem( item ) {
		const pos = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createBefore( item );

		return this.containsPosition( pos ) || this.start.isEqual( pos );
	}

	/**
	 * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.
	 *
	 * @param {module:engine/model/range~Range} otherRange Range to compare with.
	 * @returns {Boolean} `true` if ranges are equal, `false` otherwise.
	 */
	isEqual( otherRange ) {
		return this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end );
	}

	/**
	 * Checks and returns whether this range intersects with given range.
	 *
	 * @param {module:engine/model/range~Range} otherRange Range to compare with.
	 * @returns {Boolean} `true` if ranges intersect, `false` otherwise.
	 */
	isIntersecting( otherRange ) {
		return this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );
	}

	/**
	 * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.
	 * Returned array contains zero, one or two {@link ~Range ranges}.
	 *
	 * Examples:
	 *
	 *		let range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );
	 *		let otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 5 ] ) );
	 *		let transformed = range.getDifference( otherRange );
	 *		// transformed array has no ranges because `otherRange` contains `range`
	 *
	 *		otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 3 ] ) );
	 *		transformed = range.getDifference( otherRange );
	 *		// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
	 *
	 *		otherRange = new Range( new Position( root, [ 3 ] ), new Position( root, [ 4 ] ) );
	 *		transformed = range.getDifference( otherRange );
	 *		// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
	 *
	 * @param {module:engine/model/range~Range} otherRange Range to differentiate against.
	 * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.
	 */
	getDifference( otherRange ) {
		const ranges = [];

		if ( this.isIntersecting( otherRange ) ) {
			// Ranges intersect.

			if ( this.containsPosition( otherRange.start ) ) {
				// Given range start is inside this range. This means that we have to
				// add shrunken range - from the start to the middle of this range.
				ranges.push( new Range( this.start, otherRange.start ) );
			}

			if ( this.containsPosition( otherRange.end ) ) {
				// Given range end is inside this range. This means that we have to
				// add shrunken range - from the middle of this range to the end.
				ranges.push( new Range( otherRange.end, this.end ) );
			}
		} else {
			// Ranges do not intersect, return the original range.
			ranges.push( Range.createFromRange( this ) );
		}

		return ranges;
	}

	/**
	 * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.
	 * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
	 *
	 * Examples:
	 *
	 *		let range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );
	 *		let otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 2 ] ) );
	 *		let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
	 *
	 *		otherRange = new Range( new Position( root, [ 3 ] ), new Position( root, [ 5 ] ) );
	 *		transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
	 *
	 * @param {module:engine/model/range~Range} otherRange Range to check for intersection.
	 * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.
	 */
	getIntersection( otherRange ) {
		if ( this.isIntersecting( otherRange ) ) {
			// Ranges intersect, so a common range will be returned.
			// At most, it will be same as this range.
			let commonRangeStart = this.start;
			let commonRangeEnd = this.end;

			if ( this.containsPosition( otherRange.start ) ) {
				// Given range start is inside this range. This means thaNt we have to
				// shrink common range to the given range start.
				commonRangeStart = otherRange.start;
			}

			if ( this.containsPosition( otherRange.end ) ) {
				// Given range end is inside this range. This means that we have to
				// shrink common range to the given range end.
				commonRangeEnd = otherRange.end;
			}

			return new Range( commonRangeStart, commonRangeEnd );
		}

		// Ranges do not intersect, so they do not have common part.
		return null;
	}

	/**
	 * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.
	 *
	 * See an example of a model structure (`[` and `]` are range boundaries):
	 *
	 *		root                                                            root
	 *		 |- element DIV                         DIV             P2              P3             DIV
	 *		 |   |- element H                   H        P1        f o o           b a r       H         P4
	 *		 |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
	 *		 |   |- element P1
	 *		 |   |   |- "lorem"                                              ||
	 *		 |- element P2                                                   ||
	 *		 |   |- "foo"                                                    VV
	 *		 |- element P3
	 *		 |   |- "bar"                                                   root
	 *		 |- element DIV                         DIV             [P2             P3]             DIV
	 *		 |   |- element H                   H       [P1]       f o o           b a r        H         P4
	 *		 |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
	 *		 |   |- element P4
	 *		 |   |   |- "ipsum"
	 *
	 * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.
	 * We are looking for minimal set of flat ranges that contains the same nodes.
	 *
	 * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
	 *
	 *		( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
	 *		( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
	 *		( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
	 *		( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
	 *
	 * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned
	 * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range
	 * were omitted. Only their parts that were wholly in the range were returned.
	 *
	 * **Note:** this method is not returning flat ranges that contain no nodes.
	 *
	 * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.
	 */
	getMinimalFlatRanges() {
		const ranges = [];
		const diffAt = this.start.getCommonPath( this.end ).length;

		const pos = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( this.start );
		let posParent = pos.parent;

		// Go up.
		while ( pos.path.length > diffAt + 1 ) {
			const howMany = posParent.maxOffset - pos.offset;

			if ( howMany !== 0 ) {
				ranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );
			}

			pos.path = pos.path.slice( 0, -1 );
			pos.offset++;
			posParent = posParent.parent;
		}

		// Go down.
		while ( pos.path.length <= this.end.path.length ) {
			const offset = this.end.path[ pos.path.length - 1 ];
			const howMany = offset - pos.offset;

			if ( howMany !== 0 ) {
				ranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );
			}

			pos.offset = offset;
			pos.path.push( 0 );
		}

		return ranges;
	}

	/**
	 * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
	 *
	 * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
	 * @param {module:engine/model/position~Position} [options.startPosition]
	 * @param {Boolean} [options.singleCharacters=false]
	 * @param {Boolean} [options.shallow=false]
	 * @param {Boolean} [options.ignoreElementEnd=false]
	 */
	getWalker( options = {} ) {
		options.boundaries = this;

		return new __WEBPACK_IMPORTED_MODULE_1__treewalker__["a" /* default */]( options );
	}

	/**
	 * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
	 * them.
	 *
	 * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
	 * set to `true`. However it returns only {@link module:engine/model/item~Item model items},
	 * not {@link module:engine/model/treewalker~TreeWalkerValue}.
	 *
	 * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
	 * a full list of available options.
	 *
	 * @method getItems
	 * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
	 * @returns {Iterable.<module:engine/model/item~Item>}
	 */
	* getItems( options = {} ) {
		options.boundaries = this;
		options.ignoreElementEnd = true;

		const treeWalker = new __WEBPACK_IMPORTED_MODULE_1__treewalker__["a" /* default */]( options );

		for ( const value of treeWalker ) {
			yield value.item;
		}
	}

	/**
	 * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or
	 * contained in this range.
	 *
	 * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
	 * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.
	 *
	 * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
	 * a full list of available options.
	 *
	 * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
	 * @returns {Iterable.<module:engine/model/position~Position>}
	 */
	* getPositions( options = {} ) {
		options.boundaries = this;

		const treeWalker = new __WEBPACK_IMPORTED_MODULE_1__treewalker__["a" /* default */]( options );

		yield treeWalker.position;

		for ( const value of treeWalker ) {
			yield value.nextPosition;
		}
	}

	/**
	 * Returns a range that is a result of transforming this range by given `delta`.
	 *
	 * **Note:** transformation may break one range into multiple ranges (e.g. when a part of the range is
	 * moved to a different part of document tree). For this reason, an array is returned by this method and it
	 * may contain one or more `Range` instances.
	 *
	 * @param {module:engine/model/delta/delta~Delta} delta Delta to transform range by.
	 * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.
	 */
	getTransformedByDelta( delta ) {
		const ranges = [ Range.createFromRange( this ) ];

		// Operation types that a range can be transformed by.
		const supportedTypes = new Set( [ 'insert', 'move', 'remove', 'reinsert' ] );

		for ( const operation of delta.operations ) {
			if ( supportedTypes.has( operation.type ) ) {
				for ( let i = 0; i < ranges.length; i++ ) {
					const result = ranges[ i ]._getTransformedByDocumentChange(
						operation.type,
						delta.type,
						operation.targetPosition || operation.position,
						operation.howMany || operation.nodes.maxOffset,
						operation.sourcePosition
					);

					ranges.splice( i, 1, ...result );

					i += result.length - 1;
				}
			}
		}

		return ranges;
	}

	/**
	 * Returns a range that is a result of transforming this range by multiple `deltas`.
	 *
	 * **Note:** transformation may break one range into multiple ranges (e.g. when a part of the range is
	 * moved to a different part of document tree). For this reason, an array is returned by this method and it
	 * may contain one or more `Range` instances.
	 *
	 * @param {Iterable.<module:engine/model/delta/delta~Delta>} deltas Deltas to transform the range by.
	 * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.
	 */
	getTransformedByDeltas( deltas ) {
		const ranges = [ Range.createFromRange( this ) ];

		for ( const delta of deltas ) {
			for ( let i = 0; i < ranges.length; i++ ) {
				const result = ranges[ i ].getTransformedByDelta( delta );

				ranges.splice( i, 1, ...result );
				i += result.length - 1;
			}
		}

		// It may happen that a range is split into two, and then the part of second "piece" is moved into first
		// "piece". In this case we will have incorrect third range, which should not be included in the result --
		// because it is already included in the first "piece". In this loop we are looking for all such ranges that
		// are inside other ranges and we simply remove them.
		for ( let i = 0; i < ranges.length; i++ ) {
			const range = ranges[ i ];

			for ( let j = i + 1; j < ranges.length; j++ ) {
				const next = ranges[ j ];

				if ( range.containsRange( next ) || next.containsRange( range ) || range.isEqual( next ) ) {
					ranges.splice( j, 1 );
				}
			}
		}

		return ranges;
	}

	/**
	 * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
	 * which is a common ancestor of the range's both ends (in which the entire range is contained).
	 *
	 * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}
	 */
	getCommonAncestor() {
		return this.start.getCommonAncestor( this.end );
	}

	/**
	 * Returns a range that is a result of transforming this range by a change in the model document.
	 *
	 * @protected
	 * @param {'insert'|'move'|'remove'|'reinsert'} type Change type.
	 * @param {String} deltaType Type of delta that introduced the change.
	 * @param {module:engine/model/position~Position} targetPosition Position before the first changed node.
	 * @param {Number} howMany How many nodes has been changed.
	 * @param {module:engine/model/position~Position} sourcePosition Source position of changes.
	 * @returns {Array.<module:engine/model/range~Range>}
	 */
	_getTransformedByDocumentChange( type, deltaType, targetPosition, howMany, sourcePosition ) {
		if ( type == 'insert' ) {
			return this._getTransformedByInsertion( targetPosition, howMany, false, false );
		} else {
			const sourceRange = Range.createFromPositionAndShift( sourcePosition, howMany );

			// Edge case for merge delta.
			if (
				deltaType == 'merge' &&
				this.isCollapsed &&
				( this.start.isEqual( sourceRange.start ) || this.start.isEqual( sourceRange.end ) )
			) {
				// Collapsed range is in merged element, at the beginning or at the end of it.
				// Without fix, the range would end up in the graveyard, together with removed element.
				// <p>foo</p><p>[]bar</p> -> <p>foobar</p><p>[]</p> -> <p>foobar</p> -> <p>foo[]bar</p>
				// <p>foo</p><p>bar[]</p> -> <p>foobar</p><p>[]</p> -> <p>foobar</p> -> <p>foobar[]</p>
				//
				// In most cases, `sourceRange.start.offset` for merge delta's move operation would be 0,
				// so this formula might look overcomplicated.
				// However in some scenarios, after operational transformation, move operation might not
				// in fact start from 0 and we need to properly count new offset.
				// https://github.com/ckeditor/ckeditor5-engine/pull/1133#issuecomment-329080668.
				const offset = this.start.offset - sourceRange.start.offset;

				return [ new Range( targetPosition.getShiftedBy( offset ) ) ];
			}
			//
			// Edge case for split delta.
			//
			if ( deltaType == 'split' && this.isCollapsed && this.end.isEqual( sourceRange.end ) ) {
				// Collapsed range is at the end of split element.
				// Without fix, the range would end up at the end of split (old) element instead of at the end of new element.
				// That would happen because this range is not technically inside moved range. Last step below shows the fix.
				// <p>foobar[]</p> -> <p>foobar[]</p><p></p> -> <p>foo[]</p><p>bar</p> -> <p>foo</p><p>bar[]</p>
				return [ new Range( targetPosition.getShiftedBy( howMany ) ) ];
			}
			//
			// Other edge cases:
			//
			// In all examples `[]` is `this` and `{}` is `sourceRange`, while `^` is move target position.
			//
			// Example:
			// <p>xx</p>^<w>{<p>a[b</p>}</w><p>c]d</p>   -->   <p>xx</p><p>a[b</p><w></w><p>c]d</p>
			// ^<p>xx</p><w>{<p>a[b</p>}</w><p>c]d</p>   -->   <p>a[b</p><p>xx</p><w></w><p>c]d</p>  // Note <p>xx</p> inclusion.
			// <w>{<p>a[b</p>}</w>^<p>c]d</p>            -->   <w></w><p>a[b</p><p>c]d</p>
			if (
				( sourceRange.containsPosition( this.start ) || sourceRange.start.isEqual( this.start ) ) &&
				this.containsPosition( sourceRange.end ) &&
				this.end.isAfter( targetPosition )
			) {
				const start = this.start._getCombined(
					sourcePosition,
					targetPosition._getTransformedByDeletion( sourcePosition, howMany )
				);
				const end = this.end._getTransformedByMove( sourcePosition, targetPosition, howMany, false, false );

				return [ new Range( start, end ) ];
			}

			// Example:
			// <p>c[d</p><w>{<p>a]b</p>}</w>^<p>xx</p>   -->   <p>c[d</p><w></w><p>a]b</p><p>xx</p>
			// <p>c[d</p><w>{<p>a]b</p>}</w><p>xx</p>^   -->   <p>c[d</p><w></w><p>xx</p><p>a]b</p>  // Note <p>xx</p> inclusion.
			// <p>c[d</p>^<w>{<p>a]b</p>}</w>            -->   <p>c[d</p><p>a]b</p><w></w>
			if (
				( sourceRange.containsPosition( this.end ) || sourceRange.end.isEqual( this.end ) ) &&
				this.containsPosition( sourceRange.start ) &&
				this.start.isBefore( targetPosition )
			) {
				const start = this.start._getTransformedByMove(
					sourcePosition,
					targetPosition,
					howMany,
					true,
					false
				);
				const end = this.end._getCombined(
					sourcePosition,
					targetPosition._getTransformedByDeletion( sourcePosition, howMany )
				);

				return [ new Range( start, end ) ];
			}

			return this._getTransformedByMove( sourcePosition, targetPosition, howMany );
		}
	}

	/**
	 * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this
	 * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are
	 * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.
	 *
	 * Examples:
	 *
	 *		let range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );
	 *		let transformed = range._getTransformedByInsertion( new Position( root, [ 1 ] ), 2 );
	 *		// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
	 *
	 *		transformed = range._getTransformedByInsertion( new Position( root, [ 4, 0, 0 ] ), 4 );
	 *		// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
	 *
	 *		transformed = range._getTransformedByInsertion( new Position( root, [ 3, 2 ] ), 4 );
	 *		// transformed array has one range, which is equal to original range
	 *
	 *		transformed = range._getTransformedByInsertion( new Position( root, [ 3, 2 ] ), 4, true );
	 *		// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
	 *
	 *		transformed = range._getTransformedByInsertion( new Position( root, [ 4, 0, 1 ] ), 4, false, false );
	 *		// transformed array has one range which is equal to original range because insertion is after the range boundary
	 *
	 *		transformed = range._getTransformedByInsertion( new Position( root, [ 4, 0, 1 ] ), 4, false, true );
	 *		// transformed array has one range: from [ 2, 7 ] to [ 4, 0, 5 ] because range was expanded
	 *
	 * @protected
	 * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.
	 * @param {Number} howMany How many nodes are inserted.
	 * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion
	 * was inside the range. Defaults to `false`.
	 * @param {Boolean} [isSticky] Flag indicating whether insertion should expand a range if it is in a place of
	 * range boundary. Defaults to `false`.
	 * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.
	 */
	_getTransformedByInsertion( insertPosition, howMany, spread = false, isSticky = false ) {
		if ( spread && this.containsPosition( insertPosition ) ) {
			// Range has to be spread. The first part is from original start to the spread point.
			// The other part is from spread point to the original end, but transformed by
			// insertion to reflect insertion changes.

			return [
				new Range( this.start, insertPosition ),
				new Range(
					insertPosition._getTransformedByInsertion( insertPosition, howMany, true ),
					this.end._getTransformedByInsertion( insertPosition, howMany, this.isCollapsed )
				)
			];
		} else {
			const range = Range.createFromRange( this );

			const insertBeforeStart = !isSticky;
			const insertBeforeEnd = range.isCollapsed ? true : isSticky;

			range.start = range.start._getTransformedByInsertion( insertPosition, howMany, insertBeforeStart );
			range.end = range.end._getTransformedByInsertion( insertPosition, howMany, insertBeforeEnd );

			return [ range ];
		}
	}

	/**
	 * Returns an array containing {@link ~Range ranges} that are a result of transforming this
	 * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
	 *
	 * @protected
	 * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.
	 * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.
	 * @param {Number} howMany How many nodes are moved.
	 * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.
	 */
	_getTransformedByMove( sourcePosition, targetPosition, howMany ) {
		if ( this.isCollapsed ) {
			const newPos = this.start._getTransformedByMove( sourcePosition, targetPosition, howMany, true, false );

			return [ new Range( newPos ) ];
		}

		let result;

		const moveRange = new Range( sourcePosition, sourcePosition.getShiftedBy( howMany ) );

		const differenceSet = this.getDifference( moveRange );
		let difference = null;

		const common = this.getIntersection( moveRange );

		if ( differenceSet.length == 1 ) {
			// `moveRange` and this range may intersect.
			difference = new Range(
				differenceSet[ 0 ].start._getTransformedByDeletion( sourcePosition, howMany ),
				differenceSet[ 0 ].end._getTransformedByDeletion( sourcePosition, howMany )
			);
		} else if ( differenceSet.length == 2 ) {
			// `moveRange` is inside this range.
			difference = new Range(
				this.start,
				this.end._getTransformedByDeletion( sourcePosition, howMany )
			);
		} // else, `moveRange` contains this range.

		const insertPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );

		if ( difference ) {
			result = difference._getTransformedByInsertion( insertPosition, howMany, common !== null );
		} else {
			result = [];
		}

		if ( common ) {
			result.push( new Range(
				common.start._getCombined( moveRange.start, insertPosition ),
				common.end._getCombined( moveRange.start, insertPosition )
			) );
		}

		return result;
	}

	/**
	 * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by
	 * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
	 *
	 * @param {module:engine/model/position~Position} position Beginning of the range.
	 * @param {Number} shift How long the range should be.
	 * @returns {module:engine/model/range~Range}
	 */
	static createFromPositionAndShift( position, shift ) {
		const start = position;
		const end = position.getShiftedBy( shift );

		return shift > 0 ? new this( start, end ) : new this( end, start );
	}

	/**
	 * Creates a range from given parents and offsets.
	 *
	 * @param {module:engine/model/element~Element} startElement Start position parent element.
	 * @param {Number} startOffset Start position offset.
	 * @param {module:engine/model/element~Element} endElement End position parent element.
	 * @param {Number} endOffset End position offset.
	 * @returns {module:engine/model/range~Range}
	 */
	static createFromParentsAndOffsets( startElement, startOffset, endElement, endOffset ) {
		return new this(
			__WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromParentAndOffset( startElement, startOffset ),
			__WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromParentAndOffset( endElement, endOffset )
		);
	}

	/**
	 * Creates a new instance of `Range` which is equal to passed range.
	 *
	 * @param {module:engine/model/range~Range} range Range to clone.
	 * @returns {module:engine/model/range~Range}
	 */
	static createFromRange( range ) {
		return new this( range.start, range.end );
	}

	/**
	 * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
	 * that element and ends after the last child of that element.
	 *
	 * @param {module:engine/model/element~Element} element Element which is a parent for the range.
	 * @returns {module:engine/model/range~Range}
	 */
	static createIn( element ) {
		return this.createFromParentsAndOffsets( element, 0, element, element.maxOffset );
	}

	/**
	 * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.
	 *
	 * @param {module:engine/model/item~Item} item
	 * @returns {module:engine/model/range~Range}
	 */
	static createOn( item ) {
		return this.createFromPositionAndShift( __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createBefore( item ), item.offsetSize );
	}

	/**
	 * Creates a collapsed range at given {@link module:engine/model/position~Position position}
	 * or on the given {@link module:engine/model/item~Item item}.
	 *
	 * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
	 * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
	 * first parameter is a {@link module:engine/model/item~Item model item}.
	 */
	static createCollapsedAt( itemOrPosition, offset ) {
		const start = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( itemOrPosition, offset );
		const end = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( start );

		return new Range( start, end );
	}

	/**
	 * Combines all ranges from the passed array into a one range. At least one range has to be passed.
	 * Passed ranges must not have common parts.
	 *
	 * The first range from the array is a reference range. If other ranges start or end on the exactly same position where
	 * the reference range, they get combined into one range.
	 *
	 *		[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted
	 *		[    ]                                       // The result of the function if the first range was a reference range.
	 *	            [                           ]        // The result of the function if the third-to-seventh range was a reference range.
	 *	                                           [  ]  // The result of the function if the last range was a reference range.
	 *
	 * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.
	 * @returns {module:engine/model/range~Range} Combined range.
	 */
	static createFromRanges( ranges ) {
		if ( ranges.length === 0 ) {
			/**
			 * At least one range has to be passed to
			 * {@link module:engine/model/range~Range.createFromRanges `Range.createFromRanges()`}.
			 *
			 * @error range-create-from-ranges-empty-array
			 */
			throw new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'range-create-from-ranges-empty-array: At least one range has to be passed.' );
		} else if ( ranges.length == 1 ) {
			return this.createFromRange( ranges[ 0 ] );
		}

		// 1. Set the first range in `ranges` array as a reference range.
		// If we are going to return just a one range, one of the ranges need to be the reference one.
		// Other ranges will be stuck to that range, if possible.
		const ref = ranges[ 0 ];

		// 2. Sort all the ranges so it's easier to process them.
		ranges.sort( ( a, b ) => {
			return a.start.isAfter( b.start ) ? 1 : -1;
		} );

		// 3. Check at which index the reference range is now.
		const refIndex = ranges.indexOf( ref );

		// 4. At this moment we don't need the original range.
		// We are going to modify the result and we need to return a new instance of Range.
		// We have to create a copy of the reference range.
		const result = new this( ref.start, ref.end );

		// 5. Ranges should be checked and glued starting from the range that is closest to the reference range.
		// Since ranges are sorted, start with the range with index that is closest to reference range index.
		for ( let i = refIndex - 1; i >= 0; i++ ) {
			if ( ranges[ i ].end.isEqual( result.start ) ) {
				result.start = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( ranges[ i ].start );
			} else {
				// If ranges are not starting/ending at the same position there is no point in looking further.
				break;
			}
		}

		// 6. Ranges should be checked and glued starting from the range that is closest to the reference range.
		// Since ranges are sorted, start with the range with index that is closest to reference range index.
		for ( let i = refIndex + 1; i < ranges.length; i++ ) {
			if ( ranges[ i ].start.isEqual( result.end ) ) {
				result.end = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( ranges[ i ].end );
			} else {
				// If ranges are not starting/ending at the same position there is no point in looking further.
				break;
			}
		}

		return result;
	}

	/**
	 * Creates a `Range` instance from given plain object (i.e. parsed JSON string).
	 *
	 * @param {Object} json Plain object to be converted to `Range`.
	 * @param {module:engine/model/document~Document} doc Document object that will be range owner.
	 * @returns {module:engine/model/element~Element} `Range` instance created using given plain object.
	 */
	static fromJSON( json, doc ) {
		return new this( __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].fromJSON( json.start, doc ), __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].fromJSON( json.end, doc ) );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Range;



/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module core/plugin
 */




/**
 * The base class for CKEditor plugin classes.
 *
 * @implements module:core/plugin~PluginInterface
 * @mixes module:utils/observablemixin~ObservableMixin
 */
class Plugin {
	/**
	 * @inheritDoc
	 */
	constructor( editor ) {
		/**
		 * The editor instance.
		 *
		 * @readonly
		 * @member {module:core/editor/editor~Editor} #editor
		 */
		this.editor = editor;
	}

	/**
	 * @inheritDoc
	 */
	destroy() {
		this.stopListening();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Plugin;


Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Plugin, __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );

/**
 * The base interface for CKEditor plugins.
 *
 * In its minimal form it can be a simple function (it will be used as a constructor) which accepts
 * {@link module:core/editor/editor~Editor the editor} as a parm.
 * It can also implement a few methods which, when present, will be used to properly initialize and destroy the plugin.
 *
 *		// A simple plugin which enables a data processor.
 *		function MyPlugin( editor ) {
 *			editor.data.processor = new MyDataProcessor();
 *		}
 *
 * In most cases, however, you'll want to inherit from the {@link module:core/plugin~Plugin} class which implements the
 * {@link module:utils/observablemixin~ObservableMixin} and is, therefore, more convenient:
 *
 *		class MyPlugin extends Plugin {
 *			init() {
 *				// `listenTo()` and `editor` are available thanks to `Plugin`.
 *				// By using `listenTo()` you'll ensure that the listener will be removed when
 *				// the plugin is destroyed.
 *				this.listenTo( this.editor, 'dataReady', () => {
 *					// Do something when data is ready.
 *				} );
 *			}
 *		}
 *
 * @interface PluginInterface
 */

/**
 * Creates a new plugin instance. This is the first step of a plugin initialization.
 * See also {@link #init} and {@link #afterInit}.
 *
 * A plugin is always instantiated after its {@link module:core/plugin~PluginInterface.requires dependencies} and the
 * {@link #init} and {@link #afterInit} methods are called in the same order.
 *
 * Usually, you'll want to put your plugin's initialization code in the {@link #init} method.
 * The constructor can be understood as "before init" and used in special cases, just like
 * {@link #afterInit} servers for the special "after init" scenarios (e.g. code which depends on other
 * plugins, but which doesn't {@link module:core/plugin~PluginInterface.requires explicitly require} them).
 *
 * @method #constructor
 * @param {module:core/editor/editor~Editor} editor
 */

/**
 * An array of plugins required by this plugin.
 *
 * To keep a plugin class definition tight it's recommended to define this property as a static getter:
 *
 *		import Image from './image.js';
 *
 *		export default class ImageCaption {
 *			static get requires() {
 *				return [ Image ];
 *			}
 *		}
 *
 * @static
 * @readonly
 * @member {Array.<Function>|undefined} module:core/plugin~PluginInterface.requires
 */

/**
 * Optional name of the plugin. If set, the plugin will be available in
 * {@link module:core/plugincollection~PluginCollection#get} by its
 * name and its constructor. If not, then only by its constructor.
 *
 * The name should reflect the constructor name.
 *
 * To keep a plugin class definition tight it's recommended to define this property as a static getter:
 *
 *		export default class ImageCaption {
 *			static get pluginName() {
 *				return 'ImageCaption';
 *			}
 *		}
 *
 * Note: The native `Function.name` property could not be used to keep the plugin name because
 * it will be mangled during code minification.
 *
 * Naming a plugin is necessary to enable removing it through the
 * {@link module:core/editor/editorconfig~EditorConfig#removePlugins `config.removePlugins`} option.
 *
 * @static
 * @readonly
 * @member {String|undefined} module:core/plugin~PluginInterface.pluginName
 */

/**
 * The second stage (after plugin {@link #constructor}) of plugin initialization.
 * Unlike the plugin constructor this method can be asynchronous.
 *
 * A plugin's `init()` method is called after its {@link module:core/plugin~PluginInterface.requires dependencies} are initialized,
 * so in the same order as constructors of these plugins.
 *
 * **Note:** This method is optional. A plugin instance does not need to have to have it defined.
 *
 * @method #init
 * @returns {null|Promise}
 */

/**
 * The third (and last) stage of plugin initialization. See also {@link #constructor} and {@link #init}.
 *
 * **Note:** This method is optional. A plugin instance does not need to have to have it defined.
 *
 * @method #afterInit
 * @returns {null|Promise}
 */

/**
 * Destroys the plugin.
 *
 * **Note:** This method is optional. A plugin instance does not need to have to have it defined.
 *
 * @method #destroy
 * @returns {null|Promise}
 */


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = mix;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/mix
 */

/**
 * Copies enumerable properties and symbols from the objects given as 2nd+ parameters to the
 * prototype of first object (a constructor).
 *
 *		class Editor {
 *			...
 *		}
 *
 *		const SomeMixin = {
 *			a() {
 *				return 'a';
 *			}
 *		};
 *
 *		mix( Editor, SomeMixin, ... );
 *
 *		new Editor().a(); // -> 'a'
 *
 * Note: Properties which already exist in the base class will not be overriden.
 *
 * @param {Function} [baseClass] Class which prototype will be extended.
 * @param {Object} [...mixins] Objects from which to get properties.
 */
function mix( baseClass, ...mixins ) {
	mixins.forEach( mixin => {
		Object.getOwnPropertyNames( mixin ).concat( Object.getOwnPropertySymbols( mixin ) )
			.forEach( key => {
				if ( key in baseClass.prototype ) {
					return;
				}

				const sourceDescriptor = Object.getOwnPropertyDescriptor( mixin, key );
				sourceDescriptor.enumerable = false;

				Object.defineProperty( baseClass.prototype, key, sourceDescriptor );
			} );
	} );
}


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__nodelist__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__text__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_isiterable__ = __webpack_require__(34);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/element
 */






/**
 * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and
 * {@link module:engine/model/element~Element#getChildren child nodes}.
 *
 * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.
 */
class Element extends __WEBPACK_IMPORTED_MODULE_0__node__["a" /* default */] {
	/**
	 * Creates a model element.
	 *
	 * @param {String} name Element's name.
	 * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
	 * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]
	 * One or more nodes to be inserted as children of created element.
	 */
	constructor( name, attrs, children ) {
		super( attrs );

		/**
		 * Element name.
		 *
		 * @member {String} module:engine/model/element~Element#name
		 */
		this.name = name;

		/**
		 * List of children nodes.
		 *
		 * @private
		 * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children
		 */
		this._children = new __WEBPACK_IMPORTED_MODULE_1__nodelist__["a" /* default */]();

		if ( children ) {
			this.insertChildren( 0, children );
		}
	}

	/**
	 * Number of this element's children.
	 *
	 * @readonly
	 * @type {Number}
	 */
	get childCount() {
		return this._children.length;
	}

	/**
	 * Sum of {module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.
	 *
	 * @readonly
	 * @type {Number}
	 */
	get maxOffset() {
		return this._children.maxOffset;
	}

	/**
	 * Is `true` if there are no nodes inside this element, `false` otherwise.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isEmpty() {
		return this.childCount === 0;
	}

	/**
	 * Checks whether given model tree object is of given type.
	 *
	 *		obj.name; // 'listItem'
	 *		obj instanceof Element; // true
	 *
	 *		obj.is( 'element' ); // true
	 *		obj.is( 'listItem' ); // true
	 *		obj.is( 'element', 'listItem' ); // true
	 *		obj.is( 'text' ); // false
	 *		obj.is( 'element', 'image' ); // false
	 *
	 * Read more in {@link module:engine/model/node~Node#is}.
	 *
	 * @param {String} type Type to check when `name` parameter is present.
	 * Otherwise, it acts like the `name` parameter.
	 * @param {String} [name] Element name.
	 * @returns {Boolean}
	 */
	is( type, name = null ) {
		if ( !name ) {
			return type == 'element' || type == this.name;
		} else {
			return type == 'element' && name == this.name;
		}
	}

	/**
	 * Gets the child at the given index.
	 *
	 * @param {Number} index Index of child.
	 * @returns {module:engine/model/node~Node} Child node.
	 */
	getChild( index ) {
		return this._children.getNode( index );
	}

	/**
	 * Returns an iterator that iterates over all of this element's children.
	 *
	 * @returns {Iterable.<module:engine/model/node~Node>}
	 */
	getChildren() {
		return this._children[ Symbol.iterator ]();
	}

	/**
	 * Returns an index of the given child node. Returns `null` if given node is not a child of this element.
	 *
	 * @param {module:engine/model/node~Node} node Child node to look for.
	 * @returns {Number} Child node's index in this element.
	 */
	getChildIndex( node ) {
		return this._children.getNodeIndex( node );
	}

	/**
	 * Returns the starting offset of given child. Starting offset is equal to the sum of
	 * {module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
	 * given node is not a child of this element.
	 *
	 * @param {module:engine/model/node~Node} node Child node to look for.
	 * @returns {Number} Child node's starting offset.
	 */
	getChildStartOffset( node ) {
		return this._children.getNodeStartOffset( node );
	}

	/**
	 * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.
	 * If clone is deep, the original element's children are also cloned. If not, then empty element is removed.
	 *
	 * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,
	 * element will be cloned without any child.
	 */
	clone( deep = false ) {
		const children = deep ? Array.from( this._children ).map( node => node.clone( true ) ) : null;

		return new Element( this.name, this.getAttributes(), children );
	}

	/**
	 * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
	 * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.
	 *
	 *		const textNode = new Text( 'foo' );
	 *		const pElement = new Element( 'p' );
	 *		const divElement = new Element( [ textNode, pElement ] );
	 *		divElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.
	 *		divElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
	 *		divElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
	 *		divElement.offsetToIndex( 2 ); // Returns 0.
	 *		divElement.offsetToIndex( 3 ); // Returns 1.
	 *		divElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
	 *
	 * @param {Number} offset Offset to look for.
	 * @returns {Number}
	 */
	offsetToIndex( offset ) {
		return this._children.offsetToIndex( offset );
	}

	/**
	 * {@link module:engine/model/element~Element#insertChildren Inserts} one or more nodes at the end of this element.
	 *
	 * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} nodes Nodes to be inserted.
	 */
	appendChildren( nodes ) {
		this.insertChildren( this.childCount, nodes );
	}

	/**
	 * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
	 * to this element.
	 *
	 * @param {Number} index Index at which nodes should be inserted.
	 * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} nodes Nodes to be inserted.
	 */
	insertChildren( index, nodes ) {
		nodes = normalize( nodes );

		for ( const node of nodes ) {
			// If node that is being added to this element is already inside another element, first remove it from the old parent.
			if ( node.parent !== null ) {
				node.remove();
			}

			node.parent = this;
		}

		this._children.insertNodes( index, nodes );
	}

	/**
	 * Removes one or more nodes starting at the given index and sets
	 * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
	 *
	 * @param {Number} index Index of the first node to remove.
	 * @param {Number} [howMany=1] Number of nodes to remove.
	 * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.
	 */
	removeChildren( index, howMany = 1 ) {
		const nodes = this._children.removeNodes( index, howMany );

		for ( const node of nodes ) {
			node.parent = null;
		}

		return nodes;
	}

	/**
	 * Returns a descendant node by its path relative to this element.
	 *
	 *		// <this>a<b>c</b></this>
	 *		this.getNodeByPath( [ 0 ] );     // -> "a"
	 *		this.getNodeByPath( [ 1 ] );     // -> <b>
	 *		this.getNodeByPath( [ 1, 0 ] );  // -> "c"
	 *
	 * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.
	 * @returns {module:engine/model/node~Node}
	 */
	getNodeByPath( relativePath ) {
		let node = this; // eslint-disable-line consistent-this

		for ( const index of relativePath ) {
			node = node.getChild( node.offsetToIndex( index ) );
		}

		return node;
	}

	/**
	 * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.
	 *
	 * @returns {Object} `Element` instance converted to plain object.
	 */
	toJSON() {
		const json = super.toJSON();

		json.name = this.name;

		if ( this._children.length > 0 ) {
			json.children = [];

			for ( const node of this._children ) {
				json.children.push( node.toJSON() );
			}
		}

		return json;
	}

	/**
	 * Creates an `Element` instance from given plain object (i.e. parsed JSON string).
	 * Converts `Element` children to proper nodes.
	 *
	 * @param {Object} json Plain object to be converted to `Element`.
	 * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.
	 */
	static fromJSON( json ) {
		let children = null;

		if ( json.children ) {
			children = [];

			for ( const child of json.children ) {
				if ( child.name ) {
					// If child has name property, it is an Element.
					children.push( Element.fromJSON( child ) );
				} else {
					// Otherwise, it is a Text node.
					children.push( __WEBPACK_IMPORTED_MODULE_2__text__["a" /* default */].fromJSON( child ) );
				}
			}
		}

		return new Element( json.name, json.attributes, children );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Element;


// Converts strings to Text and non-iterables to arrays.
//
// @param {String|module:engine/model/node~Node|Iterable.<String|module:engine/model/node~Node>}
// @return {Iterable.<module:engine/model/node~Node>}
function normalize( nodes ) {
	// Separate condition because string is iterable.
	if ( typeof nodes == 'string' ) {
		return [ new __WEBPACK_IMPORTED_MODULE_2__text__["a" /* default */]( nodes ) ];
	}

	if ( !Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_isiterable__["a" /* default */])( nodes ) ) {
		nodes = [ nodes ];
	}

	// Array.from to enable .map() on non-arrays.
	return Array.from( nodes )
		.map( node => {
			return typeof node == 'string' ? new __WEBPACK_IMPORTED_MODULE_2__text__["a" /* default */]( node ) : node;
		} );
}


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__viewcollection__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__template__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_dom_emittermixin__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_collection__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_isiterable__ = __webpack_require__(34);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/view
 */










/**
 * The basic view class, which represents an HTML element created out of a
 * {@link module:ui/view~View#template}. Views are building blocks of the user interface and handle
 * interaction
 *
 * Views {@link module:ui/view~View#registerChildren aggregate} children in
 * {@link module:ui/view~View#createCollection collections} and manage the life cycle of DOM
 * listeners e.g. by handling rendering and destruction.
 *
 * See the {@link module:ui/template~TemplateDefinition} syntax to learn more about shaping view
 * elements, attributes and listeners.
 *
 *		class SampleView extends View {
 *			constructor( locale ) {
 *				super( locale );
 *
 *				const bind = this.bindTemplate;
 *
 *				// Views define their interface (state) using observable attributes.
 *				this.set( 'elementClass', 'bar' );
 *
 *				this.setTemplate( {
 *					tag: 'p',
 *
 *					// The element of the view can be defined with its children.
 *					children: [
 *						'Hello',
 *						{
 *							tag: 'b',
 *							children: [ 'world!' ]
 *						}
 *					],
 *					attributes: {
 *						class: [
 *							'foo',
 *
 *							// Observable attributes control the state of the view in DOM.
 *							bind.to( 'elementClass' )
 *						]
 *					},
 *					on: {
 *						// Views listen to DOM events and propagate them.
 *						click: bind.to( 'clicked' )
 *					}
 *				} );
 *			}
 *		}
 *
 *		const view = new SampleView( locale );
 *
 *		view.render();
 *
 *		// Append <p class="foo bar">Hello<b>world</b></p> to the <body>
 *		document.body.appendChild( view.element );
 *
 *		// Change the class attribute to <p class="foo baz">Hello<b>world</b></p>
 *		view.elementClass = 'baz';
 *
 *		// Respond to the "click" event in DOM by executing a custom action.
 *		view.on( 'clicked', () => {
 *			console.log( 'The view has been clicked!' );
 *		} );
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */
class View {
	/**
	 * Creates an instance of the {@link module:ui/view~View} class.
	 *
	 * Also see {@link #render}.
	 *
	 * @param {module:utils/locale~Locale} [locale] The localization services instance.
	 */
	constructor( locale ) {
		/**
		 * An HTML element of the view. `null` until {@link #render rendered}
		 * from the {@link #template}.
		 *
		 *		class SampleView extends View {
		 *			constructor() {
		 *				super();
		 *
		 *				// A template instance the #element will be created from.
		 *				this.setTemplate( {
		 *					tag: 'p'
		 *
		 *					// ...
		 *				} );
		 *			}
		 *		}
		 *
		 *		const view = new SampleView();
		 *
		 *		// Renders the #template
		 *		view.render();
		 *
		 *		// Append the HTML element of the view to <body>.
		 *		document.body.appendChild( view.element );
		 *
		 * **Note**: The element of the view can also be assigned directly:
		 *
		 *		view.element = document.querySelector( '#my-container' );
		 *
		 * @member {HTMLElement}
		 */
		this.element = null;

		/**
		 * Set `true` when the view has already been {@link module:ui/view~View#render rendered}.
		 *
		 * @readonly
		 * @member {Boolean} #isRendered
		 */
		this.isRendered = false;

		/**
		 * A set of tools to localize the user interface.
		 *
		 * Also see {@link module:core/editor/editor~Editor#locale}.
		 *
		 * @readonly
		 * @member {module:utils/locale~Locale}
		 */
		this.locale = locale;

		/**
		 * Shorthand for {@link module:utils/locale~Locale#t}.
		 *
		 * Note: If {@link #locale} instance hasn't been passed to the view this method may not
		 * be available.
		 *
		 * @see module:utils/locale~Locale#t
		 * @method
		 */
		this.t = locale && locale.t;

		/**
		 * Collections registered with {@link #createCollection}.
		 *
		 * @protected
		 * @member {Set.<module:ui/viewcollection~ViewCollection>}
		 */
		this._viewCollections = new __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_collection__["a" /* default */]();

		/**
		 * A collection of view instances, which have been added directly
		 * into the {@link module:ui/template~Template#children}.
		 *
		 * @protected
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this._unboundChildren = this.createCollection();

		// Pass parent locale to its children.
		this._viewCollections.on( 'add', ( evt, collection ) => {
			collection.locale = locale;
		} );

		/**
		 * Template of this view. It provides the {@link #element} representing
		 * the view in DOM, which is {@link #render rendered}.
		 *
		 * @member {module:ui/template~Template} #template
		 */

		/**
		 * Cached {@link @link module:ui/template~BindChain bind chain} object created by the
		 * {@link #template}. See {@link #bindTemplate}.
		 *
		 * @private
		 * @member {Object} #_bindTemplate
		 */
	}

	/**
	 * Shorthand for {@link module:ui/template~Template.bind}, a binding
	 * {@link module:ui/template~BindChain interface} preconfigured for the view instance.
	 *
	 * It provides {@link module:ui/template~BindChain#to `to()`} and
	 * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
	 * observable attributes and attach DOM listeners.
	 *
	 *		class SampleView extends View {
	 *			constructor( locale ) {
	 *				super( locale );
	 *
	 *				const bind = this.bindTemplate;
	 *
	 *				// These {@link module:utils/observablemixin~Observable observable} attributes will control
	 *				// the state of the view in DOM.
	 *				this.set( {
	 *					elementClass: 'foo',
	 *				 	isEnabled: true
	 *				 } );
	 *
	 *				this.setTemplate( {
	 *					tag: 'p',
	 *
	 *					attributes: {
	 *						// The class HTML attribute will follow elementClass
	 *						// and isEnabled view attributes.
	 *						class: [
	 *							bind.to( 'elementClass' )
	 *							bind.if( 'isEnabled', 'present-when-enabled' )
	 *						]
	 *					},
	 *
	 *					on: {
	 *						// The view will fire the "clicked" event upon clicking <p> in DOM.
	 *						click: bind.to( 'clicked' )
	 *					}
	 *				} );
	 *			}
	 *		}
	 *
	 * @method #bindTemplate
	 */
	get bindTemplate() {
		if ( this._bindTemplate ) {
			return this._bindTemplate;
		}

		return ( this._bindTemplate = __WEBPACK_IMPORTED_MODULE_2__template__["a" /* default */].bind( this, this ) );
	}

	/**
	 * Creates a new collection of views, which can be used as
	 * {@link module:ui/template~Template#children} of this view.
	 *
	 *		class SampleView extends View {
	 *			constructor( locale ) {
	 *				super( locale );
	 *
	 *				this.items = this.createCollection();
 	 *
	 *				this.setTemplate( {
	 *					tag: 'p',
	 *
	 *					// `items` collection will render here.
	 *					children: this.items
	 *				} );
	 *			}
	 *		}
	 *
	 *		const view = new SampleView( locale );
	 *		const child = new ChildView( locale );
	 *
	 *		view.render();
	 *
	 *		// It will append <p></p> to the <body>.
	 *		document.body.appendChild( view.element );
	 *
	 *		// From now on the child is nested under its parent, which is also reflected in DOM.
	 *		// <p><child#element></p>
	 *		view.items.add( child );
	 *
	 * @returns {module:ui/viewcollection~ViewCollection} A new collection of view instances.
	 */
	createCollection() {
		const collection = new __WEBPACK_IMPORTED_MODULE_1__viewcollection__["a" /* default */]();

		this._viewCollections.add( collection );

		return collection;
	}

	/**
	 * Registers a new child view under the view instance. Once registered, a child
	 * view is managed by its parent, including {@link #render rendering}
	 * and {@link #destroy destruction}.
	 *
	 * To revert this, use {@link #deregisterChildren}.
	 *
	 *		class SampleView extends View {
	 *			constructor( locale ) {
	 *				super( locale );
	 *
	 *				this.childA = new SomeChildView( locale );
	 *				this.childB = new SomeChildView( locale );
	 *
	 *				this.setTemplate( { tag: 'p' } );
	 *
	 *				// Register the children.
	 *				this.registerChildren( [ this.childA, this.childB ] );
	 *			}
	 *
	 *			render() {
	 *				super.render();
	 *
	 *				this.element.appendChild( this.childA.element );
	 *				this.element.appendChild( this.childB.element );
	 *			}
	 *		}
	 *
	 *		const view = new SampleView( locale );
	 *
	 *		view.render();
	 *
	 *		// Will append <p><childA#element><b></b><childB#element></p>.
	 *		document.body.appendChild( view.element );
	 *
	 * **Note**: There's no need to add child views if they're already referenced in the
	 * {@link #template}:
	 *
	 *		class SampleView extends View {
	 *			constructor( locale ) {
	 *				super( locale );
	 *
	 *				this.childA = new SomeChildView( locale );
	 *				this.childB = new SomeChildView( locale );
	 *
	 *				this.setTemplate( {
	 *					tag: 'p',
	 *
 	 *					// These children will be added automatically. There's no
 	 *					// need to call {@link #registerChildren} for any of them.
	 *					children: [ this.childA, this.childB ]
	 *				} );
	 *			}
	 *
	 *			// ...
	 *		}
	 *
	 * @param {module:ui/view~View|Iterable.<module:ui/view~View>} children Children views to be registered.
	 */
	registerChildren( children ) {
		if ( !Object(__WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_isiterable__["a" /* default */])( children ) ) {
			children = [ children ];
		}

		for ( const child of children ) {
			this._unboundChildren.add( child );
		}
	}

	/**
	 * The opposite of {@link #registerChildren}. Removes a child view from this view instance.
	 * Once removed, the child is no longer managed by its parent, e.g. it can safely
	 * become a child of another parent view.
	 *
	 * @see #registerChildren
	 * @param {module:ui/view~View|Iterable.<module:ui/view~View>} children Child views to be removed.
	 */
	deregisterChildren( children ) {
		if ( !Object(__WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_isiterable__["a" /* default */])( children ) ) {
			children = [ children ];
		}

		for ( const child of children ) {
			this._unboundChildren.remove( child );
		}
	}

	/**
	 * Sets the {@link #template} of the view with with given definition.
	 *
	 * A shorthand for:
	 *
	 *		view.setTemplate( definition );
	 *
	 * @param {module:ui/template~TemplateDefinition} definition Definition of view's template.
	 */
	setTemplate( definition ) {
		this.template = new __WEBPACK_IMPORTED_MODULE_2__template__["a" /* default */]( definition );
	}

	/**
	 * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
	 * with given definition.
	 *
	 * A shorthand for:
	 *
	 *		Template.extend( view.template, definition );
	 *
	 * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
	 *
	 * @param {module:ui/template~TemplateDefinition} definition Definition which
	 * extends the {@link #template}.
	 */
	extendTemplate( definition ) {
		__WEBPACK_IMPORTED_MODULE_2__template__["a" /* default */].extend( this.template, definition );
	}

	/**
	 * Recursively renders the view.
	 *
	 * Once the view is rendered:
	 * * the {@link #element} becomes an HTML element out of {@link #template},
	 * * the {@link #isRendered} flag is set `true`.
	 *
	 * **Note**: The children of the view:
	 * * defined directly in the {@link #template}
	 * * residing in collections created by the {@link #createCollection} method,
	 * * and added by {@link #registerChildren}
	 * are also rendered in the process.
	 *
	 * In general, `render()` method is the right place to keep the code which refers to the
	 * {@link #element} and should be executed at the very beginning of the view's life cycle.
	 *
	 * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
	 * the view is rendered. To allow an early customization of the view (e.g. by its parent),
	 * such references should be done in `render()`.
	 *
	 *		class SampleView extends View {
	 *			constructor() {
	 *				this.setTemplate( {
	 *					// ...
	 *				} );
	 *			},
	 *
	 *			render() {
	 *				// View#element becomes available.
	 *				super.render();
	 *
	 *				// The "scroll" listener depends on #element.
	 *				this.listenTo( window, 'scroll', () => {
	 *					// A reference to #element would render the #template and make it non-extendable.
	 *					if ( window.scrollY > 0 ) {
	 *						this.element.scrollLeft = 100;
	 *					} else {
	 *						this.element.scrollLeft = 0;
	 *					}
	 *				} );
	 *			}
	 *		}
	 *
	 *		const view = new SampleView();
	 *
	 *		// Let's customize the view before it gets rendered.
	 *		view.extendTemplate( {
	 *			attributes: {
	 *				class: [
	 *					'additional-class'
	 *				]
	 *			}
	 *		} );
	 *
	 *		// Late rendering allows customization of the view.
	 *		view.render();
	 */
	render() {
		if ( this.isRendered ) {
			/**
			 * This View has already been rendered.
			 *
			 * @error ui-view-render-rendered
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'ui-view-render-already-rendered: This View has already been rendered.' );
		}

		// Render #element of the view.
		if ( this.template ) {
			this.element = this.template.render();

			// Autoregister view children from #template.
			this.registerChildren( this.template.getViews() );
		}

		this.isRendered = true;
	}

	/**
	 * Recursively destroys the view instance and child views added by {@link #registerChildren} and
	 * residing in collections created by the {@link #createCollection}.
	 *
	 * Destruction disables all event listeners:
	 * * created on the view, e.g. `view.on( 'event', () => {} )`,
	 * * defined in the {@link #template} for DOM events.
	 */
	destroy() {
		this.stopListening();

		this._viewCollections.map( c => c.destroy() );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = View;


Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( View, __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_dom_emittermixin__["a" /* default */] );
Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( View, __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__apply__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger__ = __webpack_require__(12);



/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : Object(__WEBPACK_IMPORTED_MODULE_1__toInteger__["a" /* default */])(start), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, array);
      case 1: return func.call(this, args[0], array);
      case 2: return func.call(this, args[0], args[1], array);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return Object(__WEBPACK_IMPORTED_MODULE_0__apply__["a" /* default */])(func, this, otherArgs);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (rest);


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = _getEmitterListenedTo;
/* harmony export (immutable) */ __webpack_exports__["b"] = _setEmitterId;
/* unused harmony export _getEmitterId */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__eventinfo__ = __webpack_require__(297);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uid__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__priorities__ = __webpack_require__(299);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/emittermixin
 */





const _listeningTo = Symbol( 'listeningTo' );
const _emitterId = Symbol( 'emitterId' );

/**
 * Mixin that injects the events API into its host.
 *
 * @mixin EmitterMixin
 * @implements module:utils/emittermixin~Emitter
 */
const EmitterMixin = {
	/**
	 * Registers a callback function to be executed when an event is fired.
	 *
	 * Events can be grouped in namespaces using `:`.
	 * When namespaced event is fired, it additionally fires all callbacks for that namespace.
	 *
	 *		myEmitter.on( 'myGroup', genericCallback );
	 *		myEmitter.on( 'myGroup:myEvent', specificCallback );
	 *
	 *		// genericCallback is fired.
	 *		myEmitter.fire( 'myGroup' );
	 *		// both genericCallback and specificCallback are fired.
	 *		myEmitter.fire( 'myGroup:myEvent' );
	 *		// genericCallback is fired even though there are no callbacks for "foo".
	 *		myEmitter.fire( 'myGroup:foo' );
	 *
	 * An event callback can {@link module:utils/eventinfo~EventInfo#stop stop the event} and
	 * set the {@link module:utils/eventinfo~EventInfo#return return value} of the {@link #fire} method.
	 *
	 * @method #on
	 * @param {String} event The name of the event.
	 * @param {Function} callback The function to be called on event.
	 * @param {Object} [options={}] Additional options.
	 * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
	 * the priority value the sooner the callback will be fired. Events having the same priority are called in the
	 * order they were added.
	 */
	on( event, callback, options = {} ) {
		createEventNamespace( this, event );
		const lists = getCallbacksListsForNamespace( this, event );
		const priority = __WEBPACK_IMPORTED_MODULE_2__priorities__["a" /* default */].get( options.priority );

		callback = {
			callback,
			priority
		};

		// Add the callback to all callbacks list.
		for ( const callbacks of lists ) {
			// Add the callback to the list in the right priority position.
			let added = false;

			for ( let i = 0; i < callbacks.length; i++ ) {
				if ( callbacks[ i ].priority < priority ) {
					callbacks.splice( i, 0, callback );
					added = true;

					break;
				}
			}

			// Add at the end, if right place was not found.
			if ( !added ) {
				callbacks.push( callback );
			}
		}
	},

	/**
	 * Registers a callback function to be executed on the next time the event is fired only. This is similar to
	 * calling {@link #on} followed by {@link #off} in the callback.
	 *
	 * @method #once
	 * @param {String} event The name of the event.
	 * @param {Function} callback The function to be called on event.
	 * @param {Object} [options={}] Additional options.
	 * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
	 * the priority value the sooner the callback will be fired. Events having the same priority are called in the
	 * order they were added.
	 */
	once( event, callback, options ) {
		const onceCallback = function( event, ...args ) {
			// Go off() at the first call.
			event.off();

			// Go with the original callback.
			callback.call( this, event, ...args );
		};

		// Make a similar on() call, simply replacing the callback.
		this.on( event, onceCallback, options );
	},

	/**
	 * Stops executing the callback on the given event.
	 *
	 * @method #off
	 * @param {String} event The name of the event.
	 * @param {Function} callback The function to stop being called.
	 */
	off( event, callback ) {
		const lists = getCallbacksListsForNamespace( this, event );

		for ( const callbacks of lists ) {
			for ( let i = 0; i < callbacks.length; i++ ) {
				if ( callbacks[ i ].callback == callback ) {
					// Remove the callback from the list (fixing the next index).
					callbacks.splice( i, 1 );
					i--;
				}
			}
		}
	},

	/**
	 * Registers a callback function to be executed when an event is fired in a specific (emitter) object.
	 *
	 * @method #listenTo
	 * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.
	 * @param {String} event The name of the event.
	 * @param {Function} callback The function to be called on event.
	 * @param {Object} [options={}] Additional options.
	 * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
	 * the priority value the sooner the callback will be fired. Events having the same priority are called in the
	 * order they were added.
	 */
	listenTo( emitter, event, callback, options ) {
		let emitterInfo, eventCallbacks;

		// _listeningTo contains a list of emitters that this object is listening to.
		// This list has the following format:
		//
		// _listeningTo: {
		//     emitterId: {
		//         emitter: emitter,
		//         callbacks: {
		//             event1: [ callback1, callback2, ... ]
		//             ....
		//         }
		//     },
		//     ...
		// }

		if ( !this[ _listeningTo ] ) {
			this[ _listeningTo ] = {};
		}

		const emitters = this[ _listeningTo ];

		if ( !_getEmitterId( emitter ) ) {
			_setEmitterId( emitter );
		}

		const emitterId = _getEmitterId( emitter );

		if ( !( emitterInfo = emitters[ emitterId ] ) ) {
			emitterInfo = emitters[ emitterId ] = {
				emitter,
				callbacks: {}
			};
		}

		if ( !( eventCallbacks = emitterInfo.callbacks[ event ] ) ) {
			eventCallbacks = emitterInfo.callbacks[ event ] = [];
		}

		eventCallbacks.push( callback );

		// Finally register the callback to the event.
		emitter.on( event, callback, options );
	},

	/**
	 * Stops listening for events. It can be used at different levels:
	 *
	 * * To stop listening to a specific callback.
	 * * To stop listening to a specific event.
	 * * To stop listening to all events fired by a specific object.
	 * * To stop listening to all events fired by all object.
	 *
	 * @method #stopListening
	 * @param {module:utils/emittermixin~Emitter} [emitter] The object to stop listening to. If omitted, stops it for all objects.
	 * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it
	 * for all events from `emitter`.
	 * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given
	 * `event`.
	 */
	stopListening( emitter, event, callback ) {
		const emitters = this[ _listeningTo ];
		let emitterId = emitter && _getEmitterId( emitter );
		const emitterInfo = emitters && emitterId && emitters[ emitterId ];
		const eventCallbacks = emitterInfo && event && emitterInfo.callbacks[ event ];

		// Stop if nothing has been listened.
		if ( !emitters || ( emitter && !emitterInfo ) || ( event && !eventCallbacks ) ) {
			return;
		}

		// All params provided. off() that single callback.
		if ( callback ) {
			emitter.off( event, callback );
		}
		// Only `emitter` and `event` provided. off() all callbacks for that event.
		else if ( eventCallbacks ) {
			while ( ( callback = eventCallbacks.pop() ) ) {
				emitter.off( event, callback );
			}
			delete emitterInfo.callbacks[ event ];
		}
		// Only `emitter` provided. off() all events for that emitter.
		else if ( emitterInfo ) {
			for ( event in emitterInfo.callbacks ) {
				this.stopListening( emitter, event );
			}
			delete emitters[ emitterId ];
		}
		// No params provided. off() all emitters.
		else {
			for ( emitterId in emitters ) {
				this.stopListening( emitters[ emitterId ].emitter );
			}
			delete this[ _listeningTo ];
		}
	},

	/**
	 * Fires an event, executing all callbacks registered for it.
	 *
	 * The first parameter passed to callbacks is an {@link module:utils/eventinfo~EventInfo} object,
	 * followed by the optional `args` provided in the `fire()` method call.
	 *
	 * @method #fire
	 * @param {String|module:utils/eventinfo~EventInfo} eventOrInfo The name of the event or `EventInfo` object if event is delegated.
	 * @param {...*} [args] Additional arguments to be passed to the callbacks.
	 * @returns {*} By default the method returns `undefined`. However, the return value can be changed by listeners
	 * through modification of the {@link module:utils/eventinfo~EventInfo#return}'s value (the event info
	 * is the first param of every callback).
	 */
	fire( eventOrInfo, ...args ) {
		const eventInfo = eventOrInfo instanceof __WEBPACK_IMPORTED_MODULE_0__eventinfo__["a" /* default */] ? eventOrInfo : new __WEBPACK_IMPORTED_MODULE_0__eventinfo__["a" /* default */]( this, eventOrInfo );
		const event = eventInfo.name;
		let callbacks = getCallbacksForEvent( this, event );

		// Record that the event passed this emitter on its path.
		eventInfo.path.push( this );

		// Handle event listener callbacks first.
		if ( callbacks ) {
			// Arguments passed to each callback.
			const callbackArgs = [ eventInfo, ...args ];

			// Copying callbacks array is the easiest and most secure way of preventing infinite loops, when event callbacks
			// are added while processing other callbacks. Previous solution involved adding counters (unique ids) but
			// failed if callbacks were added to the queue before currently processed callback.
			// If this proves to be too inefficient, another method is to change `.on()` so callbacks are stored if same
			// event is currently processed. Then, `.fire()` at the end, would have to add all stored events.
			callbacks = Array.from( callbacks );

			for ( let i = 0; i < callbacks.length; i++ ) {
				callbacks[ i ].callback.apply( this, callbackArgs );

				// Remove the callback from future requests if off() has been called.
				if ( eventInfo.off.called ) {
					// Remove the called mark for the next calls.
					delete eventInfo.off.called;

					this.off( event, callbacks[ i ].callback );
				}

				// Do not execute next callbacks if stop() was called.
				if ( eventInfo.stop.called ) {
					break;
				}
			}
		}

		// Delegate event to other emitters if needed.
		if ( this._delegations ) {
			const destinations = this._delegations.get( event );
			const passAllDestinations = this._delegations.get( '*' );

			if ( destinations ) {
				fireDelegatedEvents( destinations, eventInfo, args );
			}

			if ( passAllDestinations ) {
				fireDelegatedEvents( passAllDestinations, eventInfo, args );
			}
		}

		return eventInfo.return;
	},

	/**
	 * Delegates selected events to another {@link module:utils/emittermixin~Emitter}. For instance:
	 *
	 *		emitterA.delegate( 'eventX' ).to( emitterB );
	 *		emitterA.delegate( 'eventX', 'eventY' ).to( emitterC );
	 *
	 * then `eventX` is delegated (fired by) `emitterB` and `emitterC` along with `data`:
	 *
	 *		emitterA.fire( 'eventX', data );
	 *
	 * and `eventY` is delegated (fired by) `emitterC` along with `data`:
	 *
	 *		emitterA.fire( 'eventY', data );
	 *
	 * @method #delegate
	 * @param {...String} events Event names that will be delegated to another emitter.
	 * @returns {module:utils/emittermixin~EmitterMixinDelegateChain}
	 */
	delegate( ...events ) {
		return {
			to: ( emitter, nameOrFunction ) => {
				if ( !this._delegations ) {
					this._delegations = new Map();
				}

				for ( const eventName of events ) {
					const destinations = this._delegations.get( eventName );

					if ( !destinations ) {
						this._delegations.set( eventName, new Map( [ [ emitter, nameOrFunction ] ] ) );
					} else {
						destinations.set( emitter, nameOrFunction );
					}
				}
			}
		};
	},

	/**
	 * Stops delegating events. It can be used at different levels:
	 *
	 * * To stop delegating all events.
	 * * To stop delegating a specific event to all emitters.
	 * * To stop delegating a specific event to a specific emitter.
	 *
	 * @method #stopDelegating
	 * @param {String} [event] The name of the event to stop delegating. If omitted, stops it all delegations.
	 * @param {module:utils/emittermixin~Emitter} [emitter] (requires `event`) The object to stop delegating a particular event to.
	 * If omitted, stops delegation of `event` to all emitters.
	 */
	stopDelegating( event, emitter ) {
		if ( !this._delegations ) {
			return;
		}

		if ( !event ) {
			this._delegations.clear();
		} else if ( !emitter ) {
			this._delegations.delete( event );
		} else {
			const destinations = this._delegations.get( event );

			if ( destinations ) {
				destinations.delete( emitter );
			}
		}
	}
};

/* harmony default export */ __webpack_exports__["c"] = (EmitterMixin);

/**
 * Checks if `listeningEmitter` listens to an emitter with given `listenedToEmitterId` and if so, returns that emitter.
 * If not, returns `null`.
 *
 * @protected
 * @param {module:utils/emittermixin~EmitterMixin} listeningEmitter Emitter that listens.
 * @param {String} listenedToEmitterId Unique emitter id of emitter listened to.
 * @returns {module:utils/emittermixin~EmitterMixin|null}
 */
function _getEmitterListenedTo( listeningEmitter, listenedToEmitterId ) {
	if ( listeningEmitter[ _listeningTo ] && listeningEmitter[ _listeningTo ][ listenedToEmitterId ] ) {
		return listeningEmitter[ _listeningTo ][ listenedToEmitterId ].emitter;
	}

	return null;
}

/**
 * Sets emitter's unique id.
 *
 * **Note:** `_emitterId` can be set only once.
 *
 * @protected
 * @param {module:utils/emittermixin~EmitterMixin} emitter Emitter for which id will be set.
 * @param {String} [id] Unique id to set. If not passed, random unique id will be set.
 */
function _setEmitterId( emitter, id ) {
	if ( !emitter[ _emitterId ] ) {
		emitter[ _emitterId ] = id || Object(__WEBPACK_IMPORTED_MODULE_1__uid__["a" /* default */])();
	}
}

/**
 * Returns emitter's unique id.
 *
 * @protected
 * @param {module:utils/emittermixin~EmitterMixin} emitter Emitter which id will be returned.
 */
function _getEmitterId( emitter ) {
	return emitter[ _emitterId ];
}

// Gets the internal `_events` property of the given object.
// `_events` property store all lists with callbacks for registered event names.
// If there were no events registered on the object, empty `_events` object is created.
function getEvents( source ) {
	if ( !source._events ) {
		Object.defineProperty( source, '_events', {
			value: {}
		} );
	}

	return source._events;
}

// Creates event node for generic-specific events relation architecture.
function makeEventNode() {
	return {
		callbacks: [],
		childEvents: []
	};
}

// Creates an architecture for generic-specific events relation.
// If needed, creates all events for given eventName, i.e. if the first registered event
// is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.
// It also copies callbacks from more generic events to more specific events when
// specific events are created.
function createEventNamespace( source, eventName ) {
	const events = getEvents( source );

	// First, check if the event we want to add to the structure already exists.
	if ( events[ eventName ] ) {
		// If it exists, we don't have to do anything.
		return;
	}

	// In other case, we have to create the structure for the event.
	// Note, that we might need to create intermediate events too.
	// I.e. if foo:bar:abc is being registered and we only have foo in the structure,
	// we need to also register foo:bar.

	// Currently processed event name.
	let name = eventName;
	// Name of the event that is a child event for currently processed event.
	let childEventName = null;

	// Array containing all newly created specific events.
	const newEventNodes = [];

	// While loop can't check for ':' index because we have to handle generic events too.
	// In each loop, we truncate event name, going from the most specific name to the generic one.
	// I.e. foo:bar:abc -> foo:bar -> foo.
	while ( name !== '' ) {
		if ( events[ name ] ) {
			// If the currently processed event name is already registered, we can be sure
			// that it already has all the structure created, so we can break the loop here
			// as no more events need to be registered.
			break;
		}

		// If this event is not yet registered, create a new object for it.
		events[ name ] = makeEventNode();
		// Add it to the array with newly created events.
		newEventNodes.push( events[ name ] );

		// Add previously processed event name as a child of this event.
		if ( childEventName ) {
			events[ name ].childEvents.push( childEventName );
		}

		childEventName = name;
		// If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.
		name = name.substr( 0, name.lastIndexOf( ':' ) );
	}

	if ( name !== '' ) {
		// If name is not empty, we found an already registered event that was a parent of the
		// event we wanted to register.

		// Copy that event's callbacks to newly registered events.
		for ( const node of newEventNodes ) {
			node.callbacks = events[ name ].callbacks.slice();
		}

		// Add last newly created event to the already registered event.
		events[ name ].childEvents.push( childEventName );
	}
}

// Gets an array containing callbacks list for a given event and it's more specific events.
// I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will
// return callback list of foo:bar and foo:bar:abc (but not foo).
// Returns empty array if given event has not been yet registered.
function getCallbacksListsForNamespace( source, eventName ) {
	const eventNode = getEvents( source )[ eventName ];

	if ( !eventNode ) {
		return [];
	}

	let callbacksLists = [ eventNode.callbacks ];

	for ( let i = 0; i < eventNode.childEvents.length; i++ ) {
		const childCallbacksLists = getCallbacksListsForNamespace( source, eventNode.childEvents[ i ] );

		callbacksLists = callbacksLists.concat( childCallbacksLists );
	}

	return callbacksLists;
}

// Get the list of callbacks for a given event, but only if there any callbacks have been registered.
// If there are no callbacks registered for given event, it checks if this is a specific event and looks
// for callbacks for it's more generic version.
function getCallbacksForEvent( source, eventName ) {
	let event;

	if ( !source._events || !( event = source._events[ eventName ] ) || !event.callbacks.length ) {
		// There are no callbacks registered for specified eventName.
		// But this could be a specific-type event that is in a namespace.
		if ( eventName.indexOf( ':' ) > -1 ) {
			// If the eventName is specific, try to find callback lists for more generic event.
			return getCallbacksForEvent( source, eventName.substr( 0, eventName.lastIndexOf( ':' ) ) );
		} else {
			// If this is a top-level generic event, return null;
			return null;
		}
	}

	return event.callbacks;
}

// Fires delegated events for given map of destinations.
//
// @private
// * @param {Map.<utils.Emitter>} destinations A map containing `[ {@link utils.Emitter}, "event name" ]` pair destinations.
// * @param {utils.EventInfo} eventInfo The original event info object.
// * @param {Array.<*>} fireArgs Arguments the original event was fired with.
function fireDelegatedEvents( destinations, eventInfo, fireArgs ) {
	for ( let [ emitter, name ] of destinations ) {
		if ( !name ) {
			name = eventInfo.name;
		} else if ( typeof name == 'function' ) {
			name = name( eventInfo.name );
		}

		const delegatedInfo = new __WEBPACK_IMPORTED_MODULE_0__eventinfo__["a" /* default */]( eventInfo.source, name );

		delegatedInfo.path = [ ...eventInfo.path ];

		emitter.fire( delegatedInfo, ...fireArgs );
	}
}

/**
 * Interface representing classes which mix in {@link module:utils/emittermixin~EmitterMixin}.
 *
 * @interface Emitter
 */

/**
 * The return value of {@link ~EmitterMixin#delegate}.
 *
 * @interface module:utils/emittermixin~EmitterMixinDelegateChain
 */

/**
 * Selects destination for {@link module:utils/emittermixin~EmitterMixin#delegate} events.
 *
 * @method #to
 * @param {module:utils/emittermixin~Emitter} emitter An `EmitterMixin` instance which is the destination for delegated events.
 * @param {String|Function} nameOrFunction A custom event name or function which converts the original name string.
 */


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__text__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_objecttomap__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_isiterable__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_lib_lodash_isPlainObject__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__matcher__ = __webpack_require__(181);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/element
 */








/**
 * View element.
 *
 * Editing engine does not define fixed HTML DTD. This is why the type of the {@link module:engine/view/element~Element} need to
 * be defined by the feature developer. Creating an element you should use {@link module:engine/view/containerelement~ContainerElement}
 * class, {@link module:engine/view/attributeelement~AttributeElement} class or {@link module:engine/view/emptyelement~EmptyElement} class.
 *
 * Note that for view elements which are not created from model, like elements from mutations, paste or
 * {@link module:engine/controller/datacontroller~DataController#set data.set} it is not possible to define the type of the element, so
 * these will be instances of the {@link module:engine/view/element~Element}.
 *
 * @extends module:engine/view/node~Node
 */
class Element extends __WEBPACK_IMPORTED_MODULE_0__node__["a" /* default */] {
	/**
	 * Creates a view element.
	 *
	 * Attributes can be passed in various formats:
	 *
	 *		new Element( 'div', { 'class': 'editor', 'contentEditable': 'true' } ); // object
	 *		new Element( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
	 *		new Element( 'div', mapOfAttributes ); // map
	 *
	 * @param {String} name Node name.
	 * @param {Object|Iterable} [attrs] Collection of attributes.
	 * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]
	 * List of nodes to be inserted into created element.
	 */
	constructor( name, attrs, children ) {
		super();

		/**
		 * Name of the element.
		 *
		 * @readonly
		 * @member {String}
		 */
		this.name = name;

		/**
		 * Map of attributes, where attributes names are keys and attributes values are values.
		 *
		 * @protected
		 * @member {Map} #_attrs
		 */
		if ( Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_lib_lodash_isPlainObject__["a" /* default */])( attrs ) ) {
			this._attrs = Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_objecttomap__["a" /* default */])( attrs );
		} else {
			this._attrs = new Map( attrs );
		}

		/**
		 * Array of child nodes.
		 *
		 * @protected
		 * @member {Array.<module:engine/view/node~Node>}
		 */
		this._children = [];

		if ( children ) {
			this.insertChildren( 0, children );
		}

		/**
		 * Set of classes associated with element instance.
		 *
		 * @protected
		 * @member {Set}
		 */
		this._classes = new Set();

		if ( this._attrs.has( 'class' ) ) {
			// Remove class attribute and handle it by class set.
			const classString = this._attrs.get( 'class' );
			parseClasses( this._classes, classString );
			this._attrs.delete( 'class' );
		}

		/**
		 * Map of styles.
		 *
		 * @protected
		 * @member {Set} module:engine/view/element~Element#_styles
		 */
		this._styles = new Map();

		if ( this._attrs.has( 'style' ) ) {
			// Remove style attribute and handle it by styles map.
			parseInlineStyles( this._styles, this._attrs.get( 'style' ) );
			this._attrs.delete( 'style' );
		}

		/**
		 * Map of custom properties.
		 * Custom properties can be added to element instance, will be cloned but not rendered into DOM.
		 *
		 * @protected
		 * @memeber {Map}
		 */
		this._customProperties = new Map();
	}

	/**
	 * Number of element's children.
	 *
	 * @readonly
	 * @type {Number}
	 */
	get childCount() {
		return this._children.length;
	}

	/**
	 * Is `true` if there are no nodes inside this element, `false` otherwise.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isEmpty() {
		return this._children.length === 0;
	}

	/**
	 * Checks whether given view tree object is of given type.
	 *
	 * Read more in {@link module:engine/view/node~Node#is}.
	 *
	 * @param {String} type
	 * @param {String} [name] Element name.
	 * @returns {Boolean}
	 */
	is( type, name = null ) {
		if ( !name ) {
			return type == 'element' || type == this.name;
		} else {
			return type == 'element' && name == this.name;
		}
	}

	/**
	 * Clones provided element.
	 *
	 * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,
	 * element will be cloned without any children.
	 * @returns {module:engine/view/element~Element} Clone of this element.
	 */
	clone( deep = false ) {
		const childrenClone = [];

		if ( deep ) {
			for ( const child of this.getChildren() ) {
				childrenClone.push( child.clone( deep ) );
			}
		}

		// ContainerElement and AttributeElement should be also cloned properly.
		const cloned = new this.constructor( this.name, this._attrs, childrenClone );

		// Classes and styles are cloned separately - this solution is faster than adding them back to attributes and
		// parse once again in constructor.
		cloned._classes = new Set( this._classes );
		cloned._styles = new Map( this._styles );

		// Clone custom properties.
		cloned._customProperties = new Map( this._customProperties );

		// Clone filler offset method.
		// We can't define this method in a prototype because it's behavior which
		// is changed by e.g. toWidget() function from ckeditor5-widget. Perhaps this should be one of custom props.
		cloned.getFillerOffset = this.getFillerOffset;

		return cloned;
	}

	/**
	 * {@link module:engine/view/element~Element#insertChildren Insert} a child node or a list of child nodes at the end of this node
	 * and sets the parent of these nodes to this element.
	 *
	 * @fires module:engine/view/node~Node#change
	 * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} nodes Node or the list of nodes to be inserted.
	 * @returns {Number} Number of appended nodes.
	 */
	appendChildren( nodes ) {
		return this.insertChildren( this.childCount, nodes );
	}

	/**
	 * Gets child at the given index.
	 *
	 * @param {Number} index Index of child.
	 * @returns {module:engine/view/node~Node} Child node.
	 */
	getChild( index ) {
		return this._children[ index ];
	}

	/**
	 * Gets index of the given child node. Returns `-1` if child node is not found.
	 *
	 * @param {module:engine/view/node~Node} node Child node.
	 * @returns {Number} Index of the child node.
	 */
	getChildIndex( node ) {
		return this._children.indexOf( node );
	}

	/**
	 * Gets child nodes iterator.
	 *
	 * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.
	 */
	getChildren() {
		return this._children[ Symbol.iterator ]();
	}

	/**
	 * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
	 *
	 * @returns {Iterator.<String>} Keys for attributes.
	 */
	* getAttributeKeys() {
		if ( this._classes.size > 0 ) {
			yield 'class';
		}

		if ( this._styles.size > 0 ) {
			yield 'style';
		}

		// This is not an optimal solution because of https://github.com/ckeditor/ckeditor5-engine/issues/454.
		// It can be simplified to `yield* this._attrs.keys();`.
		for ( const key of this._attrs.keys() ) {
			yield key;
		}
	}

	/**
	 * Returns iterator that iterates over this element's attributes.
	 *
	 * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
	 * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
	 *
	 * @returns {Iterable.<*>}
	 */
	* getAttributes() {
		yield* this._attrs.entries();

		if ( this._classes.size > 0 ) {
			yield [ 'class', this.getAttribute( 'class' ) ];
		}

		if ( this._styles.size > 0 ) {
			yield [ 'style', this.getAttribute( 'style' ) ];
		}
	}

	/**
	 * Gets attribute by key. If attribute is not present - returns undefined.
	 *
	 * @param {String} key Attribute key.
	 * @returns {String|undefined} Attribute value.
	 */
	getAttribute( key ) {
		if ( key == 'class' ) {
			if ( this._classes.size > 0 ) {
				return [ ...this._classes ].join( ' ' );
			}

			return undefined;
		}

		if ( key == 'style' ) {
			if ( this._styles.size > 0 ) {
				let styleString = '';

				for ( const [ property, value ] of this._styles ) {
					styleString += `${ property }:${ value };`;
				}

				return styleString;
			}

			return undefined;
		}

		return this._attrs.get( key );
	}

	/**
	 * Returns a boolean indicating whether an attribute with the specified key exists in the element.
	 *
	 * @param {String} key Attribute key.
	 * @returns {Boolean} `true` if attribute with the specified key exists in the element, false otherwise.
	 */
	hasAttribute( key ) {
		if ( key == 'class' ) {
			return this._classes.size > 0;
		}

		if ( key == 'style' ) {
			return this._styles.size > 0;
		}

		return this._attrs.has( key );
	}

	/**
	 * Adds or overwrite attribute with a specified key and value.
	 *
	 * @param {String} key Attribute key.
	 * @param {String} value Attribute value.
	 * @fires module:engine/view/node~Node#change
	 */
	setAttribute( key, value ) {
		this._fireChange( 'attributes', this );

		if ( key == 'class' ) {
			parseClasses( this._classes, value );
		} else if ( key == 'style' ) {
			parseInlineStyles( this._styles, value );
		} else {
			this._attrs.set( key, value );
		}
	}

	/**
	 * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
	 * this element.
	 *
	 * @param {Number} index Position where nodes should be inserted.
	 * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} nodes Node or the list of nodes to be inserted.
	 * @fires module:engine/view/node~Node#change
	 * @returns {Number} Number of inserted nodes.
	 */
	insertChildren( index, nodes ) {
		this._fireChange( 'children', this );
		let count = 0;

		nodes = normalize( nodes );

		for ( const node of nodes ) {
			// If node that is being added to this element is already inside another element, first remove it from the old parent.
			if ( node.parent !== null ) {
				node.remove();
			}

			node.parent = this;

			this._children.splice( index, 0, node );
			index++;
			count++;
		}

		return count;
	}

	/**
	 * Removes attribute from the element.
	 *
	 * @param {String} key Attribute key.
	 * @returns {Boolean} Returns true if an attribute existed and has been removed.
	 * @fires module:engine/view/node~Node#change
	 */
	removeAttribute( key ) {
		this._fireChange( 'attributes', this );

		// Remove class attribute.
		if ( key == 'class' ) {
			if ( this._classes.size > 0 ) {
				this._classes.clear();

				return true;
			}

			return false;
		}

		// Remove style attribute.
		if ( key == 'style' ) {
			if ( this._styles.size > 0 ) {
				this._styles.clear();

				return true;
			}

			return false;
		}

		// Remove other attributes.
		return this._attrs.delete( key );
	}

	/**
	 * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
	 *
	 * @param {Number} index Number of the first node to remove.
	 * @param {Number} [howMany=1] Number of nodes to remove.
	 * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.
	 * @fires module:engine/view/node~Node#change
	 */
	removeChildren( index, howMany = 1 ) {
		this._fireChange( 'children', this );

		for ( let i = index; i < index + howMany; i++ ) {
			this._children[ i ].parent = null;
		}

		return this._children.splice( index, howMany );
	}

	/**
	 * Checks if this element is similar to other element.
	 * Both elements should have the same name and attributes to be considered as similar. Two similar elements
	 * can contain different set of children nodes.
	 *
	 * @param {module:engine/view/element~Element} otherElement
	 * @returns {Boolean}
	 */
	isSimilar( otherElement ) {
		if ( !( otherElement instanceof Element ) ) {
			return false;
		}

		// If exactly the same Element is provided - return true immediately.
		if ( this === otherElement ) {
			return true;
		}

		// Check element name.
		if ( this.name != otherElement.name ) {
			return false;
		}

		// Check number of attributes, classes and styles.
		if ( this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size ||
			this._styles.size !== otherElement._styles.size ) {
			return false;
		}

		// Check if attributes are the same.
		for ( const [ key, value ] of this._attrs ) {
			if ( !otherElement._attrs.has( key ) || otherElement._attrs.get( key ) !== value ) {
				return false;
			}
		}

		// Check if classes are the same.
		for ( const className of this._classes ) {
			if ( !otherElement._classes.has( className ) ) {
				return false;
			}
		}

		// Check if styles are the same.
		for ( const [ property, value ] of this._styles ) {
			if ( !otherElement._styles.has( property ) || otherElement._styles.get( property ) !== value ) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Adds specified class.
	 *
	 *		element.addClass( 'foo' ); // Adds 'foo' class.
	 *		element.addClass( 'foo', 'bar' ); // Adds 'foo' and 'bar' classes.
	 *
	 * @param {...String} className
	 * @fires module:engine/view/node~Node#change
	 */
	addClass( ...className ) {
		this._fireChange( 'attributes', this );
		className.forEach( name => this._classes.add( name ) );
	}

	/**
	 * Removes specified class.
	 *
 	 *		element.removeClass( 'foo' );  // Removes 'foo' class.
	 *		element.removeClass( 'foo', 'bar' ); // Removes both 'foo' and 'bar' classes.
	 *
	 * @param {...String} className
	 * @fires module:engine/view/node~Node#change
	 */
	removeClass( ...className ) {
		this._fireChange( 'attributes', this );
		className.forEach( name => this._classes.delete( name ) );
	}

	/**
	 * Returns true if class is present.
	 * If more then one class is provided - returns true only when all classes are present.
	 *
	 *		element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
	 *		element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
	 *
	 * @param {...String} className
	 */
	hasClass( ...className ) {
		for ( const name of className ) {
			if ( !this._classes.has( name ) ) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Returns iterator that contains all class names.
	 *
	 * @returns {Iterator.<String>}
	 */
	getClassNames() {
		return this._classes.keys();
	}

	/**
	 * Adds style to the element.
	 *
	 *		element.setStyle( 'color', 'red' );
	 *		element.setStyle( {
	 *			color: 'red',
	 *			position: 'fixed'
	 *		} );
	 *
	 * @param {String|Object} property Property name or object with key - value pairs.
	 * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.
	 * @fires module:engine/view/node~Node#change
	 */
	setStyle( property, value ) {
		this._fireChange( 'attributes', this );

		if ( Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_lib_lodash_isPlainObject__["a" /* default */])( property ) ) {
			const keys = Object.keys( property );

			for ( const key of keys ) {
				this._styles.set( key, property[ key ] );
			}
		} else {
			this._styles.set( property, value );
		}
	}

	/**
	 * Returns style value for given property.
	 * Undefined is returned if style does not exist.
	 *
	 * @param {String} property
	 * @returns {String|undefined}
	 */
	getStyle( property ) {
		return this._styles.get( property );
	}

	/**
	 * Returns iterator that contains all style names.
	 *
	 * @returns {Iterator.<String>}
	 */
	getStyleNames() {
		return this._styles.keys();
	}

	/**
	 * Returns true if style keys are present.
	 * If more then one style property is provided - returns true only when all properties are present.
	 *
	 *		element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
	 *		element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
	 *
	 * @param {...String} property
	 */
	hasStyle( ...property ) {
		for ( const name of property ) {
			if ( !this._styles.has( name ) ) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Removes specified style.
	 *
	 *		element.removeStyle( 'color' );  // Removes 'color' style.
	 *		element.removeStyle( 'color', 'border-top' ); // Removes both 'color' and 'border-top' styles.
	 *
	 * @param {...String} property
	 * @fires module:engine/view/node~Node#change
	 */
	removeStyle( ...property ) {
		this._fireChange( 'attributes', this );
		property.forEach( name => this._styles.delete( name ) );
	}

	/**
	 * Returns ancestor element that match specified pattern.
	 * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
	 *
	 * @see module:engine/view/matcher~Matcher
	 * @param {Object|String|RegExp|Function} patterns Patterns used to match correct ancestor.
	 * See {@link module:engine/view/matcher~Matcher}.
	 * @returns {module:engine/view/element~Element|null} Found element or `null` if no matching ancestor was found.
	 */
	findAncestor( ...patterns ) {
		const matcher = new __WEBPACK_IMPORTED_MODULE_5__matcher__["a" /* default */]( ...patterns );
		let parent = this.parent;

		while ( parent ) {
			if ( matcher.match( parent ) ) {
				return parent;
			}

			parent = parent.parent;
		}

		return null;
	}

	/**
	 * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
	 * so they can be used to add special data to elements.
	 *
	 * @param {String|Symbol} key
	 * @param {*} value
	 */
	setCustomProperty( key, value ) {
		this._customProperties.set( key, value );
	}

	/**
	 * Returns the custom property value for the given key.
	 *
	 * @param {String|Symbol} key
	 * @returns {*}
	 */
	getCustomProperty( key ) {
		return this._customProperties.get( key );
	}

	/**
	 * Removes the custom property stored under the given key.
	 *
	 * @param {String|Symbol} key
	 * @returns {Boolean} Returns true if property was removed.
	 */
	removeCustomProperty( key ) {
		return this._customProperties.delete( key );
	}

	/**
	 * Returns an iterator which iterates over this element's custom properties.
	 * Iterator provides [key, value] pair for each stored property.
	 *
	 * @returns {Iterable.<*>}
	 */
	* getCustomProperties() {
		yield* this._customProperties.entries();
	}

	/**
	 * Returns identity string based on element's name, styles, classes and other attributes.
	 * Two elements that {@link #isSimilar are similar} will have same identity string.
	 * It has the following format:
	 *
	 *		'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
 	 *
	 * For example:
	 *
	 *		const element = new ViewElement( 'foo' );
	 *		element.setAttribute( 'banana', '10' );
	 *		element.setAttribute( 'apple', '20' );
	 *		element.setStyle( 'color', 'red' );
	 *		element.setStyle( 'border-color', 'white' );
	 *		element.addClass( 'baz' );
	 *
	 *		// returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
	 *		element.getIdentity();
	 *
	 * NOTE: Classes, styles and other attributes are sorted alphabetically.
	 *
	 * @returns {String}
	 */
	getIdentity() {
		const classes = Array.from( this._classes ).sort().join( ',' );
		const styles = Array.from( this._styles ).map( i => `${ i[ 0 ] }:${ i[ 1 ] }` ).sort().join( ';' );
		const attributes = Array.from( this._attrs ).map( i => `${ i[ 0 ] }="${ i[ 1 ] }"` ).sort().join( ' ' );

		return this.name +
			( classes == '' ? '' : ` class="${ classes }"` ) +
			( styles == '' ? '' : ` style="${ styles }"` ) +
			( attributes == '' ? '' : ` ${ attributes }` );
	}

	/**
	 * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.
	 *
	 * @abstract
	 * @method module:engine/view/element~Element#getFillerOffset
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Element;


// Parses inline styles and puts property - value pairs into styles map.
// Styles map is cleared before insertion.
//
// @param {Map.<String, String>} stylesMap Map to insert parsed properties and values.
// @param {String} stylesString Styles to parse.
function parseInlineStyles( stylesMap, stylesString ) {
	// `null` if no quote was found in input string or last found quote was a closing quote. See below.
	let quoteType = null;
	let propertyNameStart = 0;
	let propertyValueStart = 0;
	let propertyName = null;

	stylesMap.clear();

	// Do not set anything if input string is empty.
	if ( stylesString === '' ) {
		return;
	}

	// Fix inline styles that do not end with `;` so they are compatible with algorithm below.
	if ( stylesString.charAt( stylesString.length - 1 ) != ';' ) {
		stylesString = stylesString + ';';
	}

	// Seek the whole string for "special characters".
	for ( let i = 0; i < stylesString.length; i++ ) {
		const char = stylesString.charAt( i );

		if ( quoteType === null ) {
			// No quote found yet or last found quote was a closing quote.
			switch ( char ) {
				case ':':
					// Most of time colon means that property name just ended.
					// Sometimes however `:` is found inside property value (for example in background image url).
					if ( !propertyName ) {
						// Treat this as end of property only if property name is not already saved.
						// Save property name.
						propertyName = stylesString.substr( propertyNameStart, i - propertyNameStart );
						// Save this point as the start of property value.
						propertyValueStart = i + 1;
					}

					break;

				case '"':
				case '\'':
					// Opening quote found (this is an opening quote, because `quoteType` is `null`).
					quoteType = char;

					break;

				// eslint-disable-next-line no-case-declarations
				case ';':
					// Property value just ended.
					// Use previously stored property value start to obtain property value.
					const propertyValue = stylesString.substr( propertyValueStart, i - propertyValueStart );

					if ( propertyName ) {
						// Save parsed part.
						stylesMap.set( propertyName.trim(), propertyValue.trim() );
					}

					propertyName = null;

					// Save this point as property name start. Property name starts immediately after previous property value ends.
					propertyNameStart = i + 1;

					break;
			}
		} else if ( char === quoteType ) {
			// If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.
			quoteType = null;
		}
	}
}

// Parses class attribute and puts all classes into classes set.
// Classes set s cleared before insertion.
//
// @param {Set.<String>} classesSet Set to insert parsed classes.
// @param {String} classesString String with classes to parse.
function parseClasses( classesSet, classesString ) {
	const classArray = classesString.split( /\s+/ );
	classesSet.clear();
	classArray.forEach( name => classesSet.add( name ) );
}

// Converts strings to Text and non-iterables to arrays.
//
// @param {String|module:engine/view/node~Node|Iterable.<String|module:engine/view/node~Node>}
// @return {Iterable.<module:engine/view/node~Node>}
function normalize( nodes ) {
	// Separate condition because string is iterable.
	if ( typeof nodes == 'string' ) {
		return [ new __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */]( nodes ) ];
	}

	if ( !Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_isiterable__["a" /* default */])( nodes ) ) {
		nodes = [ nodes ];
	}

	// Array.from to enable .map() on non-arrays.
	return Array.from( nodes )
		.map( node => {
			return typeof node == 'string' ? new __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */]( node ) : node;
		} );
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseMatches__ = __webpack_require__(382);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseMatchesProperty__ = __webpack_require__(389);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__identity__ = __webpack_require__(198);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArray__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__property__ = __webpack_require__(397);






/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return __WEBPACK_IMPORTED_MODULE_2__identity__["a" /* default */];
  }
  if (typeof value == 'object') {
    return Object(__WEBPACK_IMPORTED_MODULE_3__isArray__["a" /* default */])(value)
      ? Object(__WEBPACK_IMPORTED_MODULE_1__baseMatchesProperty__["a" /* default */])(value[0], value[1])
      : Object(__WEBPACK_IMPORTED_MODULE_0__baseMatches__["a" /* default */])(value);
  }
  return Object(__WEBPACK_IMPORTED_MODULE_4__property__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (baseIteratee);


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module core/command
 */




/**
 * The base class for CKEditor commands.
 *
 * Commands are the main way to manipulate editor contents and state. They are mostly used by UI elements (or by other
 * commands) to make changes in the model. Commands are available in every part of code that has access to
 * the {@link module:core/editor/editor~Editor editor} instance.
 *
 * Instances of registered commands can be retrieved from {@link module:core/editor/editor~Editor#commands}.
 * The easiest way to execute a command is through {@link module:core/editor/editor~Editor#execute}.
 *
 * By default commands are disabled when the editor is in {@link module:core/editor/editor~Editor#isReadOnly read-only} mode.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */
class Command {
	/**
	 * Creates a new `Command` instance.
	 *
	 * @param {module:core/editor/editor~Editor} editor Editor on which this command will be used.
	 */
	constructor( editor ) {
		/**
		 * The editor on which this command will be used.
		 *
		 * @readonly
		 * @member {module:core/editor/editor~Editor}
		 */
		this.editor = editor;

		/**
		 * The value of a command. Concrete command class should define what it represents.
		 *
		 * For example, the `bold` command's value is whether the selection starts in a bolded text.
		 * And the value of the `link` command may be an object with links details.
		 *
		 * It's possible for a command to have no value (e.g. for stateless actions such as `uploadImage`).
		 *
		 * @observable
		 * @readonly
		 * @member #value
		 */
		this.set( 'value', undefined );

		/**
		 * Flag indicating whether a command is enabled or disabled.
		 * A disabled command should do nothing when executed.
		 *
		 * @observable
		 * @readonly
		 * @member {Boolean} #isEnabled
		 */
		this.set( 'isEnabled', false );

		this.decorate( 'execute' );

		// By default every command is refreshed when changes are applied to the model.
		this.listenTo( this.editor.document, 'changesDone', () => {
			this.refresh();
		} );

		this.on( 'execute', evt => {
			if ( !this.isEnabled ) {
				evt.stop();
			}
		}, { priority: 'high' } );

		// By default commands are disabled when the editor is in read-only mode.
		this.listenTo( editor, 'change:isReadOnly', ( evt, name, value ) => {
			if ( value ) {
				// See a ticket about overriding observable properties
				// https://github.com/ckeditor/ckeditor5-utils/issues/171.
				this.on( 'change:isEnabled', forceDisable, { priority: 'lowest' } );
				this.isEnabled = false;
			} else {
				this.off( 'change:isEnabled', forceDisable );
				this.refresh();
			}
		} );

		function forceDisable() {
			this.isEnabled = false;
		}
	}

	/**
	 * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} property
	 * in this method.
	 *
	 * This method is automatically called when
	 * {@link module:engine/model/document~Document#event:changesDone any changes are applied to the model}.
	 */
	refresh() {
		this.isEnabled = true;
	}

	/**
	 * Executes the command.
	 *
	 * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute}
	 * to the command.
	 *
	 * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).
	 * This behavior is implemented by a high priority listener to the {@link #event:execute} event.
	 *
	 * @fires execute
	 */
	execute() {}

	/**
	 * Destroys the command.
	 */
	destroy() {
		this.stopListening();
	}

	/**
	 * Event fired by the {@link #execute} method. The command action is a listener to this event so it's
	 * possible to change/cancel the behavior of the command by listening to this event.
	 *
	 * See {@link module:utils/observablemixin~ObservableMixin.decorate} for more information and samples.
	 *
	 * **Note:** This event is fired even if command is disabled. However, it is automatically blocked
	 * by a high priority listener in order to prevent command execution.
	 *
	 * @event execute
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Command;


Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Command, __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__toFinite__ = __webpack_require__(303);


/**
 * Converts `value` to an integer.
 *
 * **Note:** This function is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = Object(__WEBPACK_IMPORTED_MODULE_0__toFinite__["a" /* default */])(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/* harmony default export */ __webpack_exports__["a"] = (toInteger);


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArrayLike__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike__ = __webpack_require__(43);



/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike__["a" /* default */])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__isArrayLike__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (isArrayLikeObject);


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @type {Function}
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/* harmony default export */ __webpack_exports__["a"] = (isArray);


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_lodash_extend__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_lodash_isObject__ = __webpack_require__(16);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/observablemixin
 */






const attributesSymbol = Symbol( 'attributes' );
const boundObservablesSymbol = Symbol( 'boundObservables' );
const boundAttributesSymbol = Symbol( 'boundAttributes' );

/**
 * Mixin that injects the "observable attributes" and data binding functionality.
 * Used mainly in the {@link module:ui/model~Model} class.
 *
 * @mixin ObservableMixin
 * @mixes module:utils/emittermixin~EmitterMixin
 * @implements module:utils/observablemixin~Observable
 */
const ObservableMixin = {
	/**
	 * Creates and sets the value of an observable attribute of this object. Such an attribute becomes a part
	 * of the state and is be observable.
	 *
	 * It accepts also a single object literal containing key/value pairs with attributes to be set.
	 *
	 * This method throws the observable-set-cannot-override error if the observable instance already
	 * have a property with a given attribute name. This prevents from mistakenly overriding existing
	 * properties and methods, but means that `foo.set( 'bar', 1 )` may be slightly slower than `foo.bar = 1`.
	 *
	 * @method #set
	 * @param {String} name The attributes name.
	 * @param {*} value The attributes value.
	 */
	set( name, value ) {
		// If the first parameter is an Object, iterate over its properties.
		if ( Object(__WEBPACK_IMPORTED_MODULE_3__lib_lodash_isObject__["a" /* default */])( name ) ) {
			Object.keys( name ).forEach( attr => {
				this.set( attr, name[ attr ] );
			}, this );

			return;
		}

		initObservable( this );

		const attributes = this[ attributesSymbol ];

		if ( ( name in this ) && !attributes.has( name ) ) {
			/**
			 * Cannot override an existing property.
			 *
			 * This error is thrown when trying to {@link ~Observable#set set} an attribute with
			 * a name of an already existing property. For example:
			 *
			 *		let observable = new Model();
			 *		observable.property = 1;
			 *		observable.set( 'property', 2 );		// throws
			 *
			 *		observable.set( 'attr', 1 );
			 *		observable.set( 'attr', 2 );			// ok, because this is an existing attribute.
			 *
			 * @error observable-set-cannot-override
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'observable-set-cannot-override: Cannot override an existing property.' );
		}

		Object.defineProperty( this, name, {
			enumerable: true,
			configurable: true,

			get() {
				return attributes.get( name );
			},

			set( value ) {
				const oldValue = attributes.get( name );

				// Allow undefined as an initial value like A.define( 'x', undefined ) (#132).
				// Note: When attributes map has no such own property, then its value is undefined.
				if ( oldValue !== value || !attributes.has( name ) ) {
					attributes.set( name, value );
					this.fire( 'change:' + name, name, value, oldValue );
				}
			}
		} );

		this[ name ] = value;
	},

	/**
	 * Binds observable attributes to another objects implementing {@link ~ObservableMixin}
	 * interface (like {@link module:ui/model~Model}).
	 *
	 * Once bound, the observable will immediately share the current state of attributes
	 * of the observable it is bound to and react to the changes to these attributes
	 * in the future.
	 *
	 * **Note**: To release the binding use {@link module:utils/observablemixin~ObservableMixin#unbind}.
	 *
	 *		A.bind( 'a' ).to( B );
	 *		A.bind( 'a' ).to( B, 'b' );
	 *		A.bind( 'a', 'b' ).to( B, 'c', 'd' );
	 *		A.bind( 'a' ).to( B, 'b', C, 'd', ( b, d ) => b + d );
	 *
	 * @method #bind
	 * @param {...String} bindAttrs Observable attributes that will be bound to another observable(s).
	 * @returns {module:utils/observablemixin~BindChain}
	 */
	bind( ...bindAttrs ) {
		if ( !bindAttrs.length || !isStringArray( bindAttrs ) ) {
			/**
			 * All attributes must be strings.
			 *
			 * @error observable-bind-wrong-attrs
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'observable-bind-wrong-attrs: All attributes must be strings.' );
		}

		if ( ( new Set( bindAttrs ) ).size !== bindAttrs.length ) {
			/**
			 * Attributes must be unique.
			 *
			 * @error observable-bind-duplicate-attrs
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'observable-bind-duplicate-attrs: Attributes must be unique.' );
		}

		initObservable( this );

		const boundAttributes = this[ boundAttributesSymbol ];

		bindAttrs.forEach( attrName => {
			if ( boundAttributes.has( attrName ) ) {
				/**
				 * Cannot bind the same attribute more that once.
				 *
				 * @error observable-bind-rebind
				 */
				throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'observable-bind-rebind: Cannot bind the same attribute more that once.' );
			}
		} );

		const bindings = new Map();

		/**
		 * @typedef Binding
		 * @type Object
		 * @property {Array} attr Attribute which is bound.
		 * @property {Array} to Array of observableattribute components of the binding (`{ observable: ..., attr: .. }`).
		 * @property {Array} callback A function which processes `to` components.
		 */
		bindAttrs.forEach( a => {
			const binding = { attr: a, to: [] };

			boundAttributes.set( a, binding );
			bindings.set( a, binding );
		} );

		/**
		 * @typedef BindChain
		 * @type Object
		 * @property {Function} to See {@link ~ObservableMixin#_bindTo}.
		 * @property {module:utils/observablemixin~Observable} _observable The observable which initializes the binding.
		 * @property {Array} _bindAttrs Array of `_observable` attributes to be bound.
		 * @property {Array} _to Array of `to()` observableattributes (`{ observable: toObservable, attrs: ...toAttrs }`).
		 * @property {Map} _bindings Stores bindings to be kept in
		 *  {@link ~ObservableMixin#_boundAttributes}/{@link ~ObservableMixin#_boundObservables}
		 * initiated in this binding chain.
		 */
		return {
			to: bindTo,

			_observable: this,
			_bindAttrs: bindAttrs,
			_to: [],
			_bindings: bindings
		};
	},

	/**
	 * Removes the binding created with {@link ~ObservableMixin#bind}.
	 *
	 *		A.unbind( 'a' );
	 *		A.unbind();
	 *
	 * @method #unbind
	 * @param {...String} [unbindAttrs] Observable attributes to be unbound. All the bindings will
	 * be released if no attributes provided.
	 */
	unbind( ...unbindAttrs ) {
		// Nothing to do here if not inited yet.
		if ( !( attributesSymbol in this ) ) {
			return;
		}

		const boundAttributes = this[ boundAttributesSymbol ];
		const boundObservables = this[ boundObservablesSymbol ];

		if ( unbindAttrs.length ) {
			if ( !isStringArray( unbindAttrs ) ) {
				/**
				 * Attributes must be strings.
				 *
				 * @error observable-unbind-wrong-attrs
				 */
				throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'observable-unbind-wrong-attrs: Attributes must be strings.' );
			}

			unbindAttrs.forEach( attrName => {
				const binding = boundAttributes.get( attrName );
				let toObservable, toAttr, toAttrs, toAttrBindings;

				binding.to.forEach( to => {
					// TODO: ES6 destructuring.
					toObservable = to[ 0 ];
					toAttr = to[ 1 ];
					toAttrs = boundObservables.get( toObservable );
					toAttrBindings = toAttrs[ toAttr ];

					toAttrBindings.delete( binding );

					if ( !toAttrBindings.size ) {
						delete toAttrs[ toAttr ];
					}

					if ( !Object.keys( toAttrs ).length ) {
						boundObservables.delete( toObservable );
						this.stopListening( toObservable, 'change' );
					}
				} );

				boundAttributes.delete( attrName );
			} );
		} else {
			boundObservables.forEach( ( bindings, boundObservable ) => {
				this.stopListening( boundObservable, 'change' );
			} );

			boundObservables.clear();
			boundAttributes.clear();
		}
	},

	/**
	 * Turns the given methods of this object into event-based ones. This means that the new method will fire an event
	 * (named after the method) and the original action will be plugged as a listener to that event.
	 *
	 * This is a very simplified method decoration. Itself it doesn't change the behavior of a method (expect adding the event),
	 * but it allows to modify it later on by listening to the method's event.
	 *
	 * For example, in order to cancel the method execution one can stop the event:
	 *
	 *		class Foo {
	 *			constructor() {
	 *				this.decorate( 'method' );
	 *			}
	 *
	 *			method() {
	 *				console.log( 'called!' );
	 *			}
	 *		}
	 *
	 *		const foo = new Foo();
	 *		foo.on( 'method', ( evt ) => {
	 *			evt.stop();
	 *		}, { priority: 'high' } );
	 *
	 *		foo.method(); // Nothing is logged.
	 *
	 *
	 * Note: we used a high priority listener here to execute this callback before the one which
	 * calls the orignal method (which used the default priority).
	 *
	 * It's also possible to change the return value:
	 *
	 *		foo.on( 'method', ( evt ) => {
	 *			evt.return = 'Foo!';
	 *		} );
	 *
	 *		foo.method(); // -> 'Foo'
	 *
	 * Finally, it's possible to access and modify the parameters:
	 *
	 *		method( a, b ) {
	 *			console.log( `${ a }, ${ b }`  );
	 *		}
	 *
	 *		// ...
	 *
	 *		foo.on( 'method', ( evt, args ) => {
	 *			args[ 0 ] = 3;
	 *
	 *			console.log( args[ 1 ] ); // -> 2
	 *		}, { priority: 'high' } );
	 *
	 *		foo.method( 1, 2 ); // -> '3, 2'
	 *
	 * @method #decorate
	 * @param {String} methodName Name of the method to decorate.
	 */
	decorate( methodName ) {
		const originalMethod = this[ methodName ];

		if ( !originalMethod ) {
			/**
			 * Cannot decorate an undefined method.
			 *
			 * @error observablemixin-cannot-decorate-undefined
			 * @param {Object} object The object which method should be decorated.
			 * @param {String} methodName Name of the method which does not exist.
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */](
				'observablemixin-cannot-decorate-undefined: Cannot decorate an undefined method.',
				{ object: this, methodName }
			);
		}

		this.on( methodName, ( evt, args ) => {
			evt.return = originalMethod.apply( this, args );
		} );

		this[ methodName ] = function( ...args ) {
			return this.fire( methodName, args );
		};
	}

	/**
	 * @private
	 * @member ~ObservableMixin#_boundAttributes
	 */

	/**
	 * @private
	 * @member ~ObservableMixin#_boundObservables
	 */

	/**
	 * @private
	 * @member ~ObservableMixin#_bindTo
	 */
};

/* harmony default export */ __webpack_exports__["a"] = (ObservableMixin);

// Init symbol properties needed to for the observable mechanism to work.
//
// @private
// @param {module:utils/observablemixin~ObservableMixin} observable
function initObservable( observable ) {
	// Do nothing if already inited.
	if ( attributesSymbol in observable ) {
		return;
	}

	// The internal hash containing the observable's state.
	//
	// @private
	// @type {Map}
	Object.defineProperty( observable, attributesSymbol, {
		value: new Map()
	} );

	// Map containing bindings to external observables. It shares the binding objects
	// (`{ observable: A, attr: 'a', to: ... }`) with {@link module:utils/observablemixin~ObservableMixin#_boundAttributes} and
	// it is used to observe external observables to update own attributes accordingly.
	// See {@link module:utils/observablemixin~ObservableMixin#bind}.
	//
	//		A.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );
	//		console.log( A._boundObservables );
	//
	//			Map( {
	//				B: {
	//					x: Set( [
	//						{ observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
	//						{ observable: A, attr: 'c', to: [ [ B, 'x' ] ] }
	//					] ),
	//					y: Set( [
	//						{ observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
	//					] )
	//				}
	//			} )
	//
	//		A.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );
	//		console.log( A._boundObservables );
	//
	//			Map( {
	//				B: {
	//					x: Set( [
	//						{ observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
	//						{ observable: A, attr: 'c', to: [ [ B, 'x' ] ] }
	//					] ),
	//					y: Set( [
	//						{ observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
	//					] ),
	//					z: Set( [
	//						{ observable: A, attr: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
	//					] )
	//				},
	//				C: {
	//					w: Set( [
	//						{ observable: A, attr: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
	//					] )
	//				}
	//			} )
	//
	// @private
	// @type {Map}
	Object.defineProperty( observable, boundObservablesSymbol, {
		value: new Map()
	} );

	// Object that stores which attributes of this observable are bound and how. It shares
	// the binding objects (`{ observable: A, attr: 'a', to: ... }`) with {@link utils.ObservableMixin#_boundObservables}.
	// This data structure is a reverse of {@link utils.ObservableMixin#_boundObservables} and it is helpful for
	// {@link utils.ObservableMixin#unbind}.
	//
	// See {@link utils.ObservableMixin#bind}.
	//
	//		A.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );
	//		console.log( A._boundAttributes );
	//
	//			Map( {
	//				a: { observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
	//				b: { observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
	//				c: { observable: A, attr: 'c', to: [ [ B, 'x' ] ] }
	//			} )
	//
	//		A.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );
	//		console.log( A._boundAttributes );
	//
	//			Map( {
	//				a: { observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
	//				b: { observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
	//				c: { observable: A, attr: 'c', to: [ [ B, 'x' ] ] },
	//				d: { observable: A, attr: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
	//			} )
	//
	// @private
	// @type {Map}
	Object.defineProperty( observable, boundAttributesSymbol, {
		value: new Map()
	} );
}

// A chaining for {@link module:utils/observablemixin~ObservableMixin#bind} providing `.to()` interface.
//
// @private
// @param {...[Observable|String|Function]} args Arguments of the `.to( args )` binding.
function bindTo( ...args ) {
	const parsedArgs = parseBindToArgs( ...args );
	const bindingsKeys = Array.from( this._bindings.keys() );
	const numberOfBindings = bindingsKeys.length;

	// Eliminate A.bind( 'x' ).to( B, C )
	if ( !parsedArgs.callback && parsedArgs.to.length > 1 ) {
		/**
		 * Binding multiple observables only possible with callback.
		 *
		 * @error observable-bind-no-callback
		 */
		throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'observable-bind-to-no-callback: Binding multiple observables only possible with callback.' );
	}

	// Eliminate A.bind( 'x', 'y' ).to( B, callback )
	if ( numberOfBindings > 1 && parsedArgs.callback ) {
		/**
		 * Cannot bind multiple attributes and use a callback in one binding.
		 *
		 * @error observable-bind-to-extra-callback
		 */
		throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'observable-bind-to-extra-callback: Cannot bind multiple attributes and use a callback in one binding.' );
	}

	parsedArgs.to.forEach( to => {
		// Eliminate A.bind( 'x', 'y' ).to( B, 'a' )
		if ( to.attrs.length && to.attrs.length !== numberOfBindings ) {
			/**
			 * The number of attributes must match.
			 *
			 * @error observable-bind-to-attrs-length
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'observable-bind-to-attrs-length: The number of attributes must match.' );
		}

		// When no to.attrs specified, observing source attributes instead i.e.
		// A.bind( 'x', 'y' ).to( B ) -> Observe B.x and B.y
		if ( !to.attrs.length ) {
			to.attrs = this._bindAttrs;
		}
	} );

	this._to = parsedArgs.to;

	// Fill {@link BindChain#_bindings} with callback. When the callback is set there's only one binding.
	if ( parsedArgs.callback ) {
		this._bindings.get( bindingsKeys[ 0 ] ).callback = parsedArgs.callback;
	}

	attachBindToListeners( this._observable, this._to );

	// Update observable._boundAttributes and observable._boundObservables.
	updateBindToBound( this );

	// Set initial values of bound attributes.
	this._bindAttrs.forEach( attrName => {
		updateBoundObservableAttr( this._observable, attrName );
	} );
}

// Check if all entries of the array are of `String` type.
//
// @private
// @param {Array} arr An array to be checked.
// @returns {Boolean}
function isStringArray( arr ) {
	return arr.every( a => typeof a == 'string' );
}

// Parses and validates {@link Observable#bind}`.to( args )` arguments and returns
// an object with a parsed structure. For example
//
//		A.bind( 'x' ).to( B, 'a', C, 'b', call );
//
// becomes
//
//		{
//			to: [
//				{ observable: B, attrs: [ 'a' ] },
//				{ observable: C, attrs: [ 'b' ] },
//			],
//			callback: call
// 		}
//
// @private
// @param {...*} args Arguments of {@link Observable#bind}`.to( args )`.
// @returns {Object}
function parseBindToArgs( ...args ) {
	// Eliminate A.bind( 'x' ).to()
	if ( !args.length ) {
		/**
		 * Invalid argument syntax in `to()`.
		 *
		 * @error observable-bind-to-parse-error
		 */
		throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'observable-bind-to-parse-error: Invalid argument syntax in `to()`.' );
	}

	const parsed = { to: [] };
	let lastObservable;

	if ( typeof args[ args.length - 1 ] == 'function' ) {
		parsed.callback = args.pop();
	}

	args.forEach( a => {
		if ( typeof a == 'string' ) {
			lastObservable.attrs.push( a );
		} else if ( typeof a == 'object' ) {
			lastObservable = { observable: a, attrs: [] };
			parsed.to.push( lastObservable );
		} else {
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'observable-bind-to-parse-error: Invalid argument syntax in `to()`.' );
		}
	} );

	return parsed;
}

// Synchronizes {@link module:utils/observablemixin#_boundObservables} with {@link Binding}.
//
// @private
// @param {Binding} binding A binding to store in {@link Observable#_boundObservables}.
// @param {Observable} toObservable A observable, which is a new component of `binding`.
// @param {String} toAttrName A name of `toObservable`'s attribute, a new component of the `binding`.
function updateBoundObservables( observable, binding, toObservable, toAttrName ) {
	const boundObservables = observable[ boundObservablesSymbol ];
	const bindingsToObservable = boundObservables.get( toObservable );
	const bindings = bindingsToObservable || {};

	if ( !bindings[ toAttrName ] ) {
		bindings[ toAttrName ] = new Set();
	}

	// Pass the binding to a corresponding Set in `observable._boundObservables`.
	bindings[ toAttrName ].add( binding );

	if ( !bindingsToObservable ) {
		boundObservables.set( toObservable, bindings );
	}
}

// Synchronizes {@link Observable#_boundAttributes} and {@link Observable#_boundObservables}
// with {@link BindChain}.
//
// Assuming the following binding being created
//
// 		A.bind( 'a', 'b' ).to( B, 'x', 'y' );
//
// the following bindings were initialized by {@link Observable#bind} in {@link BindChain#_bindings}:
//
// 		{
// 			a: { observable: A, attr: 'a', to: [] },
// 			b: { observable: A, attr: 'b', to: [] },
// 		}
//
// Iterate over all bindings in this chain and fill their `to` properties with
// corresponding to( ... ) arguments (components of the binding), so
//
// 		{
// 			a: { observable: A, attr: 'a', to: [ B, 'x' ] },
// 			b: { observable: A, attr: 'b', to: [ B, 'y' ] },
// 		}
//
// Then update the structure of {@link Observable#_boundObservables} with updated
// binding, so it becomes:
//
// 		Map( {
// 			B: {
// 				x: Set( [
// 					{ observable: A, attr: 'a', to: [ [ B, 'x' ] ] }
// 				] ),
// 				y: Set( [
// 					{ observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
// 				] )
//			}
// 		} )
//
// @private
// @param {BindChain} chain The binding initialized by {@link Observable#bind}.
function updateBindToBound( chain ) {
	let toAttr;

	chain._bindings.forEach( ( binding, attrName ) => {
		// Note: For a binding without a callback, this will run only once
		// like in A.bind( 'x', 'y' ).to( B, 'a', 'b' )
		// TODO: ES6 destructuring.
		chain._to.forEach( to => {
			toAttr = to.attrs[ binding.callback ? 0 : chain._bindAttrs.indexOf( attrName ) ];

			binding.to.push( [ to.observable, toAttr ] );
			updateBoundObservables( chain._observable, binding, to.observable, toAttr );
		} );
	} );
}

// Updates an attribute of a {@link Observable} with a value
// determined by an entry in {@link Observable#_boundAttributes}.
//
// @private
// @param {Observable} observable A observable which attribute is to be updated.
// @param {String} attrName An attribute to be updated.
function updateBoundObservableAttr( observable, attrName ) {
	const boundAttributes = observable[ boundAttributesSymbol ];
	const binding = boundAttributes.get( attrName );
	let attrValue;

	// When a binding with callback is created like
	//
	// 		A.bind( 'a' ).to( B, 'b', C, 'c', callback );
	//
	// collect B.b and C.c, then pass them to callback to set A.a.
	if ( binding.callback ) {
		attrValue = binding.callback.apply( observable, binding.to.map( to => to[ 0 ][ to[ 1 ] ] ) );
	} else {
		attrValue = binding.to[ 0 ];
		attrValue = attrValue[ 0 ][ attrValue[ 1 ] ];
	}

	if ( observable.hasOwnProperty( attrName ) ) {
		observable[ attrName ] = attrValue;
	} else {
		observable.set( attrName, attrValue );
	}
}

// Starts listening to changes in {@link BindChain._to} observables to update
// {@link BindChain._observable} {@link BindChain._bindAttrs}. Also sets the
// initial state of {@link BindChain._observable}.
//
// @private
// @param {BindChain} chain The chain initialized by {@link Observable#bind}.
function attachBindToListeners( observable, toBindings ) {
	toBindings.forEach( to => {
		const boundObservables = observable[ boundObservablesSymbol ];
		let bindings;

		// If there's already a chain between the observables (`observable` listens to
		// `to.observable`), there's no need to create another `change` event listener.
		if ( !boundObservables.get( to.observable ) ) {
			observable.listenTo( to.observable, 'change', ( evt, attrName ) => {
				bindings = boundObservables.get( to.observable )[ attrName ];

				// Note: to.observable will fire for any attribute change, react
				// to changes of attributes which are bound only.
				if ( bindings ) {
					bindings.forEach( binding => {
						updateBoundObservableAttr( observable, binding.attr );
					} );
				}
			} );
		}
	} );
}

Object(__WEBPACK_IMPORTED_MODULE_2__lib_lodash_extend__["a" /* default */])( ObservableMixin, __WEBPACK_IMPORTED_MODULE_0__emittermixin__["c" /* default */] );

/**
 * Fired when an attribute changed value.
 *
 *		observable.set( 'prop', 1 );
 *
 *		observable.on( 'change:prop', ( evt, propertyName, newValue, oldValue ) => {
 *			console.log( `${ propertyName } has changed from ${ oldValue } to ${ newValue }` );
 *		} )
 *
 *		observable.prop = 2; // -> 'prop has changed from 1 to 2'
 *
 * @event module:utils/observablemixin~ObservableMixin#change:{attribute}
 * @param {String} name The attribute name.
 * @param {*} value The new attribute value.
 * @param {*} oldValue The previous attribute value.
 */

/**
 * Interface representing classes which mix in {@link module:utils/observablemixin~ObservableMixin}.
 *
 * @interface Observable
 */


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/* harmony default export */ __webpack_exports__["a"] = (isObject);


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (last);


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__operation_operationfactory__ = __webpack_require__(369);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/deltafactory
 */





const deserializers = new Map();

/**
 * A factory class for creating operations.
 *
 * Delta is a single, from the user action point of view, change in the editable document, like insert, split or
 * rename element. Delta is composed of operations, which are unit changes needed to be done to execute user action.
 *
 * Multiple deltas are grouped into a single {@link module:engine/model/batch~Batch}.
 */
class DeltaFactory {
	/**
	 * Creates InsertDelta from deserialized object, i.e. from parsed JSON string.
	 *
	 * @param {Object} json
	 * @param {module:engine/model/document~Document} doc Document on which this delta will be applied.
	 * @returns {module:engine/model/delta/insertdelta~InsertDelta}
	 */
	static fromJSON( json, doc ) {
		if ( !deserializers.has( json.__className ) ) {
			/**
			 * This delta has no defined deserializer.
			 *
			 * @error delta-fromjson-no-deserializer
			 * @param {String} name
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'delta-fromjson-no-deserializer: This delta has no defined deserializer',
				{ name: json.__className }
			);
		}

		const Delta = deserializers.get( json.__className );

		const delta = new Delta();

		for ( const operation of json.operations ) {
			delta.addOperation( __WEBPACK_IMPORTED_MODULE_1__operation_operationfactory__["a" /* default */].fromJSON( operation, doc ) );
		}

		// Rewrite all other properties.
		for ( const prop in json ) {
			if ( prop != '__className' && delta[ prop ] === undefined ) {
				delta[ prop ] = json[ prop ];
			}
		}

		return delta;
	}

	/**
	 * Registers a class for delta factory.
	 *
	 * @param {Function} Delta A delta class to register.
	 */
	static register( Delta ) {
		deserializers.set( Delta.className, Delta );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DeltaFactory;



/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = register;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/batch
 */



/**
 * `Batch` instance groups document changes ({@link module:engine/model/delta/delta~Delta deltas}). All deltas grouped in a single `Batch`
 * can be reverted together, so you can think about `Batch` as of a single undo step. If you want to extend given undo step you
 * can call another method on the same `Batch` object. If you want to create a separate undo step you can create a new `Batch`.
 *
 * For example to create two separate undo steps you can call:
 *
 *		doc.batch().insert( firstPosition, 'foo' );
 *		doc.batch().insert( secondPosition, 'bar' );
 *
 * To create a single undo step:
 *
 *		const batch = doc.batch();
 *		batch.insert( firstPosition, 'foo' );
 *		batch.insert( secondPosition, 'bar' );
 *
 * Note that all document modification methods (insert, remove, split, etc.) are chainable so you can shorten code to:
 *
 *		doc.batch().insert( firstPosition, 'foo' ).insert( secondPosition, 'bar' );
 */
class Batch {
	/**
	 * Creates `Batch` instance. Not recommended to use directly, use {@link module:engine/model/document~Document#batch} instead.
	 *
	 * @param {module:engine/model/document~Document} document Document which this Batch changes.
	 * @param {'transparent'|'default'} [type='default'] Type of the batch.
	 */
	constructor( document, type = 'default' ) {
		/**
		 * Document which this batch changes.
		 *
		 * @readonly
		 * @member {module:engine/model/document~Document} module:engine/model/batch~Batch#document
		 */
		this.document = document;

		/**
		 * Array of deltas which compose this batch.
		 *
		 * @readonly
		 * @member {Array.<module:engine/model/delta/delta~Delta>} module:engine/model/batch~Batch#deltas
		 */
		this.deltas = [];

		/**
		 * Type of the batch.
		 *
		 * Can be one of the following values:
		 * * `'default'` - all "normal" batches, most commonly used type.
		 * * `'transparent'` - batch that should be ignored by other features, i.e. initial batch or collaborative editing changes.
		 *
		 * @readonly
		 * @member {'transparent'|'default'} module:engine/model/batch~Batch#type
		 */
		this.type = type;
	}

	/**
	 * Returns this batch base version, which is equal to the base version of first delta in the batch.
	 * If there are no deltas in the batch, it returns `null`.
	 *
	 * @readonly
	 * @type {Number|null}
	 */
	get baseVersion() {
		return this.deltas.length > 0 ? this.deltas[ 0 ].baseVersion : null;
	}

	/**
	 * Adds delta to the batch instance. All modification methods (insert, remove, split, etc.) use this method
	 * to add created deltas.
	 *
	 * @param {module:engine/model/delta/delta~Delta} delta Delta to add.
	 * @return {module:engine/model/delta/delta~Delta} Added delta.
	 */
	addDelta( delta ) {
		delta.batch = this;
		this.deltas.push( delta );

		return delta;
	}

	/**
	 * Gets an iterable collection of operations.
	 *
	 * @returns {Iterable.<module:engine/model/operation/operation~Operation>}
	 */
	* getOperations() {
		for ( const delta of this.deltas ) {
			yield* delta.operations;
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Batch;


/**
 * Function to register batch methods. To make code scalable `Batch` do not have modification
 * methods built in. They can be registered using this method.
 *
 * This method checks if there is no naming collision and throws `batch-register-taken` if the method name
 * is already taken.
 *
 * Besides that no magic happens here, the method is added to the `Batch` class prototype.
 *
 * For example:
 *
 *		Batch.register( 'insert', function( position, nodes ) {
 *			// You can use a class inheriting from `Delta` if that class should handle OT in a special way.
 *			const delta = new Delta();
 *
 *			// Add delta to the Batch instance. It is important to add a delta to the batch before applying any operation.
 *			this.addDelta( delta );
 *
 *			// Create operations which should be components of this delta.
 *			const operation = new InsertOperation( position, nodes, this.document.version );
 *
 *			// Add operation to the delta. It is important to add operation before applying it.
 *			delta.addOperation( operation );
 *
 *			// Remember to apply every operation, no magic, you need to do it manually.
 *			this.document.applyOperation( operation );
 *
 *			// Make this method chainable.
 *			return this;
 *		} );
 *
 * @method module:engine/model/batch~Batch.register
 * @param {String} name Method name.
 * @param {Function} creator Method body.
 */
function register( name, creator ) {
	if ( Batch.prototype[ name ] ) {
		/**
		 * This batch method name is already taken.
		 *
		 * @error batch-register-taken
		 * @param {String} name
		 */
		throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
			'model-batch-register-taken: This batch method name is already taken.',
			{ name } );
	}

	Batch.prototype[ name ] = creator;
}


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__treewalker__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_comparearrays__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__editableelement__ = __webpack_require__(89);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/position
 */







/**
 * Position in the tree. Position is always located before or after a node.
 */
class Position {
	/**
	 * Creates a position.
	 *
	 * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} parent Position parent.
	 * @param {Number} offset Position offset.
	 */
	constructor( parent, offset ) {
		/**
		 * Position parent.
		 *
		 * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}
		 * module:engine/view/position~Position#parent
		 */
		this.parent = parent;

		/**
		 * Position offset.
		 *
		 * @member {Number} module:engine/view/position~Position#offset
		 */
		this.offset = offset;
	}

	/**
	 * Node directly after the position. Equals `null` when there is no node after position or position is located
	 * inside text node.
	 *
	 * @readonly
	 * @type {module:engine/view/node~Node|null}
	 */
	get nodeAfter() {
		if ( this.parent.is( 'text' ) ) {
			return null;
		}

		return this.parent.getChild( this.offset ) || null;
	}

	/**
	 * Node directly before the position. Equals `null` when there is no node before position or position is located
	 * inside text node.
	 *
	 * @readonly
	 * @type {module:engine/view/node~Node|null}
	 */
	get nodeBefore() {
		if ( this.parent.is( 'text' ) ) {
			return null;
		}

		return this.parent.getChild( this.offset - 1 ) || null;
	}

	/**
	 * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isAtStart() {
		return this.offset === 0;
	}

	/**
	 * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isAtEnd() {
		const endOffset = this.parent.is( 'text' ) ? this.parent.data.length : this.parent.childCount;

		return this.offset === endOffset;
	}

	/**
	 * Position's root, that is the root of the position's parent element.
	 *
	 * @readonly
	 * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}
	 */
	get root() {
		return this.parent.root;
	}

	/**
	 * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if
	 * position is not inside an editable element.
	 *
	 * @type {module:engine/view/editableelement~EditableElement|null}
	 */
	get editableElement() {
		let editable = this.parent;

		while ( !( editable instanceof __WEBPACK_IMPORTED_MODULE_3__editableelement__["a" /* default */] ) ) {
			if ( editable.parent ) {
				editable = editable.parent;
			} else {
				return null;
			}
		}

		return editable;
	}

	/**
	 * Returns a new instance of Position with offset incremented by `shift` value.
	 *
	 * @param {Number} shift How position offset should get changed. Accepts negative values.
	 * @returns {module:engine/view/position~Position} Shifted position.
	 */
	getShiftedBy( shift ) {
		const shifted = Position.createFromPosition( this );

		const offset = shifted.offset + shift;
		shifted.offset = offset < 0 ? 0 : offset;

		return shifted;
	}

	/**
	 * Gets the farthest position which matches the callback using
	 * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.
	 *
	 * For example:
	 *
	 * 		getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
	 * 		getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
	 * 		getLastMatchingPosition( value => false ); // Do not move the position.
	 *
	 * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
	 * return `true` if the value should be skipped or `false` if not.
	 * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
	 *
	 * @returns {module:engine/view/position~Position} The position after the last item which matches the `skip` callback test.
	 */
	getLastMatchingPosition( skip, options = {} ) {
		options.startPosition = this;

		const treeWalker = new __WEBPACK_IMPORTED_MODULE_0__treewalker__["a" /* default */]( options );
		treeWalker.skip( skip );

		return treeWalker.position;
	}

	/**
	 * Returns ancestors array of this position, that is this position's parent and it's ancestors.
	 *
	 * @returns {Array} Array with ancestors.
	 */
	getAncestors() {
		if ( this.parent.is( 'documentFragment' ) ) {
			return [ this.parent ];
		} else {
			return this.parent.getAncestors( { includeSelf: true } );
		}
	}

	/**
	 * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
	 * which is a common ancestor of both positions.
	 *
	 * @param {module:engine/view/position~Position} position
	 * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}
	 */
	getCommonAncestor( position ) {
		const ancestorsA = this.getAncestors();
		const ancestorsB = position.getAncestors();

		let i = 0;

		while ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {
			i++;
		}

		return i === 0 ? null : ancestorsA[ i - 1 ];
	}

	/**
	 * Checks whether this position equals given position.
	 *
	 * @param {module:engine/view/position~Position} otherPosition Position to compare with.
	 * @returns {Boolean} True if positions are same.
	 */
	isEqual( otherPosition ) {
		return ( this.parent == otherPosition.parent && this.offset == otherPosition.offset );
	}

	/**
	 * Checks whether this position is located before given position. When method returns `false` it does not mean that
	 * this position is after give one. Two positions may be located inside separate roots and in that situation this
	 * method will still return `false`.
	 *
	 * @see module:engine/view/position~Position#isAfter
	 * @see module:engine/view/position~Position#compareWith
	 * @param {module:engine/view/position~Position} otherPosition Position to compare with.
	 * @returns {Boolean} Returns `true` if this position is before given position.
	 */
	isBefore( otherPosition ) {
		return this.compareWith( otherPosition ) == 'before';
	}

	/**
	 * Checks whether this position is located after given position. When method returns `false` it does not mean that
	 * this position is before give one. Two positions may be located inside separate roots and in that situation this
	 * method will still return `false`.
	 *
	 * @see module:engine/view/position~Position#isBefore
	 * @see module:engine/view/position~Position#compareWith
	 * @param {module:engine/view/position~Position} otherPosition Position to compare with.
	 * @returns {Boolean} Returns `true` if this position is after given position.
	 */
	isAfter( otherPosition ) {
		return this.compareWith( otherPosition ) == 'after';
	}

	/**
	 * Checks whether this position is before, after or in same position that other position. Two positions may be also
	 * different when they are located in separate roots.
	 *
	 * @param {module:engine/view/position~Position} otherPosition Position to compare with.
	 * @returns {module:engine/view/position~PositionRelation}
	 */
	compareWith( otherPosition ) {
		if ( this.isEqual( otherPosition ) ) {
			return 'same';
		}

		// If positions have same parent.
		if ( this.parent === otherPosition.parent ) {
			return this.offset - otherPosition.offset < 0 ? 'before' : 'after';
		}

		// Get path from root to position's parent element.
		const path = this.getAncestors();
		const otherPath = otherPosition.getAncestors();

		// Compare both path arrays to find common ancestor.
		const result = Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( path, otherPath );

		let commonAncestorIndex;

		switch ( result ) {
			case 0:
				// No common ancestors found.
				return 'different';

			case 'prefix':
				commonAncestorIndex = path.length - 1;
				break;

			case 'extension':
				commonAncestorIndex = otherPath.length - 1;
				break;

			default:
				commonAncestorIndex = result - 1;
		}

		// Common ancestor of two positions.
		const commonAncestor = path[ commonAncestorIndex ];
		const nextAncestor1 = path[ commonAncestorIndex + 1 ];
		const nextAncestor2 = otherPath[ commonAncestorIndex + 1 ];

		// Check if common ancestor is not one of the parents.
		if ( commonAncestor === this.parent ) {
			const index = this.offset - nextAncestor2.index;

			return index <= 0 ? 'before' : 'after';
		} else if ( commonAncestor === otherPosition.parent ) {
			const index = nextAncestor1.index - otherPosition.offset;

			return index < 0 ? 'before' : 'after';
		}

		const index = nextAncestor1.index - nextAncestor2.index;

		// Compare indexes of next ancestors inside common one.
		return index < 0 ? 'before' : 'after';
	}

	/**
	 * Creates position at the given location. The location can be specified as:
	 *
	 * * a {@link module:engine/view/position~Position position},
	 * * parent element and offset (offset defaults to `0`),
	 * * parent element and `'end'` (sets position at the end of that element),
	 * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
	 *
	 * This method is a shortcut to other constructors such as:
	 *
	 * * {@link module:engine/view/position~Position.createBefore},
	 * * {@link module:engine/view/position~Position.createAfter},
	 * * {@link module:engine/view/position~Position.createFromPosition}.
	 *
	 * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition
	 * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
	 * first parameter is a {@link module:engine/view/item~Item view item}.
	 */
	static createAt( itemOrPosition, offset ) {
		if ( itemOrPosition instanceof Position ) {
			return this.createFromPosition( itemOrPosition );
		} else {
			const node = itemOrPosition;

			if ( offset == 'end' ) {
				offset = node.is( 'text' ) ? node.data.length : node.childCount;
			} else if ( offset == 'before' ) {
				return this.createBefore( node );
			} else if ( offset == 'after' ) {
				return this.createAfter( node );
			} else if ( !offset ) {
				offset = 0;
			}

			return new Position( node, offset );
		}
	}

	/**
	 * Creates a new position after given view item.
	 *
	 * @param {module:engine/view/item~Item} item View item after which the position should be located.
	 * @returns {module:engine/view/position~Position}
	 */
	static createAfter( item ) {
		// TextProxy is not a instance of Node so we need do handle it in specific way.
		if ( item.is( 'textProxy' ) ) {
			return new Position( item.textNode, item.offsetInText + item.data.length );
		}

		if ( !item.parent ) {
			/**
			 * You can not make a position after a root.
			 *
			 * @error view-position-after-root
			 * @param {module:engine/view/node~Node} root
			 */
			throw new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-position-after-root: You can not make position after root.', { root: item } );
		}

		return new Position( item.parent, item.index + 1 );
	}

	/**
	 * Creates a new position before given view item.
	 *
	 * @param {module:engine/view/item~Item} item View item before which the position should be located.
	 * @returns {module:engine/view/position~Position}
	 */
	static createBefore( item ) {
		// TextProxy is not a instance of Node so we need do handle it in specific way.
		if ( item.is( 'textProxy' ) ) {
			return new Position( item.textNode, item.offsetInText );
		}

		if ( !item.parent ) {
			/**
			 * You cannot make a position before a root.
			 *
			 * @error view-position-before-root
			 * @param {module:engine/view/node~Node} root
			 */
			throw new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-position-before-root: You can not make position before root.', { root: item } );
		}

		return new Position( item.parent, item.index );
	}

	/**
	 * Creates and returns a new instance of `Position`, which is equal to the passed position.
	 *
	 * @param {module:engine/view/position~Position} position Position to be cloned.
	 * @returns {module:engine/view/position~Position}
	 */
	static createFromPosition( position ) {
		return new this( position.parent, position.offset );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Position;


/**
 * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.
 * If positions are in different roots `'different'` flag is returned.
 *
 * @typedef {String} module:engine/view/position~PositionRelation
 */


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node__ = __webpack_require__(82);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/text
 */



/**
 * Tree view text node.
 *
 * @extends module:engine/view/node~Node
 */
class Text extends __WEBPACK_IMPORTED_MODULE_0__node__["a" /* default */] {
	/**
	 * Creates a tree view text node.
	 *
	 * @param {String} data Text.
	 */
	constructor( data ) {
		super();

		/**
		 * The text content.
		 *
		 * Setting the data fires the {@link module:engine/view/node~Node#event:change:text change event}.
		 *
		 * @private
		 * @member {String} module:engine/view/text~Text#_data
		 */
		this._data = data;
	}

	/**
	 * Clones this node.
	 *
	 * @returns {module:engine/view/text~Text} Text node that is a clone of this node.
	 */
	clone() {
		return new Text( this.data );
	}

	/**
	 * @inheritDoc
	 */
	is( type ) {
		return type == 'text';
	}

	/**
	 * The text content.
	 *
	 * Setting the data fires the {@link module:engine/view/node~Node#event:change:text change event}.
	 */
	get data() {
		return this._data;
	}

	set data( data ) {
		this._fireChange( 'text', this );

		this._data = data;
	}

	/**
	 * Checks if this text node is similar to other text node.
	 * Both nodes should have the same data to be considered as similar.
	 *
	 * @param {module:engine/view/text~Text} otherNode Node to check if it is same as this node.
	 * @returns {Boolean}
	 */
	isSimilar( otherNode ) {
		if ( !( otherNode instanceof Text ) ) {
			return false;
		}

		return this === otherNode || this.data === otherNode.data;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Text;



/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = insert;
/* harmony export (immutable) */ __webpack_exports__["d"] = remove;
/* unused harmony export move */
/* unused harmony export setAttribute */
/* unused harmony export removeAttribute */
/* harmony export (immutable) */ __webpack_exports__["c"] = normalizeNodes;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__text__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__textproxy__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__documentfragment__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__nodelist__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/writer
 */









/**
 * Contains functions used for composing model tree, grouped together under "model writer" name. Those functions
 * are built on top of {@link module:engine/model/node~Node node}, and it's child classes', APIs.
 *
 * Model writer API has multiple advantages and it is highly recommended to use it when changing model tree and nodes:
 * * model writer API {@link module:engine/model/writer~writer.normalizeNodes normalizes inserted nodes}, which means that you can insert
 * not only {@link module:engine/model/node~Node nodes}, but also `String`s, {@link module:engine/model/textproxy~TextProxy text proxies}
 * and
 * {@link module:engine/model/documentfragment~DocumentFragment document fragments},
 * * model writer API operates on {@link module:engine/model/position~Position positions}, which means that you have
 * better control over manipulating model tree as positions operate on offsets rather than indexes,
 * * model writer API automatically merges {@link module:engine/model/text~Text text nodes} with same attributes, which means
 * lower memory usage and better efficiency.
 *
 * @namespace writer
 */
const writer = {
	insert,
	remove,
	move,
	setAttribute,
	removeAttribute,
	normalizeNodes
};

/* harmony default export */ __webpack_exports__["a"] = (writer);

/**
 * Inserts given nodes at given position.
 *
 * @function module:engine/model/writer~writer.insert
 * @param {module:engine/model/position~Position} position Position at which nodes should be inserted.
 * @param {module:engine/model/node~NodeSet} nodes Nodes to insert.
 * @returns {module:engine/model/range~Range} Range spanning over inserted elements.
 */
function insert( position, nodes ) {
	nodes = normalizeNodes( nodes );

	// We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.
	const offset = nodes.reduce( ( sum, node ) => sum + node.offsetSize, 0 );
	const parent = position.parent;

	// Insertion might be in a text node, we should split it if that's the case.
	_splitNodeAtPosition( position );
	const index = position.index;

	// Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,
	// using basic `Element` API.
	parent.insertChildren( index, nodes );

	// Merge text nodes, if possible. Merging is needed only at points where inserted nodes "touch" "old" nodes.
	_mergeNodesAtIndex( parent, index + nodes.length );
	_mergeNodesAtIndex( parent, index );

	return new __WEBPACK_IMPORTED_MODULE_3__range__["a" /* default */]( position, position.getShiftedBy( offset ) );
}

/**
 * Removed nodes in given range. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.
 *
 * @function module:engine/model/writer~writer.remove
 * @param {module:engine/model/range~Range} range Range containing nodes to remove.
 * @returns {Array.<module:engine/model/node~Node>}
 */
function remove( range ) {
	if ( !range.isFlat ) {
		/**
		 * Trying to remove a range which starts and ends in different element.
		 *
		 * @error model-writer-remove-range-not-flat
		 */
		throw new __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-writer-remove-range-not-flat: ' +
			'Trying to remove a range which starts and ends in different element.' );
	}

	const parent = range.start.parent;

	// Range may be inside text nodes, we have to split them if that's the case.
	_splitNodeAtPosition( range.start );
	_splitNodeAtPosition( range.end );

	// Remove the text nodes using basic `Element` API.
	const removed = parent.removeChildren( range.start.index, range.end.index - range.start.index );

	// Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be
	// touching at the position equal to the removed range beginning. We check merging possibility there.
	_mergeNodesAtIndex( parent, range.start.index );

	return removed;
}

/**
 * Moves nodes in given range to given target position. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.
 *
 * @param {module:engine/model/range~Range} sourceRange Range containing nodes to move.
 * @param {module:engine/model/position~Position} targetPosition Position to which nodes should be moved.
 * @returns {module:engine/model/range~Range} Range containing moved nodes.
 */
function move( sourceRange, targetPosition ) {
	if ( !sourceRange.isFlat ) {
		/**
		 * Trying to move a range which starts and ends in different element.
		 *
		 * @error model-writer-move-range-not-flat
		 */
		throw new __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-writer-move-range-not-flat: ' +
			'Trying to move a range which starts and ends in different element.' );
	}

	const nodes = this.remove( sourceRange );

	// We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and
	// that change might have an impact on `targetPosition`.
	targetPosition = targetPosition._getTransformedByDeletion( sourceRange.start, sourceRange.end.offset - sourceRange.start.offset );

	return this.insert( targetPosition, nodes );
}

/**
 * Sets given attribute on nodes in given range.
 *
 * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute set.
 * @param {String} key Key of attribute to set.
 * @param {*} value Attribute value.
 */
function setAttribute( range, key, value ) {
	// Range might start or end in text nodes, so we have to split them.
	_splitNodeAtPosition( range.start );
	_splitNodeAtPosition( range.end );

	// Iterate over all items in the range.
	for ( const item of range.getItems() ) {
		// Iterator will return `TextProxy` instances but we know that those text proxies will
		// always represent full text nodes (this is guaranteed thanks to splitting we did before).
		// So, we can operate on those text proxies' text nodes.
		const node = item.is( 'textProxy' ) ? item.textNode : item;

		if ( value !== null ) {
			node.setAttribute( key, value );
		} else {
			node.removeAttribute( key );
		}

		// After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.
		_mergeNodesAtIndex( node.parent, node.index );
	}

	// Try to merge last changed node with it's previous sibling (not covered by the loop above).
	_mergeNodesAtIndex( range.end.parent, range.end.index );
}

/**
 * Removes given attribute from nodes in given range.
 *
 * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute removed.
 * @param {String} key Key of attribute to remove.
 */
function removeAttribute( range, key ) {
	this.setAttribute( range, key, null );
}

/**
 * Normalizes given object or an array of objects to an array of {@link module:engine/model/node~Node nodes}. See
 * {@link module:engine/model/node~NodeSet NodeSet} for details on how normalization is performed.
 *
 * @param {module:engine/model/node~NodeSet} nodes Objects to normalize.
 * @returns {Array.<module:engine/model/node~Node>} Normalized nodes.
 */
function normalizeNodes( nodes ) {
	const normalized = [];

	if ( !( nodes instanceof Array ) ) {
		nodes = [ nodes ];
	}

	// Convert instances of classes other than Node.
	for ( let i = 0; i < nodes.length; i++ ) {
		if ( typeof nodes[ i ] == 'string' ) {
			normalized.push( new __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */]( nodes[ i ] ) );
		} else if ( nodes[ i ] instanceof __WEBPACK_IMPORTED_MODULE_2__textproxy__["a" /* default */] ) {
			normalized.push( new __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */]( nodes[ i ].data, nodes[ i ].getAttributes() ) );
		} else if ( nodes[ i ] instanceof __WEBPACK_IMPORTED_MODULE_4__documentfragment__["a" /* default */] || nodes[ i ] instanceof __WEBPACK_IMPORTED_MODULE_5__nodelist__["a" /* default */] ) {
			for ( const child of nodes[ i ] ) {
				normalized.push( child );
			}
		} else if ( nodes[ i ] instanceof __WEBPACK_IMPORTED_MODULE_0__node__["a" /* default */] ) {
			normalized.push( nodes[ i ] );
		}
		// Skip unrecognized type.
	}

	// Merge text nodes.
	for ( let i = 1; i < normalized.length; i++ ) {
		const node = normalized[ i ];
		const prev = normalized[ i - 1 ];

		if ( node instanceof __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */] && prev instanceof __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */] && _haveSameAttributes( node, prev ) ) {
			// Doing this instead changing prev.data because .data is readonly.
			normalized.splice( i - 1, 2, new __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */]( prev.data + node.data, prev.getAttributes() ) );
			i--;
		}
	}

	return normalized;
}

/**
 * Checks if nodes before and after given index in given element are {@link module:engine/model/text~Text text nodes} and
 * merges them into one node if they have same attributes.
 *
 * Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.
 *
 * @ignore
 * @private
 * @param {module:engine/model/element~Element} element Parent element of nodes to merge.
 * @param {Number} index Index between nodes to merge.
 */
function _mergeNodesAtIndex( element, index ) {
	const nodeBefore = element.getChild( index - 1 );
	const nodeAfter = element.getChild( index );

	// Check if both of those nodes are text objects with same attributes.
	if ( nodeBefore && nodeAfter && nodeBefore.is( 'text' ) && nodeAfter.is( 'text' ) && _haveSameAttributes( nodeBefore, nodeAfter ) ) {
		// Append text of text node after index to the before one.
		const mergedNode = new __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */]( nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes() );

		// Remove separate text nodes.
		element.removeChildren( index - 1, 2 );

		// Insert merged text node.
		element.insertChildren( index - 1, mergedNode );
	}
}

/**
 * Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them
 * containing a part of original text node.
 *
 * @ignore
 * @private
 * @param {module:engine/model/position~Position} position Position at which node should be split.
 */
function _splitNodeAtPosition( position ) {
	const textNode = position.textNode;
	const element = position.parent;

	if ( textNode ) {
		const offsetDiff = position.offset - textNode.startOffset;
		const index = textNode.index;

		element.removeChildren( index, 1 );

		const firstPart = new __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */]( textNode.data.substr( 0, offsetDiff ), textNode.getAttributes() );
		const secondPart = new __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */]( textNode.data.substr( offsetDiff ), textNode.getAttributes() );

		element.insertChildren( index, [ firstPart, secondPart ] );
	}
}

/**
 * Checks whether two given nodes have same attributes.
 *
 * @ignore
 * @private
 * @param {module:engine/model/node~Node} nodeA Node to check.
 * @param {module:engine/model/node~Node} nodeB Node to check.
 * @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.
 */
function _haveSameAttributes( nodeA, nodeB ) {
	const iteratorA = nodeA.getAttributes();
	const iteratorB = nodeB.getAttributes();

	for ( const attr of iteratorA ) {
		if ( attr[ 1 ] !== nodeB.getAttribute( attr[ 0 ] ) ) {
			return false;
		}

		iteratorB.next();
	}

	return iteratorB.next().done;
}

/**
 * Value that can be normalized to an array of {@link module:engine/model/node~Node nodes}.
 *
 * Non-arrays are normalized as follows:
 * * {@link module:engine/model/node~Node Node} is left as is,
 * * {@link module:engine/model/textproxy~TextProxy TextProxy} and `String` are normalized to {@link module:engine/model/text~Text Text},
 * * {@link module:engine/model/nodelist~NodeList NodeList} is normalized to an array containing all nodes that are in that node list,
 * * {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment} is normalized to an array containing all of it's
 * * children.
 *
 * Arrays are processed item by item like non-array values and flattened to one array. Normalization always results in
 * a flat array of {@link module:engine/model/node~Node nodes}. Consecutive text nodes (or items normalized to text nodes) will be
 * merged if they have same attributes.
 *
 * @typedef {module:engine/model/node~Node|module:engine/model/textproxy~TextProxy|String|
 * module:engine/model/nodelist~NodeList|module:engine/model/documentfragment~DocumentFragment|Iterable}
 * module:engine/model/node~NodeSet
 */


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_clone__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__deltafactory__ = __webpack_require__(18);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/delta
 */




/**
 * Base class for all deltas.
 *
 * Delta is a single, from the user action point of view, change in the editable document, like insert, split or
 * rename element. Delta is composed of operations, which are unit changes needed to be done to execute user action.
 *
 * Multiple deltas are grouped into a single {@link module:engine/model/batch~Batch}.
 */
class Delta {
	/**
	 * Creates a delta instance.
	 */
	constructor() {
		/**
		 * {@link module:engine/model/batch~Batch} which delta is a part of. This property is null by default and set by the
		 * {@link module:engine/model/batch~Batch#addDelta} method.
		 *
		 * @readonly
		 * @member {module:engine/model/batch~Batch} module:engine/model/delta/delta~Delta#batch
		 */
		this.batch = null;

		/**
		 * Array of operations which compose delta.
		 *
		 * @readonly
		 * @member {module:engine/model/operation/operation~Operation[]} module:engine/model/delta/delta~Delta#operations
		 */
		this.operations = [];
	}

	/**
	 * Returns delta base version which is equal to the base version of the first operation in delta. If there
	 * are no operations in delta, returns `null`.
	 *
	 * @see module:engine/model/document~Document
	 * @type {Number|null}
	 */
	get baseVersion() {
		if ( this.operations.length > 0 ) {
			return this.operations[ 0 ].baseVersion;
		}

		return null;
	}

	/**
	 * @param {Number} baseVersion
	 */
	set baseVersion( baseVersion ) {
		for ( const operation of this.operations ) {
			operation.baseVersion = baseVersion++;
		}
	}

	/**
	 * A class that will be used when creating reversed delta.
	 *
	 * @private
	 * @type {Function}
	 */
	get _reverseDeltaClass() {
		return Delta;
	}

	/**
	 * Delta type.
	 *
	 * @readonly
	 * @member {String} #type
	 */

	/**
	 * Add operation to the delta.
	 *
	 * @param {module:engine/model/operation/operation~Operation} operation Operation instance.
	 */
	addOperation( operation ) {
		operation.delta = this;
		this.operations.push( operation );

		return operation;
	}

	/**
	 * Creates and returns a delta that has the same parameters as this delta.
	 *
	 * @returns {module:engine/model/delta/delta~Delta} Clone of this delta.
	 */
	clone() {
		const delta = new this.constructor();

		for ( const op of this.operations ) {
			delta.addOperation( op.clone() );
		}

		return delta;
	}

	/**
	 * Creates and returns a reverse delta. Reverse delta when executed right after the original delta will bring back
	 * tree model state to the point before the original delta execution. In other words, it reverses changes done
	 * by the original delta.
	 *
	 * Keep in mind that tree model state may change since executing the original delta, so reverse delta may be "outdated".
	 * In that case you will need to {@link module:engine/model/delta/transform~transform} it by all deltas that were executed after
	 * the original delta.
	 *
	 * @returns {module:engine/model/delta/delta~Delta} Reversed delta.
	 */
	getReversed() {
		const delta = new this._reverseDeltaClass();

		for ( const op of this.operations ) {
			delta.addOperation( op.getReversed() );
		}

		delta.operations.reverse();

		for ( let i = 0; i < delta.operations.length; i++ ) {
			delta.operations[ i ].baseVersion = this.operations[ this.operations.length - 1 ].baseVersion + i + 1;
		}

		return delta;
	}

	/**
	 * Custom toJSON method to make deltas serializable.
	 *
	 * @returns {Object} Clone of this delta with added class name.
	 */
	toJSON() {
		const json = Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_clone__["a" /* default */])( this );

		json.__className = this.constructor.className;

		// Remove parent batch to avoid circular dependencies.
		delete json.batch;

		return json;
	}

	/**
	 * Delta class name. Used by {@link #toJSON} method for serialization and
	 * {@link module:engine/model/delta/deltafactory~DeltaFactory.fromJSON} during deserialization.
	 *
	 * @type {String}
	 * @readonly
	 */
	static get className() {
		return 'engine.model.delta.Delta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Delta;


__WEBPACK_IMPORTED_MODULE_1__deltafactory__["a" /* default */].register( Delta );


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayPush__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isFlattenable__ = __webpack_require__(381);



/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = __WEBPACK_IMPORTED_MODULE_1__isFlattenable__["a" /* default */]);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        Object(__WEBPACK_IMPORTED_MODULE_0__arrayPush__["a" /* default */])(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseFlatten);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__icon_iconview__ = __webpack_require__(477);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tooltip_tooltipview__ = __webpack_require__(478);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_keyboard__ = __webpack_require__(28);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/button/buttonview
 */







/**
 * The button view class.
 *
 *		const view = new ButtonView();
 *
 *		view.set( {
 *			label: 'A button',
 *			keystroke: 'Ctrl+B',
 *			tooltip: true,
 *			withText: true
 *		} );
 *
 *		view.render();
 *
 *		document.body.append( view.element );
 *
 * @extends module:ui/view~View
 */
class ButtonView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		const bind = this.bindTemplate;

		/**
		 * The label of the button view visible to the user when {@link #withText} is `true`.
		 * It can also be used to create a {@link #tooltip}.
		 *
		 * @observable
		 * @member {String} #label
		 */
		this.set( 'label' );

		/**
		 * (Optional) The keystroke associated with the button, i.e. <kbd>CTRL+B</kbd>,
		 * in the string format compatible with {@link module:utils/keyboard}.
		 *
		 * @observable
		 * @member {Boolean} #keystroke
		 */
		this.set( 'keystroke' );

		/**
		 * (Optional) Tooltip of the button, i.e. displayed when hovering the button with the mouse cursor.
		 *
		 * * If defined as a `Boolean` (e.g. `true`), then combination of `label` and `keystroke` will be set as a tooltip.
		 * * If defined as a `String`, tooltip will equal the exact text of that `String`.
		 * * If defined as a `Function`, `label` and `keystroke` will be passed to that function, which is to return
		 * a string with the tooltip text.
		 *
		 *		const view = new ButtonView( locale );
		 *		view.tooltip = ( label, keystroke ) => `A tooltip for ${ label } and ${ keystroke }.`
		 *
		 * @observable
		 * @default false
		 * @member {Boolean|String|Function} #tooltip
		 */
		this.set( 'tooltip' );

		/**
		 * (Optional) The position of the tooltip. See {@link module:ui/tooltip/tooltipview~TooltipView#position}
		 * to learn more about the available position values.
		 *
		 * **Note:** It makes sense only when the {@link #tooltip `tooltip` attribute} is defined.
		 *
		 * @observable
		 * @default 's'
		 * @member {'s'|'n'} #position
		 */
		this.set( 'tooltipPosition', 's' );

		/**
		 * The HTML type of the button. Default `button`.
		 *
		 * @observable
		 * @member {'button'|'submit'|'reset'|'menu'} #type
		 */
		this.set( 'type', 'button' );

		/**
		 * Controls whether the button view is "on". It makes sense when a feature it represents
		 * is currently active, e.g. a bold button is "on" when the selection is in the bold text.
		 *
		 * To disable the button, use {@link #isEnabled} instead.
		 *
		 * @observable
		 * @member {Boolean} #isOn
		 */
		this.set( 'isOn', false );

		/**
		 * Controls whether the button view is enabled, i.e. it can be clicked and execute an action.
		 *
		 * To change the "on" state of the button, use {@link #isOn} instead.
		 *
		 * @observable
		 * @member {Boolean} #isEnabled
		 */
		this.set( 'isEnabled', true );

		/**
		 * Controls whether the button view is visible. Visible by default, buttons are hidden
		 * using a CSS class.
		 *
		 * @observable
		 * @member {Boolean} #isVisible
		 */
		this.set( 'isVisible', true );

		/**
		 * (Optional) Controls whether the label of the button is hidden (e.g. an icononly button).
		 *
		 * @observable
		 * @member {Boolean} #withText
		 */
		this.set( 'withText', false );

		/**
		 * (Optional) An XML {@link module:ui/icon/iconview~IconView#content content} of the icon.
		 * When defined, an {@link #iconView} will be added to the button.
		 *
		 * @observable
		 * @member {String} #icon
		 */
		this.set( 'icon' );

		/**
		 * (Optional) Controls the `tabindex` HTML attribute of the button. By default, the button is focusable
		 * but does not included in the <kbd>Tab</kbd> order.
		 *
		 * @observable
		 * @default -1
		 * @member {String} #tabindex
		 */
		this.set( 'tabindex', -1 );

		/**
		 * Collection of the child views inside of the button {@link #element}.
		 *
		 * @readonly
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this.children = this.createCollection();

		/**
		 * Tooltip of the button view. It is configurable using the {@link #tooltip tooltip attribute}.
		 *
		 * @readonly
		 * @member {module:ui/tooltip/tooltipview~TooltipView} #tooltipView
		 */
		this.tooltipView = this._createTooltipView();

		/**
		 * Label of the button view. It is configurable using the {@link #label label attribute}.
		 *
		 * @readonly
		 * @member {module:ui/view~View} #labelView
		 */
		this.labelView = this._createLabelView();

		/**
		 * Tooltip of the button bound to the template.
		 *
		 * @see #tooltip
		 * @see #_getTooltipString
		 * @private
		 * @observable
		 * @member {Boolean} #_tooltipString
		 */
		this.bind( '_tooltipString' ).to(
			this, 'tooltip',
			this, 'label',
			this, 'keystroke',
			this._getTooltipString.bind( this )
		);

		/**
		 * (Optional) The icon view of the button. Only present when the {@link #icon icon attribute} is defined.
		 *
		 * @readonly
		 * @member {module:ui/icon/iconview~IconView} #iconView
		 */

		this.setTemplate( {
			tag: 'button',

			attributes: {
				class: [
					'ck-button',
					bind.to( 'isEnabled', value => value ? 'ck-enabled' : 'ck-disabled' ),
					bind.if( 'isVisible', 'ck-hidden', value => !value ),
					bind.to( 'isOn', value => value ? 'ck-on' : 'ck-off' ),
					bind.if( 'withText', 'ck-button_with-text' )
				],
				type: bind.to( 'type', value => value ? value : 'button' ),
				tabindex: bind.to( 'tabindex' )
			},

			children: this.children,

			on: {
				mousedown: bind.to( evt => {
					evt.preventDefault();
				} ),

				click: bind.to( evt => {
					// We can't make the button disabled using the disabled attribute, because it won't be focusable.
					// Though, shouldn't this condition be moved to the button controller?
					if ( this.isEnabled ) {
						this.fire( 'execute' );
					} else {
						// Prevent the default when button is disabled, to block e.g.
						// automatic form submitting. See ckeditor/ckeditor5-link#74.
						evt.preventDefault();
					}
				} )
			}
		} );

		/**
		 * Fired when the button view is clicked. It won't be fired when the button {@link #isEnabled}
		 * is `false`.
		 *
		 * @event execute
		 */
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		if ( this.icon ) {
			const iconView = this.iconView = new __WEBPACK_IMPORTED_MODULE_1__icon_iconview__["a" /* default */]();

			iconView.bind( 'content' ).to( this, 'icon' );

			this.children.add( iconView );
		}

		this.children.add( this.tooltipView );
		this.children.add( this.labelView );
	}

	/**
	 * Focuses the {@link #element} of the button.
	 */
	focus() {
		this.element.focus();
	}

	/**
	 * Creates a {@link module:ui/tooltip/tooltipview~TooltipView} instance and binds it with button
	 * attributes.
	 *
	 * @private
	 * @returns {module:ui/tooltip/tooltipview~TooltipView}
	 */
	_createTooltipView() {
		const tooltipView = new __WEBPACK_IMPORTED_MODULE_2__tooltip_tooltipview__["a" /* default */]();

		tooltipView.bind( 'text' ).to( this, '_tooltipString' );
		tooltipView.bind( 'position' ).to( this, 'tooltipPosition' );

		return tooltipView;
	}

	/**
	 * Creates a label view instance and binds it with button attributes.
	 *
	 * @private
	 * @returns {module:ui/view~View}
	 */
	_createLabelView() {
		const labelView = new __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */]();

		labelView.setTemplate( {
			tag: 'span',

			attributes: {
				class: [ 'ck-button__label' ]
			},

			children: [
				{
					text: this.bindTemplate.to( 'label' )
				}
			]
		} );

		return labelView;
	}

	/**
	 * Gets the text for the {@link #tooltipView} from the combination of
	 * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
	 *
	 * @private
	 * @see #tooltip
	 * @see #_tooltipString
	 * @param {Boolean|String|Function} tooltip Button tooltip.
	 * @param {String} label Button label.
	 * @param {String} keystroke Button keystroke.
	 * @returns {String}
	 */
	_getTooltipString( tooltip, label, keystroke ) {
		if ( tooltip ) {
			if ( typeof tooltip == 'string' ) {
				return tooltip;
			} else {
				if ( keystroke ) {
					keystroke = Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_keyboard__["b" /* getEnvKeystrokeText */])( keystroke );
				}

				if ( tooltip instanceof Function ) {
					return tooltip( label, keystroke );
				} else {
					return `${ label }${ keystroke ? ` (${ keystroke })` : '' }`;
				}
			}
		}

		return '';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ButtonView;



/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* global console */

/**
 * @module utils/log
 */



/**
 * The logging module.
 *
 * This object features two functions that should be used across CKEditor code base to log errors and warnings.
 * Despite being an overridable interface for native `console.*` this module serves also the goal to limit the
 * code size of a minified CKEditor package. During minification process the messages will be shortened and
 * links to their documentation will be logged to the console.
 *
 * All errors and warning should be documented in the following way:
 *
 *		/**
 *		 * Error thrown when a plugin cannot be loaded due to JavaScript errors, lack of plugins with a given name, etc.
 *		 *
 *		 * @error plugin-load
 *		 * @param pluginName The name of the plugin that could not be loaded.
 *		 * @param moduleName The name of the module which tried to load this plugin.
 *		 * /
 *		log.error( 'plugin-load: It was not possible to load the "{$pluginName}" plugin in module "{$moduleName}', {
 *			pluginName: 'foo',
 *			moduleName: 'bar'
 *		} );
 *
 * ### Warning vs Error vs Throw
 *
 * * Whenever a potentially incorrect situation occurs, which does not directly lead to an incorrect behavior,
 * log a warning.
 * * Whenever an incorrect situation occurs, but the app may continue working (although perhaps incorrectly),
 * log an error.
 * * Whenever it's really bad and it does not make sense to continue working, throw a {@link module:utils/ckeditorerror~CKEditorError}.
 *
 * @namespace
 */
const log = {
	/**
	 * Logs an error to the console.
	 *
	 * Read more about error logging in the {@link module:utils/log} module.
	 *
	 * @param {String} message The error message in an `error-name: Error message.` format.
	 * During the minification process the "Error message" part will be removed to limit the code size
	 * and a link to this error documentation will be logged to the console.
	 * @param {Object} [data] Additional data describing the error.
	 */
	error( message, data ) {
		console.error( Object(__WEBPACK_IMPORTED_MODULE_0__ckeditorerror__["a" /* attachLinkToDocumentation */])( message ), data );
	},

	/**
	 * Logs a warning to the console.
	 *
	 * Read more about error logging in the {@link module:utils/log} module.
	 *
	 * @param {String} message The warning message in a `warning-name: Warning message.` format.
	 * During the minification process the "Warning message" part will be removed to limit the code size
	 * and a link to this error documentation will be logged to the console.
	 * @param {Object} [data] Additional data describing the warning.
	 */
	warn( message, data ) {
		console.warn( Object(__WEBPACK_IMPORTED_MODULE_0__ckeditorerror__["a" /* attachLinkToDocumentation */])( message ), data );
	}
};

/* harmony default export */ __webpack_exports__["a"] = (log);


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node__ = __webpack_require__(65);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/text
 */



/**
 * Model text node. Type of {@link module:engine/model/node~Node node} that contains {@link module:engine/model/text~Text#data text data}.
 *
 * **Important:** see {@link module:engine/model/node~Node} to read about restrictions using `Text` and `Node` API.
 *
 * **Note:** keep in mind that `Text` instances might indirectly got removed from model tree when model is changed.
 * This happens when {@link module:engine/model/writer~writer model writer} is used to change model and the text node is merged with
 * another text node. Then, both text nodes are removed and a new text node is inserted into the model. Because of
 * this behavior, keeping references to `Text` is not recommended. Instead, consider creating
 * {@link module:engine/model/liveposition~LivePosition live position} placed before the text node.
 */
class Text extends __WEBPACK_IMPORTED_MODULE_0__node__["a" /* default */] {
	/**
	 * Creates a text node.
	 *
	 * @param {String} data Node's text.
	 * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
	 */
	constructor( data, attrs ) {
		super( attrs );

		/**
		 * Text data contained in this text node.
		 *
		 * @type {String}
		 */
		this.data = data || '';
	}

	/**
	 * @inheritDoc
	 */
	get offsetSize() {
		return this.data.length;
	}

	/**
	 * @inheritDoc
	 */
	is( type ) {
		return type == 'text';
	}

	/**
	 * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.
	 */
	clone() {
		return new Text( this.data, this.getAttributes() );
	}

	/**
	 * Converts `Text` instance to plain object and returns it.
	 *
	 * @returns {Object} `Text` instance converted to plain object.
	 */
	toJSON() {
		const json = super.toJSON();

		json.data = this.data;

		return json;
	}

	/**
	 * Creates a `Text` instance from given plain object (i.e. parsed JSON string).
	 *
	 * @param {Object} json Plain object to be converted to `Text`.
	 * @returns {module:engine/model/text~Text} `Text` instance created using given plain object.
	 */
	static fromJSON( json ) {
		return new Text( json.data, json.attributes );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Text;



/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getCode;
/* harmony export (immutable) */ __webpack_exports__["d"] = parseKeystroke;
/* harmony export (immutable) */ __webpack_exports__["b"] = getEnvKeystrokeText;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__env__ = __webpack_require__(359);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Set of utils related to keyboard support.
 *
 * @module utils/keyboard
 */




/**
 * Object with `keyName => keyCode` pairs for a set of known keys.
 *
 * Contains:
 *
 * * `a-z`,
 * * `0-9`,
 * * `f1-f12`,
 * * `arrow(left|up|right|bottom)`,
 * * `backspace`, `delete`, `enter`, `esc`, `tab`,
 * * `ctrl`, `cmd`, `shift`, `alt`.
 */
const keyCodes = generateKnownKeyCodes();
/* harmony export (immutable) */ __webpack_exports__["c"] = keyCodes;


/**
 * Converts a key name or a {@link module:utils/keyboard~KeystrokeInfo keystroke info} into a key code.
 *
 * Note: Key names are matched with {@link module:utils/keyboard~keyCodes} in a case-insensitive way.
 *
 * @param {String|module:utils/keyboard~KeystrokeInfo} Key name (see {@link module:utils/keyboard~keyCodes})
 * or a keystroke data object.
 * @returns {Number} Key or keystroke code.
 */
function getCode( key ) {
	let keyCode;

	if ( typeof key == 'string' ) {
		keyCode = keyCodes[ key.toLowerCase() ];

		if ( !keyCode ) {
			/**
			 * Unknown key name. Only key names contained by the {@link module:utils/keyboard~keyCodes} can be used.
			 *
			 * @errror keyboard-unknown-key
			 * @param {String} key
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditorerror__["b" /* default */]( 'keyboard-unknown-key: Unknown key name.', { key } );
		}
	} else {
		keyCode = key.keyCode +
			( key.altKey ? keyCodes.alt : 0 ) +
			( key.ctrlKey ? keyCodes.ctrl : 0 ) +
			( key.shiftKey ? keyCodes.shift : 0 );
	}

	return keyCode;
}

/**
 * Parses keystroke and returns a keystroke code that will match the code returned by
 * link {@link module:utils/keyboard.getCode} for a corresponding {@link module:utils/keyboard~KeystrokeInfo keystroke info}.
 *
 * The keystroke can be passed in two formats:
 *
 * * as a single string  e.g. `ctrl + A`,
 * * as an array of {@link module:utils/keyboard~keyCodes known key names} and key codes  e.g.:
 *   * `[ 'ctrl', 32 ]` (ctrl + space),
 *   * `[ 'ctrl', 'a' ]` (ctrl + A).
 *
 * Note: Key names are matched with {@link module:utils/keyboard~keyCodes} in a case-insensitive way.
 *
 * Note: Only keystrokes with a single non-modifier key are supported (e.g. `ctrl+A` is OK, but `ctrl+A+B` is not).
 *
 * @param {String|Array.<Number|String>} keystroke Keystroke definition.
 * @returns {Number} Keystroke code.
 */
function parseKeystroke( keystroke ) {
	if ( typeof keystroke == 'string' ) {
		keystroke = splitKeystrokeText( keystroke );
	}

	return keystroke
		.map( key => ( typeof key == 'string' ) ? getCode( key ) : key )
		.reduce( ( key, sum ) => sum + key, 0 );
}

/**
 * It translates any keystroke string text like `"CTRL+A"` to an
 * environmentspecific keystroke, i.e. `"A"` on Mac OSX.
 *
 * @param {String} keystroke Keystroke text.
 * @returns {String} Keystroke text specific for the environment.
 */
function getEnvKeystrokeText( keystroke ) {
	const split = splitKeystrokeText( keystroke );

	if ( __WEBPACK_IMPORTED_MODULE_1__env__["a" /* default */].mac ) {
		if ( split[ 0 ].toLowerCase() == 'ctrl' ) {
			return '' + ( split[ 1 ] || '' );
		}
	}

	return keystroke;
}

function generateKnownKeyCodes() {
	const keyCodes = {
		arrowleft: 37,
		arrowup: 38,
		arrowright: 39,
		arrowdown: 40,
		backspace: 8,
		delete: 46,
		enter: 13,
		space: 32,
		esc: 27,
		tab: 9,

		// The idea about these numbers is that they do not collide with any real key codes, so we can use them
		// like bit masks.
		ctrl: 0x110000,
		// Has the same code as ctrl, because their behaviour should be unified across the editor.
		// See http://ckeditor.github.io/editor-recommendations/general-policies#ctrl-vs-cmd
		cmd: 0x110000,
		shift: 0x220000,
		alt: 0x440000
	};

	// a-z
	for ( let code = 65; code <= 90; code++ ) {
		const letter = String.fromCharCode( code );

		keyCodes[ letter.toLowerCase() ] = code;
	}

	// 0-9
	for ( let code = 48; code <= 57; code++ ) {
		keyCodes[ code - 48 ] = code;
	}

	// F1-F12
	for ( let code = 112; code <= 123; code++ ) {
		keyCodes[ 'f' + ( code - 111 ) ] = code;
	}

	return keyCodes;
}

function splitKeystrokeText( keystroke ) {
	return keystroke.split( /\s*\+\s*/ );
}

/**
 * Information about a keystroke.
 *
 * @interface module:utils/keyboard~KeystrokeInfo
 */

/**
 * The [key code](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode).
 *
 * @member {Number} module:utils/keyboard~KeystrokeInfo#keyCode
 */

/**
 * Whether the <kbd>Alt</kbd> modifier was pressed.
 *
 * @member {Bolean} module:utils/keyboard~KeystrokeInfo#altKey
 */

/**
 * Whether the <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> modifier was pressed.
 *
 * @member {Bolean} module:utils/keyboard~KeystrokeInfo#ctrlKey
 */

/**
 * Whether the <kbd>Shift</kbd> modifier was pressed.
 *
 * @member {Bolean} module:utils/keyboard~KeystrokeInfo#shiftKey
 */


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__operation__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_comparearrays__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__writer__ = __webpack_require__(22);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/moveoperation
 */








/**
 * Operation to move a range of {@link module:engine/model/item~Item model items}
 * to given {@link module:engine/model/position~Position target position}.
 *
 * @extends module:engine/model/operation/operation~Operation
 */
class MoveOperation extends __WEBPACK_IMPORTED_MODULE_0__operation__["a" /* default */] {
	/**
	 * Creates a move operation.
	 *
	 * @param {module:engine/model/position~Position} sourcePosition
	 * Position before the first {@link module:engine/model/item~Item model item} to move.
	 * @param {Number} howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
	 * `sourcePosition` with offset shifted by `howMany`.
	 * @param {module:engine/model/position~Position} targetPosition Position at which moved nodes will be inserted.
	 * @param {Number} baseVersion {@link module:engine/model/document~Document#version} on which operation can be applied.
	 */
	constructor( sourcePosition, howMany, targetPosition, baseVersion ) {
		super( baseVersion );

		/**
		 * Position before the first {@link module:engine/model/item~Item model item} to move.
		 *
		 * @member {module:engine/model/position~Position} module:engine/model/operation/moveoperation~MoveOperation#sourcePosition
		 */
		this.sourcePosition = __WEBPACK_IMPORTED_MODULE_1__position__["a" /* default */].createFromPosition( sourcePosition );

		/**
		 * Offset size of moved range.
		 *
		 * @member {Number} module:engine/model/operation/moveoperation~MoveOperation#howMany
		 */
		this.howMany = howMany;

		/**
		 * Position at which moved nodes will be inserted.
		 *
		 * @member {module:engine/model/position~Position} module:engine/model/operation/moveoperation~MoveOperation#targetPosition
		 */
		this.targetPosition = __WEBPACK_IMPORTED_MODULE_1__position__["a" /* default */].createFromPosition( targetPosition );

		/**
		 * Defines whether `MoveOperation` is sticky. If `MoveOperation` is sticky, during
		 * {@link module:engine/model/operation/transform~transform operational transformation} if there will be an operation that
		 * inserts some nodes at the position equal to the boundary of this `MoveOperation`, that operation will
		 * get their insertion path updated to the position where this `MoveOperation` moves the range.
		 *
		 * @member {Boolean} module:engine/model/operation/moveoperation~MoveOperation#isSticky
		 */
		this.isSticky = false;
	}

	/**
	 * @inheritDoc
	 */
	get type() {
		return 'move';
	}

	/**
	 * Creates and returns an operation that has the same parameters as this operation.
	 *
	 * @returns {module:engine/model/operation/moveoperation~MoveOperation} Clone of this operation.
	 */
	clone() {
		const op = new this.constructor( this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion );
		op.isSticky = this.isSticky;

		return op;
	}

	/**
	 * Returns the start position of the moved range after it got moved. This may be different than
	 * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved
	 * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}
	 * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.
	 *
	 *		 vv              vv
	 *		abcdefg ===> adefbcg
	 *		     ^          ^
	 *		     targetPos	movedRangeStart
	 *		     offset 6	offset 4
	 *
	 * @returns {module:engine/model/position~Position}
	 */
	getMovedRangeStart() {
		return this.targetPosition._getTransformedByDeletion( this.sourcePosition, this.howMany );
	}

	/**
	 * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
	 *
	 * @returns {module:engine/model/operation/moveoperation~MoveOperation}
	 */
	getReversed() {
		const newTargetPosition = this.sourcePosition._getTransformedByInsertion( this.targetPosition, this.howMany );

		const op = new this.constructor( this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1 );
		op.isSticky = this.isSticky;

		return op;
	}

	/**
	 * @inheritDoc
	 */
	_execute() {
		const sourceElement = this.sourcePosition.parent;
		const targetElement = this.targetPosition.parent;
		const sourceOffset = this.sourcePosition.offset;
		const targetOffset = this.targetPosition.offset;

		// Validate whether move operation has correct parameters.
		// Validation is pretty complex but move operation is one of the core ways to manipulate the document state.
		// We expect that many errors might be connected with one of scenarios described below.
		if ( !sourceElement || !targetElement ) {
			/**
			 * Source position or target position is invalid.
			 *
			 * @error move-operation-position-invalid
			 */
			throw new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'move-operation-position-invalid: Source position or target position is invalid.'
			);
		} else if ( sourceOffset + this.howMany > sourceElement.maxOffset ) {
			/**
			 * The nodes which should be moved do not exist.
			 *
			 * @error move-operation-nodes-do-not-exist
			 */
			throw new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'move-operation-nodes-do-not-exist: The nodes which should be moved do not exist.'
			);
		} else if ( sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany ) {
			/**
			 * Trying to move a range of nodes into the middle of that range.
			 *
			 * @error move-operation-range-into-itself
			 */
			throw new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'move-operation-range-into-itself: Trying to move a range of nodes to the inside of that range.'
			);
		} else if ( this.sourcePosition.root == this.targetPosition.root ) {
			if ( Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( this.sourcePosition.getParentPath(), this.targetPosition.getParentPath() ) == 'prefix' ) {
				const i = this.sourcePosition.path.length - 1;

				if ( this.targetPosition.path[ i ] >= sourceOffset && this.targetPosition.path[ i ] < sourceOffset + this.howMany ) {
					/**
					 * Trying to move a range of nodes into one of nodes from that range.
					 *
					 * @error move-operation-node-into-itself
					 */
					throw new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
						'move-operation-node-into-itself: Trying to move a range of nodes into one of nodes from that range.'
					);
				}
			}
		}

		const range = __WEBPACK_IMPORTED_MODULE_5__writer__["a" /* default */].move( __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */].createFromPositionAndShift( this.sourcePosition, this.howMany ), this.targetPosition );

		return {
			sourcePosition: this.sourcePosition,
			range
		};
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.operation.MoveOperation';
	}

	/**
	 * Creates `MoveOperation` object from deserilized object, i.e. from parsed JSON string.
	 *
	 * @param {Object} json Deserialized JSON object.
	 * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
	 * @returns {module:engine/model/operation/moveoperation~MoveOperation}
	 */
	static fromJSON( json, document ) {
		const sourcePosition = __WEBPACK_IMPORTED_MODULE_1__position__["a" /* default */].fromJSON( json.sourcePosition, document );
		const targetPosition = __WEBPACK_IMPORTED_MODULE_1__position__["a" /* default */].fromJSON( json.targetPosition, document );

		const move = new this( sourcePosition, json.howMany, targetPosition, json.baseVersion );

		if ( json.isSticky ) {
			move.isSticky = true;
		}

		return move;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MoveOperation;



/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayMap);


/***/ }),
/* 31 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(447);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__checkGlobal__ = __webpack_require__(308);


/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
  ? exports
  : undefined;

/** Detect free variable `module`. */
var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
  ? module
  : undefined;

/** Detect free variable `global` from Node.js. */
var freeGlobal = Object(__WEBPACK_IMPORTED_MODULE_0__checkGlobal__["a" /* default */])(freeExports && freeModule && typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = Object(__WEBPACK_IMPORTED_MODULE_0__checkGlobal__["a" /* default */])(objectTypes[typeof self] && self);

/** Detect free variable `window`. */
var freeWindow = Object(__WEBPACK_IMPORTED_MODULE_0__checkGlobal__["a" /* default */])(objectTypes[typeof window] && window);

/** Detect `this` as the global object. */
var thisGlobal = Object(__WEBPACK_IMPORTED_MODULE_0__checkGlobal__["a" /* default */])(objectTypes[typeof this] && this);

/**
 * Used as a reference to the global object.
 *
 * The `this` value is used if it's the global object to avoid Greasemonkey's
 * restricted `window` object, otherwise the `window` object is used.
 */
var root = freeGlobal ||
  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
    freeSelf || thisGlobal || Function('return this')();

/* harmony default export */ __webpack_exports__["a"] = (root);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(167)(module), __webpack_require__(307)))

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isIterable;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/isiterable
 */

/**
 * Checks if value implements iterator interface.
 *
 * @param {*} value The value to check.
 * @returns {Boolean} True if value implements iterator interface.
 */
function isIterable( value ) {
	return !!( value && value[ Symbol.iterator ] );
}


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = toImageWidget;
/* unused harmony export isImageWidget */
/* harmony export (immutable) */ __webpack_exports__["b"] = isImageWidgetSelected;
/* harmony export (immutable) */ __webpack_exports__["a"] = isImage;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_widget_src_utils__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_element__ = __webpack_require__(5);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/image/utils
 */




const imageSymbol = Symbol( 'isImage' );

/**
 * Converts a given {@link module:engine/view/element~Element} to an image widget:
 * * adds a {@link module:engine/view/element~Element#setCustomProperty custom property} allowing to recognize the image widget element,
 * * calls the {@link module:widget/utils~toWidget toWidget} function with the proper element's label creator.
 *
 * @param {module:engine/view/element~Element} viewElement
 * @param {String} label Element's label. It will be concatenated with the image `alt` attribute if one is present.
 * @returns {module:engine/view/element~Element}
 */
function toImageWidget( viewElement, label ) {
	viewElement.setCustomProperty( imageSymbol, true );

	return Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_widget_src_utils__["d" /* toWidget */])( viewElement, { label: labelCreator } );

	function labelCreator() {
		const imgElement = viewElement.getChild( 0 );
		const altText = imgElement.getAttribute( 'alt' );

		return altText ? `${ altText } ${ label }` : label;
	}
}

/**
 * Checks if a given view element is an image widget.
 *
 * @param {module:engine/view/element~Element} viewElement
 * @returns {Boolean}
 */
function isImageWidget( viewElement ) {
	return !!viewElement.getCustomProperty( imageSymbol ) && Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_widget_src_utils__["c" /* isWidget */])( viewElement );
}

/**
 * Checks if an image widget is the only selected element.
 *
 * @param {module:engine/view/selection~Selection} viewSelection
 * @returns {Boolean}
 */
function isImageWidgetSelected( viewSelection ) {
	const viewElement = viewSelection.getSelectedElement();

	return !!( viewElement && isImageWidget( viewElement ) );
}

/**
 * Checks if the provided model element is an instance of {@link module:engine/model/element~Element Element} and its name
 * is `image`.
 *
 * @param {module:engine/model/element~Element} modelElement
 * @returns {Boolean}
 */
function isImage( modelElement ) {
	return modelElement instanceof __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */] && modelElement.name == 'image';
}


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/* harmony default export */ __webpack_exports__["a"] = (isIndex);


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__treewalker__ = __webpack_require__(67);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/range
 */




/**
 * Tree view range.
 */
class Range {
	/**
	 * Creates a range spanning from `start` position to `end` position.
	 *
	 * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
	 *
	 * @param {module:engine/view/position~Position} start Start position.
	 * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.
	 */
	constructor( start, end = null ) {
		/**
		 * Start position.
		 *
		 * @member {module:engine/view/position~Position}
		 */
		this.start = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( start );

		/**
		 * End position.
		 *
		 * @member {module:engine/view/position~Position}
		 */
		this.end = end ? __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( end ) : __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( start );
	}

	/**
	 * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
	 * them together with additional information like length or {@link module:engine/view/position~Position positions},
	 * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.
	 *
	 * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and
	 * `ignoreElementEnd` option
	 * set to `true`.
	 *
	 * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}
	 */
	* [ Symbol.iterator ]() {
		yield* new __WEBPACK_IMPORTED_MODULE_1__treewalker__["a" /* default */]( { boundaries: this, ignoreElementEnd: true } );
	}

	/**
	 * Returns whether the range is collapsed, that is it start and end positions are equal.
	 *
	 * @type {Boolean}
	 */
	get isCollapsed() {
		return this.start.isEqual( this.end );
	}

	/**
	 * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and
	 * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.
	 *
	 * @type {Boolean}
	 */
	get isFlat() {
		return this.start.parent === this.end.parent;
	}

	/**
	 * Range root element.
	 *
	 * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}
	 */
	get root() {
		return this.start.root;
	}

	/**
	 * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
	 * and at the end).
	 *
	 * For example:
	 *
	 * 		<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
	 * 		<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
	 *
	 * Note that in the sample above:
	 *  - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
	 *  - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
	 *  - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
	 *
	 * @returns {module:engine/view/range~Range} Enlarged range.
	 */
	getEnlarged() {
		let start = this.start.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );
		let end = this.end.getLastMatchingPosition( enlargeTrimSkip );

		// Fix positions, in case if they are in Text node.
		if ( start.parent.is( 'text' ) && start.isAtStart ) {
			start = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createBefore( start.parent );
		}

		if ( end.parent.is( 'text' ) && end.isAtEnd ) {
			end = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAfter( end.parent );
		}

		return new Range( start, end );
	}

	/**
	 * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
	 * and at the end).
	 *
	 * For example:
	 *
	 * 		<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
	 * 		<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
	 *
	 * Note that in the sample above:
	 *  - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
	 *  - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
	 *  - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
	 *
	 * @returns {module:engine/view/range~Range} Shrink range.
	 */
	getTrimmed() {
		let start = this.start.getLastMatchingPosition( enlargeTrimSkip );

		if ( start.isAfter( this.end ) || start.isEqual( this.end ) ) {
			return new Range( start, start );
		}

		let end = this.end.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );
		const nodeAfterStart = start.nodeAfter;
		const nodeBeforeEnd = end.nodeBefore;

		// Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.
		if ( nodeAfterStart && nodeAfterStart.is( 'text' ) ) {
			start = new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( nodeAfterStart, 0 );
		}

		if ( nodeBeforeEnd && nodeBeforeEnd.is( 'text' ) ) {
			end = new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( nodeBeforeEnd, nodeBeforeEnd.data.length );
		}

		return new Range( start, end );
	}

	/**
	 * Two ranges are equal if their start and end positions are equal.
	 *
	 * @param {module:engine/view/range~Range} otherRange Range to compare with.
	 * @returns {Boolean} `true` if ranges are equal, `false` otherwise
	 */
	isEqual( otherRange ) {
		return this == otherRange || ( this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end ) );
	}

	/**
	 * Checks whether this range contains given {@link module:engine/view/position~Position position}.
	 *
	 * @param {module:engine/view/position~Position} position Position to check.
	 * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,
	 * `false` otherwise.
	 */
	containsPosition( position ) {
		return position.isAfter( this.start ) && position.isBefore( this.end );
	}

	/**
	 * Checks whether this range contains given {@link module:engine/view/range~Range range}.
	 *
	 * @param {module:engine/view/range~Range} otherRange Range to check.
	 * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
	 * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
	 * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
	 * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`
	 * otherwise.
	 */
	containsRange( otherRange, loose = false ) {
		if ( otherRange.isCollapsed ) {
			loose = false;
		}

		const containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );
		const containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );

		return containsStart && containsEnd;
	}

	/**
	 * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given
	 * {@link module:engine/view/range~Range range}.
	 * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.
	 *
	 * Examples:
	 *
	 *		let foo = new Text( 'foo' );
	 *		let img = new ContainerElement( 'img' );
	 *		let bar = new Text( 'bar' );
	 *		let p = new ContainerElement( 'p', null, [ foo, img, bar ] );
	 *
	 *		let range = new Range( new Position( foo, 2 ), new Position( bar, 1 ); // "o", img, "b" are in range.
	 *		let otherRange = new Range( new Position( foo, 1 ), new Position( bar, 2 ); "oo", img, "ba" are in range.
	 *		let transformed = range.getDifference( otherRange );
	 *		// transformed array has no ranges because `otherRange` contains `range`
	 *
	 *		otherRange = new Range( new Position( foo, 1 ), new Position( p, 2 ); // "oo", img are in range.
	 *		transformed = range.getDifference( otherRange );
	 *		// transformed array has one range: from ( p, 2 ) to ( bar, 1 )
	 *
	 *		otherRange = new Range( new Position( p, 1 ), new Position( p, 2 ) ); // img is in range.
	 *		transformed = range.getDifference( otherRange );
	 *		// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
	 *
	 * @param {module:engine/view/range~Range} otherRange Range to differentiate against.
	 * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.
	 */
	getDifference( otherRange ) {
		const ranges = [];

		if ( this.isIntersecting( otherRange ) ) {
			// Ranges intersect.

			if ( this.containsPosition( otherRange.start ) ) {
				// Given range start is inside this range. This means that we have to
				// add shrunken range - from the start to the middle of this range.
				ranges.push( new Range( this.start, otherRange.start ) );
			}

			if ( this.containsPosition( otherRange.end ) ) {
				// Given range end is inside this range. This means that we have to
				// add shrunken range - from the middle of this range to the end.
				ranges.push( new Range( otherRange.end, this.end ) );
			}
		} else {
			// Ranges do not intersect, return the original range.
			ranges.push( Range.createFromRange( this ) );
		}

		return ranges;
	}

	/**
	 * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.
	 * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
	 *
	 * Examples:
	 *
	 *		let foo = new Text( 'foo' );
	 *		let img = new ContainerElement( 'img' );
	 *		let bar = new Text( 'bar' );
	 *		let p = new ContainerElement( 'p', null, [ foo, img, bar ] );
	 *
	 *		let range = new Range( new Position( foo, 2 ), new Position( bar, 1 ); // "o", img, "b" are in range.
	 *		let otherRange = new Range( new Position( foo, 1 ), new Position( p, 2 ); // "oo", img are in range.
	 *		let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
	 *
	 *		otherRange = new Range( new Position( bar, 1 ), new Position( bar, 3 ); "ar" is in range.
	 *		transformed = range.getIntersection( otherRange ); // null - no common part.
	 *
	 * @param {module:engine/view/range~Range} otherRange Range to check for intersection.
	 * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.
	 */
	getIntersection( otherRange ) {
		if ( this.isIntersecting( otherRange ) ) {
			// Ranges intersect, so a common range will be returned.
			// At most, it will be same as this range.
			let commonRangeStart = this.start;
			let commonRangeEnd = this.end;

			if ( this.containsPosition( otherRange.start ) ) {
				// Given range start is inside this range. This means thaNt we have to
				// shrink common range to the given range start.
				commonRangeStart = otherRange.start;
			}

			if ( this.containsPosition( otherRange.end ) ) {
				// Given range end is inside this range. This means that we have to
				// shrink common range to the given range end.
				commonRangeEnd = otherRange.end;
			}

			return new Range( commonRangeStart, commonRangeEnd );
		}

		// Ranges do not intersect, so they do not have common part.
		return null;
	}

	/**
	 * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
	 *
	 * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
	 * @param {module:engine/view/position~Position} [options.startPosition]
	 * @param {Boolean} [options.singleCharacters=false]
	 * @param {Boolean} [options.shallow=false]
	 * @param {Boolean} [options.ignoreElementEnd=false]
	 */
	getWalker( options = {} ) {
		options.boundaries = this;

		return new __WEBPACK_IMPORTED_MODULE_1__treewalker__["a" /* default */]( options );
	}

	/**
	 * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
	 * which is a common ancestor of range's both ends (in which the entire range is contained).
	 *
	 * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}
	 */
	getCommonAncestor() {
		return this.start.getCommonAncestor( this.end );
	}

	/**
	 * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
	 * them.
	 *
	 * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
	 * set to `true`. However it returns only {@link module:engine/view/item~Item items},
	 * not {@link module:engine/view/treewalker~TreeWalkerValue}.
	 *
	 * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
	 * a full list of available options.
	 *
	 * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
	 * @returns {Iterable.<module:engine/view/item~Item>}
	 */
	* getItems( options = {} ) {
		options.boundaries = this;
		options.ignoreElementEnd = true;

		const treeWalker = new __WEBPACK_IMPORTED_MODULE_1__treewalker__["a" /* default */]( options );

		for ( const value of treeWalker ) {
			yield value.item;
		}
	}

	/**
	 * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or
	 * contained in this range.
	 *
	 * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
	 * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.
	 *
	 * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
	 * a full list of available options.
	 *
	 * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
	 * @returns {Iterable.<module:engine/view/position~Position>}
	 */
	* getPositions( options = {} ) {
		options.boundaries = this;

		const treeWalker = new __WEBPACK_IMPORTED_MODULE_1__treewalker__["a" /* default */]( options );

		yield treeWalker.position;

		for ( const value of treeWalker ) {
			yield value.nextPosition;
		}
	}

	/**
	 * Checks and returns whether this range intersects with given range.
	 *
	 * @param {module:engine/view/range~Range} otherRange Range to compare with.
	 * @returns {Boolean} True if ranges intersect.
	 */
	isIntersecting( otherRange ) {
		return this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );
	}

	/**
	 * Creates a range from given parents and offsets.
	 *
	 * @param {module:engine/view/element~Element} startElement Start position parent element.
	 * @param {Number} startOffset Start position offset.
	 * @param {module:engine/view/element~Element} endElement End position parent element.
	 * @param {Number} endOffset End position offset.
	 * @returns {module:engine/view/range~Range} Created range.
	 */
	static createFromParentsAndOffsets( startElement, startOffset, endElement, endOffset ) {
		return new this(
			new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( startElement, startOffset ),
			new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( endElement, endOffset )
		);
	}

	/**
	 * Creates and returns a new instance of Range which is equal to passed range.
	 *
	 * @param {module:engine/view/range~Range} range Range to clone.
	 * @returns {module:engine/view/range~Range}
	 */
	static createFromRange( range ) {
		return new this( range.start, range.end );
	}

	/**
	 * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by
	 * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
	 *
	 * @param {module:engine/view/position~Position} position Beginning of the range.
	 * @param {Number} shift How long the range should be.
	 * @returns {module:engine/view/range~Range}
	 */
	static createFromPositionAndShift( position, shift ) {
		const start = position;
		const end = position.getShiftedBy( shift );

		return shift > 0 ? new this( start, end ) : new this( end, start );
	}

	/**
	 * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
	 * that element and ends after the last child of that element.
	 *
	 * @param {module:engine/view/element~Element} element Element which is a parent for the range.
	 * @returns {module:engine/view/range~Range}
	 */
	static createIn( element ) {
		return this.createFromParentsAndOffsets( element, 0, element, element.childCount );
	}

	/**
	 * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
	 *
	 * @param {module:engine/view/item~Item} item
	 * @returns {module:engine/view/range~Range}
	 */
	static createOn( item ) {
		return this.createFromPositionAndShift( __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createBefore( item ), 1 );
	}

	/**
	 * Creates a collapsed range at given {@link module:engine/view/position~Position position}
	 * or on the given {@link module:engine/view/item~Item item}.
	 *
	 * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition
	 * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
	 * first parameter is a {@link module:engine/view/item~Item view item}.
	 */
	static createCollapsedAt( itemOrPosition, offset ) {
		const start = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( itemOrPosition, offset );
		const end = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( start );

		return new Range( start, end );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Range;


// Function used by getEnlarged and getTrimmed methods.
function enlargeTrimSkip( value ) {
	if ( value.item.is( 'attributeElement' ) || value.item.is( 'uiElement' ) ) {
		return true;
	}

	return false;
}


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nodelist__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__text__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_isiterable__ = __webpack_require__(34);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module module:engine/model/documentfragment
 */






/**
 * DocumentFragment represents a part of model which does not have a common root but it's top-level nodes
 * can be seen as siblings. In other words, it is a detached part of model tree, without a root.
 *
 * DocumentFragment has own {@link module:engine/model/markercollection~MarkerCollection}. Markers from this collection
 * will be set to the {@link module:engine/model/document~Document#markers document markers} by a
 * {@link module:engine/model/writer~writer.insert} function.
 */
class DocumentFragment {
	/**
	 * Creates an empty `DocumentFragment`.
	 *
	 * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]
	 * Nodes to be contained inside the `DocumentFragment`.
	 */
	constructor( children ) {
		/**
		 * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}
		 * which will be set as Markers to {@link module:engine/model/document~Document#markers document markers collection}
		 * when DocumentFragment will be inserted to the document.
		 *
		 * @member {Map<String, {module:engine/model/range~Range}>} module:engine/model/documentfragment~DocumentFragment#markers
		 */
		this.markers = new Map();

		/**
		 * List of nodes contained inside the document fragment.
		 *
		 * @private
		 * @member {module:engine/model/nodelist~NodeList} module:engine/model/documentfragment~DocumentFragment#_children
		 */
		this._children = new __WEBPACK_IMPORTED_MODULE_0__nodelist__["a" /* default */]();

		if ( children ) {
			this.insertChildren( 0, children );
		}
	}

	/**
	 * Returns an iterator that iterates over all nodes contained inside this document fragment.
	 *
	 * @returns {Iterator.<module:engine/model/node~Node>}
	 */
	[ Symbol.iterator ]() {
		return this.getChildren();
	}

	/**
	 * Number of this document fragment's children.
	 *
	 * @readonly
	 * @type {Number}
	 */
	get childCount() {
		return this._children.length;
	}

	/**
	 * Sum of {module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.
	 *
	 * @readonly
	 * @type {Number}
	 */
	get maxOffset() {
		return this._children.maxOffset;
	}

	/**
	 * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isEmpty() {
		return this.childCount === 0;
	}

	/**
	 * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
	 *
	 * @readonly
	 * @type {module:engine/model/documentfragment~DocumentFragment}
	 */
	get root() {
		return this;
	}

	/**
	 * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
	 *
	 * @readonly
	 * @type {null}
	 */
	get parent() {
		return null;
	}

	/**
	 * Checks whether given model tree object is of given type.
	 *
	 * Read more in {@link module:engine/model/node~Node#is}.
	 *
	 * @param {String} type
	 * @returns {Boolean}
	 */
	is( type ) {
		return type == 'documentFragment';
	}

	/**
	 * Gets the child at the given index. Returns `null` if incorrect index was passed.
	 *
	 * @param {Number} index Index of child.
	 * @returns {module:engine/model/node~Node|null} Child node.
	 */
	getChild( index ) {
		return this._children.getNode( index );
	}

	/**
	 * Returns an iterator that iterates over all of this document fragment's children.
	 *
	 * @returns {Iterable.<module:engine/model/node~Node>}
	 */
	getChildren() {
		return this._children[ Symbol.iterator ]();
	}

	/**
	 * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.
	 *
	 * @param {module:engine/model/node~Node} node Child node to look for.
	 * @returns {Number|null} Child node's index.
	 */
	getChildIndex( node ) {
		return this._children.getNodeIndex( node );
	}

	/**
	 * Returns the starting offset of given child. Starting offset is equal to the sum of
	 * {module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
	 * given node is not a child of this document fragment.
	 *
	 * @param {module:engine/model/node~Node} node Child node to look for.
	 * @returns {Number|null} Child node's starting offset.
	 */
	getChildStartOffset( node ) {
		return this._children.getNodeStartOffset( node );
	}

	/**
	 * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.
	 *
	 * @returns {Array}
	 */
	getPath() {
		return [];
	}

	/**
	 * Returns a descendant node by its path relative to this element.
	 *
	 *		// <this>a<b>c</b></this>
	 *		this.getNodeByPath( [ 0 ] );     // -> "a"
	 *		this.getNodeByPath( [ 1 ] );     // -> <b>
	 *		this.getNodeByPath( [ 1, 0 ] );  // -> "c"
	 *
	 * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.
	 * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}
	 */
	getNodeByPath( relativePath ) {
		let node = this; // eslint-disable-line consistent-this

		for ( const index of relativePath ) {
			node = node.getChild( node.offsetToIndex( index ) );
		}

		return node;
	}

	/**
	 * Converts offset "position" to index "position".
	 *
	 * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
	 * too high, returns index after last child}.
	 *
	 *		const textNode = new Text( 'foo' );
	 *		const pElement = new Element( 'p' );
	 *		const docFrag = new DocumentFragment( [ textNode, pElement ] );
	 *		docFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.
	 *		docFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
	 *		docFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
	 *		docFrag.offsetToIndex( 2 ); // Returns 0.
	 *		docFrag.offsetToIndex( 3 ); // Returns 1.
	 *		docFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
	 *
	 * @param {Number} offset Offset to look for.
	 * @returns {Number} Index of a node that occupies given offset.
	 */
	offsetToIndex( offset ) {
		return this._children.offsetToIndex( offset );
	}

	/**
	 * {@link #insertChildren Inserts} one or more nodes at the end of this document fragment.
	 *
	 * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} nodes Nodes to be inserted.
	 */
	appendChildren( nodes ) {
		this.insertChildren( this.childCount, nodes );
	}

	/**
	 * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
	 * to this document fragment.
	 *
	 * @param {Number} index Index at which nodes should be inserted.
	 * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} nodes Nodes to be inserted.
	 */
	insertChildren( index, nodes ) {
		nodes = normalize( nodes );

		for ( const node of nodes ) {
			// If node that is being added to this element is already inside another element, first remove it from the old parent.
			if ( node.parent !== null ) {
				node.remove();
			}

			node.parent = this;
		}

		this._children.insertNodes( index, nodes );
	}

	/**
	 * Removes one or more nodes starting at the given index
	 * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
	 *
	 * @param {Number} index Index of the first node to remove.
	 * @param {Number} [howMany=1] Number of nodes to remove.
	 * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.
	 */
	removeChildren( index, howMany = 1 ) {
		const nodes = this._children.removeNodes( index, howMany );

		for ( const node of nodes ) {
			node.parent = null;
		}

		return nodes;
	}

	/**
	 * Converts `DocumentFragment` instance to plain object and returns it.
	 * Takes care of converting all of this document fragment's children.
	 *
	 * @returns {Object} `DocumentFragment` instance converted to plain object.
	 */
	toJSON() {
		const json = [];

		for ( const node of this._children ) {
			json.push( node.toJSON() );
		}

		return json;
	}

	/**
	 * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).
	 * Converts `DocumentFragment` children to proper nodes.
	 *
	 * @param {Object} json Plain object to be converted to `DocumentFragment`.
	 * @returns {module:engine/model/documentfragment~DocumentFragment} `DocumentFragment` instance created using given plain object.
	 */
	static fromJSON( json ) {
		const children = [];

		for ( const child of json ) {
			if ( child.name ) {
				// If child has name property, it is an Element.
				children.push( __WEBPACK_IMPORTED_MODULE_1__element__["a" /* default */].fromJSON( child ) );
			} else {
				// Otherwise, it is a Text node.
				children.push( __WEBPACK_IMPORTED_MODULE_2__text__["a" /* default */].fromJSON( child ) );
			}
		}

		return new DocumentFragment( children );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DocumentFragment;


// Converts strings to Text and non-iterables to arrays.
//
// @param {String|module:engine/model/node~Node|Iterable.<String|module:engine/model/node~Node>}
// @return {Iterable.<module:engine/model/node~Node>}
function normalize( nodes ) {
	// Separate condition because string is iterable.
	if ( typeof nodes == 'string' ) {
		return [ new __WEBPACK_IMPORTED_MODULE_2__text__["a" /* default */]( nodes ) ];
	}

	if ( !Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_isiterable__["a" /* default */])( nodes ) ) {
		nodes = [ nodes ];
	}

	// Array.from to enable .map() on non-arrays.
	return Array.from( nodes )
		.map( node => {
			return typeof node == 'string' ? new __WEBPACK_IMPORTED_MODULE_2__text__["a" /* default */]( node ) : node;
		} );
}


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_clone__ = __webpack_require__(68);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/operation
 */



/**
 * Abstract base operation class.
 *
 * @abstract
 */
class Operation {
	/**
	 * Base operation constructor.
	 * @param {Number} baseVersion {@link module:engine/model/document~Document#version} on which the operation can be applied.
	 */
	constructor( baseVersion ) {
		/**
		 * {@link module:engine/model/document~Document#version} on which operation can be applied. If you try to
		 * {@link module:engine/model/document~Document#applyOperation apply} operation with different base version than the
		 * {@link module:engine/model/document~Document#version document version} the
		 * {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.
		 *
		 * @member {Number}
		 */
		this.baseVersion = baseVersion;

		/**
		 * Operation type.
		 *
		 * @readonly
		 * @member {String} #type
		 */

		/**
		 * {@link module:engine/model/delta/delta~Delta Delta} which the operation is a part of. This property is set by the
		 * {@link module:engine/model/delta/delta~Delta delta} when the operations is added to it by the
		 * {@link module:engine/model/delta/delta~Delta#addOperation} method.
		 *
		 * @member {module:engine/model/delta/delta~Delta} #delta
		 */

		/**
		 * Creates and returns an operation that has the same parameters as this operation.
		 *
		 * @method #clone
		 * @returns {module:engine/model/operation/operation~Operation} Clone of this operation.
		 */

		/**
		 * Creates and returns a reverse operation. Reverse operation when executed right after
		 * the original operation will bring back tree model state to the point before the original
		 * operation execution. In other words, it reverses changes done by the original operation.
		 *
		 * Keep in mind that tree model state may change since executing the original operation,
		 * so reverse operation will be "outdated". In that case you will need to
		 * {@link module:engine/model/operation/transform~transform} it by all operations that were executed after the original operation.
		 *
		 * @method #getReversed
		 * @returns {module:engine/model/operation/operation~Operation} Reversed operation.
		 */

		/**
		 * Executes the operation - modifications described by the operation attributes
		 * will be applied to the tree model.
		 *
		 * @protected
		 * @method #_execute
		 * @returns {Object} Object with additional information about the applied changes. It properties depends on the
		 * operation type.
		 */
	}

	/**
	 * Custom toJSON method to solve child-parent circular dependencies.
	 *
	 * @method #toJSON
	 * @returns {Object} Clone of this object with the delta property replaced with string.
	 */
	toJSON() {
		const json = Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_clone__["a" /* default */])( this, true );

		json.__className = this.constructor.className;

		// Remove parent delta to avoid circular dependencies.
		delete json.delta;

		return json;
	}

	/**
	 * Name of the operation class used for serialization.
	 *
	 * @type {String}
	 */
	static get className() {
		return 'engine.model.operation.Operation';
	}

	/**
	 * Creates Operation object from deserilized object, i.e. from parsed JSON string.
	 *
	 * @param {Object} json Deserialized JSON object.
	 * @param {module:engine/model/document~Document} doc Document on which this operation will be applied.
	 * @returns {module:engine/model/operation/operation~Operation}
	 */
	static fromJSON( json ) {
		return new this( json.baseVersion );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Operation;



/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__moveoperation__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__reinsertoperation__ = __webpack_require__(96);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/removeoperation
 */




/**
 * Operation to remove a range of nodes.
 */
class RemoveOperation extends __WEBPACK_IMPORTED_MODULE_0__moveoperation__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	get type() {
		return 'remove';
	}

	/**
	 * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
	 *
	 * @returns {module:engine/model/operation/reinsertoperation~ReinsertOperation|module:engine/model/operation/nooperation~NoOperation}
	 */
	getReversed() {
		const newTargetPosition = this.sourcePosition._getTransformedByInsertion( this.targetPosition, this.howMany );

		return new __WEBPACK_IMPORTED_MODULE_1__reinsertoperation__["a" /* default */]( this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1 );
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.operation.RemoveOperation';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RemoveOperation;



/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseSlice);


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = buildViewConverter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view_matcher__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_writer__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_isiterable__ = __webpack_require__(34);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/conversion/buildviewconverter
 */








/**
 * Provides chainable, high-level API to easily build basic view-to-model converters that are appended to given
 * dispatchers. View-to-model converters are used when external data is added to the editor, i.e. when a user pastes
 * HTML content to the editor. Then, converters are used to translate this structure, possibly removing unknown/incorrect
 * nodes, and add it to the model. Also multiple, different elements might be translated into the same thing in the
 * model, i.e. `<b>` and `<strong>` elements might be converted to `bold` attribute (even though `bold` attribute will
 * be then converted only to `<strong>` tag). Instances of this class are created by
 * {@link module:engine/conversion/buildviewconverter~buildViewConverter}.
 *
 * If you need more complex converters, see {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher},
 * {@link module:engine/conversion/view-to-model-converters}, {@link module:engine/conversion/viewconsumable~ViewConsumable}.
 *
 * Using this API it is possible to create various kind of converters:
 *
 * 1. View element to model element:
 *
 *		buildViewConverter().for( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
 *
 * 2. View element to model attribute:
 *
 *		buildViewConverter().for( dispatcher ).fromElement( 'b' ).fromElement( 'strong' ).toAttribute( 'bold', 'true' );
 *
 * 3. View attribute to model attribute:
 *
 *		buildViewConverter().for( dispatcher ).fromAttribute( 'style', { 'font-weight': 'bold' } ).toAttribute( 'bold', 'true' );
 *		buildViewConverter().for( dispatcher )
 *			.fromAttribute( 'class' )
 *			.toAttribute( ( viewElement ) => ( { class: viewElement.getAttribute( 'class' ) } ) );
 *
 * 4. View elements and attributes to model attribute:
 *
 *		buildViewConverter().for( dispatcher )
 *			.fromElement( 'b' ).fromElement( 'strong' ).fromAttribute( 'style', { 'font-weight': 'bold' } )
 *			.toAttribute( 'bold', 'true' );
 *
 * 5. View {@link module:engine/view/matcher~Matcher view element matcher instance} or
 * {@link module:engine/view/matcher~Matcher#add matcher pattern}
 * to model element or attribute:
 *
 *		const matcher = new ViewMatcher();
 *		matcher.add( 'div', { class: 'quote' } );
 *		buildViewConverter().for( dispatcher ).from( matcher ).toElement( 'quote' );
 *
 *		buildViewConverter().for( dispatcher ).from( { name: 'span', class: 'bold' } ).toAttribute( 'bold', 'true' );
 *
 * Note, that converters built using `ViewConverterBuilder` automatically check {@link module:engine/model/schema~Schema schema}
 * if created model structure is valid. If given conversion would be invalid according to schema, it is ignored.
 *
 * It is possible to provide creator functions as parameters for {@link ~ViewConverterBuilder#toElement}
 * and {@link module:engine/conversion/buildviewconverter~ViewConverterBuilder#toAttribute} methods. See their descriptions to learn more.
 *
 * By default, converter will {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume} every value specified in
 * given `from...` query, i.e. `.from( { name: 'span', class: 'bold' } )` will make converter consume both `span` name
 * and `bold` class. It is possible to change this behavior using {@link ~ViewConverterBuilder#consuming consuming}
 * modifier. The modifier alters the last `fromXXX` query used before it. To learn more about consuming values,
 * see {@link module:engine/conversion/viewconsumable~ViewConsumable}.
 *
 * It is also possible to {@link module:engine/conversion/buildviewconverter~ViewConverterBuilder#withPriority change default priority}
 * of created converters to decide which converter should be fired earlier and which later. This is useful if you provide
 * a general converter but want to provide different converter for a specific-case (i.e. given view element is converted
 * always to given model element, but if it has given class it is converter to other model element). For this,
 * use {@link module:engine/conversion/buildviewconverter~ViewConverterBuilder#withPriority withPriority} modifier. The modifier alters
 * the last `from...` query used before it.
 *
 * Note that `to...` methods are "terminators", which means that should be the last one used in building converter.
 *
 * You can use {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder}
 * to create "opposite" converters - from model to view.
 */
class ViewConverterBuilder {
	/**
	 * Creates `ViewConverterBuilder` with given `dispatchers` registered to it.
	 */
	constructor() {
		/**
		 * Dispatchers to which converters will be attached.
		 *
		 * @type {Array.<module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher>}
		 * @private
		 */
		this._dispatchers = [];

		/**
		 * Stores "from" queries.
		 *
		 * @type {Array}
		 * @private
		 */
		this._from = [];
	}

	/**
	 * Set one or more dispatchers which the built converter will be attached to.
	 *
	 * @chainable
	 * @param {...module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher} dispatchers One or more dispatchers.
	 * @returns {module:engine/conversion/buildviewconverter~ViewConverterBuilder}
	 */
	for( ...dispatchers ) {
		this._dispatchers = dispatchers;

		return this;
	}

	/**
	 * Registers what view element should be converted.
	 *
	 *		buildViewConverter().for( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
	 *
	 * @chainable
	 * @param {String} elementName View element name.
	 * @returns {module:engine/conversion/buildviewconverter~ViewConverterBuilder}
	 */
	fromElement( elementName ) {
		return this.from( { name: elementName } );
	}

	/**
	 * Registers what view attribute should be converted.
	 *
	 *		buildViewConverter().for( dispatcher ).fromAttribute( 'style', { 'font-weight': 'bold' } ).toAttribute( 'bold', 'true' );
	 *
	 * @chainable
	 * @param {String|RegExp} key View attribute key.
	 * @param {String|RegExp} [value] View attribute value.
	 * @returns {module:engine/conversion/buildviewconverter~ViewConverterBuilder}
	 */
	fromAttribute( key, value = /.*/ ) {
		const pattern = {};

		if ( key === 'style' || key === 'class' ) {
			pattern[ key ] = value;
		} else {
			pattern.attribute = {};
			pattern.attribute[ key ] = value;
		}

		const matcher = new __WEBPACK_IMPORTED_MODULE_0__view_matcher__["a" /* default */]( pattern );

		this._from.push( {
			matcher,
			consume: false,
			priority: null,
			attributeKey: key
		} );

		return this;
	}

	/**
	 * Registers what view pattern should be converted. The method accepts either {@link module:engine/view/matcher~Matcher view matcher}
	 * or view matcher pattern.
	 *
	 *		const matcher = new ViewMatcher();
	 *		matcher.add( 'div', { class: 'quote' } );
	 *		buildViewConverter().for( dispatcher ).from( matcher ).toElement( 'quote' );
	 *
	 *		buildViewConverter().for( dispatcher ).from( { name: 'span', class: 'bold' } ).toAttribute( 'bold', 'true' );
	 *
	 * @chainable
	 * @param {Object|module:engine/view/matcher~Matcher} matcher View matcher or view matcher pattern.
	 * @returns {module:engine/conversion/buildviewconverter~ViewConverterBuilder}
	 */
	from( matcher ) {
		if ( !( matcher instanceof __WEBPACK_IMPORTED_MODULE_0__view_matcher__["a" /* default */] ) ) {
			matcher = new __WEBPACK_IMPORTED_MODULE_0__view_matcher__["a" /* default */]( matcher );
		}

		this._from.push( {
			matcher,
			consume: false,
			priority: null
		} );

		return this;
	}

	/**
	 * Modifies which consumable values will be {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}
	 * by built converter.
	 * It modifies the last `from...` query. Can be used after each `from...` query in given chain. Useful for providing
	 * more specific matches.
	 *
	 *		// This converter will only handle class bold conversion (to proper attribute) but span element
	 *		// conversion will have to be done in separate converter.
	 *		// Without consuming modifier, the converter would consume both class and name, so a converter for
	 *		// span element would not be fired.
	 *		buildViewConverter().for( dispatcher )
	 *			.from( { name: 'span', class: 'bold' } ).consuming( { class: 'bold' } )
	 *			.toAttribute( 'bold', 'true' } );
	 *
	 *		buildViewConverter().for( dispatcher )
	 *			.fromElement( 'img' ).consuming( { name: true, attribute: [ 'src', 'title' ] } )
	 *			.toElement( ( viewElement ) => new ModelElement( 'image', { src: viewElement.getAttribute( 'src' ),
	 *			                                                            title: viewElement.getAttribute( 'title' ) } );
	 *
	 * **Note:** All and only values from passed object has to be consumable on converted view element. This means that
	 * using `consuming` method, you can either make looser conversion conditions (like in first example) or tighter
	 * conversion conditions (like in second example). So, the view element, to be converter, has to match query of
	 * `from...` method and then have to have enough consumable values to consume.
	 *
	 * @see module:engine/conversion/viewconsumable~ViewConsumable
	 * @chainable
	 * @param {Object} consume Values to consume.
	 * @returns {module:engine/conversion/buildviewconverter~ViewConverterBuilder}
	 */
	consuming( consume ) {
		const lastFrom = this._from[ this._from.length - 1 ];
		lastFrom.consume = consume;

		return this;
	}

	/**
	 * Changes default priority for built converter. It modifies the last `from...` query. Can be used after each
	 * `from...` query in given chain. Useful for overwriting converters. The lower the number, the earlier converter will be fired.
	 *
	 *		buildViewConverter().for( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
	 *		// Register converter with proper priority, otherwise "p" element would get consumed by first
	 *		// converter and the second converter would not be fired.
	 *		buildViewConverter().for( dispatcher )
	 *			.from( { name: 'p', class: 'custom' } ).withPriority( 9 )
	 *			.toElement( 'customParagraph' );
	 *
	 * **Note:** `ViewConverterBuilder` takes care of applying all `toElement()` conversions before all `toAttribute()`
	 * conversions. This is done by setting default `toElement()` priority to `normal` and `toAttribute()` priority to `low`.
	 * It is recommended to set converter priority for `toElement()` around `0` (the value of `normal` priority)
	 * and `toAttribute()` priority around `-1000` (the value of `low` priority).
	 * It is important that model elements are created before attributes, otherwise attributes would
	 * not be applied or other errors may occur.
	 *
	 * @chainable
	 * @param {Number} priority Converter priority.
	 * @returns {module:engine/conversion/buildviewconverter~ViewConverterBuilder}
	 */
	withPriority( priority ) {
		const lastFrom = this._from[ this._from.length - 1 ];
		lastFrom.priority = priority;

		return this;
	}

	/**
	 * Registers what model element will be created by converter.
	 *
	 * Method accepts two ways of providing what kind of model element will be created. You can pass model element
	 * name as a `string` or a function that will return model element instance. If you provide creator function,
	 * it will be passed converted view element as first and only parameter.
	 *
	 *		buildViewConverter().for( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
	 *		buildViewConverter().for( dispatcher )
	 *			.fromElement( 'img' )
	 *			.toElement( ( viewElement ) => new ModelElement( 'image', { src: viewElement.getAttribute( 'src' ) } );
	 *
	 * @param {String|Function} element Model element name or model element creator function.
	 */
	toElement( element ) {
		function eventCallbackGen( from ) {
			return ( evt, data, consumable, conversionApi ) => {
				// There is one callback for all patterns in the matcher.
				// This will be usually just one pattern but we support matchers with many patterns too.
				const matchAll = from.matcher.matchAll( data.input );

				// If there is no match, this callback should not do anything.
				if ( !matchAll ) {
					return;
				}

				// Now, for every match between matcher and actual element, we will try to consume the match.
				for ( const match of matchAll ) {
					// Create model element basing on creator function or element name.
					const modelElement = element instanceof Function ? element( data.input ) : new __WEBPACK_IMPORTED_MODULE_1__model_element__["a" /* default */]( element );

					// Do not convert if element building function returned falsy value.
					if ( !modelElement ) {
						continue;
					}

					// Check whether generated structure is okay with `Schema`.
					const keys = Array.from( modelElement.getAttributeKeys() );

					if ( !conversionApi.schema.check( { name: modelElement.name, attributes: keys, inside: data.context } ) ) {
						continue;
					}

					// Try to consume appropriate values from consumable values list.
					if ( !consumable.consume( data.input, from.consume || match.match ) ) {
						continue;
					}

					// If everything is fine, we are ready to start the conversion.
					// Add newly created `modelElement` to the parents stack.
					data.context.push( modelElement );

					// Convert children of converted view element and append them to `modelElement`.
					const modelChildren = conversionApi.convertChildren( data.input, consumable, data );
					const insertPosition = __WEBPACK_IMPORTED_MODULE_2__model_position__["a" /* default */].createAt( modelElement, 'end' );
					__WEBPACK_IMPORTED_MODULE_3__model_writer__["a" /* default */].insert( insertPosition, modelChildren );

					// Remove created `modelElement` from the parents stack.
					data.context.pop();

					// Add `modelElement` as a result.
					data.output = modelElement;

					// Prevent multiple conversion if there are other correct matches.
					break;
				}
			};
		}

		this._setCallback( eventCallbackGen, 'normal' );
	}

	/**
	 * Registers what model attribute will be created by converter.
	 *
	 * Method accepts two ways of providing what kind of model attribute will be created. You can either pass two strings
	 * representing attribute key and attribute value or a function that returns an object with `key` and `value` properties.
	 * If you provide creator function, it will be passed converted view element as first and only parameter.
	 *
	 *		buildViewConverter().for( dispatcher ).fromAttribute( 'alt' ).toAttribute( 'alt' );
	 *		buildViewConverter().for( dispatcher ).fromAttribute( 'style', { 'font-weight': 'bold' } ).toAttribute( 'bold', true );
	 *		buildViewConverter().for( dispatcher )
	 *			.fromAttribute( 'class' )
	 *			.toAttribute( ( viewElement ) => ( { key: 'class', value: 'class-' + viewElement.getAttribute( 'class' ) } ) );
	 *
	 * @param {String|Function} keyOrCreator Attribute key or a creator function.
	 * @param {String} [value] Attribute value. Ignored if `keyOrCreator` is not a `string`. If `keyOrCreator` is `string`,
	 * if `value` is not set, attribute value from converted element will be used.
	 */
	toAttribute( keyOrCreator, value ) {
		function eventCallbackGen( from ) {
			return ( evt, data, consumable, conversionApi ) => {
				// There is one callback for all patterns in the matcher.
				// This will be usually just one pattern but we support matchers with many patterns too.
				const matchAll = from.matcher.matchAll( data.input );

				// If there is no match, this callback should not do anything.
				if ( !matchAll ) {
					return;
				}

				// Now, for every match between matcher and actual element, we will try to consume the match.
				for ( const match of matchAll ) {
					// Try to consume appropriate values from consumable values list.
					if ( !consumable.consume( data.input, from.consume || match.match ) ) {
						continue;
					}

					// Since we are converting to attribute we need an output on which we will set the attribute.
					// If the output is not created yet, we will create it.
					if ( !data.output ) {
						data.output = conversionApi.convertChildren( data.input, consumable, data );
					}

					// Use attribute creator function, if provided.
					let attribute;

					if ( keyOrCreator instanceof Function ) {
						attribute = keyOrCreator( data.input );

						if ( !attribute ) {
							return;
						}
					} else {
						attribute = {
							key: keyOrCreator,
							value: value ? value : data.input.getAttribute( from.attributeKey )
						};
					}

					// Set attribute on current `output`. `Schema` is checked inside this helper function.
					setAttributeOn( data.output, attribute, data, conversionApi );

					// Prevent multiple conversion if there are other correct matches.
					break;
				}
			};
		}

		this._setCallback( eventCallbackGen, 'low' );
	}

	/**
	 * Registers how model element marking marker range will be created by converter.
	 *
	 * Created element has to match the following pattern:
	 *
	 * 		{ name: '$marker', attribute: { data-name: /^\w/ } }
	 *
	 * There are two ways of creating this element:
	 *
	 * 1. Makes sure that converted view element will have property `data-name` then converter will
	 * automatically take this property value. In this case there is no need to provide creator function.
	 * For the following view:
	 *
	 *		<marker data-name="search"></marker>foo<marker data-name="search"></marker>
	 *
	 * converter should look like this:
	 *
	 *		buildViewConverter().for( dispatcher ).fromElement( 'marker' ).toMarker();
	 *
	 * 2. Creates element by creator:
	 *
	 * For the following view:
	 *
	 * 		<span foo="search"></span>foo<span foo="search"></span>
	 *
	 * converter should look like this:
	 *
	 * 		buildViewConverter().for( dispatcher ).from( { name: 'span', { attribute: foo: /^\w/ } } ).toMarker( ( data ) => {
	 * 			return new Element( '$marker', { 'data-name': data.getAttribute( 'foo' ) } );
	 * 		} );
	 *
	 * @param {Function} [creator] Creator function.
	 */
	toMarker( creator ) {
		function eventCallbackGen( from ) {
			return ( evt, data, consumable ) => {
				// There is one callback for all patterns in the matcher.
				// This will be usually just one pattern but we support matchers with many patterns too.
				const matchAll = from.matcher.matchAll( data.input );

				// If there is no match, this callback should not do anything.
				if ( !matchAll ) {
					return;
				}

				let modelElement;

				// When creator is provided then create model element basing on creator function.
				if ( creator instanceof Function ) {
					modelElement = creator( data.input );
				// When there is no creator then create model element basing on data from view element.
				} else {
					modelElement = new __WEBPACK_IMPORTED_MODULE_1__model_element__["a" /* default */]( '$marker', { 'data-name': data.input.getAttribute( 'data-name' ) } );
				}

				// Check if model element is correct (has proper name and property).
				if ( modelElement.name != '$marker' || typeof modelElement.getAttribute( 'data-name' ) != 'string' ) {
					throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
						'build-view-converter-invalid-marker: Invalid model element to mark marker range.'
					);
				}

				// Now, for every match between matcher and actual element, we will try to consume the match.
				for ( const match of matchAll ) {
					// Try to consume appropriate values from consumable values list.
					if ( !consumable.consume( data.input, from.consume || match.match ) ) {
						continue;
					}

					data.output = modelElement;

					// Prevent multiple conversion if there are other correct matches.
					break;
				}
			};
		}

		this._setCallback( eventCallbackGen, 'normal' );
	}

	/**
	 * Helper function that uses given callback generator to created callback function and sets it on registered dispatchers.
	 *
	 * @param eventCallbackGen
	 * @param defaultPriority
	 * @private
	 */
	_setCallback( eventCallbackGen, defaultPriority ) {
		// We will add separate event callback for each registered `from` entry.
		for ( const from of this._from ) {
			// We have to figure out event name basing on matcher's patterns.
			// If there is exactly one pattern and it has `name` property we will used that name.
			const matcherElementName = from.matcher.getElementName();
			const eventName = matcherElementName ? 'element:' + matcherElementName : 'element';
			const eventCallback = eventCallbackGen( from );

			const priority = from.priority === null ? defaultPriority : from.priority;

			// Add event to each registered dispatcher.
			for ( const dispatcher of this._dispatchers ) {
				dispatcher.on( eventName, eventCallback, { priority } );
			}
		}
	}
}

// Helper function that sets given attributes on given `module:engine/model/node~Node` or
// `module:engine/model/documentfragment~DocumentFragment`.
function setAttributeOn( toChange, attribute, data, conversionApi ) {
	if ( Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_isiterable__["a" /* default */])( toChange ) ) {
		for ( const node of toChange ) {
			setAttributeOn( node, attribute, data, conversionApi );
		}

		return;
	}

	const keys = Array.from( toChange.getAttributeKeys() );
	keys.push( attribute.key );

	const schemaQuery = {
		name: toChange.name || '$text',
		attributes: keys,
		inside: data.context
	};

	if ( conversionApi.schema.check( schemaQuery ) ) {
		toChange.setAttribute( attribute.key, attribute.value );
	}
}

/**
 * Entry point for view-to-model converters builder. This chainable API makes it easy to create basic, most common
 * view-to-model converters and attach them to provided dispatchers. The method returns an instance of
 * {@link module:engine/conversion/buildviewconverter~ViewConverterBuilder}.
 */
function buildViewConverter() {
	return new ViewConverterBuilder();
}


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/* harmony default export */ __webpack_exports__["a"] = (isObjectLike);


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assignIn__ = __webpack_require__(300);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__assignIn__["a"]; });



/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isObjectLike__ = __webpack_require__(43);


/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (Object(__WEBPACK_IMPORTED_MODULE_0__isObjectLike__["a" /* default */])(value) && objectToString.call(value) == symbolTag);
}

/* harmony default export */ __webpack_exports__["a"] = (isSymbol);


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__element__ = __webpack_require__(9);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/containerelement
 */



/**
 * Containers are elements which define document structure. They define boundaries for
 * {@link module:engine/view/attributeelement~AttributeElement attributes}. They are mostly use for block elements like `<p>` or `<div>`.
 *
 * Editing engine does not define fixed HTML DTD. This is why the type of the {@link module:engine/view/element~Element} need to
 * be defined by the feature developer.
 *
 * Creating an element you should use `ContainerElement` class or {@link module:engine/view/attributeelement~AttributeElement}. This is
 * important to define the type of the element because of two reasons:
 *
 * Firstly, {@link module:engine/view/domconverter~DomConverter} needs the information what is an editable block to convert elements to
 * DOM properly. {@link module:engine/view/domconverter~DomConverter} will ensure that `ContainerElement` is editable and it is possible
 * to put caret inside it, even if the container is empty.
 *
 * Secondly, {@link module:engine/view/writer~writer view writer} uses this information.
 * Nodes {@link module:engine/view/writer~writer.breakAttributes breaking} and {@link module:engine/view/writer~writer.mergeAttributes
 * merging}
 * is performed only in a bounds of a container nodes.
 *
 * For instance if `<p>` is an container and `<b>` is attribute:
 *
 *		<p><b>fo^o</b></p>
 *
 * {@link module:engine/view/writer~writer.breakAttributes breakAttributes} will create:
 *
 *		<p><b>fo</b><b>o</b></p>
 *
 * There might be a need to mark `<span>` element as a container node, for example in situation when it will be a
 * container of an inline widget:
 *
 *		<span color="red">foobar</span>		// attribute
 *		<span data-widget>foobar</span>		// container
 *
 * @extends module:engine/view/element~Element
 */
class ContainerElement extends __WEBPACK_IMPORTED_MODULE_0__element__["a" /* default */] {
	/**
	 * Creates a container element.
	 *
	 * @see module:engine/view/element~Element
	 */
	constructor( name, attrs, children ) {
		super( name, attrs, children );

		/**
		 * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.
		 *
		 * @method #getFillerOffset
		 * @returns {Number|null} Block filler offset or `null` if block filler is not needed.
		 */
		this.getFillerOffset = getFillerOffset;
	}

	/**
	 * @inheritDoc
	 */
	is( type, name = null ) {
		if ( !name ) {
			return type == 'containerElement' || super.is( type );
		} else {
			return ( type == 'containerElement' && name == this.name ) || super.is( type, name );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ContainerElement;


// Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.
//
// @returns {Number|null} Block filler offset or `null` if block filler is not needed.
function getFillerOffset() {
	for ( const child of this.getChildren() ) {
		// If there's any non-UI element  don't render the bogus.
		if ( !child.is( 'uiElement' ) ) {
			return null;
		}
	}

	// If there are only UI elements  render the bogus at the end of the element.
	return this.childCount;
}


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__operation__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nodelist__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__removeoperation__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__writer__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__text__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__element__ = __webpack_require__(5);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/insertoperation
 */









/**
 * Operation to insert one or more nodes at given position in the model.
 *
 * @extends module:engine/model/operation/operation~Operation
 */
class InsertOperation extends __WEBPACK_IMPORTED_MODULE_0__operation__["a" /* default */] {
	/**
	 * Creates an insert operation.
	 *
	 * @param {module:engine/model/position~Position} position Position of insertion.
	 * @param {module:engine/model/node~NodeSet} nodes The list of nodes to be inserted.
	 * @param {Number} baseVersion {@link module:engine/model/document~Document#version} on which operation can be applied.
	 */
	constructor( position, nodes, baseVersion ) {
		super( baseVersion );

		/**
		 * Position of insertion.
		 *
		 * @readonly
		 * @member {module:engine/model/position~Position} module:engine/model/operation/insertoperation~InsertOperation#position
		 */
		this.position = __WEBPACK_IMPORTED_MODULE_1__position__["a" /* default */].createFromPosition( position );

		/**
		 * List of nodes to insert.
		 *
		 * @readonly
		 * @member {module:engine/model/nodelist~NodeList} module:engine/model/operation/insertoperation~InsertOperation#nodeList
		 */
		this.nodes = new __WEBPACK_IMPORTED_MODULE_2__nodelist__["a" /* default */]( Object(__WEBPACK_IMPORTED_MODULE_4__writer__["c" /* normalizeNodes */])( nodes ) );
	}

	/**
	 * @inheritDoc
	 */
	get type() {
		return 'insert';
	}

	/**
	 * Creates and returns an operation that has the same parameters as this operation.
	 *
	 * @returns {module:engine/model/operation/insertoperation~InsertOperation} Clone of this operation.
	 */
	clone() {
		const nodes = new __WEBPACK_IMPORTED_MODULE_2__nodelist__["a" /* default */]( [ ...this.nodes ].map( node => node.clone( true ) ) );

		return new InsertOperation( this.position, nodes, this.baseVersion );
	}

	/**
	 * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
	 *
	 * @returns {module:engine/model/operation/removeoperation~RemoveOperation}
	 */
	getReversed() {
		const graveyard = this.position.root.document.graveyard;
		const gyPosition = new __WEBPACK_IMPORTED_MODULE_1__position__["a" /* default */]( graveyard, [ 0 ] );

		return new __WEBPACK_IMPORTED_MODULE_3__removeoperation__["a" /* default */]( this.position, this.nodes.maxOffset, gyPosition, this.baseVersion + 1 );
	}

	/**
	 * @inheritDoc
	 */
	_execute() {
		// What happens here is that we want original nodes be passed to writer because we want original nodes
		// to be inserted to the model. But in InsertOperation, we want to keep those nodes as they were added
		// to the operation, not modified. For example, text nodes can get merged or cropped while Elements can
		// get children. It is important that InsertOperation has the copy of original nodes in intact state.
		const originalNodes = this.nodes;
		this.nodes = new __WEBPACK_IMPORTED_MODULE_2__nodelist__["a" /* default */]( [ ...originalNodes ].map( node => node.clone( true ) ) );

		const range = Object(__WEBPACK_IMPORTED_MODULE_4__writer__["b" /* insert */])( this.position, originalNodes );

		return { range };
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.operation.InsertOperation';
	}

	/**
	 * Creates `InsertOperation` object from deserilized object, i.e. from parsed JSON string.
	 *
	 * @param {Object} json Deserialized JSON object.
	 * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
	 * @returns {module:engine/model/operation/insertoperation~InsertOperation}
	 */
	static fromJSON( json, document ) {
		const children = [];

		for ( const child of json.nodes ) {
			if ( child.name ) {
				// If child has name property, it is an Element.
				children.push( __WEBPACK_IMPORTED_MODULE_6__element__["a" /* default */].fromJSON( child ) );
			} else {
				// Otherwise, it is a Text node.
				children.push( __WEBPACK_IMPORTED_MODULE_5__text__["a" /* default */].fromJSON( child ) );
			}
		}

		return new InsertOperation( __WEBPACK_IMPORTED_MODULE_1__position__["a" /* default */].fromJSON( json.position, document ), children, json.baseVersion );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = InsertOperation;



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SetCache__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayIncludes__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__cacheHas__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createSet__ = __webpack_require__(407);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__setToArray__ = __webpack_require__(88);







/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = __WEBPACK_IMPORTED_MODULE_1__arrayIncludes__["a" /* default */],
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith__["a" /* default */];
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : Object(__WEBPACK_IMPORTED_MODULE_4__createSet__["a" /* default */])(array);
    if (set) {
      return Object(__WEBPACK_IMPORTED_MODULE_5__setToArray__["a" /* default */])(set);
    }
    isCommon = false;
    includes = __WEBPACK_IMPORTED_MODULE_3__cacheHas__["a" /* default */];
    seen = new __WEBPACK_IMPORTED_MODULE_0__SetCache__["a" /* default */];
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseUniq);


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dom_emittermixin__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keyboard__ = __webpack_require__(28);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/keystrokehandler
 */




/**
 * Keystroke handler registers keystrokes so the callbacks associated
 * with these keystrokes will be executed if the matching `keydown` is fired
 * by a defined emitter.
 *
 *		const handler = new KeystrokeHandler();
 *
 *		handler.listenTo( emitter );
 *
 *		handler.set( 'Ctrl+A', ( keyEvtData, cancel ) => {
 *			console.log( 'Ctrl+A has been pressed' );
 *			cancel();
 *		} );
 */
class KeystrokeHandler {
	/**
	 * Creates an instance of the keystroke handler.
	 */
	constructor() {
		/**
		 * Listener used to listen to events for easier keystroke handler destruction.
		 *
		 * @protected
		 * @member {module:utils/dom/emittermixin~Emitter}
		 */
		this._listener = Object.create( __WEBPACK_IMPORTED_MODULE_0__dom_emittermixin__["a" /* default */] );
	}

	/**
	 * Starts listening for `keydown` events from a given emitter.
	 *
	 * @param {module:utils/emittermixin~Emitter} emitter
	 */
	listenTo( emitter ) {
		// The #_listener works here as a kind of dispatcher. It groups the events coming from the same
		// keystroke so the listeners can be attached to them with different priorities.
		//
		// E.g. all the keystrokes with the `keyCode` of 42 coming from the `emitter` are propagated
		// as a `_keydown:42` event by the `_listener`. If there's a callback created by the `set`
		// method for this 42 keystroke, it listens to the `_listener#_keydown:42` event only and interacts
		// only with other listeners of this particular event, thus making it possible to prioritize
		// the listeners and safely cancel execution, when needed. Instead of duplicating the Emitter logic,
		// the KeystrokeHandler reuses it to do its job.
		this._listener.listenTo( emitter, 'keydown', ( evt, keyEvtData ) => {
			this._listener.fire( '_keydown:' + Object(__WEBPACK_IMPORTED_MODULE_1__keyboard__["a" /* getCode */])( keyEvtData ), keyEvtData );
		} );
	}

	/**
	 * Registers a handler for the specified keystroke.
	 *
	 * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by
	 * the {@link module:utils/keyboard~parseKeystroke} function.
	 * @param {Function} callback A function called with the
	 * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
	 * a helper to both `preventDefault` and `stopPropagation` of the event.
	 * @param {Object} [options={}] Additional options.
	 * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke
	 * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority
	 * are called in the order they were added.
	 */
	set( keystroke, callback, options = {} ) {
		const keyCode = Object(__WEBPACK_IMPORTED_MODULE_1__keyboard__["d" /* parseKeystroke */])( keystroke );
		const priority = options.priority;

		// Execute the passed callback on KeystrokeHandler#_keydown.
		// TODO: https://github.com/ckeditor/ckeditor5-utils/issues/144
		this._listener.listenTo( this._listener, '_keydown:' + keyCode, ( evt, keyEvtData ) => {
			callback( keyEvtData, () => {
				// Stop the event in the DOM: no listener in the web page
				// will be triggered by this event.
				keyEvtData.preventDefault();
				keyEvtData.stopPropagation();

				// Stop the event in the KeystrokeHandler: no more callbacks
				// will be executed for this keystroke.
				evt.stop();
			} );

			// Mark this keystroke as handled by the callback. See: #press.
			evt.return = true;
		}, { priority } );
	}

	/**
	 * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
	 *
	 * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEvtData Key event data.
	 * @returns {Boolean} Whether the keystroke was handled.
	 */
	press( keyEvtData ) {
		return !!this._listener.fire( '_keydown:' + Object(__WEBPACK_IMPORTED_MODULE_1__keyboard__["a" /* getCode */])( keyEvtData ), keyEvtData );
	}

	/**
	 * Destroys the keystroke handler.
	 */
	destroy() {
		this._listener.stopListening();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = KeystrokeHandler;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dom_emittermixin__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__observablemixin__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* global setTimeout, clearTimeout */

/**
 * @module utils/focustracker
 */






/**
 * Allows observing a group of `HTMLElement`s whether at least one of them is focused.
 *
 * Used by the {@link module:core/editor/editor~Editor} in order to track whether the focus is still within the application,
 * or were used outside of its UI.
 *
 * **Note** `focus` and `blur` listeners use event capturing, so it is only needed to register wrapper `HTMLElement`
 * which contain other `focusable` elements. But note that this wrapper element has to be focusable too
 * (have e.g. `tabindex="-1"`).
 *
 * @mixes module:utils/dom/emittermixin~EmitterMixin
 * @mixes module:utils/observablemixin~ObservableMixin
 */
class FocusTracker {
	constructor() {
		/**
		 * True when one of the registered elements is focused.
		 *
		 * @readonly
		 * @observable
		 * @member {Boolean} #isFocused
		 */
		this.set( 'isFocused', false );

		/**
		 * Currently focused element.
		 *
		 * @readonly
		 * @member {HTMLElement}
		 */
		this.focusedElement = null;

		/**
		 * List of registered elements.
		 *
		 * @private
		 * @member {Set.<HTMLElement>}
		 */
		this._elements = new Set();

		/**
		 * Event loop timeout.
		 *
		 * @private
		 * @member {Number}
		 */
		this._nextEventLoopTimeout = null;
	}

	/**
	 * Starts tracking the specified element.
	 *
	 * @param {HTMLElement} element
	 */
	add( element ) {
		if ( this._elements.has( element ) ) {
			throw new __WEBPACK_IMPORTED_MODULE_2__ckeditorerror__["b" /* default */]( 'focusTracker-add-element-already-exist' );
		}

		this.listenTo( element, 'focus', () => this._focus( element ), { useCapture: true } );
		this.listenTo( element, 'blur', () => this._blur(), { useCapture: true } );
		this._elements.add( element );
	}

	/**
	 * Stops tracking the specified element and stops listening on this element.
	 *
	 * @param {HTMLElement} element
	 */
	remove( element ) {
		if ( element === this.focusedElement ) {
			this._blur( element );
		}

		if ( this._elements.has( element ) ) {
			this.stopListening( element );
			this._elements.delete( element );
		}
	}

	/**
	 * Stores currently focused element and set {#isFocused} as `true`.
	 *
	 * @private
	 * @param {HTMLElement} element Element which has been focused.
	 */
	_focus( element ) {
		clearTimeout( this._nextEventLoopTimeout );

		this.focusedElement = element;
		this.isFocused = true;
	}

	/**
	 * Clears currently focused element and set {@link #isFocused} as `false`.
	 * This method uses `setTimeout` to change order of fires `blur` and `focus` events.
	 *
	 * @private
	 * @fires blur
	 */
	_blur() {
		clearTimeout( this._nextEventLoopTimeout );

		this._nextEventLoopTimeout = setTimeout( () => {
			this.focusedElement = null;
			this.isFocused = false;
		}, 0 );
	}

	/**
	 * @event focus
	 */

	/**
	 * @event blur
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FocusTracker;


Object(__WEBPACK_IMPORTED_MODULE_3__mix__["a" /* default */])( FocusTracker, __WEBPACK_IMPORTED_MODULE_0__dom_emittermixin__["a" /* default */] );
Object(__WEBPACK_IMPORTED_MODULE_3__mix__["a" /* default */])( FocusTracker, __WEBPACK_IMPORTED_MODULE_1__observablemixin__["a" /* default */] );


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = buildModelConverter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_selection_to_view_converters__ = __webpack_require__(264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__view_attributeelement__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__view_containerelement__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__view_uielement__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/conversion/buildmodelconverter
 */











/**
 * Provides chainable, high-level API to easily build basic model-to-view converters that are appended to given
 * dispatchers. In many cases, this is the API that should be used to specify how abstract model elements and
 * attributes should be represented in the view (and then later in DOM). Instances of this class are created by
 * {@link module:engine/conversion/buildmodelconverter~buildModelConverter}.
 *
 * If you need more complex converters, see {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher},
 * {@link module:engine/conversion/model-to-view-converters}, {@link module:engine/conversion/modelconsumable~ModelConsumable},
 * {@link module:engine/conversion/mapper~Mapper}.
 *
 * Using this API it is possible to create five kinds of converters:
 *
 * 1. Model element to view element converter. This is a converter that takes the model element and represents it
 * in the view.
 *
 *		buildModelConverter().for( dispatcher ).fromElement( 'paragraph' ).toElement( 'p' );
 *		buildModelConverter().for( dispatcher ).fromElement( 'image' ).toElement( 'img' );
 *
 * 2. Model attribute to view attribute converter. This is a converter that operates on model element attributes
 * and converts them to view element attributes. It is suitable for elements like `image` (`src`, `title` attributes).
 *
 *		buildModelConverter().for( dispatcher ).fromElement( 'image' ).toElement( 'img' );
 *		buildModelConverter().for( dispatcher ).fromAttribute( 'src' ).toAttribute();
 *
 * 3. Model attribute to view element converter. This is a converter that takes model attributes and represents them
 * as view elements. Elements created by this kind of converter are wrapping other view elements. Wrapped view nodes
 * correspond to model nodes had converter attribute. It is suitable for attributes like `bold`, where `bold` attribute
 * set on model text nodes is converter to `strong` view element.
 *
 *		buildModelConverter().for( dispatcher ).fromAttribute( 'bold' ).toElement( 'strong' );
 *
 * 4. Model marker to view highlight converter. This is a converter that converts model markers to view highlight
 * described by {@link module:engine/conversion/model-to-view-converters~HighlightDescriptor} object passed to
 * {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder#toHighlight} method.
 *
 *		buildModelConverter().for( dispatcher ).fromMarker( 'search' ).toHighlight( {
 *			class: 'search',
 *			priority: 20
 *		} );
 *
 * 5. Model marker to element converter. This is a converter that takes model marker and creates separate elements at
 * the beginning and at the end of the marker's range. For more information see
 * {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder#toElement} method.
 *
 *		buildModelConverter().for( dispatcher ).fromMarker( 'search' ).toElement( 'span' );
 *
 * It is possible to provide various different parameters for
 * {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder#toElement},
 * {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder#toAttribute} and
 * {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder#toHighlight} methods.
 * See their descriptions to learn more.
 *
 * It is also possible to {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder#withPriority change default priority}
 * of created converters to decide which converter should be fired earlier and which later. This is useful if you have
 * a general converter but also want to provide different special-case converters (i.e. given model element is converted
 * always to given view element, but if it has given attribute it is converter to other view element). For this,
 * use {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder#withPriority withPriority} right after `from...` method.
 *
 * Note that `to...` methods are "terminators", which means that should be the last one used in building converter.
 *
 * You can use {@link module:engine/conversion/buildviewconverter~ViewConverterBuilder}
 * to create "opposite" converters - from view to model.
 */
class ModelConverterBuilder {
	/**
	 * Creates `ModelConverterBuilder` with given `dispatchers` registered to it.
	 */
	constructor() {
		/**
		 * Dispatchers to which converters will be attached.
		 *
		 * @type {Array.<module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher>}
		 * @private
		 */
		this._dispatchers = [];

		/**
		 * Contains data about registered "from" query.
		 *
		 * @type {Object}
		 * @private
		 */
		this._from = null;
	}

	/**
	 * Set one or more dispatchers which the built converter will be attached to.
	 *
	 * @chainable
	 * @param {...module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher} dispatchers One or more dispatchers.
	 * @returns {module:engine/conversion/buildmodelconverter~ModelConverterBuilder}
	 */
	for( ...dispatchers ) {
		this._dispatchers = dispatchers;

		return this;
	}

	/**
	 * Registers what model element should be converted.
	 *
	 * @chainable
	 * @param {String} elementName Name of element to convert.
	 * @returns {module:engine/conversion/buildmodelconverter~ModelConverterBuilder}
	 */
	fromElement( elementName ) {
		this._from = {
			type: 'element',
			name: elementName,
			priority: null
		};

		return this;
	}

	/**
	 * Registers what model attribute should be converted.
	 *
	 * @chainable
	 * @param {String} key Key of attribute to convert.
	 * @returns {module:engine/conversion/buildmodelconverter~ModelConverterBuilder}
	 */
	fromAttribute( key ) {
		this._from = {
			type: 'attribute',
			key,
			priority: null
		};

		return this;
	}

	/**
	 * Registers what type of marker should be converted.
	 *
	 * @chainable
	 * @param {String} markerName Name of marker to convert.
	 * @returns {module:engine/conversion/buildmodelconverter~ModelConverterBuilder}
	 */
	fromMarker( markerName ) {
		this._from = {
			type: 'marker',
			name: markerName,
			priority: null
		};

		return this;
	}

	/**
	 * Changes default priority for built converter. The lower the number, the earlier converter will be fired.
	 * Default priority is `10`.
	 *
	 * **Note:** Keep in mind that event priority, that is set by this modifier, is used for attribute priority
	 * when {@link module:engine/view/writer~writer} is used. This changes how view elements are ordered,
	 * i.e.: `<strong><em>foo</em></strong>` vs `<em><strong>foo</strong></em>`. Using priority you can also
	 * prevent node merging, i.e.: `<span class="bold"><span class="theme">foo</span><span>` vs `<span class="bold theme">foo</span>`.
	 * If you want to prevent merging, just set different priority for both converters.
	 *
	 *		buildModelConverter().for( dispatcher ).fromAttribute( 'bold' ).withPriority( 2 ).toElement( 'strong' );
	 *		buildModelConverter().for( dispatcher ).fromAttribute( 'italic' ).withPriority( 3 ).toElement( 'em' );
	 *
	 * @chainable
	 * @param {Number} priority Converter priority.
	 * @returns {module:engine/conversion/buildmodelconverter~ModelConverterBuilder}
	 */
	withPriority( priority ) {
		this._from.priority = priority;

		return this;
	}

	/**
	 * Registers what view element will be created by converter.
	 *
	 * Method accepts various ways of providing how the view element will be created. You can pass view element name as
	 * `string`, view element instance which will be cloned and used, or creator function which returns view element that
	 * will be used. Keep in mind that when you view element instance or creator function, it has to be/return a
	 * proper type of view element: {@link module:engine/view/containerelement~ContainerElement ViewContainerElement} if you convert
	 * from element, {@link module:engine/view/attributeelement~AttributeElement ViewAttributeElement} if you convert
	 * from attribute and {@link module:engine/view/uielement~UIElement ViewUIElement} if you convert from marker.
	 *
	 * **Note:** When converting from model's marker, separate elements will be created at the beginning and at the end of the
	 * marker's range. If range is collapsed then only one element will be created. See how markers
	 * {module:engine/model/buildviewconverter~ViewConverterBuilder#toMarker serialization from view to model}
	 * works to find out what view element format is the best for you.
	 *
	 *		buildModelConverter().for( dispatcher ).fromElement( 'paragraph' ).toElement( 'p' );
	 *
	 *		buildModelConverter().for( dispatcher ).fromElement( 'image' ).toElement( new ViewContainerElement( 'img' ) );
	 *
	 *		buildModelConverter().for( dispatcher )
	 *			.fromElement( 'header' )
	 *			.toElement( ( data ) => new ViewContainerElement( 'h' + data.item.getAttribute( 'level' ) ) );
	 *
	 *		buildModelConverter().for( dispatcher ).fromAttribute( 'bold' ).toElement( new ViewAttributeElement( 'strong' ) );
	 *
	 *		buildModelConverter().for( dispatcher ).fromMarker( 'search' ).toElement( 'span' );
	 *
	 *		buildModelConverter().for( dispatcher ).fromMarker( 'search' ).toElement( new ViewUIElement( 'span' ) );
	 *
	 * Creator function will be passed different values depending whether conversion is from element or from attribute:
	 *
	 * * from element: dispatcher's
	 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:insert insert event}
	 * parameters will be passed,
	 * * from attribute: there is one parameter and it is attribute value,
	 * * from marker: {@link module:engine/conversion/buildmodelconverter~MarkerViewElementCreatorData}.
	 *
	 * This method also registers model selection to view selection converter, if conversion is from attribute.
	 *
	 * This method creates the converter and adds it as a callback to a proper
	 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher conversion dispatcher} event.
	 *
	 * @param {String|module:engine/view/element~Element|Function} element Element created by converter or
	 * a function that returns view element.
	 */
	toElement( element ) {
		const priority = this._from.priority === null ? 'normal' : this._from.priority;

		for ( const dispatcher of this._dispatchers ) {
			if ( this._from.type == 'element' ) {
				// From model element to view element -> insert element.
				element = typeof element == 'string' ? new __WEBPACK_IMPORTED_MODULE_3__view_containerelement__["a" /* default */]( element ) : element;

				dispatcher.on( 'insert:' + this._from.name, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["d" /* insertElement */])( element ), { priority } );
			} else if ( this._from.type == 'attribute' ) {
				// From model attribute to view element -> wrap and unwrap.
				element = typeof element == 'string' ? new __WEBPACK_IMPORTED_MODULE_2__view_attributeelement__["a" /* default */]( element ) : element;

				dispatcher.on( 'addAttribute:' + this._from.key, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["l" /* wrapItem */])( element ), { priority } );
				dispatcher.on( 'changeAttribute:' + this._from.key, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["l" /* wrapItem */])( element ), { priority } );
				dispatcher.on( 'removeAttribute:' + this._from.key, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["k" /* unwrapItem */])( element ), { priority } );

				dispatcher.on( 'selectionAttribute:' + this._from.key, Object(__WEBPACK_IMPORTED_MODULE_1__model_selection_to_view_converters__["e" /* convertSelectionAttribute */])( element ), { priority } );
			} else { // From marker to element.
				const priority = this._from.priority === null ? 'normal' : this._from.priority;

				element = typeof element == 'string' ? new __WEBPACK_IMPORTED_MODULE_4__view_uielement__["a" /* default */]( element ) : element;

				dispatcher.on( 'addMarker:' + this._from.name, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["f" /* insertUIElement */])( element ), { priority } );
				dispatcher.on( 'removeMarker:' + this._from.name, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["i" /* removeUIElement */])( element ), { priority } );
			}
		}
	}

	/**
	 * Registers that marker should be converted to view highlight. Markers, basically,
	 * are {@link module:engine/model/liverange~LiveRange} instances, that are named. View highlight is
	 * a representation of the model marker in the view:
	 * * each {@link module:engine/view/text~Text view text node} in the marker's range will be wrapped with `span`
	 * {@link module:engine/view/attributeelement~AttributeElement},
	 * * each {@link module:engine/view/containerelement~ContainerElement container view element} in the marker's
	 * range can handle highlighting individually by providing `addHighlight` and `removeHighlight`
	 * custom properties:
	 *
	 *		viewElement.setCustomProperty( 'addHighlight', ( element, descriptor ) => {} );
	 *		viewElement.setCustomProperty( 'removeHighlight', ( element, descriptorId ) => {} );
	 *
	 * {@link module:engine/conversion/model-to-view-converters~HighlightDescriptor} will be used to create
	 * spans over text nodes and also will be provided to `addHighlight` and `removeHighlight` methods
	 * each time highlight should be set or removed from view elements.
	 *
	 * **Note:** When `addHighlight` and `removeHighlight` custom properties are present, converter assumes
	 * that element itself is taking care of presenting highlight on its child nodes, so it won't convert them.
	 *
	 * Highlight descriptor can be provided as plain object:
	 *
	 *		buildModelConverter.for( dispatcher ).fromMarker( 'search' ).toHighlight( { class: 'search-highlight' } );
 	 *
	 * Also, descriptor creator function can be provided:
	 *
	 *		buildModelConverter.for( dispatcher ).fromMarker( 'search:blue' ).toHighlight( data => {
	 *			const color = data.markerName.split( ':' )[ 1 ];
	 *
	 *			return { class: 'search-' + color };
	 *		} );
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
	 * `build-model-converter-non-marker-to-highlight` when trying to convert not from marker.
	 *
	 * @param {function|module:engine/conversion/model-to-view-converters~HighlightDescriptor} highlightDescriptor
	 */
	toHighlight( highlightDescriptor ) {
		const priority = this._from.priority === null ? 'normal' : this._from.priority;

		if ( this._from.type != 'marker' ) {
			/**
			 * Conversion to a highlight is supported only from model markers.
			 *
			 * @error build-model-converter-non-marker-to-highlight
			 */
			throw new __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'build-model-converter-non-marker-to-highlight: Conversion to a highlight is supported ' +
				'only from model markers.'
			);
		}

		for ( const dispatcher of this._dispatchers ) {
			// Separate converters for converting texts and elements inside marker's range.
			dispatcher.on( 'addMarker:' + this._from.name, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["c" /* highlightText */])( highlightDescriptor ), { priority } );
			dispatcher.on( 'addMarker:' + this._from.name, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["b" /* highlightElement */])( highlightDescriptor ), { priority } );

			dispatcher.on( 'removeMarker:' + this._from.name, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["c" /* highlightText */])( highlightDescriptor ), { priority } );
			dispatcher.on( 'removeMarker:' + this._from.name, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["b" /* highlightElement */])( highlightDescriptor ), { priority } );

			dispatcher.on( 'selectionMarker:' + this._from.name, Object(__WEBPACK_IMPORTED_MODULE_1__model_selection_to_view_converters__["f" /* convertSelectionMarker */])( highlightDescriptor ), { priority } );
		}
	}

	/**
	 * Registers what view attribute will be created by converter. Keep in mind, that only model attribute to
	 * view attribute conversion is supported.
	 *
	 * Method accepts various ways of providing how the view attribute will be created:
	 *
	 * * for no passed parameter, attribute key and value will be converted 1-to-1 to view attribute,
	 * * if you pass one `string`, it will be used as new attribute key while attribute value will be copied,
	 * * if you pass two `string`s, first one will be used as new attribute key and second one as new attribute value,
	 * * if you pass a function, it is expected to return an object with `key` and `value` properties representing attribute key and value.
	 * This function will be passed model attribute value and model attribute key as first two parameters and then
	 * all dispatcher's
	 * {module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:changeAttribute changeAttribute event}
	 * parameters.
	 *
	 *		buildModelConverter().for( dispatcher ).fromAttribute( 'class' ).toAttribute( '' );
	 *
	 *		buildModelConverter().for( dispatcher ).fromAttribute( 'linkTitle' ).toAttribute( 'title' );
	 *
	 *		buildModelConverter().for( dispatcher ).fromAttribute( 'highlighted' ).toAttribute( 'style', 'background:yellow' );
	 *
	 *		buildModelConverter().for( dispatcher )
	 *			.fromAttribute( 'theme' )
	 *			.toAttribute( ( value ) => ( { key: 'class', value: value + '-theme' } ) );
	 *
	 * This method creates the converter and adds it as a callback to a proper
	 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher conversion dispatcher} event.
	 *
	 * @param {String|Function} [keyOrCreator] Attribute key or a creator function.
	 * @param {*} [value] Attribute value.
	 */
	toAttribute( keyOrCreator, value ) {
		if ( this._from.type != 'attribute' ) {
			/**
			 * To-attribute conversion is supported only for model attributes.
			 *
			 * @error build-model-converter-element-to-attribute
			 */
			throw new __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'build-model-converter-non-attribute-to-attribute: ' +
				'To-attribute conversion is supported only from model attributes.' );
		}

		let attributeCreator;

		if ( !keyOrCreator ) {
			// If `keyOrCreator` is not set, we assume default behavior which is 1:1 attribute re-write.
			// This is also a default behavior for `setAttribute` converter when no attribute creator is passed.
			attributeCreator = undefined;
		} else if ( typeof keyOrCreator == 'string' ) {
			// `keyOrCreator` is an attribute key.

			if ( value ) {
				// If value is set, create "dumb" creator that always returns the same object.
				attributeCreator = function() {
					return { key: keyOrCreator, value };
				};
			} else {
				// If value is not set, take it from the passed parameter.
				attributeCreator = function( value ) {
					return { key: keyOrCreator, value };
				};
			}
		} else {
			// `keyOrCreator` is an attribute creator function.
			attributeCreator = keyOrCreator;
		}

		for ( const dispatcher of this._dispatchers ) {
			const options = { priority: this._from.priority || 'normal' };

			dispatcher.on( 'addAttribute:' + this._from.key, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["j" /* setAttribute */])( attributeCreator ), options );
			dispatcher.on( 'changeAttribute:' + this._from.key, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["j" /* setAttribute */])( attributeCreator ), options );
			dispatcher.on( 'removeAttribute:' + this._from.key, Object(__WEBPACK_IMPORTED_MODULE_0__model_to_view_converters__["h" /* removeAttribute */])( attributeCreator ), options );
		}
	}
}

/**
 * Entry point for model-to-view converters builder. This chainable API makes it easy to create basic, most common
 * model-to-view converters and attach them to provided dispatchers. The method returns an instance of
 * {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder}.
 */
function buildModelConverter() {
	return new ModelConverterBuilder();
}

/**
 * @typedef {Object} module:engine/conversion/buildmodelconverter~MarkerViewElementCreatorData
 *
 * @param {String} markerName Marker name.
 * @param {module:engine/model/range~Range} markerRange Marker range.
 * @param {Boolean} isOpening Defines if currently converted element is a beginning or end of the marker range.
 */


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/* harmony default export */ __webpack_exports__["a"] = (eq);


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__text__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__textproxy__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/treewalker
 */







/**
 * Position iterator class. It allows to iterate forward and backward over the document.
 */
class TreeWalker {
	/**
	 * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
	 *
	 * @constructor
	 * @param {Object} [options={}] Object with configuration.
	 * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.
	 * @param {module:engine/model/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.
	 * @param {module:engine/model/position~Position} [options.startPosition] Starting position.
	 * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes
	 * should be returned one by one as multiple {@link module:engine/model/textproxy~TextProxy} (`true`) objects or as one
	 * {@link module:engine/model/textproxy~TextProxy} (`false`).
	 * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the
	 * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.
	 * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`
	 * tags. If the option is true walker will not return a parent node of start position. If this option is `true`
	 * each {@link module:engine/model/element~Element} will be returned once, while if the option is `false` they might be returned
	 * twice: for `'elementStart'` and `'elementEnd'`.
	 */
	constructor( options = {} ) {
		if ( !options.boundaries && !options.startPosition ) {
			/**
			 * Neither boundaries nor starting position of a `TreeWalker` have been defined.
			 *
			 * @error model-tree-walker-no-start-position
			 */
			throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.' );
		}

		const direction = options.direction || 'forward';

		if ( direction != 'forward' && direction != 'backward' ) {
			throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.',
				{ direction }
			);
		}

		/**
		 * Walking direction. Defaults `'forward'`.
		 *
		 * @readonly
		 * @member {'backward'|'forward'} module:engine/model/treewalker~TreeWalker#direction
		 */
		this.direction = direction;

		/**
		 * Iterator boundaries.
		 *
		 * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
		 * on the start of boundary, then `{ done: true }` is returned.
		 *
		 * If boundaries are not defined they are set before first and after last child of the root node.
		 *
		 * @readonly
		 * @member {module:engine/model/range~Range} module:engine/model/treewalker~TreeWalker#boundaries
		 */
		this.boundaries = options.boundaries || null;

		/**
		 * Iterator position. This is always static position, even if the initial position was a
		 * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends
		 * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
		 * is `'backward'` position starts from the end.
		 *
		 * @readonly
		 * @member {module:engine/model/position~Position} module:engine/model/treewalker~TreeWalker#position
		 */
		if ( options.startPosition ) {
			this.position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromPosition( options.startPosition );
		} else {
			this.position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromPosition( this.boundaries[ this.direction == 'backward' ? 'end' : 'start' ] );
		}

		/**
		 * Flag indicating whether all consecutive characters with the same attributes should be
		 * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).
		 *
		 * @readonly
		 * @member {Boolean} module:engine/model/treewalker~TreeWalker#singleCharacters
		 */
		this.singleCharacters = !!options.singleCharacters;

		/**
		 * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
		 * iterated node will not be returned along with `elementEnd` tag.
		 *
		 * @readonly
		 * @member {Boolean} module:engine/model/treewalker~TreeWalker#shallow
		 */
		this.shallow = !!options.shallow;

		/**
		 * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not
		 * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will
		 * be returned once, while if the option is `false` they might be returned twice:
		 * for `'elementStart'` and `'elementEnd'`.
		 *
		 * @readonly
		 * @member {Boolean} module:engine/model/treewalker~TreeWalker#ignoreElementEnd
		 */
		this.ignoreElementEnd = !!options.ignoreElementEnd;

		/**
		 * Start boundary cached for optimization purposes.
		 *
		 * @private
		 * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryStartParent
		 */
		this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;

		/**
		 * End boundary cached for optimization purposes.
		 *
		 * @private
		 * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryEndParent
		 */
		this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;

		/**
		 * Parent of the most recently visited node. Cached for optimization purposes.
		 *
		 * @private
		 * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}
		 * module:engine/model/treewalker~TreeWalker#_visitedParent
		 */
		this._visitedParent = this.position.parent;
	}

	/**
	 * Iterator interface.
	 */
	[ Symbol.iterator ]() {
		return this;
	}

	/**
	 * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
	 *
	 * For example:
	 *
	 * 		walker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
	 * 		walker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]
	 * 		walker.skip( () => false ); // Do not move the position.
	 *
	 * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
	 * return `true` if the value should be skipped or `false` if not.
	 */
	skip( skip ) {
		let done, value, prevPosition, prevVisitedParent;

		do {
			prevPosition = this.position;
			prevVisitedParent = this._visitedParent;

			( { done, value } = this.next() );
		} while ( !done && skip( value ) );

		if ( !done ) {
			this.position = prevPosition;
			this._visitedParent = prevVisitedParent;
		}
	}

	/**
	 * Iterator interface method.
	 * Detects walking direction and makes step forward or backward.
	 *
	 * @returns {Object} Object implementing iterator interface, returning information about taken step.
	 */
	next() {
		if ( this.direction == 'forward' ) {
			return this._next();
		} else {
			return this._previous();
		}
	}

	/**
	 * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
	 *
	 * @private
	 * @returns {Object}
	 * @returns {Boolean} return.done True if iterator is done.
	 * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.
	 */
	_next() {
		const previousPosition = this.position;
		const position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromPosition( this.position );
		const parent = this._visitedParent;

		// We are at the end of the root.
		if ( parent.parent === null && position.offset === parent.maxOffset ) {
			return { done: true };
		}

		// We reached the walker boundary.
		if ( parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset ) {
			return { done: true };
		}

		const node = position.textNode ? position.textNode : position.nodeAfter;

		if ( node instanceof __WEBPACK_IMPORTED_MODULE_2__element__["a" /* default */] ) {
			if ( !this.shallow ) {
				// Manual operations on path internals for optimization purposes. Here and in the rest of the method.
				position.path.push( 0 );
				this._visitedParent = node;
			} else {
				position.offset++;
			}

			this.position = position;

			return formatReturnValue( 'elementStart', node, previousPosition, position, 1 );
		} else if ( node instanceof __WEBPACK_IMPORTED_MODULE_0__text__["a" /* default */] ) {
			let charactersCount;

			if ( this.singleCharacters ) {
				charactersCount = 1;
			} else {
				let offset = node.endOffset;

				if ( this._boundaryEndParent == parent && this.boundaries.end.offset < offset ) {
					offset = this.boundaries.end.offset;
				}

				charactersCount = offset - position.offset;
			}

			const offsetInTextNode = position.offset - node.startOffset;
			const item = new __WEBPACK_IMPORTED_MODULE_1__textproxy__["a" /* default */]( node, offsetInTextNode, charactersCount );

			position.offset += charactersCount;
			this.position = position;

			return formatReturnValue( 'text', item, previousPosition, position, charactersCount );
		} else {
			// `node` is not set, we reached the end of current `parent`.
			position.path.pop();
			position.offset++;
			this.position = position;
			this._visitedParent = parent.parent;

			if ( this.ignoreElementEnd ) {
				return this._next();
			} else {
				return formatReturnValue( 'elementEnd', parent, previousPosition, position );
			}
		}
	}

	/**
	 * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
	 *
	 * @private
	 * @returns {Object}
	 * @returns {Boolean} return.done True if iterator is done.
	 * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.
	 */
	_previous() {
		const previousPosition = this.position;
		const position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromPosition( this.position );
		const parent = this._visitedParent;

		// We are at the beginning of the root.
		if ( parent.parent === null && position.offset === 0 ) {
			return { done: true };
		}

		// We reached the walker boundary.
		if ( parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset ) {
			return { done: true };
		}

		// Get node just before current position
		const node = position.textNode ? position.textNode : position.nodeBefore;

		if ( node instanceof __WEBPACK_IMPORTED_MODULE_2__element__["a" /* default */] ) {
			position.offset--;

			if ( !this.shallow ) {
				position.path.push( node.maxOffset );
				this.position = position;
				this._visitedParent = node;

				if ( this.ignoreElementEnd ) {
					return this._previous();
				} else {
					return formatReturnValue( 'elementEnd', node, previousPosition, position );
				}
			} else {
				this.position = position;

				return formatReturnValue( 'elementStart', node, previousPosition, position, 1 );
			}
		} else if ( node instanceof __WEBPACK_IMPORTED_MODULE_0__text__["a" /* default */] ) {
			let charactersCount;

			if ( this.singleCharacters ) {
				charactersCount = 1;
			} else {
				let offset = node.startOffset;

				if ( this._boundaryStartParent == parent && this.boundaries.start.offset > offset ) {
					offset = this.boundaries.start.offset;
				}

				charactersCount = position.offset - offset;
			}

			const offsetInTextNode = position.offset - node.startOffset;
			const item = new __WEBPACK_IMPORTED_MODULE_1__textproxy__["a" /* default */]( node, offsetInTextNode - charactersCount, charactersCount );

			position.offset -= charactersCount;
			this.position = position;

			return formatReturnValue( 'text', item, previousPosition, position, charactersCount );
		} else {
			// `node` is not set, we reached the beginning of current `parent`.
			position.path.pop();
			this.position = position;
			this._visitedParent = parent.parent;

			return formatReturnValue( 'elementStart', parent, previousPosition, position, 1 );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TreeWalker;


function formatReturnValue( type, item, previousPosition, nextPosition, length ) {
	return {
		done: false,
		value: {
			type,
			item,
			previousPosition,
			nextPosition,
			length
		}
	};
}

/**
 * Type of the step made by {@link module:engine/model/treewalker~TreeWalker}.
 * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end of node,
 * `'character'` if walker traversed over a character, or `'text'` if walker traversed over multiple characters (available in
 * character merging mode, see {@link module:engine/model/treewalker~TreeWalker#constructor}).
 *
 * @typedef {'elementStart'|'elementEnd'|'character'|'text'} module:engine/model/treewalker~TreeWalkerValueType
 */

/**
 * Object returned by {@link module:engine/model/treewalker~TreeWalker} when traversing tree model.
 *
 * @typedef {Object} module:engine/model/treewalker~TreeWalkerValue
 * @property {module:engine/model/treewalker~TreeWalkerValueType} type
 * @property {module:engine/model/item~Item} item Item between old and new positions of {@link module:engine/model/treewalker~TreeWalker}.
 * @property {module:engine/model/position~Position} previousPosition Previous position of the iterator.
 * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the
 * position before the item. Note that it is more efficient to use this position then calculate the position before
 * the node using {@link module:engine/model/position~Position.createBefore}. It is also more efficient to get the
 * position after node by shifting `previousPosition` by `length`, using {@link module:engine/model/position~Position#getShiftedBy},
 * then calculate the position using {@link module:engine/model/position~Position.createAfter}.
 * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is
 * the position after item.
 * @property {module:engine/model/position~Position} nextPosition Next position of the iterator.
 * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is
 * the position after the item.
 * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position
 * before the item.
 * @property {Number} [length] Length of the item. For `'elementStart'` and `'character'` it is 1. For `'text'` it is
 * the length of the text. For `'elementEnd'` it is undefined.
 */

/**
 * Tree walking directions.
 *
 * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection
 */


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = compareArrays;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/comparearrays
 */

/**
 * Compares how given arrays relate to each other. One array can be: same as another array, prefix of another array
 * or completely different. If arrays are different, first index at which they differ is returned. Otherwise,
 * a flag specifying the relation is returned. Flags are negative numbers, so whenever a number >= 0 is returned
 * it means that arrays differ.
 *
 *		compareArrays( [ 0, 2 ], [ 0, 2 ] );		// 'same'
 *		compareArrays( [ 0, 2 ], [ 0, 2, 1 ] );		// 'prefix'
 *		compareArrays( [ 0, 2 ], [ 0 ] );			// 'extension'
 *		compareArrays( [ 0, 2 ], [ 1, 2 ] );		// 0
 *		compareArrays( [ 0, 2 ], [ 0, 1 ] );		// 1
 *
 * @param {Array} a Array that is compared.
 * @param {Array} b Array to compare with.
 * @returns {module:utils/comparearrays~ArrayRelation} How array `a` is related to `b`.
 */
function compareArrays( a, b ) {
	const minLen = Math.min( a.length, b.length );

	for ( let i = 0; i < minLen; i++ ) {
		if ( a[ i ] != b[ i ] ) {
			// The arrays are different.
			return i;
		}
	}

	// Both arrays were same at all points.
	if ( a.length == b.length ) {
		// If their length is also same, they are the same.
		return 'same';
	} else if ( a.length < b.length ) {
		// Compared array is shorter so it is a prefix of the other array.
		return 'prefix';
	} else {
		// Compared array is longer so it is an extension of the other array.
		return 'extension';
	}
}

/**
 * @typedef {'extension'|'same'|'prefix'} module:utils/comparearrays~ArrayRelation
 */


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isNative__ = __webpack_require__(323);


/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object[key];
  return Object(__WEBPACK_IMPORTED_MODULE_0__isNative__["a" /* default */])(value) ? value : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (getNative);


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArray__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isSymbol__ = __webpack_require__(45);



/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (Object(__WEBPACK_IMPORTED_MODULE_0__isArray__["a" /* default */])(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || Object(__WEBPACK_IMPORTED_MODULE_1__isSymbol__["a" /* default */])(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* harmony default export */ __webpack_exports__["a"] = (isKey);


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isSymbol__ = __webpack_require__(45);


/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || Object(__WEBPACK_IMPORTED_MODULE_0__isSymbol__["a" /* default */])(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/* harmony default export */ __webpack_exports__["a"] = (toKey);


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals window, document */

/**
 * @module utils/dom/global
 */

/**
 * A helper (module) giving an access to the global DOM objects such as `window` and
 * `document`. Accessing these objects using this helper allows easy and bulletproof
 * testing, i.e. stubbing native properties:
 *
 *		import global from 'ckeditor5/utils/dom/global.js';
 *
 *		// This stub will work for any code using global module.
 *		testUtils.sinon.stub( global, 'window', {
 *			innerWidth: 10000
 *		} );
 *
 *		console.log( global.window.innerWidth );
 */
/* harmony default export */ __webpack_exports__["a"] = ({ window, document });


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_dom_emittermixin__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/observer
 */




/**
 * Abstract base observer class. Observers are classes which observe changes on DOM elements, do the preliminary
 * processing and fire events on the {@link module:engine/view/document~Document} objects. Observers can also add features to the view,
 * for instance by updating its status or marking elements which need refresh on DOM events.
 *
 * @abstract
 */
class Observer {
	/**
	 * Creates an instance of the observer.
	 *
	 * @param {module:engine/view/document~Document} document
	 */
	constructor( document ) {
		/**
		 * Reference to the {@link module:engine/view/document~Document} object.
		 *
		 * @readonly
		 * @member {module:engine/view/document~Document}
		 */
		this.document = document;

		/**
		 * State of the observer. If it is disabled events will not be fired.
		 *
		 * @readonly
		 * @member {Boolean}
		 */
		this.isEnabled = false;
	}

	/**
	 * Enables the observer. This method is called when then observer is registered to the
	 * {@link module:engine/view/document~Document} and after {@link module:engine/view/document~Document#render rendering}
	 * (all observers are {@link #disable disabled} before rendering).
	 *
	 * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
	 * However, a child class may not need to be disabled, so it can implement an empty method.
	 *
	 * @see module:engine/view/observer/observer~Observer#disable
	 */
	enable() {
		this.isEnabled = true;
	}

	/**
	 * Disables the observer. This method is called before
	 * {@link module:engine/view/document~Document#render rendering} to prevent firing events during rendering.
	 *
	 * @see module:engine/view/observer/observer~Observer#enable
	 */
	disable() {
		this.isEnabled = false;
	}

	/**
	 * Disables and destroys the observer, among others removes event listeners created by the observer.
	 */
	destroy() {
		this.disable();
		this.stopListening();
	}

	/**
	 * Starts observing the given root element.
	 *
	 * @method #observe
	 * @param {HTMLElement} domElement
	 * @param {String} name The name of the root element.
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Observer;


Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Observer, __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_dom_emittermixin__["a" /* default */] );


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = first;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/first
 */

/**
 * Returns first item of the given `iterable`.
 *
 * @param {Iterable.<*>} iterable
 * @returns {*}
 */
function first( iterable ) {
	const iteratorItem = iterable.next();

	if ( iteratorItem.done ) {
		return null;
	}

	return iteratorItem.value;
}


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var encode = __webpack_require__(563);
var decode = __webpack_require__(564);

var C_BACKSLASH = 92;

var decodeHTML = __webpack_require__(283).decodeHTML;

var ENTITY = "&(?:#x[a-f0-9]{1,8}|#[0-9]{1,8}|[a-z][a-z0-9]{1,31});";

var TAGNAME = '[A-Za-z][A-Za-z0-9-]*';
var ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var UNQUOTEDVALUE = "[^\"'=<>`\\x00-\\x20]+";
var SINGLEQUOTEDVALUE = "'[^']*'";
var DOUBLEQUOTEDVALUE = '"[^"]*"';
var ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")";
var ATTRIBUTEVALUESPEC = "(?:" + "\\s*=" + "\\s*" + ATTRIBUTEVALUE + ")";
var ATTRIBUTE = "(?:" + "\\s+" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)";
var OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*" + "\\s*/?>";
var CLOSETAG = "</" + TAGNAME + "\\s*[>]";
var HTMLCOMMENT = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var PROCESSINGINSTRUCTION = "[<][?].*?[?][>]";
var DECLARATION = "<![A-Z]+" + "\\s+[^>]*>";
var CDATA = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" +
        PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")";
var reHtmlTag = new RegExp('^' + HTMLTAG, 'i');

var reBackslashOrAmp = /[\\&]/;

var ESCAPABLE = '[!"#$%&\'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]';

var reEntityOrEscapedChar = new RegExp('\\\\' + ESCAPABLE + '|' + ENTITY, 'gi');

var XMLSPECIAL = '[&<>"]';

var reXmlSpecial = new RegExp(XMLSPECIAL, 'g');

var reXmlSpecialOrEntity = new RegExp(ENTITY + '|' + XMLSPECIAL, 'gi');

var unescapeChar = function(s) {
    if (s.charCodeAt(0) === C_BACKSLASH) {
        return s.charAt(1);
    } else {
        return decodeHTML(s);
    }
};

// Replace entities and backslash escapes with literal characters.
var unescapeString = function(s) {
    if (reBackslashOrAmp.test(s)) {
        return s.replace(reEntityOrEscapedChar, unescapeChar);
    } else {
        return s;
    }
};

var normalizeURI = function(uri) {
    try {
        return encode(decode(uri));
    }
    catch(err) {
        return uri;
    }
};

var replaceUnsafeChar = function(s) {
    switch (s) {
    case '&':
        return '&amp;';
    case '<':
        return '&lt;';
    case '>':
        return '&gt;';
    case '"':
        return '&quot;';
    default:
        return s;
    }
};

var escapeXml = function(s, preserve_entities) {
    if (reXmlSpecial.test(s)) {
        if (preserve_entities) {
            return s.replace(reXmlSpecialOrEntity, replaceUnsafeChar);
        } else {
            return s.replace(reXmlSpecial, replaceUnsafeChar);
        }
    } else {
        return s;
    }
};

module.exports = { unescapeString: unescapeString,
                   normalizeURI: normalizeURI,
                   escapeXml: escapeXml,
                   reHtmlTag: reHtmlTag,
                   OPENTAG: OPENTAG,
                   CLOSETAG: CLOSETAG,
                   ENTITY: ENTITY,
                   ESCAPABLE: ESCAPABLE
                 };


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = uid;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/uid
 */

/**
 * Returns a unique id. This id is a number (starting from 1) which will never get repeated on successive calls
 * to this method.
 *
 * @returns {String} A number representing the id.
 */
function uid() {
	let uuid = 'e'; // Make sure that id does not start with number.

	for ( let i = 0; i < 8; i++ ) {
		uuid += Math.floor( ( 1 + Math.random() ) * 0x10000 ).toString( 16 ).substring( 1 );
	}

	return uuid;
}


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__eq__ = __webpack_require__(52);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && Object(__WEBPACK_IMPORTED_MODULE_0__eq__["a" /* default */])(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/* harmony default export */ __webpack_exports__["a"] = (assignValue);


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isObject__ = __webpack_require__(16);


/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = Object(__WEBPACK_IMPORTED_MODULE_0__isObject__["a" /* default */])(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/* harmony default export */ __webpack_exports__["a"] = (isFunction);


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_tomap__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/node
 */




/**
 * Model node. Most basic structure of model tree.
 *
 * This is an abstract class that is a base for other classes representing different nodes in model.
 *
 * **Note:** If a node is detached from the model tree, you can manipulate it using it's API.
 * However, it is **very important** that nodes already attached to model tree should be only changed through
 * {@link module:engine/model/document~Document#batch Batch API}.
 *
 * Changes done by `Node` methods, like {@link module:engine/model/element~Element#insertChildren insertChildren} or
 * {@link module:engine/model/node~Node#setAttribute setAttribute}
 * do not generate {@link module:engine/model/operation/operation~Operation operations}
 * which are essential for correct editor work if you modify nodes in {@link module:engine/model/document~Document document} root.
 *
 * The flow of working on `Node` (and classes that inherits from it) is as such:
 * 1. You can create a `Node` instance, modify it using it's API.
 * 2. Add `Node` to the model using `Batch` API.
 * 3. Change `Node` that was already added to the model using `Batch` API.
 *
 * Similarly, you cannot use `Batch` API on a node that has not been added to the model tree, with the exception
 * of {@link module:engine/model/batch~Batch#insert inserting} that node to the model tree.
 *
 * Be aware that using {@link module:engine/model/batch~Batch#remove remove from Batch API} does not allow to use `Node` API because
 * the information about `Node` is still kept in model document.
 *
 * In case of {@link module:engine/model/element~Element element node}, adding and removing children also counts as changing a node and
 * follows same rules.
 */
class Node {
	/**
	 * Creates a model node.
	 *
	 * This is an abstract class, so this constructor should not be used directly.
	 *
	 * @abstract
	 * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
	 */
	constructor( attrs ) {
		/**
		 * Parent of this node. It could be {@link module:engine/model/element~Element}
		 * or {@link module:engine/model/documentfragment~DocumentFragment}.
		 * Equals to `null` if the node has no parent.
		 *
		 * @readonly
		 * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}
		 */
		this.parent = null;

		/**
		 * Attributes set on this node.
		 *
		 * @private
		 * @member {Map} module:engine/model/node~Node#_attrs
		 */
		this._attrs = Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_tomap__["a" /* default */])( attrs );
	}

	/**
	 * Index of this node in it's parent or `null` if the node has no parent.
	 *
	 * Accessing this property throws an error if this node's parent element does not contain it.
	 * This means that model tree got broken.
	 *
	 * @readonly
	 * @type {Number|null}
	 */
	get index() {
		let pos;

		if ( !this.parent ) {
			return null;
		}

		if ( ( pos = this.parent.getChildIndex( this ) ) === null ) {
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-node-not-found-in-parent: The node\'s parent does not contain this node.' );
		}

		return pos;
	}

	/**
	 * Offset at which this node starts in it's parent. It is equal to the sum of {@link #offsetSize offsetSize}
	 * of all it's previous siblings. Equals to `null` if node has no parent.
	 *
	 * Accessing this property throws an error if this node's parent element does not contain it.
	 * This means that model tree got broken.
	 *
	 * @readonly
	 * @type {Number|Null}
	 */
	get startOffset() {
		let pos;

		if ( !this.parent ) {
			return null;
		}

		if ( ( pos = this.parent.getChildStartOffset( this ) ) === null ) {
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-node-not-found-in-parent: The node\'s parent does not contain this node.' );
		}

		return pos;
	}

	/**
	 * Offset size of this node. Represents how much "offset space" is occupied by the node in it's parent.
	 * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position
	 * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more
	 * than one entity, i.e. {@link module:engine/model/text~Text text node}.
	 *
	 * @readonly
	 * @type {Number}
	 */
	get offsetSize() {
		return 1;
	}

	/**
	 * Offset at which this node ends in it's parent. It is equal to the sum of this node's
	 * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.
	 * Equals to `null` if the node has no parent.
	 *
	 * @readonly
	 * @type {Number|null}
	 */
	get endOffset() {
		if ( !this.parent ) {
			return null;
		}

		return this.startOffset + this.offsetSize;
	}

	/**
	 * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.
	 *
	 * @readonly
	 * @type {module:engine/model/node~Node|null}
	 */
	get nextSibling() {
		const index = this.index;

		return ( index !== null && this.parent.getChild( index + 1 ) ) || null;
	}

	/**
	 * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.
	 *
	 * @readonly
	 * @type {module:engine/model/node~Node|null}
	 */
	get previousSibling() {
		const index = this.index;

		return ( index !== null && this.parent.getChild( index - 1 ) ) || null;
	}

	/**
	 * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part
	 * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.
	 *
	 * @readonly
	 * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}
	 */
	get root() {
		let root = this; // eslint-disable-line consistent-this

		while ( root.parent ) {
			root = root.parent;
		}

		return root;
	}

	/**
	 * {@link module:engine/model/document~Document Document} that owns this node or `null` if the node has no parent or is inside
	 * a {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment}.
	 *
	 * @readonly
	 * @type {module:engine/model/document~Document|null}
	 */
	get document() {
		// This is a top element of a sub-tree.
		if ( this.root == this ) {
			return null;
		}

		// Root may be `DocumentFragment` which does not have document property.
		return this.root.document || null;
	}

	/**
	 * Creates a copy of this node, that is a node with exactly same attributes, and returns it.
	 *
	 * @returns {module:engine/model/node~Node} Node with same attributes as this node.
	 */
	clone() {
		return new Node( this._attrs );
	}

	/**
	 * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,
	 * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to
	 * create {@link module:engine/model/position~Position Position} instance.
	 *
	 *		const abc = new Text( 'abc' );
	 *		const foo = new Text( 'foo' );
	 *		const h1 = new Element( 'h1', null, new Text( 'header' ) );
	 *		const p = new Element( 'p', null, [ abc, foo ] );
	 *		const div = new Element( 'div', null, [ h1, p ] );
	 *		foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
	 *		h1.getPath(); // Returns [ 0 ].
	 *		div.getPath(); // Returns [].
	 *
	 * @returns {Array.<Number>} The path.
	 */
	getPath() {
		const path = [];
		let node = this; // eslint-disable-line consistent-this

		while ( node.parent ) {
			path.unshift( node.startOffset );
			node = node.parent;
		}

		return path;
	}

	/**
	 * Returns ancestors array of this node.
	 *
	 * @param {Object} options Options object.
	 * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.
	 * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,
	 * otherwise root element will be the first item in the array.
	 * @returns {Array} Array with ancestors.
	 */
	getAncestors( options = { includeSelf: false, parentFirst: false } ) {
		const ancestors = [];
		let parent = options.includeSelf ? this : this.parent;

		while ( parent ) {
			ancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );
			parent = parent.parent;
		}

		return ancestors;
	}

	/**
	 * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
	 * which is a common ancestor of both nodes.
	 *
	 * @param {module:engine/model/node~Node} node The second node.
	 * @param {Object} options Options object.
	 * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered "ancestors" too.
	 * Which means that if e.g. node A is inside B, then their common ancestor will be B.
	 * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}
	 */
	getCommonAncestor( node, options = {} ) {
		const ancestorsA = this.getAncestors( options );
		const ancestorsB = node.getAncestors( options );

		let i = 0;

		while ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {
			i++;
		}

		return i === 0 ? null : ancestorsA[ i - 1 ];
	}

	/**
	 * Removes this node from it's parent.
	 */
	remove() {
		this.parent.removeChildren( this.index );
	}

	/**
	 * Checks if the node has an attribute with given key.
	 *
	 * @param {String} key Key of attribute to check.
	 * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.
	 */
	hasAttribute( key ) {
		return this._attrs.has( key );
	}

	/**
	 * Gets an attribute value for given key or `undefined` if that attribute is not set on node.
	 *
	 * @param {String} key Key of attribute to look for.
	 * @returns {*} Attribute value or `undefined`.
	 */
	getAttribute( key ) {
		return this._attrs.get( key );
	}

	/**
	 * Returns iterator that iterates over this node's attributes.
	 *
	 * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
	 * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
	 *
	 * @returns {Iterable.<*>}
	 */
	getAttributes() {
		return this._attrs.entries();
	}

	/**
	 * Returns iterator that iterates over this node's attribute keys.
	 *
	 * @returns {Iterator.<String>}
	 */
	getAttributeKeys() {
		return this._attrs.keys();
	}

	/**
	 * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.
	 *
	 * @param {String} key Key of attribute to set.
	 * @param {*} value Attribute value.
	 */
	setAttribute( key, value ) {
		this._attrs.set( key, value );
	}

	/**
	 * Removes all attributes from the node and sets given attributes.
	 *
	 * @param {Object} [attrs] Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.
	 */
	setAttributesTo( attrs ) {
		this._attrs = Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_tomap__["a" /* default */])( attrs );
	}

	/**
	 * Removes an attribute with given key from the node.
	 *
	 * @param {String} key Key of attribute to remove.
	 * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.
	 */
	removeAttribute( key ) {
		return this._attrs.delete( key );
	}

	/**
	 * Removes all attributes from the node.
	 */
	clearAttributes() {
		this._attrs.clear();
	}

	/**
	 * Converts `Node` to plain object and returns it.
	 *
	 * @returns {Object} `Node` converted to plain object.
	 */
	toJSON() {
		const json = {};

		if ( this._attrs.size ) {
			json.attributes = [ ...this._attrs ];
		}

		return json;
	}

	/**
	 * Checks whether given model tree object is of given type.
	 *
	 * This method is useful when processing model tree objects that are of unknown type. For example, a function
	 * may return {@link module:engine/model/documentfragment~DocumentFragment} or {@link module:engine/model/node~Node}
	 * that can be either text node or element. This method can be used to check what kind of object is returned.
	 *
	 *		obj.is( 'node' ); // true for any node, false for document fragment
	 *		obj.is( 'documentFragment' ); // true for document fragment, false for any node
	 *		obj.is( 'element' ); // true for any element, false for text node or document fragment
	 *		obj.is( 'element', 'paragraph' ); // true only for element which name is 'paragraph'
	 *		obj.is( 'paragraph' ); // shortcut for obj.is( 'element', 'paragraph' )
	 *		obj.is( 'text' ); // true for text node, false for element and document fragment
	 *		obj.is( 'textProxy' ); // true for text proxy object
	 *
	 * @method #is
	 * @param {'element'|'rootElement'|'text'|'textProxy'|'documentFragment'} type
	 * @returns {Boolean}
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Node;


/**
 * The node's parent does not contain this node.
 *
 * This error may be thrown from corrupted trees.
 *
 * @error model-node-not-found-in-parent
 */


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/textproxy
 */



/**
 * `TextProxy` represents a part of {@link module:engine/model/text~Text text node}.
 *
 * Since {@link module:engine/model/position~Position positions} can be placed between characters of a text node,
 * {@link module:engine/model/range~Range ranges} may contain only parts of text nodes. When {@link module:engine/model/range~Range#getItems
 * getting items}
 * contained in such range, we need to represent a part of that text node, since returning the whole text node would be incorrect.
 * `TextProxy` solves this issue.
 *
 * `TextProxy` has an API similar to {@link module:engine/model/text~Text Text} and allows to do most of the common tasks performed
 * on model nodes.
 *
 * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.
 * See {@link module:engine/model/textproxy~TextProxy#isPartial}.
 *
 * **Note:** `TextProxy` is not an instance of {@link module:engine/model/node~Node node}. Keep this in mind when using it as a
 * parameter of methods.
 *
 * **Note:** `TextProxy` is a readonly interface. If you want to perform changes on model data represented by a `TextProxy`
 * use {@link module:engine/model/writer~writer model writer API}.
 *
 * **Note:** `TextProxy` instances are created on the fly, basing on the current state of model. Because of this, it is
 * highly unrecommended to store references to `TextProxy` instances. `TextProxy` instances are not refreshed when
 * model changes, so they might get invalidated. Instead, consider creating {@link module:engine/model/liveposition~LivePosition live
 * position}.
 *
 * `TextProxy` instances are created by {@link module:engine/model/treewalker~TreeWalker model tree walker}. You should not need to create
 * an instance of this class by your own.
 */
class TextProxy {
	/**
	 * Creates a text proxy.
	 *
	 * @protected
	 * @param {module:engine/model/text~Text} textNode Text node which part is represented by this text proxy.
	 * @param {Number} offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy
	 * starts.
	 * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
	 * @constructor
	 */
	constructor( textNode, offsetInText, length ) {
		/**
		 * Text node which part is represented by this text proxy.
		 *
		 * @readonly
		 * @member {module:engine/model/text~Text}
		 */
		this.textNode = textNode;

		if ( offsetInText < 0 || offsetInText > textNode.offsetSize ) {
			/**
			 * Given `offsetInText` value is incorrect.
			 *
			 * @error model-textproxy-wrong-offsetintext
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.' );
		}

		if ( length < 0 || offsetInText + length > textNode.offsetSize ) {
			/**
			 * Given `length` value is incorrect.
			 *
			 * @error model-textproxy-wrong-length
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-textproxy-wrong-length: Given length value is incorrect.' );
		}

		/**
		 * Text data represented by this text proxy.
		 *
		 * @readonly
		 * @member {String}
		 */
		this.data = textNode.data.substring( offsetInText, offsetInText + length );

		/**
		 * Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy starts.
		 *
		 * @readonly
		 * @member {Number}
		 */
		this.offsetInText = offsetInText;
	}

	/**
	 * Offset at which this text proxy starts in it's parent.
	 *
	 * @see module:engine/model/node~Node#startOffset
	 * @readonly
	 * @type {Number}
	 */
	get startOffset() {
		return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
	}

	/**
	 * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.
	 *
	 * @see module:engine/model/node~Node#offsetSize
	 * @readonly
	 * @type {Number}
	 */
	get offsetSize() {
		return this.data.length;
	}

	/**
	 * Offset at which this text proxy ends in it's parent.
	 *
	 * @see module:engine/model/node~Node#endOffset
	 * @readonly
	 * @type {Number}
	 */
	get endOffset() {
		return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
	}

	/**
	 * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}
	 * (`true`) or the whole text node (`false`).
	 *
	 * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}
	 * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
	 * text node size.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isPartial() {
		return this.offsetSize !== this.textNode.offsetSize;
	}

	/**
	 * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
	 *
	 * @readonly
	 * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}
	 */
	get parent() {
		return this.textNode.parent;
	}

	/**
	 * Root of this text proxy, which is same as root of text node represented by this text proxy.
	 *
	 * @readonly
	 * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}
	 */
	get root() {
		return this.textNode.root;
	}

	/**
	 * {@link module:engine/model/document~Document Document} that owns text node represented by this text proxy or `null` if the text node
	 * has no parent or is inside a {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment}.
	 *
	 * @readonly
	 * @type {module:engine/model/document~Document|null}
	 */
	get document() {
		return this.textNode.document;
	}

	/**
	 * Checks whether given model tree object is of given type.
	 *
	 * Read more in {@link module:engine/model/node~Node#is}.
	 *
	 * @param {String} type
	 * @returns {Boolean}
	 */
	is( type ) {
		return type == 'textProxy';
	}

	/**
	 * Gets path to this text proxy.
	 *
	 * @see module:engine/model/node~Node#getPath
	 * @returns {Array.<Number>}
	 */
	getPath() {
		const path = this.textNode.getPath();

		if ( path.length > 0 ) {
			path[ path.length - 1 ] += this.offsetInText;
		}

		return path;
	}

	/**
	 * Returns ancestors array of this text proxy.
	 *
	 * @param {Object} options Options object.
	 * @param {Boolean} [options.includeSelf=false] When set to `true` this text proxy will be also included in parent's array.
	 * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to root element,
	 * otherwise root element will be the first item in the array.
	 * @returns {Array} Array with ancestors.
	 */
	getAncestors( options = { includeSelf: false, parentFirst: false } ) {
		const ancestors = [];
		let parent = options.includeSelf ? this : this.parent;

		while ( parent ) {
			ancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );
			parent = parent.parent;
		}

		return ancestors;
	}

	/**
	 * Checks if this text proxy has an attribute for given key.
	 *
	 * @param {String} key Key of attribute to check.
	 * @returns {Boolean} `true` if attribute with given key is set on text proxy, `false` otherwise.
	 */
	hasAttribute( key ) {
		return this.textNode.hasAttribute( key );
	}

	/**
	 * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.
	 *
	 * @param {String} key Key of attribute to look for.
	 * @returns {*} Attribute value or `undefined`.
	 */
	getAttribute( key ) {
		return this.textNode.getAttribute( key );
	}

	/**
	 * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two
	 * items. First one is attribute key and second is attribute value.
	 *
	 * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
	 *
	 * @returns {Iterable.<*>}
	 */
	getAttributes() {
		return this.textNode.getAttributes();
	}

	/**
	 * Returns iterator that iterates over this node's attribute keys.
	 *
	 * @returns {Iterator.<String>}
	 */
	getAttributeKeys() {
		return this.textNode.getAttributeKeys();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TextProxy;



/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__element__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__text__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__textproxy__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/treewalker
 */







/**
 * Position iterator class. It allows to iterate forward and backward over the document.
 */
class TreeWalker {
	/**
	 * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
	 *
	 * @constructor
	 * @param {Object} options Object with configuration.
	 * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.
	 * @param {module:engine/view/position~Position} [options.startPosition] Starting position.
	 * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.
	 * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all characters from
	 * {@link module:engine/view/text~Text} should be returned as one {@link module:engine/view/text~Text} (`false`) ore one by one as
	 * {@link module:engine/view/textproxy~TextProxy} (`true`).
	 * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the
	 * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.
	 * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`
	 * tags. If the option is true walker will not return a parent node of start position. If this option is `true`
	 * each {@link module:engine/view/element~Element} will be returned once, while if the option is `false` they might be returned
	 * twice: for `'elementStart'` and `'elementEnd'`.
	 */
	constructor( options = {} ) {
		if ( !options.boundaries && !options.startPosition ) {
			/**
			 * Neither boundaries nor starting position have been defined.
			 *
			 * @error view-tree-walker-no-start-position
			 */
			throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.' );
		}

		if ( options.direction && options.direction != 'forward' && options.direction != 'backward' ) {
			throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'view-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.',
				{ direction: options.direction }
			);
		}

		/**
		 * Iterator boundaries.
		 *
		 * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
		 * on the start of boundary, then `{ done: true }` is returned.
		 *
		 * If boundaries are not defined they are set before first and after last child of the root node.
		 *
		 * @readonly
		 * @member {module:engine/view/range~Range} module:engine/view/treewalker~TreeWalker#boundaries
		 */
		this.boundaries = options.boundaries || null;

		/**
		 * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
		 * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
		 *
		 * @readonly
		 * @member {module:engine/view/position~Position} module:engine/view/treewalker~TreeWalker#position
		 */
		if ( options.startPosition ) {
			this.position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromPosition( options.startPosition );
		} else {
			this.position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromPosition( options.boundaries[ options.direction == 'backward' ? 'end' : 'start' ] );
		}

		/**
		 * Walking direction. Defaults `'forward'`.
		 *
		 * @readonly
		 * @member {'backward'|'forward'} module:engine/view/treewalker~TreeWalker#direction
		 */
		this.direction = options.direction || 'forward';

		/**
		 * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one
		 * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.
		 *
		 * @readonly
		 * @member {Boolean} module:engine/view/treewalker~TreeWalker#singleCharacters
		 */
		this.singleCharacters = !!options.singleCharacters;

		/**
		 * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
		 * iterated node will not be returned along with `elementEnd` tag.
		 *
		 * @readonly
		 * @member {Boolean} module:engine/view/treewalker~TreeWalker#shallow
		 */
		this.shallow = !!options.shallow;

		/**
		 * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not
		 * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.
		 * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.
		 *
		 * @readonly
		 * @member {Boolean} module:engine/view/treewalker~TreeWalker#ignoreElementEnd
		 */
		this.ignoreElementEnd = !!options.ignoreElementEnd;

		/**
		 * Start boundary parent.
		 *
		 * @private
		 * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryStartParent
		 */
		this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;

		/**
		 * End boundary parent.
		 *
		 * @private
		 * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryEndParent
		 */
		this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
	}

	/**
	 * Iterator interface.
	 */
	[ Symbol.iterator ]() {
		return this;
	}

	/**
	 * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
	 *
	 * For example:
	 *
	 * 		walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
	 * 		walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
	 * 		walker.skip( value => false ); // Do not move the position.
	 *
	 * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
	 * return `true` if the value should be skipped or `false` if not.
	 */
	skip( skip ) {
		let done, value, prevPosition;

		do {
			prevPosition = this.position;

			( { done, value } = this.next() );
		} while ( !done && skip( value ) );

		if ( !done ) {
			this.position = prevPosition;
		}
	}

	/**
	 * Iterator interface method.
	 * Detects walking direction and makes step forward or backward.
	 *
	 * @returns {Object} Object implementing iterator interface, returning information about taken step.
	 */
	next() {
		if ( this.direction == 'forward' ) {
			return this._next();
		} else {
			return this._previous();
		}
	}

	/**
	 * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
	 *
	 * @private
	 * @returns {Object}
	 * @returns {Boolean} return.done `true` if iterator is done, `false` otherwise.
	 * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.
	 */
	_next() {
		let position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromPosition( this.position );
		const previousPosition = this.position;
		const parent = position.parent;

		// We are at the end of the root.
		if ( parent.parent === null && position.offset === parent.childCount ) {
			return { done: true };
		}

		// We reached the walker boundary.
		if ( parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset ) {
			return { done: true };
		}

		// Get node just after current position.
		let node;

		// Text is a specific parent because it contains string instead of child nodes.
		if ( parent instanceof __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */] ) {
			if ( position.isAtEnd ) {
				// Prevent returning "elementEnd" for Text node. Skip that value and return the next walker step.
				this.position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createAfter( parent );

				return this._next();
			}

			node = parent.data[ position.offset ];
		} else {
			node = parent.getChild( position.offset );
		}

		if ( node instanceof __WEBPACK_IMPORTED_MODULE_0__element__["a" /* default */] ) {
			if ( !this.shallow ) {
				position = new __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */]( node, 0 );
			} else {
				position.offset++;
			}

			this.position = position;

			return this._formatReturnValue( 'elementStart', node, previousPosition, position, 1 );
		} else if ( node instanceof __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */] ) {
			if ( this.singleCharacters ) {
				position = new __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */]( node, 0 );
				this.position = position;

				return this._next();
			} else {
				let charactersCount = node.data.length;
				let item = node;

				// If text stick out of walker range, we need to cut it and wrap by TextProxy.
				if ( node == this._boundaryEndParent ) {
					charactersCount = this.boundaries.end.offset;
					item = new __WEBPACK_IMPORTED_MODULE_2__textproxy__["a" /* default */]( node, 0, charactersCount );
					position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createAfter( item );
				} else {
					// If not just keep moving forward.
					position.offset++;
				}

				this.position = position;

				return this._formatReturnValue( 'text', item, previousPosition, position, charactersCount );
			}
		} else if ( typeof node == 'string' ) {
			let textLength;

			if ( this.singleCharacters ) {
				textLength = 1;
			} else {
				// Check if text stick out of walker range.
				const endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;

				textLength = endOffset - position.offset;
			}

			const textProxy = new __WEBPACK_IMPORTED_MODULE_2__textproxy__["a" /* default */]( parent, position.offset, textLength );

			position.offset += textLength;
			this.position = position;

			return this._formatReturnValue( 'text', textProxy, previousPosition, position, textLength );
		} else {
			// `node` is not set, we reached the end of current `parent`.
			position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createAfter( parent );
			this.position = position;

			if ( this.ignoreElementEnd ) {
				return this._next();
			} else {
				return this._formatReturnValue( 'elementEnd', parent, previousPosition, position );
			}
		}
	}

	/**
	 * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
	 *
	 * @private
	 * @returns {Object}
	 * @returns {Boolean} return.done True if iterator is done.
	 * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.
	 */
	_previous() {
		let position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromPosition( this.position );
		const previousPosition = this.position;
		const parent = position.parent;

		// We are at the beginning of the root.
		if ( parent.parent === null && position.offset === 0 ) {
			return { done: true };
		}

		// We reached the walker boundary.
		if ( parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset ) {
			return { done: true };
		}

		// Get node just before current position.
		let node;

		// Text {@link module:engine/view/text~Text} element is a specific parent because contains string instead of child nodes.
		if ( parent instanceof __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */] ) {
			if ( position.isAtStart ) {
				// Prevent returning "elementStart" for Text node. Skip that value and return the next walker step.
				this.position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createBefore( parent );

				return this._previous();
			}

			node = parent.data[ position.offset - 1 ];
		} else {
			node = parent.getChild( position.offset - 1 );
		}

		if ( node instanceof __WEBPACK_IMPORTED_MODULE_0__element__["a" /* default */] ) {
			if ( !this.shallow ) {
				position = new __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */]( node, node.childCount );
				this.position = position;

				if ( this.ignoreElementEnd ) {
					return this._previous();
				} else {
					return this._formatReturnValue( 'elementEnd', node, previousPosition, position );
				}
			} else {
				position.offset--;
				this.position = position;

				return this._formatReturnValue( 'elementStart', node, previousPosition, position, 1 );
			}
		} else if ( node instanceof __WEBPACK_IMPORTED_MODULE_1__text__["a" /* default */] ) {
			if ( this.singleCharacters ) {
				position = new __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */]( node, node.data.length );
				this.position = position;

				return this._previous();
			} else {
				let charactersCount = node.data.length;
				let item = node;

				// If text stick out of walker range, we need to cut it and wrap by TextProxy.
				if ( node == this._boundaryStartParent ) {
					const offset = this.boundaries.start.offset;

					item = new __WEBPACK_IMPORTED_MODULE_2__textproxy__["a" /* default */]( node, offset, node.data.length - offset );
					charactersCount = item.data.length;
					position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createBefore( item );
				} else {
					// If not just keep moving backward.
					position.offset--;
				}

				this.position = position;

				return this._formatReturnValue( 'text', item, previousPosition, position, charactersCount );
			}
		} else if ( typeof node == 'string' ) {
			let textLength;

			if ( !this.singleCharacters ) {
				// Check if text stick out of walker range.
				const startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;

				textLength = position.offset - startOffset;
			} else {
				textLength = 1;
			}

			position.offset -= textLength;

			const textProxy = new __WEBPACK_IMPORTED_MODULE_2__textproxy__["a" /* default */]( parent, position.offset, textLength );

			this.position = position;

			return this._formatReturnValue( 'text', textProxy, previousPosition, position, textLength );
		} else {
			// `node` is not set, we reached the beginning of current `parent`.
			position = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createBefore( parent );
			this.position = position;

			return this._formatReturnValue( 'elementStart', parent, previousPosition, position, 1 );
		}
	}

	/**
	 * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.
	 *
	 * @private
	 * @param {module:engine/view/treewalker~TreeWalkerValueType} type Type of step.
	 * @param {module:engine/view/item~Item} item Item between old and new position.
	 * @param {module:engine/view/position~Position} previousPosition Previous position of iterator.
	 * @param {module:engine/view/position~Position} nextPosition Next position of iterator.
	 * @param {Number} [length] Length of the item.
	 * @returns {module:engine/view/treewalker~TreeWalkerValue}
	 */
	_formatReturnValue( type, item, previousPosition, nextPosition, length ) {
		// Text is a specific parent, because contains string instead of children.
		// Walker doesn't enter to the Text except situations when walker is iterating over every single character,
		// or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text
		// we move it just before or just after Text.
		if ( item instanceof __WEBPACK_IMPORTED_MODULE_2__textproxy__["a" /* default */] ) {
			// Position is at the end of Text.
			if ( item.offsetInText + item.data.length == item.textNode.data.length ) {
				if ( this.direction == 'forward' && !( this.boundaries && this.boundaries.end.isEqual( this.position ) ) ) {
					nextPosition = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createAfter( item.textNode );
					// When we change nextPosition of returned value we need also update walker current position.
					this.position = nextPosition;
				} else {
					previousPosition = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createAfter( item.textNode );
				}
			}

			// Position is at the begining ot the text.
			if ( item.offsetInText === 0 ) {
				if ( this.direction == 'backward' && !( this.boundaries && this.boundaries.start.isEqual( this.position ) ) ) {
					nextPosition = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createBefore( item.textNode );
					// When we change nextPosition of returned value we need also update walker current position.
					this.position = nextPosition;
				} else {
					previousPosition = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createBefore( item.textNode );
				}
			}
		}

		return {
			done: false,
			value: {
				type,
				item,
				previousPosition,
				nextPosition,
				length
			}
		};
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TreeWalker;


/**
 * Type of the step made by {@link module:engine/view/treewalker~TreeWalker}.
 * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end
 * of node, or `'text'` if walker traversed over single and multiple characters.
 * For {@link module:engine/view/text~Text} `elementStart` and `elementEnd` is not returned.
 *
 * @typedef {String} module:engine/view/treewalker~TreeWalkerValueType
 */

/**
 * Object returned by {@link module:engine/view/treewalker~TreeWalker} when traversing tree view.
 *
 * @typedef {Object} module:engine/view/treewalker~TreeWalkerValue
 * @property {module:engine/view/treewalker~TreeWalkerValueType} type
 * @property {module:engine/view/item~Item} item Item between old and new positions of {@link module:engine/view/treewalker~TreeWalker}.
 * @property {module:engine/view/position~Position} previousPosition Previous position of the iterator.
 * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the
 * position before the item. Note that it is more efficient to use this position then calculate the position before
 * the node using {@link module:engine/view/position~Position.createBefore}.
 * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is
 * the position after item.
 * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the
 * inside of the Text to its parent just before or just after Text.
 * @property {module:engine/view/position~Position} nextPosition Next position of the iterator.
 * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is
 * the position after the item.
 * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position
 * before the item.
 * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the
 * inside of the Text to its parent just before or just after Text.
 * @property {Number} [length] Length of the item. For `'elementStart'` it is 1. For `'text'` it is
 * the length of the text. For `'elementEnd'` it is undefined.
 */

/**
 * Tree walking directions.
 *
 * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection
 */


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseClone__ = __webpack_require__(172);


/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseClone__["a" /* default */])(value, false, true);
}

/* harmony default export */ __webpack_exports__["a"] = (clone);


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseHas__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseKeys__ = __webpack_require__(335);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__indexKeys__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArrayLike__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isIndex__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__isPrototype__ = __webpack_require__(80);







/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  var isProto = Object(__WEBPACK_IMPORTED_MODULE_5__isPrototype__["a" /* default */])(object);
  if (!(isProto || Object(__WEBPACK_IMPORTED_MODULE_3__isArrayLike__["a" /* default */])(object))) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__baseKeys__["a" /* default */])(object);
  }
  var indexes = Object(__WEBPACK_IMPORTED_MODULE_2__indexKeys__["a" /* default */])(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  for (var key in object) {
    if (Object(__WEBPACK_IMPORTED_MODULE_0__baseHas__["a" /* default */])(object, key) &&
        !(skipIndexes && (key == 'length' || Object(__WEBPACK_IMPORTED_MODULE_4__isIndex__["a" /* default */])(key, length))) &&
        !(isProto && key == 'constructor')) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (keys);


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__text__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_isiterable__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/documentfragment
 */






/**
 * DocumentFragment class.
 */
class DocumentFragment {
	/**
	 * Creates new DocumentFragment instance.
	 *
	 * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children] List of nodes to be inserted into
	 * created document fragment.
	 */
	constructor( children ) {
		/**
		 * Array of child nodes.
		 *
		 * @protected
		 * @member {Array.<module:engine/view/element~Element>} module:engine/view/documentfragment~DocumentFragment#_children
		 */
		this._children = [];

		if ( children ) {
			this.insertChildren( 0, children );
		}
	}

	/**
	 * Iterates over nodes added to this DocumentFragment.
	 */
	[ Symbol.iterator ]() {
		return this._children[ Symbol.iterator ]();
	}

	/**
	 * Number of child nodes in this document fragment.
	 *
	 * @readonly
	 * @type {Number}
	 */
	get childCount() {
		return this._children.length;
	}

	/**
	 * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isEmpty() {
		return this.childCount === 0;
	}

	/**
	 * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
	 *
	 * @readonly
	 * @type {module:engine/model/documentfragment~DocumentFragment}
	 */
	get root() {
		return this;
	}

	/**
	 * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
	 *
	 * @readonly
	 * @type {null}
	 */
	get parent() {
		return null;
	}

	/**
	 * Checks whether given view tree object is of given type.
	 *
	 * Read more in {@link module:engine/view/node~Node#is}.
	 *
	 * @param {String} type
	 * @returns {Boolean}
	 */
	is( type ) {
		return type == 'documentFragment';
	}

	/**
	 * {@link module:engine/view/documentfragment~DocumentFragment#insertChildren Insert} a child node or a list of child nodes at the end
	 * and sets the parent of these nodes to this fragment.
	 *
	 * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} nodes Node or the list of nodes to be inserted.
	 * @returns {Number} Number of appended nodes.
	 */
	appendChildren( nodes ) {
		return this.insertChildren( this.childCount, nodes );
	}

	/**
	 * Gets child at the given index.
	 *
	 * @param {Number} index Index of child.
	 * @returns {module:engine/view/node~Node} Child node.
	 */
	getChild( index ) {
		return this._children[ index ];
	}

	/**
	 * Gets index of the given child node. Returns `-1` if child node is not found.
	 *
	 * @param {module:engine/view/node~Node} node Child node.
	 * @returns {Number} Index of the child node.
	 */
	getChildIndex( node ) {
		return this._children.indexOf( node );
	}

	/**
	 * Gets child nodes iterator.
	 *
	 * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.
	 */
	getChildren() {
		return this._children[ Symbol.iterator ]();
	}

	/**
	 * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
	 * this fragment.
	 *
	 * @param {Number} index Position where nodes should be inserted.
	 * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} nodes Node or list of nodes to be inserted.
	 * @returns {Number} Number of inserted nodes.
	 */
	insertChildren( index, nodes ) {
		this._fireChange( 'children', this );
		let count = 0;

		nodes = normalize( nodes );

		for ( const node of nodes ) {
			// If node that is being added to this element is already inside another element, first remove it from the old parent.
			if ( node.parent !== null ) {
				node.remove();
			}

			node.parent = this;

			this._children.splice( index, 0, node );
			index++;
			count++;
		}

		return count;
	}

	/**
	 * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
	 *
	 * @param {Number} index Number of the first node to remove.
	 * @param {Number} [howMany=1] Number of nodes to remove.
	 * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.
	 */
	removeChildren( index, howMany = 1 ) {
		this._fireChange( 'children', this );

		for ( let i = index; i < index + howMany; i++ ) {
			this._children[ i ].parent = null;
		}

		return this._children.splice( index, howMany );
	}

	/**
	 * Fires `change` event with given type of the change.
	 *
	 * @private
	 * @param {module:engine/view/document~ChangeType} type Type of the change.
	 * @param {module:engine/view/node~Node} node Changed node.
	 * @fires module:engine/view/node~Node#change
	 */
	_fireChange( type, node ) {
		this.fire( 'change:' + type, node );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DocumentFragment;


Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( DocumentFragment, __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

// Converts strings to Text and non-iterables to arrays.
//
// @param {String|module:engine/view/node~Node|Iterable.<String|module:engine/view/node~Node>}
// @return {Iterable.<module:engine/view/node~Node>}
function normalize( nodes ) {
	// Separate condition because string is iterable.
	if ( typeof nodes == 'string' ) {
		return [ new __WEBPACK_IMPORTED_MODULE_0__text__["a" /* default */]( nodes ) ];
	}

	if ( !Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_isiterable__["a" /* default */])( nodes ) ) {
		nodes = [ nodes ];
	}

	// Array.from to enable .map() on non-arrays.
	return Array.from( nodes )
		.map( node => {
			return typeof node == 'string' ? new __WEBPACK_IMPORTED_MODULE_0__text__["a" /* default */]( node ) : node;
		} );
}


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__operation__ = __webpack_require__(39);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/nooperation
 */



/**
 * Operation which is doing nothing ("empty operation", "do-nothing operation", "noop"). This is an operation,
 * which when executed does not change the tree model. It still has some parameters defined for transformation purposes.
 *
 * In most cases this operation is a result of transforming operations. When transformation returns
 * {@link module:engine/model/operation/nooperation~NoOperation} it means that changes done by the transformed operation
 * have already been applied.
 *
 * @extends module:engine/model/operation/operation~Operation
 */
class NoOperation extends __WEBPACK_IMPORTED_MODULE_0__operation__["a" /* default */] {
	get type() {
		return 'noop';
	}

	/**
	 * Creates and returns an operation that has the same parameters as this operation.
	 *
	 * @returns {module:engine/model/operation/nooperation~NoOperation} Clone of this operation.
	 */
	clone() {
		return new NoOperation( this.baseVersion );
	}

	/**
	 * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
	 *
	 * @returns {module:engine/model/operation/nooperation~NoOperation}
	 */
	getReversed() {
		return new NoOperation( this.baseVersion + 1 );
	}

	/**
	 * @inheritDoc
	 */
	_execute() {
		return {};
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.operation.NoOperation';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = NoOperation;



/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SetCache__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayIncludes__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__arrayMap__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__baseUnary__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__cacheHas__ = __webpack_require__(140);







/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = __WEBPACK_IMPORTED_MODULE_1__arrayIncludes__["a" /* default */],
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = Object(__WEBPACK_IMPORTED_MODULE_3__arrayMap__["a" /* default */])(values, Object(__WEBPACK_IMPORTED_MODULE_4__baseUnary__["a" /* default */])(iteratee));
  }
  if (comparator) {
    includes = __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith__["a" /* default */];
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = __WEBPACK_IMPORTED_MODULE_5__cacheHas__["a" /* default */];
    isCommon = false;
    values = new __WEBPACK_IMPORTED_MODULE_0__SetCache__["a" /* default */](values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseDifference);


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return INLINE_FILLER; });
/* harmony export (immutable) */ __webpack_exports__["i"] = startsWithFiller;
/* harmony export (immutable) */ __webpack_exports__["h"] = isInlineFiller;
/* harmony export (immutable) */ __webpack_exports__["e"] = getDataWithoutFiller;
/* harmony export (immutable) */ __webpack_exports__["g"] = isBlockFiller;
/* harmony export (immutable) */ __webpack_exports__["f"] = injectQuirksHandling;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_keyboard__ = __webpack_require__(28);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals window, Text */



/**
 * Set of utils related to block and inline fillers handling.
 *
 * Browsers do not allow to put caret in elements which does not have height. Because of it, we need to fill all
 * empty elements which should be selectable with elements or characters called "fillers". Unfortunately there is no one
 * universal filler, this is why two types are uses:
 *
 * * Block filler is an element which fill block elements, like `<p>`. CKEditor uses `<br>` as a block filler during the editing,
 * as browsers do natively. So instead of an empty `<p>` there will be `<p><br></p>`. The advantage of block filler is that
 * it is transparent for the selection, so when the caret is before the `<br>` and user presses right arrow he will be
 * moved to the next paragraph, not after the `<br>`. The disadvantage is that it breaks a block, so it can not be used
 * in the middle of a line of text. The {@link module:engine/view/filler~BR_FILLER `<br>` filler} can be replaced with any other
 * character in the data output, for instance {@link module:engine/view/filler~NBSP_FILLER non-breaking space}.
 *
 * * Inline filler is a filler which does not break a line of text, so it can be used inside the text, for instance in the empty
 * `<b>` surrendered by text: `foo<b></b>bar`, if we want to put the caret there. CKEditor uses a sequence of the zero-width
 * spaces as an {@link module:engine/view/filler~INLINE_FILLER inline filler} having the predetermined
 * {@link module:engine/view/filler~INLINE_FILLER_LENGTH length}. A sequence is used, instead of a single character to
 * avoid treating random zero-width spaces as the inline filler. Disadvantage of the inline filler is that it is not
 * transparent for the selection. The arrow key moves the caret between zero-width spaces characters, so the additional
 * code is needed to handle the caret.
 *
 * Both inline and block fillers are handled by the {@link module:engine/view/renderer~Renderer renderer} and are not present in the
 * view.
 *
 * @module engine/view/filler
 */

/**
 * `<br> filler creator. This is a function which creates `<br data-cke-filler="true">` element.
 * It defines how the filler is created.
 *
 * @see module:engine/view/filler~NBSP_FILLER
 * @function
 */
const BR_FILLER = domDocument => {
	const fillerBr = domDocument.createElement( 'br' );
	fillerBr.dataset.ckeFiller = true;

	return fillerBr;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = BR_FILLER;


/**
 * Non-breaking space filler creator. This is a function which creates `&nbsp;` text node.
 * It defines how the filler is created.
 *
 * @see module:engine/view/filler~BR_FILLER
 * @function
 */
const NBSP_FILLER = domDocument => domDocument.createTextNode( '\u00A0' );
/* harmony export (immutable) */ __webpack_exports__["d"] = NBSP_FILLER;


/**
 * Length of the {@link module:engine/view/filler~INLINE_FILLER INLINE_FILLER}.
 */
const INLINE_FILLER_LENGTH = 7;
/* harmony export (immutable) */ __webpack_exports__["c"] = INLINE_FILLER_LENGTH;


/**
 * Inline filler which is sequence of the zero width spaces.
 */
let INLINE_FILLER = '';

for ( let i = 0; i < INLINE_FILLER_LENGTH; i++ ) {
	INLINE_FILLER += '\u200b';
}

/**
 * Checks if the node is a text node which starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 *
 *		startsWithFiller( document.createTextNode( INLINE_FILLER ) ); // true
 *		startsWithFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // true
 *		startsWithFiller( document.createTextNode( 'foo' ) ); // false
 *		startsWithFiller( document.createElement( 'p' ) ); // false
 *
 * @param {Node} domNode DOM node.
 * @returns {Boolean} True if the text node starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 */
function startsWithFiller( domNode ) {
	return ( domNode instanceof Text ) && ( domNode.data.substr( 0, INLINE_FILLER_LENGTH ) === INLINE_FILLER );
}

/**
 * Checks if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 *
 *		isInlineFiller( document.createTextNode( INLINE_FILLER ) ); // true
 *		isInlineFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // false
 *
 * @param {Text} domText DOM text node.
 * @returns {Boolean} True if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 */
function isInlineFiller( domText ) {
	return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller( domText );
}

/**
 * Get string data from the text node, removing an {@link module:engine/view/filler~INLINE_FILLER inline filler} from it,
 * if text node contains it.
 *
 *		getDataWithoutFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ) == 'foo' // true
 *		getDataWithoutFiller( document.createTextNode( 'foo' ) ) == 'foo' // true
 *
 * @param {Text} domText DOM text node, possible with inline filler.
 * @returns {String} Data without filler.
 */
function getDataWithoutFiller( domText ) {
	if ( startsWithFiller( domText ) ) {
		return domText.data.slice( INLINE_FILLER_LENGTH );
	} else {
		return domText.data;
	}
}

// Cache block fillers templates to improve performance.
const templateBlockFillers = new WeakMap();

/**
 * Checks if the node is an instance of the block filler of the given type.
 *
 *		const brFillerInstance = BR_FILLER( document );
 *		isBlockFiller( brFillerInstance, BR_FILLER ); // true
 *
 * @param {Node} domNode DOM node to check.
 * @param {Function} blockFiller Block filler creator.
 * @returns {Boolean} True if text node contains only {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 */
function isBlockFiller( domNode, blockFiller ) {
	let templateBlockFiller = templateBlockFillers.get( blockFiller );

	if ( !templateBlockFiller ) {
		templateBlockFiller = blockFiller( window.document );
		templateBlockFillers.set( blockFiller, templateBlockFiller );
	}

	return domNode.isEqualNode( templateBlockFiller );
}

/**
 * Assign key observer which move cursor from the end of the inline filler to the beginning of it when
 * the left arrow is pressed, so the filler does not break navigation.
 *
 * @param {module:engine/view/document~Document} document Document instance we should inject quirks handling on.
 */
function injectQuirksHandling( document ) {
	document.on( 'keydown', jumpOverInlineFiller );
}

// Move cursor from the end of the inline filler to the beginning of it when, so the filler does not break navigation.
function jumpOverInlineFiller( evt, data ) {
	if ( data.keyCode == __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowleft ) {
		const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();

		if ( domSelection.rangeCount == 1 && domSelection.getRangeAt( 0 ).collapsed ) {
			const domParent = domSelection.getRangeAt( 0 ).startContainer;
			const domOffset = domSelection.getRangeAt( 0 ).startOffset;

			if ( startsWithFiller( domParent ) && domOffset <= INLINE_FILLER_LENGTH ) {
				domSelection.collapse( domParent, 0 );
			}
		}
	}
}


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__observer__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__domeventdata__ = __webpack_require__(155);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/domeventobserver
 */




/**
 * Base class for DOM event observers. This class handles
 * {@link module:engine/view/observer/observer~Observer#observe adding} listeners to DOM elements,
 * {@link module:engine/view/observer/observer~Observer#disable disabling} and
 * {@link module:engine/view/observer/observer~Observer#enable re-enabling} events.
 * Child class needs to define
 * {@link module:engine/view/observer/domeventobserver~DomEventObserver#domEventType DOM event type} and
 * {@link module:engine/view/observer/domeventobserver~DomEventObserver#onDomEvent callback}.
 *
 * For instance:
 *
 *		class ClickObserver extends DomEventObserver {
 *			// It can also be defined as a normal property in the constructor.
 *			get domEventType() {
 *				return 'click';
 *			}
 *
 *			onDomEvent( domEvent ) {
 *				this.fire( 'click', domEvent );
 *			}
 *		}
 *
 * @extends module:engine/view/observer/observer~Observer
 */
class DomEventObserver extends __WEBPACK_IMPORTED_MODULE_0__observer__["a" /* default */] {
	/**
	 * Type of the DOM event the observer should listen on. Array of types can be defined
	 * if the obsever should listen to multiple DOM events.
	 *
	 * @readonly
	 * @member {String|Array.<String>} #domEventType
	 */

	/**
	 * Callback which should be called when the DOM event occurred. Note that the callback will not be called if
	 * observer {@link #isEnabled is not enabled}.
	 *
	 * @see #domEventType
	 * @abstract
	 * @method #onDomEvent
	 */

	/**
	 * @inheritDoc
	 */
	constructor( document ) {
		super( document );

		/**
		 * If set to `true` DOM events will be listened on the capturing phase.
		 * Default value is `false`.
		 *
		 * @member {Boolean}
		 */
		this.useCapture = false;
	}

	/**
	 * @inheritDoc
	 */
	observe( domElement ) {
		const types = typeof this.domEventType == 'string' ? [ this.domEventType ] : this.domEventType;

		types.forEach( type => {
			this.listenTo( domElement, type, ( eventInfo, domEvent ) => {
				if ( this.isEnabled ) {
					this.onDomEvent( domEvent );
				}
			}, { useCapture: this.useCapture } );
		} );
	}

	/**
	 * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.
	 *
	 * @see module:utils/emittermixin~EmitterMixin#fire
	 * @param {String} eventType The event type (name).
	 * @param {Event} domEvent The DOM event.
	 * @param {Object} [additionalData] The additional data which should extend the
	 * {@link module:engine/view/observer/domeventdata~DomEventData event data} object.
	 */
	fire( eventType, domEvent, additionalData ) {
		if ( this.isEnabled ) {
			this.document.fire( eventType, new __WEBPACK_IMPORTED_MODULE_1__domeventdata__["a" /* default */]( this.document, domEvent, additionalData ) );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DomEventObserver;



/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getPrototype__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isHostObject__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike__ = __webpack_require__(43);




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object,
 *  else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike__["a" /* default */])(value) ||
      objectToString.call(value) != objectTag || Object(__WEBPACK_IMPORTED_MODULE_1__isHostObject__["a" /* default */])(value)) {
    return false;
  }
  var proto = Object(__WEBPACK_IMPORTED_MODULE_0__getPrototype__["a" /* default */])(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

/* harmony default export */ __webpack_exports__["a"] = (isPlainObject);


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (isHostObject);


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__eq__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArrayLike__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isIndex__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isObject__ = __webpack_require__(16);





/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_3__isObject__["a" /* default */])(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (Object(__WEBPACK_IMPORTED_MODULE_1__isArrayLike__["a" /* default */])(object) && Object(__WEBPACK_IMPORTED_MODULE_2__isIndex__["a" /* default */])(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__eq__["a" /* default */])(object[index], value);
  }
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (isIterateeCall);


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getLength__ = __webpack_require__(302);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isFunction__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isLength__ = __webpack_require__(79);




/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && Object(__WEBPACK_IMPORTED_MODULE_2__isLength__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__getLength__["a" /* default */])(value)) && !Object(__WEBPACK_IMPORTED_MODULE_1__isFunction__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (isArrayLike);


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length,
 *  else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/* harmony default export */ __webpack_exports__["a"] = (isLength);


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/* harmony default export */ __webpack_exports__["a"] = (isPrototype);


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/nodelist
 */




/**
 * Provides an interface to operate on a list of {@link module:engine/model/node~Node nodes}. `NodeList` is used internally
 * in classes like {@link module:engine/model/element~Element Element}
 * or {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment}.
 */
class NodeList {
	/**
	 * Creates an empty node list.
	 *
	 * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes contained in this node list.
	 */
	constructor( nodes ) {
		/**
		 * Nodes contained in this node list.
		 *
		 * @private
		 * @member {Array.<module:engine/model/node~Node>}
		 */
		this._nodes = [];

		if ( nodes ) {
			this.insertNodes( 0, nodes );
		}
	}

	/**
	 * Returns an iterator that iterates over all nodes contained inside this node list.
	 *
	 * @returns {Iterator.<module:engine/model/node~Node>}
	 */
	[ Symbol.iterator ]() {
		return this._nodes[ Symbol.iterator ]();
	}

	/**
	 * Number of nodes contained inside this node list.
	 *
	 * @readonly
	 * @type {Number}
	 */
	get length() {
		return this._nodes.length;
	}

	/**
	 * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.
	 *
	 * @readonly
	 * @type {Number}
	 */
	get maxOffset() {
		return this._nodes.reduce( ( sum, node ) => sum + node.offsetSize, 0 );
	}

	/**
	 * Gets the node at the given index. Returns `null` if incorrect index was passed.
	 *
	 * @param {Number} index Index of node.
	 * @returns {module:engine/model/node~Node|null} Node at given index.
	 */
	getNode( index ) {
		return this._nodes[ index ] || null;
	}

	/**
	 * Returns an index of the given node. Returns `null` if given node is not inside this node list.
	 *
	 * @param {module:engine/model/node~Node} node Child node to look for.
	 * @returns {Number|null} Child node's index.
	 */
	getNodeIndex( node ) {
		const index = this._nodes.indexOf( node );

		return index == -1 ? null : index;
	}

	/**
	 * Returns the starting offset of given node. Starting offset is equal to the sum of
	 * {module:engine/model/node~Node#offsetSize offset sizes} of all nodes that are before this node in this node list.
	 *
	 * @param {module:engine/model/node~Node} node Node to look for.
	 * @returns {Number|null} Node's starting offset.
	 */
	getNodeStartOffset( node ) {
		const index = this.getNodeIndex( node );

		return index === null ? null : this._nodes.slice( 0, index ).reduce( ( sum, node ) => sum + node.offsetSize, 0 );
	}

	/**
	 * Converts index to offset in node list.
	 *
	 * Returns starting offset of a node that is at given index. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
	 * `model-nodelist-index-out-of-bounds` if given index is less than `0` or more than {@link #length}.
	 *
	 * @param {Number} index Node's index.
	 * @returns {Number} Node's starting offset.
	 */
	indexToOffset( index ) {
		if ( index == this._nodes.length ) {
			return this.maxOffset;
		}

		const node = this._nodes[ index ];

		if ( !node ) {
			/**
			 * Given index cannot be found in the node list.
			 *
			 * @error nodelist-index-out-of-bounds
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-nodelist-index-out-of-bounds: Given index cannot be found in the node list.' );
		}

		return this.getNodeStartOffset( node );
	}

	/**
	 * Converts offset in node list to index.
	 *
	 * Returns index of a node that occupies given offset. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
	 * `model-nodelist-offset-out-of-bounds` if given offset is less than `0` or more than {@link #maxOffset}.
	 *
	 * @param {Number} offset Offset to look for.
	 * @returns {Number} Index of a node that occupies given offset.
	 */
	offsetToIndex( offset ) {
		let totalOffset = 0;

		for ( const node of this._nodes ) {
			if ( offset >= totalOffset && offset < totalOffset + node.offsetSize ) {
				return this.getNodeIndex( node );
			}

			totalOffset += node.offsetSize;
		}

		if ( totalOffset != offset ) {
			/**
			 * Given offset cannot be found in the node list.
			 *
			 * @error nodelist-offset-out-of-bounds
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-nodelist-offset-out-of-bounds: Given offset cannot be found in the node list.' );
		}

		return this.length;
	}

	/**
	 * Inserts given nodes at given index.
	 *
	 * @param {Number} index Index at which nodes should be inserted.
	 * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to be inserted.
	 */
	insertNodes( index, nodes ) {
		// Validation.
		for ( const node of nodes ) {
			if ( !( node instanceof __WEBPACK_IMPORTED_MODULE_0__node__["a" /* default */] ) ) {
				/**
				 * Trying to insert an object which is not a Node instance.
				 *
				 * @error nodelist-insertNodes-not-node
				 */
				throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-nodelist-insertNodes-not-node: Trying to insert an object which is not a Node instance.' );
			}
		}

		this._nodes.splice( index, 0, ...nodes );
	}

	/**
	 * Removes one or more nodes starting at the given index.
	 *
	 * @param {Number} indexStart Index of the first node to remove.
	 * @param {Number} [howMany=1] Number of nodes to remove.
	 * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.
	 */
	removeNodes( indexStart, howMany = 1 ) {
		return this._nodes.splice( indexStart, howMany );
	}

	/**
	 * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes
	 * are also converted to their plain object representation.
	 *
	 * @returns {Array.<module:engine/model/node~Node>} `NodeList` instance converted to `Array`.
	 */
	toJSON() {
		return this._nodes.map( node => node.toJSON() );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = NodeList;



/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_clone__ = __webpack_require__(68);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/node
 */






/**
 * Abstract tree view node class.
 *
 * @abstract
 */
class Node {
	/**
	 * Creates a tree view node.
	 *
	 * This is an abstract class, so this constructor should not be used directly.
	 */
	constructor() {
		/**
		 * Parent element. Null by default. Set by {@link module:engine/view/element~Element#insertChildren}.
		 *
		 * @readonly
		 * @member {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}
		 */
		this.parent = null;
	}

	/**
	 * Index of the node in the parent element or null if the node has no parent.
	 *
	 * Accessing this property throws an error if this node's parent element does not contain it.
	 * This means that view tree got broken.
	 *
	 * @readonly
	 * @type {Number|null}
	 */
	get index() {
		let pos;

		if ( !this.parent ) {
			return null;
		}

		// No parent or child doesn't exist in parent's children.
		if ( ( pos = this.parent.getChildIndex( this ) ) == -1 ) {
			/**
			 * The node's parent does not contain this node. It means that the document tree is corrupted.
			 *
			 * @error view-node-not-found-in-parent
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-node-not-found-in-parent: The node\'s parent does not contain this node.' );
		}

		return pos;
	}

	/**
	 * Node's next sibling, or `null` if it is the last child.
	 *
	 * @readonly
	 * @type {module:engine/view/node~Node|null}
	 */
	get nextSibling() {
		const index = this.index;

		return ( index !== null && this.parent.getChild( index + 1 ) ) || null;
	}

	/**
	 * Node's previous sibling, or `null` if it is the first child.
	 *
	 * @readonly
	 * @type {module:engine/view/node~Node|null}
	 */
	get previousSibling() {
		const index = this.index;

		return ( index !== null && this.parent.getChild( index - 1 ) ) || null;
	}

	/**
	 * Top-most ancestor of the node. If the node has no parent it is the root itself.
	 *
	 * @readonly
	 * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}
	 */
	get root() {
		let root = this; // eslint-disable-line consistent-this

		while ( root.parent ) {
			root = root.parent;
		}

		return root;
	}

	/**
	 * {@link module:engine/view/document~Document View document} that owns this node, or `null` if the node is inside
	 * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
	 *
	 * @readonly
	 * @type {module:engine/view/document~Document|null}
	 */
	get document() {
		// Parent might be Node, null or DocumentFragment.
		if ( this.parent instanceof Node ) {
			return this.parent.document;
		} else {
			return null;
		}
	}

	/**
	 * Returns ancestors array of this node.
	 *
	 * @param {Object} options Options object.
	 * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.
	 * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,
	 * otherwise root element will be the first item in the array.
	 * @returns {Array} Array with ancestors.
	 */
	getAncestors( options = { includeSelf: false, parentFirst: false } ) {
		const ancestors = [];
		let parent = options.includeSelf ? this : this.parent;

		while ( parent ) {
			ancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );
			parent = parent.parent;
		}

		return ancestors;
	}

	/**
	 * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}
	 * which is a common ancestor of both nodes.
	 *
	 * @param {module:engine/view/node~Node} node The second node.
	 * @param {Object} options Options object.
	 * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered "ancestors" too.
	 * Which means that if e.g. node A is inside B, then their common ancestor will be B.
	 * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}
	 */
	getCommonAncestor( node, options = {} ) {
		const ancestorsA = this.getAncestors( options );
		const ancestorsB = node.getAncestors( options );

		let i = 0;

		while ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {
			i++;
		}

		return i === 0 ? null : ancestorsA[ i - 1 ];
	}

	/**
	 * Removes node from parent.
	 */
	remove() {
		this.parent.removeChildren( this.index );
	}

	/**
	 * @param {module:engine/view/document~ChangeType} type Type of the change.
	 * @param {module:engine/view/node~Node} node Changed node.
	 * @fires change
	 */
	_fireChange( type, node ) {
		this.fire( 'change:' + type, node );

		if ( this.parent ) {
			this.parent._fireChange( type, node );
		}
	}

	/**
	 * Custom toJSON method to solve child-parent circular dependencies.
	 *
	 * @returns {Object} Clone of this object with the parent property removed.
	 */
	toJSON() {
		const json = Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_clone__["a" /* default */])( this );

		// Due to circular references we need to remove parent reference.
		delete json.parent;

		return json;
	}

	/**
	 * Clones this node.
	 *
	 * @method #clone
	 * @returns {module:engine/view/node~Node} Clone of this node.
	 */

	/**
	 * Checks if provided node is similar to this node.
	 *
	 * @method #isSimilar
	 * @returns {Boolean} True if nodes are similar.
	 */

	/**
	 * Checks whether given view tree object is of given type.
	 *
	 * This method is useful when processing view tree objects that are of unknown type. For example, a function
	 * may return {@link module:engine/view/documentfragment~DocumentFragment} or {@link module:engine/view/node~Node}
	 * that can be either text node or element. This method can be used to check what kind of object is returned.
	 *
	 *		obj.is( 'node' ); // true for any node, false for document fragment
	 *		obj.is( 'documentFragment' ); // true for document fragment, false for any node
	 *		obj.is( 'element' ); // true for any element, false for text node or document fragment
	 *		obj.is( 'element', 'p' ); // true only for element which name is 'p'
	 *		obj.is( 'p' ); // shortcut for obj.is( 'element', 'p' )
	 *		obj.is( 'text' ); // true for text node, false for element and document fragment
	 *
	 * @method #is
	 * @param {'element'|'containerElement'|'attributeElement'|'emptyElement'|'uiElement'|
	 * 'rootElement'|'documentFragment'|'text'|'textProxy'} type
	 * @returns {Boolean}
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Node;


/**
 * Fired when list of {@link module:engine/view/element~Element elements} children changes.
 *
 * Change event is bubbled  it is fired on all ancestors.
 *
 * @event change:children
 * @param {module:engine/view/node~Node} changedNode
 */

/**
 * Fired when list of {@link module:engine/view/element~Element elements} attributes changes.
 *
 * Change event is bubbled  it is fired on all ancestors.
 *
 * @event change:attributes
 * @param {module:engine/view/node~Node} changedNode
 */

/**
 * Fired when {@link module:engine/view/text~Text text nodes} data changes.
 *
 * Change event is bubbled  it is fired on all ancestors.
 *
 * @event change:text
 * @param {module:engine/view/node~Node} changedNode
 */

/**
 * @event change
 */

Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Node, __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__listCacheClear__ = __webpack_require__(310);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__listCacheDelete__ = __webpack_require__(311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__listCacheGet__ = __webpack_require__(312);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__listCacheHas__ = __webpack_require__(313);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__listCacheSet__ = __webpack_require__(314);






/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = __WEBPACK_IMPORTED_MODULE_0__listCacheClear__["a" /* default */];
ListCache.prototype['delete'] = __WEBPACK_IMPORTED_MODULE_1__listCacheDelete__["a" /* default */];
ListCache.prototype.get = __WEBPACK_IMPORTED_MODULE_2__listCacheGet__["a" /* default */];
ListCache.prototype.has = __WEBPACK_IMPORTED_MODULE_3__listCacheHas__["a" /* default */];
ListCache.prototype.set = __WEBPACK_IMPORTED_MODULE_4__listCacheSet__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (ListCache);


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__eq__ = __webpack_require__(52);


/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (Object(__WEBPACK_IMPORTED_MODULE_0__eq__["a" /* default */])(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (assocIndexOf);


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative__ = __webpack_require__(55);


/* Built-in method references that are verified to be native. */
var nativeCreate = Object(__WEBPACK_IMPORTED_MODULE_0__getNative__["a" /* default */])(Object, 'create');

/* harmony default export */ __webpack_exports__["a"] = (nativeCreate);


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isKeyable__ = __webpack_require__(329);


/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return Object(__WEBPACK_IMPORTED_MODULE_0__isKeyable__["a" /* default */])(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/* harmony default export */ __webpack_exports__["a"] = (getMapData);


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayPush);


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (setToArray);


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__containerelement__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/editableelement
 */






const documentSymbol = Symbol( 'document' );

/**
 * Editable element which can be a {@link module:engine/view/rooteditableelement~RootEditableElement root}
 * or nested editable area in the editor.
 *
 * Editable is automatically read-only when its {module:engine/view/document~Document Document} is read-only.
 *
 * @extends module:engine/view/containerelement~ContainerElement
 * @mixes module:utils/observablemixin~ObservableMixin
 */
class EditableElement extends __WEBPACK_IMPORTED_MODULE_0__containerelement__["a" /* default */] {
	/**
	 * Creates an editable element.
	 */
	constructor( name, attrs, children ) {
		super( name, attrs, children );

		/**
		 * Whether the editable is in read-write or read-only mode.
		 *
		 * @observable
		 * @member {Boolean} module:engine/view/editableelement~EditableElement#isReadOnly
		 */
		this.set( 'isReadOnly', false );

		/**
		 * Whether the editable is focused.
		 *
		 * This property updates when {@link module:engine/view/document~Document#isFocused document.isFocused} is changed and after each
		 * {@link module:engine/view/document~Document#render render} method call.
		 *
		 * @readonly
		 * @observable
		 * @member {Boolean} module:engine/view/editableelement~EditableElement#isFocused
		 */
		this.set( 'isFocused', false );

		/**
		 * The {@link module:engine/view/document~Document} which is an owner of this root.
		 * Can only by set once.
		 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-editableelement-document-already-set`
		 * when document is already set.
		 *
		 * @member {module:engine/view/document~Document} #document
		 */
	}

	get document() {
		return this.getCustomProperty( documentSymbol );
	}

	set document( document ) {
		if ( this.getCustomProperty( documentSymbol ) ) {
			/**
			 * View document is already set. It can only be set once.
			 *
			 * @error view-editableelement-document-already-set
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-editableelement-document-already-set: View document is already set.' );
		}

		this.setCustomProperty( documentSymbol, document );

		this.bind( 'isReadOnly' ).to( document );

		this.bind( 'isFocused' ).to(
			document,
			'isFocused',
			isFocused => isFocused && document.selection.editableElement == this
		);

		// Update focus state before each rendering. Rendering should not change neither the selection nor the value of
		// document.isFocused property.
		this.listenTo( document, 'render', () => {
			this.isFocused = document.isFocused && document.selection.editableElement == this;
		}, { priority: 'high' } );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EditableElement;


Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( EditableElement, __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = insertElement;
/* harmony export (immutable) */ __webpack_exports__["e"] = insertText;
/* harmony export (immutable) */ __webpack_exports__["f"] = insertUIElement;
/* harmony export (immutable) */ __webpack_exports__["j"] = setAttribute;
/* harmony export (immutable) */ __webpack_exports__["h"] = removeAttribute;
/* harmony export (immutable) */ __webpack_exports__["l"] = wrapItem;
/* harmony export (immutable) */ __webpack_exports__["k"] = unwrapItem;
/* harmony export (immutable) */ __webpack_exports__["g"] = remove;
/* harmony export (immutable) */ __webpack_exports__["c"] = highlightText;
/* harmony export (immutable) */ __webpack_exports__["b"] = highlightElement;
/* harmony export (immutable) */ __webpack_exports__["i"] = removeUIElement;
/* unused harmony export eventNameToConsumableType */
/* harmony export (immutable) */ __webpack_exports__["a"] = createViewElementFromHighlightDescriptor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view_element__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__view_attributeelement__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__view_text__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__view_range__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__view_position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__view_treewalker__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__view_writer__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__model_range__ = __webpack_require__(2);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */










/**
 * Contains {@link module:engine/model/model model} to {@link module:engine/view/view view} converters for
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}.
 *
 * @module engine/conversion/model-to-view-converters
 */

/**
 * Function factory, creates a converter that converts node insertion changes from the model to the view.
 * The view element that will be added to the view depends on passed parameter. If {@link module:engine/view/element~Element} was passed,
 * it will be cloned and the copy will be inserted. If `Function` is provided, it is passed all the parameters of the
 * dispatcher's {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:insert insert event}.
 * It's expected that the function returns a {@link module:engine/view/element~Element}.
 * The result of the function will be inserted to the view.
 *
 * The converter automatically consumes corresponding value from consumables list, stops the event (see
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}) and bind model and view elements.
 *
 *		modelDispatcher.on( 'insert:paragraph', insertElement( new ViewElement( 'p' ) ) );
 *
 *		modelDispatcher.on(
 *			'insert:myElem',
 *			insertElement( ( data, consumable, conversionApi ) => {
 *				let myElem = new ViewElement( 'myElem', { myAttr: true }, new ViewText( 'myText' ) );
 *
 *				// Do something fancy with myElem using data/consumable/conversionApi ...
 *
 *				return myElem;
 *			}
 *		) );
 *
 * @param {module:engine/view/element~Element|Function} elementCreator View element, or function returning a view element, which
 * will be inserted.
 * @returns {Function} Insert element event converter.
 */
function insertElement( elementCreator ) {
	return ( evt, data, consumable, conversionApi ) => {
		const viewElement = ( elementCreator instanceof __WEBPACK_IMPORTED_MODULE_0__view_element__["a" /* default */] ) ?
			elementCreator.clone( true ) :
			elementCreator( data, consumable, conversionApi );

		if ( !viewElement ) {
			return;
		}

		if ( !consumable.consume( data.item, 'insert' ) ) {
			return;
		}

		const viewPosition = conversionApi.mapper.toViewPosition( data.range.start );

		conversionApi.mapper.bindElements( data.item, viewElement );
		__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].insert( viewPosition, viewElement );
	};
}

/**
 * Function factory, creates a default model-to-view converter for text insertion changes.
 *
 * The converter automatically consumes corresponding value from consumables list and stops the event (see
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}).
 *
 *		modelDispatcher.on( 'insert:$text', insertText() );
 *
 * @returns {Function} Insert text event converter.
 */
function insertText() {
	return ( evt, data, consumable, conversionApi ) => {
		if ( !consumable.consume( data.item, 'insert' ) ) {
			return;
		}

		const viewPosition = conversionApi.mapper.toViewPosition( data.range.start );
		const viewText = new __WEBPACK_IMPORTED_MODULE_2__view_text__["a" /* default */]( data.item.data );

		__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].insert( viewPosition, viewText );
	};
}

/**
 * Function factory, creates a converter that converts marker adding change to the view ui element.
 * The view ui element that will be added to the view depends on passed parameter. See {@link ~insertElement}.
 * In a case of collapsed range element will not wrap range but separate elements will be placed at the beginning
 * and at the end of the range.
 *
 * **Note:** unlike {@link ~insertElement}, the converter does not bind view element to model, because this converter
 * uses marker as "model source of data". This means that view ui element does not have corresponding model element.
 *
 * @param {module:engine/view/uielement~UIElement|Function} elementCreator View ui element, or function returning a view element, which
 * will be inserted.
 * @returns {Function} Insert element event converter.
 */
function insertUIElement( elementCreator ) {
	return ( evt, data, consumable, conversionApi ) => {
		let viewStartElement, viewEndElement;

		if ( elementCreator instanceof __WEBPACK_IMPORTED_MODULE_0__view_element__["a" /* default */] ) {
			viewStartElement = elementCreator.clone( true );
			viewEndElement = elementCreator.clone( true );
		} else {
			data.isOpening = true;
			viewStartElement = elementCreator( data, consumable, conversionApi );

			data.isOpening = false;
			viewEndElement = elementCreator( data, consumable, conversionApi );
		}

		if ( !viewStartElement || !viewEndElement ) {
			return;
		}

		const markerRange = data.markerRange;
		const eventName = evt.name;

		// Marker that is collapsed has consumable build differently that non-collapsed one.
		// For more information see `addMarker` and `removeMarker` events description.
		// If marker's range is collapsed - check if it can be consumed.
		if ( markerRange.isCollapsed && !consumable.consume( markerRange, eventName ) ) {
			return;
		}

		// If marker's range is not collapsed - consume all items inside.
		for ( const value of markerRange ) {
			if ( !consumable.consume( value.item, eventName ) ) {
				return;
			}
		}

		const mapper = conversionApi.mapper;

		__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].insert( mapper.toViewPosition( markerRange.start ), viewStartElement );

		if ( !markerRange.isCollapsed ) {
			__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].insert( mapper.toViewPosition( markerRange.end ), viewEndElement );
		}
	};
}

/**
 * Function factory, creates a converter that converts set/change attribute changes from the model to the view. Attributes
 * from model are converted to the view element attributes in the view. You may provide a custom function to generate a
 * key-value attribute pair to add/change. If not provided, model attributes will be converted to view elements attributes
 * on 1-to-1 basis.
 *
 * **Note:** Provided attribute creator should always return the same `key` for given attribute from the model.
 *
 * The converter automatically consumes corresponding value from consumables list and stops the event (see
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}).
 *
 *		modelDispatcher.on( 'addAttribute:customAttr:myElem', setAttribute( ( data ) => {
 *			// Change attribute key from `customAttr` to `class` in view.
 *			const key = 'class';
 *			let value = data.attributeNewValue;
 *
 *			// Force attribute value to 'empty' if the model element is empty.
 *			if ( data.item.childCount === 0 ) {
 *				value = 'empty';
 *			}
 *
 *			// Return key-value pair.
 *			return { key, value };
 *		} ) );
 *
 * @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which
 * represents attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.
 * The function is passed all the parameters of the
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:addAttribute}
 * or {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:changeAttribute} event.
 * @returns {Function} Set/change attribute converter.
 */
function setAttribute( attributeCreator ) {
	attributeCreator = attributeCreator || ( ( value, key ) => ( { value, key } ) );

	return ( evt, data, consumable, conversionApi ) => {
		if ( !consumable.consume( data.item, eventNameToConsumableType( evt.name ) ) ) {
			return;
		}

		const { key, value } = attributeCreator( data.attributeNewValue, data.attributeKey, data, consumable, conversionApi );

		conversionApi.mapper.toViewElement( data.item ).setAttribute( key, value );
	};
}

/**
 * Function factory, creates a converter that converts remove attribute changes from the model to the view. Removes attributes
 * that were converted to the view element attributes in the view. You may provide a custom function to generate a
 * key-value attribute pair to remove. If not provided, model attributes will be removed from view elements on 1-to-1 basis.
 *
 * **Note:** Provided attribute creator should always return the same `key` for given attribute from the model.
 *
 * **Note:** You can use the same attribute creator as in {@link module:engine/conversion/model-to-view-converters~setAttribute}.
 *
 * The converter automatically consumes corresponding value from consumables list and stops the event (see
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}).
 *
 *		modelDispatcher.on( 'removeAttribute:customAttr:myElem', removeAttribute( ( data ) => {
 *			// Change attribute key from `customAttr` to `class` in view.
 *			const key = 'class';
 *			let value = data.attributeNewValue;
 *
 *			// Force attribute value to 'empty' if the model element is empty.
 *			if ( data.item.childCount === 0 ) {
 *				value = 'empty';
 *			}
 *
 *			// Return key-value pair.
 *			return { key, value };
 *		} ) );
 *
 * @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which
 * represents attribute key and attribute value to be removed from {@link module:engine/view/element~Element view element}.
 * The function is passed all the parameters of the
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:addAttribute addAttribute event}
 * or {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:changeAttribute changeAttribute event}.
 * @returns {Function} Remove attribute converter.
 */
function removeAttribute( attributeCreator ) {
	attributeCreator = attributeCreator || ( ( value, key ) => ( { key } ) );

	return ( evt, data, consumable, conversionApi ) => {
		if ( !consumable.consume( data.item, eventNameToConsumableType( evt.name ) ) ) {
			return;
		}

		const { key } = attributeCreator( data.attributeOldValue, data.attributeKey, data, consumable, conversionApi );

		conversionApi.mapper.toViewElement( data.item ).removeAttribute( key );
	};
}

/**
 * Function factory, creates a converter that converts set/change attribute changes from the model to the view. In this case,
 * model attributes are converted to a view element that will be wrapping view nodes which corresponding model nodes had
 * the attribute set. This is useful for attributes like `bold`, which may be set on text nodes in model but are
 * represented as an element in the view:
 *
 *		[paragraph]              MODEL ====> VIEW        <p>
 *			|- a {bold: true}                             |- <b>
 *			|- b {bold: true}                             |   |- ab
 *			|- c                                          |- c
 *
 * The wrapping node depends on passed parameter. If {@link module:engine/view/element~Element} was passed, it will be cloned and
 * the copy will become the wrapping element. If `Function` is provided, it is passed attribute value and then all the parameters of the
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:addAttribute addAttribute event}.
 * It's expected that the function returns a {@link module:engine/view/element~Element}.
 * The result of the function will be the wrapping element.
 * When provided `Function` does not return element, then will be no conversion.
 *
 * The converter automatically consumes corresponding value from consumables list, stops the event (see
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}).
 *
 *		modelDispatcher.on( 'addAttribute:bold', wrapItem( new ViewAttributeElement( 'strong' ) ) );
 *
 * @param {module:engine/view/element~Element|Function} elementCreator View element, or function returning a view element, which will
 * be used for wrapping.
 * @returns {Function} Set/change attribute converter.
 */
function wrapItem( elementCreator ) {
	return ( evt, data, consumable, conversionApi ) => {
		const viewElement = ( elementCreator instanceof __WEBPACK_IMPORTED_MODULE_0__view_element__["a" /* default */] ) ?
			elementCreator.clone( true ) :
			elementCreator( data.attributeNewValue, data, consumable, conversionApi );

		if ( !viewElement ) {
			return;
		}

		if ( !consumable.consume( data.item, eventNameToConsumableType( evt.name ) ) ) {
			return;
		}

		let viewRange = conversionApi.mapper.toViewRange( data.range );

		// If this is a change event (because old value is not empty) and the creator is a function (so
		// it may create different view elements basing on attribute value) we have to create
		// view element basing on old value and unwrap it before wrapping with a newly created view element.
		if ( data.attributeOldValue !== null && !( elementCreator instanceof __WEBPACK_IMPORTED_MODULE_0__view_element__["a" /* default */] ) ) {
			const oldViewElement = elementCreator( data.attributeOldValue, data, consumable, conversionApi );
			viewRange = __WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].unwrap( viewRange, oldViewElement );
		}

		__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].wrap( viewRange, viewElement );
	};
}

/**
 * Function factory, creates a converter that converts remove attribute changes from the model to the view. It assumes, that
 * attributes from model were converted to elements in the view. This converter will unwrap view nodes from corresponding
 * view element if given attribute was removed.
 *
 * The view element type that will be unwrapped depends on passed parameter.
 * If {@link module:engine/view/element~Element} was passed, it will be used to look for similar element in the view for unwrapping.
 * If `Function` is provided, it is passed all the parameters of the
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:addAttribute addAttribute event}.
 * It's expected that the function returns a {@link module:engine/view/element~Element}.
 * The result of the function will be used to look for similar element in the view for unwrapping.
 *
 * The converter automatically consumes corresponding value from consumables list, stops the event (see
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}) and bind model and view elements.
 *
 *		modelDispatcher.on( 'removeAttribute:bold', unwrapItem( new ViewAttributeElement( 'strong' ) ) );
 *
 * @see module:engine/conversion/model-to-view-converters~wrapItem
 * @param {module:engine/view/element~Element|Function} elementCreator View element, or function returning a view element, which will
 * be used for unwrapping.
 * @returns {Function} Remove attribute converter.
 */
function unwrapItem( elementCreator ) {
	return ( evt, data, consumable, conversionApi ) => {
		const viewElement = ( elementCreator instanceof __WEBPACK_IMPORTED_MODULE_0__view_element__["a" /* default */] ) ?
			elementCreator.clone( true ) :
			elementCreator( data.attributeOldValue, data, consumable, conversionApi );

		if ( !viewElement ) {
			return;
		}

		if ( !consumable.consume( data.item, eventNameToConsumableType( evt.name ) ) ) {
			return;
		}

		const viewRange = conversionApi.mapper.toViewRange( data.range );

		__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].unwrap( viewRange, viewElement );
	};
}

/**
 * Function factory, creates a default model-to-view converter for node remove changes.
 *
 *		modelDispatcher.on( 'remove', remove() );
 *
 * @returns {Function} Remove event converter.
 */
function remove() {
	return ( evt, data, consumable, conversionApi ) => {
		if ( !consumable.consume( data.item, 'remove' ) ) {
			return;
		}

		// We cannot map non-existing positions from model to view. Since a range was removed
		// from the model, we cannot recreate that range and map it to view, because
		// end of that range is incorrect.
		// Instead we will use `data.sourcePosition` as this is the last correct model position and
		// it is a position before the removed item. Then, we will calculate view range to remove "manually".
		let viewPosition = conversionApi.mapper.toViewPosition( data.sourcePosition );
		let viewRange;

		if ( data.item.is( 'element' ) ) {
			// Note: in remove conversion we cannot use model-to-view element mapping because `data.item` may be
			// already mapped to another element (this happens when move change is converted).
			// In this case however, `viewPosition` is the position before view element that corresponds to removed model element.
			//
			// First, fix the position. Traverse the tree forward until the container element is found. The `viewPosition`
			// may be before a ui element, before attribute element or at the end of text element.
			viewPosition = viewPosition.getLastMatchingPosition( value => !value.item.is( 'containerElement' ) );

			if ( viewPosition.parent.is( 'text' ) && viewPosition.isAtEnd ) {
				viewPosition = __WEBPACK_IMPORTED_MODULE_4__view_position__["a" /* default */].createAfter( viewPosition.parent );
			}

			viewRange = __WEBPACK_IMPORTED_MODULE_3__view_range__["a" /* default */].createOn( viewPosition.nodeAfter );
		} else {
			// If removed item is a text node, we need to traverse view tree to find the view range to remove.
			// Range to remove will start `viewPosition` and should contain amount of characters equal to the amount of removed characters.
			const viewRangeEnd = _shiftViewPositionByCharacters( viewPosition, data.item.offsetSize );
			viewRange = new __WEBPACK_IMPORTED_MODULE_3__view_range__["a" /* default */]( viewPosition, viewRangeEnd );
		}

		// Trim the range to remove in case some UI elements are on the view range boundaries.
		__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].remove( viewRange.getTrimmed() );

		// Unbind this element only if it was moved to graveyard.
		// The dispatcher#remove event will also be fired if the element was moved to another place (remove+insert are fired).
		// Let's say that <b> is moved before <a>. The view will be changed like this:
		//
		// 1) start:    <a></a><b></b>
		// 2) insert:   <b (new)></b><a></a><b></b>
		// 3) remove:   <b (new)></b><a></a>
		//
		// If we'll unbind the <b> element in step 3 we'll also lose binding of the <b (new)> element in the view,
		// because unbindModelElement() cancels both bindings  (model <b> => view <b (new)>) and (view <b (new)> => model <b>).
		// We can't lose any of these.
		//
		// See #847.
		if ( data.item.root.rootName == '$graveyard' ) {
			conversionApi.mapper.unbindModelElement( data.item );
		}
	};
}

/**
 * Function factory, creates converter that converts all texts inside marker's range. Converter wraps each text with
 * {@link module:engine/view/attributeelement~AttributeElement} created from provided descriptor.
 * See {link module:engine/conversion/model-to-view-converters~highlightDescriptorToAttributeElement}.
 *
 * @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor|Function} highlightDescriptor
 * @return {Function}
 */
function highlightText( highlightDescriptor ) {
	return ( evt, data, consumable, conversionApi ) => {
		const descriptor = typeof highlightDescriptor == 'function' ?
			highlightDescriptor( data, consumable, conversionApi ) :
			highlightDescriptor;

		const modelItem = data.item;

		if ( !descriptor || data.markerRange.isCollapsed || !modelItem.is( 'textProxy' ) ) {
			return;
		}

		if ( !consumable.consume( modelItem, evt.name ) ) {
			return;
		}

		if ( !descriptor.id ) {
			descriptor.id = data.markerName;
		}

		const viewElement = createViewElementFromHighlightDescriptor( descriptor );
		const viewRange = conversionApi.mapper.toViewRange( data.range );

		if ( evt.name.split( ':' )[ 0 ] == 'addMarker' ) {
			__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].wrap( viewRange, viewElement );
		} else {
			__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].unwrap( viewRange, viewElement );
		}
	};
}

/**
 * Converter function factory. Creates a function which applies the marker's highlight to all elements inside a marker's range.
 * The converter checks if an element has the addHighlight and removeHighlight functions stored as
 * {@link module:engine/view/element~Element#setCustomProperty custom properties} and if so use them to apply the highlight.
 * In such case converter will consume all element's children, assuming that they were handled by element itself.
 * If the highlight descriptor will not provide priority, priority `10` will be used as default, to be compliant with
 * {@link module:engine/conversion/model-to-view-converters~highlightText} method which uses default priority of
 * {@link module:engine/view/attributeelement~AttributeElement}.
 *
 * If the highlight descriptor will not provide `id` property, name of the marker will be used.
 * When `addHighlight` and `removeHighlight` custom properties are not present, element is not converted
 * in any special way. This means that converters will proceed to convert element's child nodes.
 *
 * @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor|Function} highlightDescriptor
 * @return {Function}
 */
function highlightElement( highlightDescriptor ) {
	return ( evt, data, consumable, conversionApi ) => {
		const descriptor = typeof highlightDescriptor == 'function' ?
			highlightDescriptor( data, consumable, conversionApi ) :
			highlightDescriptor;

		const modelItem = data.item;

		if ( !descriptor || data.markerRange.isCollapsed || !modelItem.is( 'element' ) ) {
			return;
		}

		if ( !consumable.test( data.item, evt.name ) ) {
			return;
		}

		if ( !descriptor.priority ) {
			descriptor.priority = 10;
		}

		if ( !descriptor.id ) {
			descriptor.id = data.markerName;
		}

		const viewElement = conversionApi.mapper.toViewElement( modelItem );
		const addMarker = evt.name.split( ':' )[ 0 ] == 'addMarker';
		const highlightHandlingMethod = addMarker ? 'addHighlight' : 'removeHighlight';

		if ( viewElement && viewElement.getCustomProperty( highlightHandlingMethod ) ) {
			// Consume element itself.
			consumable.consume( data.item, evt.name );

			// Consume all children nodes.
			for ( const value of __WEBPACK_IMPORTED_MODULE_7__model_range__["a" /* default */].createIn( modelItem ) ) {
				consumable.consume( value.item, evt.name );
			}

			viewElement.getCustomProperty( highlightHandlingMethod )( viewElement, addMarker ? descriptor : descriptor.id );
		}
	};
}

/**
 * Function factory, creates a default model-to-view converter for removing {@link module:engine/view/uielement~UIElement ui element}
 * basing on marker remove change.
 *
 * @param {module:engine/view/uielement~UIElement|Function} elementCreator View ui element, or function returning
 * a view ui element, which will be used as a pattern when look for element to remove at the marker start position.
 * @returns {Function} Remove ui element converter.
 */
function removeUIElement( elementCreator ) {
	return ( evt, data, consumable, conversionApi ) => {
		let viewStartElement, viewEndElement;

		if ( elementCreator instanceof __WEBPACK_IMPORTED_MODULE_0__view_element__["a" /* default */] ) {
			viewStartElement = elementCreator.clone( true );
			viewEndElement = elementCreator.clone( true );
		} else {
			data.isOpening = true;
			viewStartElement = elementCreator( data, consumable, conversionApi );

			data.isOpening = false;
			viewEndElement = elementCreator( data, consumable, conversionApi );
		}

		if ( !viewStartElement || !viewEndElement ) {
			return;
		}

		const markerRange = data.markerRange;
		const eventName = evt.name;

		// If marker's range is collapsed - check if it can be consumed.
		if ( markerRange.isCollapsed && !consumable.consume( markerRange, eventName ) ) {
			return;
		}

		// Check if all items in the range can be consumed, and consume them.
		for ( const value of markerRange ) {
			if ( !consumable.consume( value.item, eventName ) ) {
				return;
			}
		}

		const viewRange = conversionApi.mapper.toViewRange( markerRange );

		// First remove closing element.
		__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].clear( viewRange.getEnlarged(), viewEndElement );

		// If closing and opening elements are not the same then remove opening element.
		if ( !viewStartElement.isSimilar( viewEndElement ) ) {
			__WEBPACK_IMPORTED_MODULE_6__view_writer__["a" /* default */].clear( viewRange.getEnlarged(), viewStartElement );
		}
	};
}

/**
 * Returns the consumable type that is to be consumed in an event, basing on that event name.
 *
 * @param {String} evtName Event name.
 * @returns {String} Consumable type.
 */
function eventNameToConsumableType( evtName ) {
	const parts = evtName.split( ':' );

	return parts[ 0 ] + ':' + parts[ 1 ];
}

// Helper function that shifts given view `position` in a way that returned position is after `howMany` characters compared
// to the original `position`.
// Because in view there might be view ui elements splitting text nodes, we cannot simply use `ViewPosition#getShiftedBy()`.
function _shiftViewPositionByCharacters( position, howMany ) {
	// Create a walker that will walk the view tree starting from given position and walking characters one-by-one.
	const walker = new __WEBPACK_IMPORTED_MODULE_5__view_treewalker__["a" /* default */]( { startPosition: position, singleCharacters: true } );
	// We will count visited characters and return the position after `howMany` characters.
	let charactersFound = 0;

	for ( const value of walker ) {
		if ( value.type == 'text' ) {
			charactersFound++;

			if ( charactersFound == howMany ) {
				return walker.position;
			}
		}
	}
}

/**
 * Creates `span` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from information
 * provided by {@link module:engine/conversion/model-to-view-converters~HighlightDescriptor} object. If priority
 * is not provided in descriptor - default priority will be used.
 *
 * @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor} descriptor
 * @return {module:engine/conversion/model-to-view-converters~HighlightAttributeElement}
 */
function createViewElementFromHighlightDescriptor( descriptor ) {
	const viewElement = new HighlightAttributeElement( 'span', descriptor.attributes );

	if ( descriptor.class ) {
		const cssClasses = Array.isArray( descriptor.class ) ? descriptor.class : [ descriptor.class ];
		viewElement.addClass( ...cssClasses );
	}

	if ( descriptor.priority ) {
		viewElement.priority = descriptor.priority;
	}

	viewElement.setCustomProperty( 'highlightDescriptorId', descriptor.id );

	return viewElement;
}

/**
 * Special kind of {@link module:engine/view/attributeelement~AttributeElement} that is created and used in
 * marker-to-highlight conversion.
 *
 * The difference between `HighlightAttributeElement` and {@link module:engine/view/attributeelement~AttributeElement}
 * is {@link module:engine/view/attributeelement~AttributeElement#isSimilar} method.
 *
 * For `HighlightAttributeElement` it checks just `highlightDescriptorId` custom property, that is set during marker-to-highlight
 * conversion basing on {@link module:engine/conversion/model-to-view-converters~HighlightDescriptor} object.
 * `HighlightAttributeElement`s with same `highlightDescriptorId` property are considered similar.
 */
class HighlightAttributeElement extends __WEBPACK_IMPORTED_MODULE_1__view_attributeelement__["a" /* default */] {
	isSimilar( otherElement ) {
		if ( otherElement.is( 'attributeElement' ) ) {
			return this.getCustomProperty( 'highlightDescriptorId' ) === otherElement.getCustomProperty( 'highlightDescriptorId' );
		}

		return false;
	}
}

/**
 * Object describing how the content highlight should be created in the view.
 *
 * Each text node contained in the highlight will be wrapped with `span` element with CSS class(es), attributes and priority
 * described by this object.
 *
 * Each element can handle displaying the highlight separately by providing `addHighlight` and `removeHighlight` custom
 * properties:
 *  * `HighlightDescriptor` is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to
 *  the element,
 *  * descriptor id is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight of given
 *  id from the element.
 *
 * @typedef {Object} module:engine/conversion/model-to-view-converters~HighlightDescriptor
 *
 * @property {String|Array.<String>} class CSS class or array of classes to set. If descriptor is used to
 * create {@link module:engine/view/attributeelement~AttributeElement} over text nodes, those classes will be set
 * on that {@link module:engine/view/attributeelement~AttributeElement}. If descriptor is applied to an element,
 * usually those class will be set on that element, however this depends on how the element converts the descriptor.
 *
 * @property {String} [id] Descriptor identifier. If not provided, defaults to converted marker's name.
 *
 * @property {Number} [priority] Descriptor priority. If not provided, defaults to `10`. If descriptor is used to create
 * {@link module:engine/view/attributeelement~AttributeElement}, it will be that element's
 * {@link module:engine/view/attributeelement~AttributeElement#priority}. If descriptor is applied to an element,
 * the priority will be used to determine which descriptor is more important.
 *
 * @property {Object} [attributes] Attributes to set. If descriptor is used to create
 * {@link module:engine/view/attributeelement~AttributeElement} over text nodes, those attributes will be set on that
 * {@link module:engine/view/attributeelement~AttributeElement}. If descriptor is applied to an element, usually those
 * attributes will be set on that element, however this depends on how the element converts the descriptor.
 */


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__element__ = __webpack_require__(9);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/attributeelement
 */



// Default attribute priority.
const DEFAULT_PRIORITY = 10;

/**
 * Attributes are elements which define document presentation. They are mostly elements like `<b>` or `<span>`.
 * Attributes can be broken and merged by the {@link module:engine/view/writer~writer view writer}.
 *
 * Editing engine does not define fixed HTML DTD. This is why the type of the {@link module:engine/view/element~Element} need to
 * be defined by the feature developer. Creating an element you should use {@link module:engine/view/containerelement~ContainerElement}
 * class or `AttributeElement`.
 *
 * @extends module:engine/view/element~Element
 */
class AttributeElement extends __WEBPACK_IMPORTED_MODULE_0__element__["a" /* default */] {
	/**
	 * Creates a attribute element.
	 *
	 * @see module:engine/view/element~Element
	 */
	constructor( name, attrs, children ) {
		super( name, attrs, children );

		/**
		 * Element priority. Attributes have to have the same priority to be
		 * {@link module:engine/view/element~Element#isSimilar similar}. Setting different priorities on similar
 		 * nodes may prevent merging, e.g. two `<abbr>` nodes next each other shouldn't be merged.
		 *
		 * @member {Number}
		 */
		this.priority = DEFAULT_PRIORITY;

		/**
		 * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.
		 *
		 * @method #getFillerOffset
		 * @returns {Number|null} Block filler offset or `null` if block filler is not needed.
		 */
		this.getFillerOffset = getFillerOffset;
	}

	/**
	 * @inheritDoc
	 */
	is( type, name = null ) {
		if ( !name ) {
			return type == 'attributeElement' || super.is( type );
		} else {
			return ( type == 'attributeElement' && name == this.name ) || super.is( type, name );
		}
	}

	/**
	 * Clones provided element with priority.
	 *
	 * @param {Boolean} deep If set to `true` clones element and all its children recursively. When set to `false`,
	 * element will be cloned without any children.
	 * @returns {module:engine/view/attributeelement~AttributeElement} Clone of this element.
	 */
	clone( deep ) {
		const cloned = super.clone( deep );

		// Clone priority too.
		cloned.priority = this.priority;

		return cloned;
	}

	/**
	 * Checks if this element is similar to other element.
	 * Both elements should have the same name, attributes and priority to be considered as similar.
	 * Two similar elements can contain different set of children nodes.
	 *
	 * @param {module:engine/view/element~Element} otherElement
	 * @returns {Boolean}
	 */
	isSimilar( otherElement ) {
		return super.isSimilar( otherElement ) && this.priority == otherElement.priority;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AttributeElement;


/**
 * Default attribute priority.
 *
 * @member {Number} module:engine/view/attributeelement~AttributeElement.DEFAULT_PRIORITY
 */
AttributeElement.DEFAULT_PRIORITY = DEFAULT_PRIORITY;

// Returns block {@link module:engine/view/filler~Filler filler} offset or `null` if block filler is not needed.
//
// @returns {Number|null} Block filler offset or `null` if block filler is not needed.
function getFillerOffset() {
	// <b>foo</b> does not need filler.
	if ( nonUiChildrenCount( this ) ) {
		return null;
	}

	let element = this.parent;

	// <p><b></b></p> needs filler -> <p><b><br></b></p>
	while ( element && element.is( 'attributeElement' ) ) {
		if ( nonUiChildrenCount( element ) > 1 ) {
			return null;
		}

		element = element.parent;
	}

	if ( !element || nonUiChildrenCount( element ) > 1 ) {
		return null;
	}

	// Render block filler at the end of element (after all ui elements).
	return this.childCount;
}

// Returns total count of children that are not {@link module:engine/view/uielement~UIElement UIElements}.
//
// @param {module:engine/view/element~Element} element
// @return {Number}
function nonUiChildrenCount( element ) {
	return Array.from( element.getChildren() ).filter( element => !element.is( 'uiElement' ) ).length;
}


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export breakAttributes */
/* unused harmony export breakContainer */
/* unused harmony export mergeAttributes */
/* unused harmony export mergeContainers */
/* unused harmony export insert */
/* unused harmony export remove */
/* unused harmony export clear */
/* unused harmony export move */
/* unused harmony export wrap */
/* unused harmony export wrapPosition */
/* unused harmony export unwrap */
/* unused harmony export rename */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__containerelement__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__attributeelement__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__emptyelement__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__uielement__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__text__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__range__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__documentfragment__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_isiterable__ = __webpack_require__(34);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module module:engine/view/writer
 */












/**
 * Contains functions used for composing view tree.
 *
 * @namespace writer
 */

const writer = {
	breakAttributes,
	breakContainer,
	mergeAttributes,
	mergeContainers,
	insert,
	remove,
	clear,
	move,
	wrap,
	wrapPosition,
	unwrap,
	rename
};

/* harmony default export */ __webpack_exports__["a"] = (writer);

/**
 * Breaks attribute nodes at provided position or at boundaries of provided range. It breaks attribute elements inside
 * up to a container element.
 *
 * In following examples `<p>` is a container, `<b>` and `<u>` are attribute nodes:
 *
 *		<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
 *		<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
 *		<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
 *		<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
 *
 * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.
 *
 * **Note:** Difference between {@link module:engine/view/writer~writer.breakAttributes breakAttributes} and
 * {@link module:engine/view/writer~writer.breakContainer breakContainer} is that `breakAttributes` breaks all
 * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`, up to the first
 * encountered {@link module:engine/view/containerelement~ContainerElement container element}. `breakContainer` assumes that given
 * `position`
 * is directly in container element and breaks that container element.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container`
 * when {@link module:engine/view/range~Range#start start}
 * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element`
 * when trying to break attributes
 * inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element`
 * when trying to break attributes
 * inside {@link module:engine/view/uielement~UIElement UIElement}.
 *
 * @see module:engine/view/attributeelement~AttributeElement
 * @see module:engine/view/containerelement~ContainerElement
 * @see module:engine/view/writer~writer.breakContainer
 * @function module:engine/view/writer~writer.breakAttributes
 * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange Position where to break attribute elements.
 * @returns {module:engine/view/position~Position|module:engine/view/range~Range} New position or range, after breaking the attribute
 * elements.
 */
function breakAttributes( positionOrRange ) {
	if ( positionOrRange instanceof __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */] ) {
		return _breakAttributes( positionOrRange );
	} else {
		return _breakAttributesRange( positionOrRange );
	}
}

/**
 * Breaks {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position. Position
 * has to be directly inside container element and cannot be in root. Does not break if position is at the beginning
 * or at the end of it's parent element.
 *
 *		<p>foo^bar</p> -> <p>foo</p><p>bar</p>
 *		<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
 *		<p>^foobar</p> -> ^<p>foobar</p>
 *		<p>foobar^</p> -> <p>foobar</p>^
 *
 * **Note:** Difference between {@link module:engine/view/writer~writer.breakAttributes breakAttributes} and
 * {@link module:engine/view/writer~writer.breakContainer breakContainer} is that `breakAttributes` breaks all
 * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`, up to the first
 * encountered {@link module:engine/view/containerelement~ContainerElement container element}. `breakContainer` assumes that given
 * `position`
 * is directly in container element and breaks that container element.
 *
 * @see module:engine/view/attributeelement~AttributeElement
 * @see module:engine/view/containerelement~ContainerElement
 * @see module:engine/view/writer~writer.breakAttributes
 * @function module:engine/view/writer~writer.breakContainer
 * @param {module:engine/view/position~Position} position Position where to break element.
 * @returns {module:engine/view/position~Position} Position between broken elements. If element has not been broken, the returned position
 * is placed either before it or after it.
 */
function breakContainer( position ) {
	const element = position.parent;

	if ( !( element.is( 'containerElement' ) ) ) {
		/**
		 * Trying to break an element which is not a container element.
		 *
		 * @error view-writer-break-non-container-element
		 */
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-break-non-container-element: Trying to break an element which is not a container element.' );
	}

	if ( !element.parent ) {
		/**
		 * Trying to break root element.
		 *
		 * @error view-writer-break-root
		 */
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-break-root: Trying to break root element.' );
	}

	if ( position.isAtStart ) {
		return __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createBefore( element );
	} else if ( !position.isAtEnd ) {
		const newElement = element.clone( false );

		insert( __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAfter( element ), newElement );

		const sourceRange = new __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */]( position, __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( element, 'end' ) );
		const targetPosition = new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( newElement, 0 );

		move( sourceRange, targetPosition );
	}

	return __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAfter( element );
}

/**
 * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.
 * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.
 *
 * In following examples `<p>` is a container and `<b>` is an attribute element:
 *
 *		<p>foo[]bar</p> -> <p>foo{}bar</p>
 *		<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>
 *		<p><b foo="bar">a</b>[]<b foo="baz">b</b></p> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b></p>
 *
 * It will also take care about empty attributes when merging:
 *
 *		<p><b>[]</b></p> -> <p>[]</p>
 *		<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
 *
 * **Note:** Difference between {@link module:engine/view/writer~writer.mergeAttributes mergeAttributes} and
 * {@link module:engine/view/writer~writer.mergeContainers mergeContainers} is that `mergeAttributes` merges two
 * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
 * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
 *
 * @see module:engine/view/attributeelement~AttributeElement
 * @see module:engine/view/containerelement~ContainerElement
 * @see module:engine/view/writer~writer.mergeContainers
 * @function module:engine/view/writer~writer.mergeAttributes
 * @param {module:engine/view/position~Position} position Merge position.
 * @returns {module:engine/view/position~Position} Position after merge.
 */
function mergeAttributes( position ) {
	const positionOffset = position.offset;
	const positionParent = position.parent;

	// When inside text node - nothing to merge.
	if ( positionParent.is( 'text' ) ) {
		return position;
	}

	// When inside empty attribute - remove it.
	if ( positionParent.is( 'attributeElement' ) && positionParent.childCount === 0 ) {
		const parent = positionParent.parent;
		const offset = positionParent.index;
		positionParent.remove();

		return mergeAttributes( new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( parent, offset ) );
	}

	const nodeBefore = positionParent.getChild( positionOffset - 1 );
	const nodeAfter = positionParent.getChild( positionOffset );

	// Position should be placed between two nodes.
	if ( !nodeBefore || !nodeAfter ) {
		return position;
	}

	// When position is between two text nodes.
	if ( nodeBefore.is( 'text' ) && nodeAfter.is( 'text' ) ) {
		return mergeTextNodes( nodeBefore, nodeAfter );
	}
	// When selection is between two same attribute elements.
	else if ( nodeBefore.is( 'attributeElement' ) && nodeAfter.is( 'attributeElement' ) && nodeBefore.isSimilar( nodeAfter ) ) {
		// Move all children nodes from node placed after selection and remove that node.
		const count = nodeBefore.childCount;
		nodeBefore.appendChildren( nodeAfter.getChildren() );
		nodeAfter.remove();

		// New position is located inside the first node, before new nodes.
		// Call this method recursively to merge again if needed.
		return mergeAttributes( new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( nodeBefore, count ) );
	}

	return position;
}

/**
 * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.
 * Precisely, the element after the position is removed and it's contents are moved to element before the position.
 *
 *		<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
 *		<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
 *
 * **Note:** Difference between {@link module:engine/view/writer~writer.mergeAttributes mergeAttributes} and
 * {@link module:engine/view/writer~writer.mergeContainers mergeContainers} is that `mergeAttributes` merges two
 * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
 * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
 *
 * @see module:engine/view/attributeelement~AttributeElement
 * @see module:engine/view/containerelement~ContainerElement
 * @see module:engine/view/writer~writer.mergeAttributes
 * @function module:engine/view/writer~writer.mergeContainers
 * @param {module:engine/view/position~Position} position Merge position.
 * @returns {module:engine/view/position~Position} Position after merge.
 */
function mergeContainers( position ) {
	const prev = position.nodeBefore;
	const next = position.nodeAfter;

	if ( !prev || !next || !prev.is( 'containerElement' ) || !next.is( 'containerElement' ) ) {
		/**
		 * Element before and after given position cannot be merged.
		 *
		 * @error view-writer-merge-containers-invalid-position
		 */
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-merge-containers-invalid-position: ' +
			'Element before and after given position cannot be merged.' );
	}

	const lastChild = prev.getChild( prev.childCount - 1 );
	const newPosition = lastChild instanceof __WEBPACK_IMPORTED_MODULE_5__text__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( lastChild, 'end' ) : __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( prev, 'end' );

	move( __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */].createIn( next ), __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( prev, 'end' ) );
	remove( __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */].createOn( next ) );

	return newPosition;
}

/**
 * Insert node or nodes at specified position. Takes care about breaking attributes before insertion
 * and merging them afterwards.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
 * contains instances that are not {@link module:engine/view/text~Text Texts},
 * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},
 * {@link module:engine/view/containerelement~ContainerElement ContainerElements},
 * {@link module:engine/view/emptyelement~EmptyElement EmptyElements} or
 * {@link module:engine/view/uielement~UIElement UIElements}.
 *
 * @function insert
 * @param {module:engine/view/position~Position} position Insertion position.
 * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|
 * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|
 * module:engine/view/uielement~UIElement|Iterable.<module:engine/view/text~Text|
 * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|
 * module:engine/view/emptyelement~EmptyElement|module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.
 * @returns {module:engine/view/range~Range} Range around inserted nodes.
 */
function insert( position, nodes ) {
	nodes = Object(__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_isiterable__["a" /* default */])( nodes ) ? [ ...nodes ] : [ nodes ];

	// Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.
	validateNodesToInsert( nodes );

	const container = getParentContainer( position );

	if ( !container ) {
		/**
		 * Position's parent container cannot be found.
		 *
		 * @error view-writer-invalid-position-container
		 */
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-invalid-position-container' );
	}

	const insertionPosition = _breakAttributes( position, true );

	const length = container.insertChildren( insertionPosition.offset, nodes );
	const endPosition = insertionPosition.getShiftedBy( length );
	const start = mergeAttributes( insertionPosition );

	// When no nodes were inserted - return collapsed range.
	if ( length === 0 ) {
		return new __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */]( start, start );
	} else {
		// If start position was merged - move end position.
		if ( !start.isEqual( insertionPosition ) ) {
			endPosition.offset--;
		}

		const end = mergeAttributes( endPosition );

		return new __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */]( start, end );
	}
}

/**
 * Removes provided range from the container.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
 * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
 * same parent container.
 *
 * @function module:engine/view/writer~writer.remove
 * @param {module:engine/view/range~Range} range Range to remove from container. After removing, it will be updated
 * to a collapsed range showing the new position.
 * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.
 */
function remove( range ) {
	validateRangeContainer( range );

	// If range is collapsed - nothing to remove.
	if ( range.isCollapsed ) {
		return new __WEBPACK_IMPORTED_MODULE_8__documentfragment__["a" /* default */]();
	}

	// Break attributes at range start and end.
	const { start: breakStart, end: breakEnd } = _breakAttributesRange( range, true );
	const parentContainer = breakStart.parent;

	const count = breakEnd.offset - breakStart.offset;

	// Remove nodes in range.
	const removed = parentContainer.removeChildren( breakStart.offset, count );

	// Merge after removing.
	const mergePosition = mergeAttributes( breakStart );
	range.start = mergePosition;
	range.end = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( mergePosition );

	// Return removed nodes.
	return new __WEBPACK_IMPORTED_MODULE_8__documentfragment__["a" /* default */]( removed );
}

/**
 * Removes matching elements from given range.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
 * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
 * same parent container.
 *
 * @function module:engine/view/writer~writer.clear
 * @param {module:engine/view/range~Range} range Range to clear.
 * @param {module:engine/view/element~Element} element Element to remove.
 */
function clear( range, element ) {
	validateRangeContainer( range );

	// Create walker on given range.
	// We walk backward because when we remove element during walk it modifies range end position.
	const walker = range.getWalker( {
		direction: 'backward',
		ignoreElementEnd: true
	} );

	// Let's walk.
	for ( const current of walker ) {
		const item = current.item;
		let rangeToRemove;

		// When current item matches to the given element.
		if ( item.is( 'element' ) && element.isSimilar( item ) ) {
			// Create range on this element.
			rangeToRemove = __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */].createOn( item );
		// When range starts inside Text or TextProxy element.
		} else if ( !current.nextPosition.isAfter( range.start ) && ( item.is( 'text' ) || item.is( 'textProxy' ) ) ) {
			// We need to check if parent of this text matches to given element.
			const parentElement = item.getAncestors().find( ancestor => {
				return ancestor.is( 'element' ) && element.isSimilar( ancestor );
			} );

			// If it is then create range inside this element.
			if ( parentElement ) {
				rangeToRemove = __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */].createIn( parentElement );
			}
		}

		// If we have found element to remove.
		if ( rangeToRemove ) {
			// We need to check if element range stick out of the given range and truncate if it is.
			if ( rangeToRemove.end.isAfter( range.end ) ) {
				rangeToRemove.end = range.end;
			}

			if ( rangeToRemove.start.isBefore( range.start ) ) {
				rangeToRemove.start = range.start;
			}

			// At the end we remove range with found element.
			remove( rangeToRemove );
		}
	}
}

/**
 * Moves nodes from provided range to target position.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
 * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
 * same parent container.
 *
 * @function module:engine/view/writer~writer.move
 * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.
 * @param {module:engine/view/position~Position} targetPosition Position to insert.
 * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between
 * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.
 */
function move( sourceRange, targetPosition ) {
	let nodes;

	if ( targetPosition.isAfter( sourceRange.end ) ) {
		targetPosition = _breakAttributes( targetPosition, true );

		const parent = targetPosition.parent;
		const countBefore = parent.childCount;

		sourceRange = _breakAttributesRange( sourceRange, true );

		nodes = remove( sourceRange );

		targetPosition.offset += ( parent.childCount - countBefore );
	} else {
		nodes = remove( sourceRange );
	}

	return insert( targetPosition, nodes );
}

/**
 * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`
 * when {@link module:engine/view/range~Range#start}
 * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.
 * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
 * an instance of {module:engine/view/attributeelement~AttributeElement AttributeElement}.
 *
 * @function module:engine/view/writer~writer.wrap
 * @param {module:engine/view/range~Range} range Range to wrap.
 * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.
 */
function wrap( range, attribute ) {
	if ( !( attribute instanceof __WEBPACK_IMPORTED_MODULE_2__attributeelement__["a" /* default */] ) ) {
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-wrap-invalid-attribute' );
	}

	validateRangeContainer( range );

	// If range is collapsed - nothing to wrap.
	if ( range.isCollapsed ) {
		return range;
	}

	// Range around one element.
	if ( range.end.isEqual( range.start.getShiftedBy( 1 ) ) ) {
		const node = range.start.nodeAfter;

		if ( node instanceof __WEBPACK_IMPORTED_MODULE_2__attributeelement__["a" /* default */] && wrapAttributeElement( attribute, node ) ) {
			return range;
		}
	}

	// Range is inside single attribute and spans on all children.
	if ( rangeSpansOnAllChildren( range ) && wrapAttributeElement( attribute, range.start.parent ) ) {
		const parent = range.start.parent.parent;
		const index = range.start.parent.index;

		return __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */].createFromParentsAndOffsets( parent, index, parent, index + 1 );
	}

	// Break attributes at range start and end.
	const { start: breakStart, end: breakEnd } = _breakAttributesRange( range, true );
	const parentContainer = breakStart.parent;

	// Unwrap children located between break points.
	const unwrappedRange = unwrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );

	// Wrap all children with attribute.
	const newRange = wrapChildren( parentContainer, unwrappedRange.start.offset, unwrappedRange.end.offset, attribute );

	// Merge attributes at the both ends and return a new range.
	const start = mergeAttributes( newRange.start );

	// If start position was merged - move end position back.
	if ( !start.isEqual( newRange.start ) ) {
		newRange.end.offset--;
	}
	const end = mergeAttributes( newRange.end );

	return new __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */]( start, end );
}

/**
 * Wraps position with provided attribute. Returns new position after wrapping. This method will also merge newly
 * added attribute with its siblings whenever possible.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
 * an instance of {module:engine/view/attributeelement~AttributeElement AttributeElement}.
 *
 * @param {module:engine/view/position~Position} position
 * @param {module:engine/view/attributeelement~AttributeElement} attribute
 * @returns {module:engine/view/position~Position} New position after wrapping.
 */
function wrapPosition( position, attribute ) {
	if ( !( attribute instanceof __WEBPACK_IMPORTED_MODULE_2__attributeelement__["a" /* default */] ) ) {
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-wrap-invalid-attribute' );
	}

	// Return same position when trying to wrap with attribute similar to position parent.
	if ( attribute.isSimilar( position.parent ) ) {
		return movePositionToTextNode( __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( position ) );
	}

	// When position is inside text node - break it and place new position between two text nodes.
	if ( position.parent.is( 'text' ) ) {
		position = breakTextNode( position );
	}

	// Create fake element that will represent position, and will not be merged with other attributes.
	const fakePosition = new __WEBPACK_IMPORTED_MODULE_2__attributeelement__["a" /* default */]();
	fakePosition.priority = Number.POSITIVE_INFINITY;
	fakePosition.isSimilar = () => false;

	// Insert fake element in position location.
	position.parent.insertChildren( position.offset, fakePosition );

	// Range around inserted fake attribute element.
	const wrapRange = new __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */]( position, position.getShiftedBy( 1 ) );

	// Wrap fake element with attribute (it will also merge if possible).
	wrap( wrapRange, attribute );

	// Remove fake element and place new position there.
	const newPosition = new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( fakePosition.parent, fakePosition.index );
	fakePosition.remove();

	// If position is placed between text nodes - merge them and return position inside.
	const nodeBefore = newPosition.nodeBefore;
	const nodeAfter = newPosition.nodeAfter;

	if ( nodeBefore instanceof __WEBPACK_IMPORTED_MODULE_5__text__["a" /* default */] && nodeAfter instanceof __WEBPACK_IMPORTED_MODULE_5__text__["a" /* default */] ) {
		return mergeTextNodes( nodeBefore, nodeAfter );
	}

	// If position is next to text node - move position inside.
	return movePositionToTextNode( newPosition );
}

/**
 * Unwraps nodes within provided range from attribute element.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
 * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
 * same parent container.
 *
 * @param {module:engine/view/range~Range} range
 * @param {module:engine/view/attributeelement~AttributeElement} element
 */
function unwrap( range, attribute ) {
	if ( !( attribute instanceof __WEBPACK_IMPORTED_MODULE_2__attributeelement__["a" /* default */] ) ) {
		/**
		 * Attribute element need to be instance of attribute element.
		 *
		 * @error view-writer-unwrap-invalid-attribute
		 */
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-unwrap-invalid-attribute' );
	}

	validateRangeContainer( range );

	// If range is collapsed - nothing to unwrap.
	if ( range.isCollapsed ) {
		return range;
	}

	// Range around one element - check if AttributeElement can be unwrapped partially when it's not similar.
	// For example:
	// <b class="foo bar" title="baz"></b> unwrap with:	<b class="foo"></p> result: <b class"bar" title="baz"></b>
	if ( range.end.isEqual( range.start.getShiftedBy( 1 ) ) ) {
		const node = range.start.nodeAfter;

		// Unwrap single attribute element.
		if ( !attribute.isSimilar( node ) && node instanceof __WEBPACK_IMPORTED_MODULE_2__attributeelement__["a" /* default */] && unwrapAttributeElement( attribute, node ) ) {
			return range;
		}
	}

	// Break attributes at range start and end.
	const { start: breakStart, end: breakEnd } = _breakAttributesRange( range, true );
	const parentContainer = breakStart.parent;

	// Unwrap children located between break points.
	const newRange = unwrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );

	// Merge attributes at the both ends and return a new range.
	const start = mergeAttributes( newRange.start );

	// If start position was merged - move end position back.
	if ( !start.isEqual( newRange.start ) ) {
		newRange.end.offset--;
	}
	const end = mergeAttributes( newRange.end );

	return new __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */]( start, end );
}

/**
 * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
 * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which
 * has renamed element as {@link module:engine/view/position~Position#parent a parent}.
 *
 * New element has to be created because `Element#tagName` property in DOM is readonly.
 *
 * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
 *
 * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.
 * @param {String} newName New name for element.
 */
function rename( viewElement, newName ) {
	const newElement = new __WEBPACK_IMPORTED_MODULE_1__containerelement__["a" /* default */]( newName, viewElement.getAttributes() );

	insert( __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAfter( viewElement ), newElement );
	move( __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */].createIn( viewElement ), __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( newElement ) );
	remove( __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */].createOn( viewElement ) );

	return newElement;
}

/**
 * Attribute element need to be instance of attribute element.
 *
 * @error view-writer-wrap-invalid-attribute
 */

// Returns first parent container of specified {@link module:engine/view/position~Position Position}.
// Position's parent node is checked as first, then next parents are checked.
// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.
//
// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.
// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}
// Parent container element or `undefined` if container is not found.
function getParentContainer( position ) {
	let parent = position.parent;

	while ( !isContainerOrFragment( parent ) ) {
		if ( !parent ) {
			return undefined;
		}
		parent = parent.parent;
	}

	return parent;
}

// Function used by both public breakAttributes (without splitting text nodes) and by other methods (with
// splitting text nodes).
//
// @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.
// @param {Boolean} [forceSplitText = false] If set to `true`, will break text nodes even if they are directly in
// container element. This behavior will result in incorrect view state, but is needed by other view writing methods
// which then fixes view state. Defaults to `false`.
// @returns {module:engine/view/range~Range} New range with located at break positions.
function _breakAttributesRange( range, forceSplitText = false ) {
	const rangeStart = range.start;
	const rangeEnd = range.end;

	validateRangeContainer( range );

	// Break at the collapsed position. Return new collapsed range.
	if ( range.isCollapsed ) {
		const position = _breakAttributes( range.start, forceSplitText );

		return new __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */]( position, position );
	}

	const breakEnd = _breakAttributes( rangeEnd, forceSplitText );
	const count = breakEnd.parent.childCount;
	const breakStart = _breakAttributes( rangeStart, forceSplitText );

	// Calculate new break end offset.
	breakEnd.offset += breakEnd.parent.childCount - count;

	return new __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */]( breakStart, breakEnd );
}

// Function used by public breakAttributes (without splitting text nodes) and by other methods (with
// splitting text nodes).
//
// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position
// is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
//
// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position
// is placed inside {@link module:engine/view/uielement~UIElement UIElement}.
//
// @param {module:engine/view/position~Position} position Position where to break attributes.
// @param {Boolean} [forceSplitText = false] If set to `true`, will break text nodes even if they are directly in
// container element. This behavior will result in incorrect view state, but is needed by other view writing methods
// which then fixes view state. Defaults to `false`.
// @returns {module:engine/view/position~Position} New position after breaking the attributes.
function _breakAttributes( position, forceSplitText = false ) {
	const positionOffset = position.offset;
	const positionParent = position.parent;

	// If position is placed inside EmptyElement - throw an exception as we cannot break inside.
	if ( position.parent.is( 'emptyElement' ) ) {
		/**
		 * Cannot break inside EmptyElement instance.
		 *
		 * @error view-writer-cannot-break-empty-element
		 */
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-cannot-break-empty-element' );
	}

	// If position is placed inside UIElement - throw an exception as we cannot break inside.
	if ( position.parent.is( 'uiElement' ) ) {
		/**
		 * Cannot break inside UIElement instance.
		 *
		 * @error view-writer-cannot-break-ui-element
		 */
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-cannot-break-ui-element' );
	}

	// There are no attributes to break and text nodes breaking is not forced.
	if ( !forceSplitText && positionParent.is( 'text' ) && isContainerOrFragment( positionParent.parent ) ) {
		return __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( position );
	}

	// Position's parent is container, so no attributes to break.
	if ( isContainerOrFragment( positionParent ) ) {
		return __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( position );
	}

	// Break text and start again in new position.
	if ( positionParent.is( 'text' ) ) {
		return _breakAttributes( breakTextNode( position ), forceSplitText );
	}

	const length = positionParent.childCount;

	// <p>foo<b><u>bar{}</u></b></p>
	// <p>foo<b><u>bar</u>[]</b></p>
	// <p>foo<b><u>bar</u></b>[]</p>
	if ( positionOffset == length ) {
		const newPosition = new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( positionParent.parent, positionParent.index + 1 );

		return _breakAttributes( newPosition, forceSplitText );
	} else
	// <p>foo<b><u>{}bar</u></b></p>
	// <p>foo<b>[]<u>bar</u></b></p>
	// <p>foo{}<b><u>bar</u></b></p>
	if ( positionOffset === 0 ) {
		const newPosition = new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( positionParent.parent, positionParent.index );

		return _breakAttributes( newPosition, forceSplitText );
	}
	// <p>foo<b><u>b{}ar</u></b></p>
	// <p>foo<b><u>b[]ar</u></b></p>
	// <p>foo<b><u>b</u>[]<u>ar</u></b></p>
	// <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
	else {
		const offsetAfter = positionParent.index + 1;

		// Break element.
		const clonedNode = positionParent.clone();

		// Insert cloned node to position's parent node.
		positionParent.parent.insertChildren( offsetAfter, clonedNode );

		// Get nodes to move.
		const count = positionParent.childCount - positionOffset;
		const nodesToMove = positionParent.removeChildren( positionOffset, count );

		// Move nodes to cloned node.
		clonedNode.appendChildren( nodesToMove );

		// Create new position to work on.
		const newPosition = new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( positionParent.parent, offsetAfter );

		return _breakAttributes( newPosition, forceSplitText );
	}
}

// Unwraps children from provided `attribute`. Only children contained in `parent` element between
// `startOffset` and `endOffset` will be unwrapped.
//
// @param {module:engine/view/element~Element} parent
// @param {Number} startOffset
// @param {Number} endOffset
// @param {module:engine/view/element~Element} attribute
function unwrapChildren( parent, startOffset, endOffset, attribute ) {
	let i = startOffset;
	const unwrapPositions = [];

	// Iterate over each element between provided offsets inside parent.
	while ( i < endOffset ) {
		const child = parent.getChild( i );

		// If attributes are the similar, then unwrap.
		if ( child.isSimilar( attribute ) ) {
			const unwrapped = child.getChildren();
			const count = child.childCount;

			// Replace wrapper element with its children
			child.remove();
			parent.insertChildren( i, unwrapped );

			// Save start and end position of moved items.
			unwrapPositions.push(
				new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( parent, i ),
				new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( parent, i + count )
			);

			// Skip elements that were unwrapped. Assuming that there won't be another element to unwrap in child
			// elements.
			i += count;
			endOffset += count - 1;
		} else {
			// If other nested attribute is found start unwrapping there.
			if ( child.is( 'attributeElement' ) ) {
				unwrapChildren( child, 0, child.childCount, attribute );
			}

			i++;
		}
	}

	// Merge at each unwrap.
	let offsetChange = 0;

	for ( const position of unwrapPositions ) {
		position.offset -= offsetChange;

		// Do not merge with elements outside selected children.
		if ( position.offset == startOffset || position.offset == endOffset ) {
			continue;
		}

		const newPosition = mergeAttributes( position );

		// If nodes were merged - other merge offsets will change.
		if ( !newPosition.isEqual( position ) ) {
			offsetChange++;
			endOffset--;
		}
	}

	return __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */].createFromParentsAndOffsets( parent, startOffset, parent, endOffset );
}

// Wraps children with provided `attribute`. Only children contained in `parent` element between
// `startOffset` and `endOffset` will be wrapped.
//
// @param {module:engine/view/element~Element} parent
// @param {Number} startOffset
// @param {Number} endOffset
// @param {module:engine/view/element~Element} attribute
function wrapChildren( parent, startOffset, endOffset, attribute ) {
	let i = startOffset;
	const wrapPositions = [];

	while ( i < endOffset ) {
		const child = parent.getChild( i );
		const isText = child.is( 'text' );
		const isAttribute = child.is( 'attributeElement' );
		const isEmpty = child.is( 'emptyElement' );
		const isUI = child.is( 'uiElement' );

		// Wrap text, empty elements, ui elements or attributes with higher or equal priority.
		if ( isText || isEmpty || isUI || ( isAttribute && shouldABeOutsideB( attribute, child ) ) ) {
			// Clone attribute.
			const newAttribute = attribute.clone();

			// Wrap current node with new attribute;
			child.remove();
			newAttribute.appendChildren( child );
			parent.insertChildren( i, newAttribute );

			wrapPositions.push(	new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( parent, i ) );
		}
		// If other nested attribute is found start wrapping there.
		else if ( isAttribute ) {
			wrapChildren( child, 0, child.childCount, attribute );
		}

		i++;
	}

	// Merge at each wrap.
	let offsetChange = 0;

	for ( const position of wrapPositions ) {
		position.offset -= offsetChange;

		// Do not merge with elements outside selected children.
		if ( position.offset == startOffset ) {
			continue;
		}

		const newPosition = mergeAttributes( position );

		// If nodes were merged - other merge offsets will change.
		if ( !newPosition.isEqual( position ) ) {
			offsetChange++;
			endOffset--;
		}
	}

	return __WEBPACK_IMPORTED_MODULE_6__range__["a" /* default */].createFromParentsAndOffsets( parent, startOffset, parent, endOffset );
}

// Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function
// can be wrapped otuside second element. It is done by comparing elements'
// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority
// {@link module:engine/view/element~Element#getIdentity identities} are compared.
//
// @param {module:engine/view/attributeelement~AttributeElement} a
// @param {module:engine/view/attributeelement~AttributeElement} b
// @returns {Boolean}
function shouldABeOutsideB( a, b ) {
	if ( a.priority < b.priority ) {
		return true;
	} else if ( a.priority > b.priority ) {
		return false;
	}

	// When priorities are equal and names are different - use identities.
	return a.getIdentity() < b.getIdentity();
}

// Returns new position that is moved to near text node. Returns same position if there is no text node before of after
// specified position.
//
//		<p>foo[]</p>  ->  <p>foo{}</p>
//		<p>[]foo</p>  ->  <p>{}foo</p>
//
// @param {module:engine/view/position~Position} position
// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes
// before or after position location.
function movePositionToTextNode( position ) {
	const nodeBefore = position.nodeBefore;

	if ( nodeBefore && nodeBefore.is( 'text' ) ) {
		return new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( nodeBefore, nodeBefore.data.length );
	}

	const nodeAfter = position.nodeAfter;

	if ( nodeAfter && nodeAfter.is( 'text' ) ) {
		return new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( nodeAfter, 0 );
	}

	return position;
}

// Breaks text node into two text nodes when possible.
//
//		<p>foo{}bar</p> -> <p>foo[]bar</p>
//		<p>{}foobar</p> -> <p>[]foobar</p>
//		<p>foobar{}</p> -> <p>foobar[]</p>
//
// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.
// @returns {module:engine/view/position~Position} New position after breaking text node.
function breakTextNode( position ) {
	if ( position.offset == position.parent.data.length ) {
		return new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( position.parent.parent, position.parent.index + 1 );
	}

	if ( position.offset === 0 ) {
		return new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( position.parent.parent, position.parent.index );
	}

	// Get part of the text that need to be moved.
	const textToMove = position.parent.data.slice( position.offset );

	// Leave rest of the text in position's parent.
	position.parent.data = position.parent.data.slice( 0, position.offset );

	// Insert new text node after position's parent text node.
	position.parent.parent.insertChildren( position.parent.index + 1, new __WEBPACK_IMPORTED_MODULE_5__text__["a" /* default */]( textToMove ) );

	// Return new position between two newly created text nodes.
	return new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( position.parent.parent, position.parent.index + 1 );
}

// Merges two text nodes into first node. Removes second node and returns merge position.
//
// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of
// this text node.
// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.
// @returns {module:engine/view/position~Position} Position after merging text nodes.
function mergeTextNodes( t1, t2 ) {
	// Merge text data into first text node and remove second one.
	const nodeBeforeLength = t1.data.length;
	t1.data += t2.data;
	t2.remove();

	return new __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */]( t1, nodeBeforeLength );
}

// Wraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by merging them if possible.
// When merging is possible - all attributes, styles and classes are moved from wrapper element to element being
// wrapped.
//
// @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.
// @param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.
// @returns {Boolean} Returns `true` if elements are merged.
function wrapAttributeElement( wrapper, toWrap ) {
	// Can't merge if name or priority differs.
	if ( wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority ) {
		return false;
	}

	// Check if attributes can be merged.
	for ( const key of wrapper.getAttributeKeys() ) {
		// Classes and styles should be checked separately.
		if ( key === 'class' || key === 'style' ) {
			continue;
		}

		// If some attributes are different we cannot wrap.
		if ( toWrap.hasAttribute( key ) && toWrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {
			return false;
		}
	}

	// Check if styles can be merged.
	for ( const key of wrapper.getStyleNames() ) {
		if ( toWrap.hasStyle( key ) && toWrap.getStyle( key ) !== wrapper.getStyle( key ) ) {
			return false;
		}
	}

	// Move all attributes/classes/styles from wrapper to wrapped AttributeElement.
	for ( const key of wrapper.getAttributeKeys() ) {
		// Classes and styles should be checked separately.
		if ( key === 'class' || key === 'style' ) {
			continue;
		}

		// Move only these attributes that are not present - other are similar.
		if ( !toWrap.hasAttribute( key ) ) {
			toWrap.setAttribute( key, wrapper.getAttribute( key ) );
		}
	}

	for ( const key of wrapper.getStyleNames() ) {
		if ( !toWrap.hasStyle( key ) ) {
			toWrap.setStyle( key, wrapper.getStyle( key ) );
		}
	}

	for ( const key of wrapper.getClassNames() ) {
		if ( !toWrap.hasClass( key ) ) {
			toWrap.addClass( key );
		}
	}

	return true;
}

// Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing corresponding attributes,
// classes and styles. All attributes, classes and styles from wrapper should be present inside element being unwrapped.
//
// @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.
// @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.
// @returns {Boolean} Returns `true` if elements are unwrapped.
function unwrapAttributeElement( wrapper, toUnwrap ) {
	// Can't unwrap if name or priority differs.
	if ( wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority ) {
		return false;
	}

	// Check if AttributeElement has all wrapper attributes.
	for ( const key of wrapper.getAttributeKeys() ) {
		// Classes and styles should be checked separately.
		if ( key === 'class' || key === 'style' ) {
			continue;
		}

		// If some attributes are missing or different we cannot unwrap.
		if ( !toUnwrap.hasAttribute( key ) || toUnwrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {
			return false;
		}
	}

	// Check if AttributeElement has all wrapper classes.
	if ( !toUnwrap.hasClass( ...wrapper.getClassNames() ) ) {
		return false;
	}

	// Check if AttributeElement has all wrapper styles.
	for ( const key of wrapper.getStyleNames() ) {
		// If some styles are missing or different we cannot unwrap.
		if ( !toUnwrap.hasStyle( key ) || toUnwrap.getStyle( key ) !== wrapper.getStyle( key ) ) {
			return false;
		}
	}

	// Remove all wrapper's attributes from unwrapped element.
	for ( const key of wrapper.getAttributeKeys() ) {
		// Classes and styles should be checked separately.
		if ( key === 'class' || key === 'style' ) {
			continue;
		}

		toUnwrap.removeAttribute( key );
	}

	// Remove all wrapper's classes from unwrapped element.
	toUnwrap.removeClass( ...wrapper.getClassNames() );

	// Remove all wrapper's styles from unwrapped element.
	toUnwrap.removeStyle( ...wrapper.getStyleNames() );

	return true;
}

// Returns `true` if range is located in same {@link module:engine/view/attributeelement~AttributeElement AttributeElement}
// (`start` and `end` positions are located inside same {@link module:engine/view/attributeelement~AttributeElement AttributeElement}),
// starts on 0 offset and ends after last child node.
//
// @param {module:engine/view/range~Range} Range
// @returns {Boolean}
function rangeSpansOnAllChildren( range ) {
	return range.start.parent == range.end.parent && range.start.parent.is( 'attributeElement' ) &&
		range.start.offset === 0 && range.end.offset === range.start.parent.childCount;
}

// Checks if provided nodes are valid to insert. Checks if each node is an instance of
// {@link module:engine/view/text~Text Text} or {@link module:engine/view/attributeelement~AttributeElement AttributeElement},
// {@link module:engine/view/containerelement~ContainerElement ContainerElement},
// {@link module:engine/view/emptyelement~EmptyElement EmptyElement} or
// {@link module:engine/view/uielement~UIElement UIElement}.
//
// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
// contains instances that are not {@link module:engine/view/text~Text Texts},
// {@link module:engine/view/emptyelement~EmptyElement EmptyElements},
// {@link module:engine/view/uielement~UIElement UIElements},
// {@link module:engine/view/attributeelement~AttributeElement AttributeElements} or
// {@link module:engine/view/containerelement~ContainerElement ContainerElements}.
//
// @param Iterable.<module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement
// |module:engine/view/containerelement~ContainerElement> nodes
function validateNodesToInsert( nodes ) {
	for ( const node of nodes ) {
		if ( !validNodesToInsert.some( ( validNode => node instanceof validNode ) ) ) { // eslint-disable-line no-use-before-define
			/**
			 * Inserted nodes should be valid to insert. of {@link module:engine/view/attributeelement~AttributeElement AttributeElement},
			 * {@link module:engine/view/containerelement~ContainerElement ContainerElement},
			 * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},
			 * {@link module:engine/view/uielement~UIElement UIElement}, {@link module:engine/view/text~Text Text}.
			 *
			 * @error view-writer-insert-invalid-node
			 */
			throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-insert-invalid-node' );
		}

		if ( !node.is( 'text' ) ) {
			validateNodesToInsert( node.getChildren() );
		}
	}
}

const validNodesToInsert = [ __WEBPACK_IMPORTED_MODULE_5__text__["a" /* default */], __WEBPACK_IMPORTED_MODULE_2__attributeelement__["a" /* default */], __WEBPACK_IMPORTED_MODULE_1__containerelement__["a" /* default */], __WEBPACK_IMPORTED_MODULE_3__emptyelement__["a" /* default */], __WEBPACK_IMPORTED_MODULE_4__uielement__["a" /* default */] ];

// Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.
//
// @param {module:engine/view/node~Node} node
// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.
function isContainerOrFragment( node ) {
	return node && ( node.is( 'containerElement' ) || node.is( 'documentFragment' ) );
}

// Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed
// inside same {@link module:engine/view/containerelement~ContainerElement container element}.
// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.
//
// @param {module:engine/view/range~Range} range
function validateRangeContainer( range ) {
	const startContainer = getParentContainer( range.start );
	const endContainer = getParentContainer( range.end );

	if ( !startContainer || !endContainer || startContainer !== endContainer ) {
		/**
		 * Range container is invalid. This can happen if {@link module:engine/view/range~Range#start range start} and
		 * {@link module:engine/view/range~Range#end range end} positions are not placed inside same container or
		 * parent container for these positions cannot be found.
		 *
		 * @error view-writer-invalid-range-container
		 */
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-writer-invalid-range-container' );
	}
}


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__operation__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__writer__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_lib_lodash_isEqual__ = __webpack_require__(370);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/attributeoperation
 */







/**
 * Operation to change nodes' attribute.
 *
 * Using this class you can add, remove or change value of the attribute.
 *
 * @extends module:engine/model/operation/operation~Operation
 */
class AttributeOperation extends __WEBPACK_IMPORTED_MODULE_0__operation__["a" /* default */] {
	/**
	 * Creates an operation that changes, removes or adds attributes.
	 *
	 * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not
	 * have an attribute with the same key as the added attribute.
	 *
	 * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range
	 * must have an attribute with that key added.
	 *
	 * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in
	 * operation's ranges must already have an attribute with given key and `oldValue` as value
	 *
	 * @param {module:engine/model/range~Range} range Range on which the operation should be applied.
	 * @param {String} key Key of an attribute to change or remove.
	 * @param {*} oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
	 * @param {*} newValue New value of the attribute with given key or `null`, if operation should remove attribute.
	 * @param {Number} baseVersion {@link module:engine/model/document~Document#version} on which the operation can be applied.
	 */
	constructor( range, key, oldValue, newValue, baseVersion ) {
		super( baseVersion );

		/**
		 * Range on which operation should be applied.
		 *
		 * @readonly
		 * @member {module:engine/model/range~Range}
		 */
		this.range = __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createFromRange( range );

		/**
		 * Key of an attribute to change or remove.
		 *
		 * @readonly
		 * @member {String}
		 */
		this.key = key;

		/**
		 * Old value of the attribute with given key or `null`, if attribute was not set before.
		 *
		 * @readonly
		 * @member {*}
		 */
		this.oldValue = oldValue === undefined ? null : oldValue;

		/**
		 * New value of the attribute with given key or `null`, if operation should remove attribute.
		 *
		 * @readonly
		 * @member {*}
		 */
		this.newValue = newValue === undefined ? null : newValue;
	}

	/**
	 * @inheritDoc
	 */
	get type() {
		if ( this.oldValue === null ) {
			return 'addAttribute';
		} else if ( this.newValue === null ) {
			return 'removeAttribute';
		} else {
			return 'changeAttribute';
		}
	}

	/**
	 * Creates and returns an operation that has the same parameters as this operation.
	 *
	 * @returns {module:engine/model/operation/attributeoperation~AttributeOperation} Clone of this operation.
	 */
	clone() {
		return new AttributeOperation( this.range, this.key, this.oldValue, this.newValue, this.baseVersion );
	}

	/**
	 * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
	 *
	 * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}
	 */
	getReversed() {
		return new AttributeOperation( this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1 );
	}

	/**
	 * @inheritDoc
	 */
	_execute() {
		// Validation.
		for ( const item of this.range.getItems() ) {
			if ( this.oldValue !== null && !Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_lib_lodash_isEqual__["a" /* default */])( item.getAttribute( this.key ), this.oldValue ) ) {
				/**
				 * Changed node has different attribute value than operation's old attribute value.
				 *
				 * @error operation-attribute-wrong-old-value
				 * @param {module:engine/model/item~Item} item
				 * @param {String} key
				 * @param {*} value
				 */
				throw new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
					'attribute-operation-wrong-old-value: Changed node has different attribute value than operation\'s ' +
					'old attribute value.',
					{ item, key: this.key, value: this.oldValue }
				);
			}

			if ( this.oldValue === null && this.newValue !== null && item.hasAttribute( this.key ) ) {
				/**
				 * The attribute with given key already exists for the given node.
				 *
				 * @error attribute-operation-attribute-exists
				 * @param {module:engine/model/node~Node} node
				 * @param {String} key
				 */
				throw new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
					'attribute-operation-attribute-exists: The attribute with given key already exists.',
					{ node: item, key: this.key }
				);
			}
		}

		// If value to set is same as old value, don't do anything.
		if ( !Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_lib_lodash_isEqual__["a" /* default */])( this.oldValue, this.newValue ) ) {
			// Execution.
			__WEBPACK_IMPORTED_MODULE_3__writer__["a" /* default */].setAttribute( this.range, this.key, this.newValue );
		}

		return { range: this.range, key: this.key, oldValue: this.oldValue, newValue: this.newValue };
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.operation.AttributeOperation';
	}

	/**
	 * Creates `AttributeOperation` object from deserilized object, i.e. from parsed JSON string.
	 *
	 * @param {Object} json Deserialized JSON object.
	 * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
	 * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}
	 */
	static fromJSON( json, document ) {
		return new AttributeOperation( __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].fromJSON( json.range, document ), json.key, json.oldValue, json.newValue, json.baseVersion );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AttributeOperation;



/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsEqualDeep__ = __webpack_require__(371);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObject__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike__ = __webpack_require__(43);




/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!Object(__WEBPACK_IMPORTED_MODULE_1__isObject__["a" /* default */])(value) && !Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike__["a" /* default */])(other))) {
    return value !== value && other !== other;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseIsEqualDeep__["a" /* default */])(value, other, baseIsEqual, customizer, bitmask, stack);
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsEqual);


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MapCache__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__setCacheAdd__ = __webpack_require__(372);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__setCacheHas__ = __webpack_require__(373);




/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new __WEBPACK_IMPORTED_MODULE_0__MapCache__["a" /* default */];
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = __WEBPACK_IMPORTED_MODULE_1__setCacheAdd__["a" /* default */];
SetCache.prototype.has = __WEBPACK_IMPORTED_MODULE_2__setCacheHas__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (SetCache);


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__moveoperation__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__removeoperation__ = __webpack_require__(40);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/reinsertoperation
 */




/**
 * Operation to reinsert previously removed nodes back to the non-graveyard root. This operation acts like
 * {@link module:engine/model/operation/moveoperation~MoveOperation} but it returns
 * {@link module:engine/model/operation/removeoperation~RemoveOperation} when reversed
 * and fires different change event.
 */
class ReinsertOperation extends __WEBPACK_IMPORTED_MODULE_0__moveoperation__["a" /* default */] {
	/**
	 * Position where nodes will be re-inserted.
	 *
	 * @type {module:engine/model/position~Position}
	 */
	get position() {
		return this.targetPosition;
	}

	/**
	 * @param {module:engine/model/position~Position} pos
	 */
	set position( pos ) {
		this.targetPosition = pos;
	}

	/**
	 * @inheritDoc
	 */
	get type() {
		return 'reinsert';
	}

	/**
	 * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
	 *
	 * @returns {module:engine/model/operation/removeoperation~RemoveOperation}
	 */
	getReversed() {
		const newTargetPosition = this.sourcePosition._getTransformedByInsertion( this.targetPosition, this.howMany );

		return new __WEBPACK_IMPORTED_MODULE_1__removeoperation__["a" /* default */]( this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1 );
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.operation.ReinsertOperation';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ReinsertOperation;



/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__movedelta__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_removeoperation__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__range__ = __webpack_require__(2);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/removedelta
 */








/**
 * To provide specific OT behavior and better collisions solving, {@link module:engine/model/batch~Batch#remove} method
 * uses the `RemoveDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class RemoveDelta extends __WEBPACK_IMPORTED_MODULE_0__movedelta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.RemoveDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RemoveDelta;


function addRemoveDelta( batch, position, howMany ) {
	const delta = new RemoveDelta();
	batch.addDelta( delta );

	const graveyard = batch.document.graveyard;
	const gyPosition = new __WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */]( graveyard, [ 0 ] );

	const operation = new __WEBPACK_IMPORTED_MODULE_3__operation_removeoperation__["a" /* default */]( position, howMany, gyPosition, batch.document.version );
	delta.addOperation( operation );
	batch.document.applyOperation( operation );
}

/**
 * Removes given {@link module:engine/model/item~Item model item} or given range.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#remove
 * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.
 */
Object(__WEBPACK_IMPORTED_MODULE_1__batch__["b" /* register */])( 'remove', function( itemOrRange ) {
	if ( itemOrRange instanceof __WEBPACK_IMPORTED_MODULE_5__range__["a" /* default */] ) {
		// The array is reversed, so the ranges to remove are in correct order and do not have to be updated.
		const ranges = itemOrRange.getMinimalFlatRanges().reverse();

		for ( const flat of ranges ) {
			addRemoveDelta( this, flat.start, flat.end.offset - flat.start.offset );
		}
	} else {
		addRemoveDelta( this, __WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */].createBefore( itemOrRange ), 1 );
	}

	return this;
} );

__WEBPACK_IMPORTED_MODULE_2__deltafactory__["a" /* default */].register( RemoveDelta );


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_moveoperation__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/movedelta
 */









/**
 * To provide specific OT behavior and better collisions solving, {@link module:engine/model/batch~Batch#move} method
 * uses the `MoveDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class MoveDelta extends __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	get type() {
		return 'move';
	}

	/**
	 * Offset size of moved range or `null` if there are no operations in the delta.
	 *
	 * @type {Number|null}
	 */
	get howMany() {
		return this._moveOperation ? this._moveOperation.howMany : null;
	}

	/**
	 * {@link module:engine/model/delta/movedelta~MoveDelta#_moveOperation Move operation}
	 * {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition source position} or `null` if there are
	 * no operations in the delta.
	 *
	 * @type {module:engine/model/position~Position|null}
	 */
	get sourcePosition() {
		return this._moveOperation ? this._moveOperation.sourcePosition : null;
	}

	/**
	 * {@link module:engine/model/delta/movedelta~MoveDelta#_moveOperation Move operation}
	 * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition target position} or `null` if there are
	 * no operations in the delta.
	 *
	 * @type {module:engine/model/position~Position|null}
	 */
	get targetPosition() {
		return this._moveOperation ? this._moveOperation.targetPosition : null;
	}

	/**
	 * {@link module:engine/model/delta/movedelta~MoveDelta#_moveOperation Move operation} that is saved in this delta or `null`
	 * if there are no operations in the delta.
	 *
	 * @protected
	 * @type {module:engine/model/operation/moveoperation~MoveOperation|null}
	 */
	get _moveOperation() {
		return this.operations[ 0 ] || null;
	}

	/**
	 * @inheritDoc
	 */
	get _reverseDeltaClass() {
		return MoveDelta;
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.MoveDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MoveDelta;


function addMoveOperation( batch, delta, sourcePosition, howMany, targetPosition ) {
	const operation = new __WEBPACK_IMPORTED_MODULE_3__operation_moveoperation__["a" /* default */]( sourcePosition, howMany, targetPosition, batch.document.version );
	delta.addOperation( operation );
	batch.document.applyOperation( operation );
}

/**
 * Moves given {@link module:engine/model/item~Item model item} or given range to target position.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#move
 * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range of nodes to move.
 * @param {module:engine/model/position~Position} targetPosition Position where moved nodes will be inserted.
 */
Object(__WEBPACK_IMPORTED_MODULE_2__batch__["b" /* register */])( 'move', function( itemOrRange, targetPosition ) {
	const delta = new MoveDelta();
	this.addDelta( delta );

	if ( itemOrRange instanceof __WEBPACK_IMPORTED_MODULE_5__range__["a" /* default */] ) {
		if ( !itemOrRange.isFlat ) {
			/**
			 * Range to move is not flat.
			 *
			 * @error batch-move-range-not-flat
			 */
			throw new __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-move-range-not-flat: Range to move is not flat.' );
		}

		addMoveOperation( this, delta, itemOrRange.start, itemOrRange.end.offset - itemOrRange.start.offset, targetPosition );
	} else {
		addMoveOperation( this, delta, __WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */].createBefore( itemOrRange ), 1, targetPosition );
	}

	return this;
} );

__WEBPACK_IMPORTED_MODULE_1__deltafactory__["a" /* default */].register( MoveDelta );


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__splitdelta__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__operation_removeoperation__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__operation_moveoperation__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/mergedelta
 */











/**
 * To provide specific OT behavior and better collisions solving, {@link module:engine/model/batch~Batch#merge} method
 * uses the `MergeDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class MergeDelta extends __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	get type() {
		return 'merge';
	}

	/**
	 * Position between to merged nodes or `null` if the delta has no operations.
	 *
	 * @readonly
	 * @type {module:engine/model/position~Position|null}
	 */
	get position() {
		return this._removeOperation ? this._removeOperation.sourcePosition : null;
	}

	/**
	 * Operation in this delta that removes the node after merge position (which will be empty at that point) or
	 * `null` if the delta has no operations. Note, that after {@link module:engine/model/delta/transform~transform transformation}
	 * this might be an instance of {@link module:engine/model/operation/moveoperation~MoveOperation} instead of
	 * {@link module:engine/model/operation/removeoperation~RemoveOperation}.
	 *
	 * @readonly
	 * @protected
	 * @type {module:engine/model/operation/moveoperation~MoveOperation|null}
	 */
	get _removeOperation() {
		return this.operations[ 1 ] || null;
	}

	/**
	 * @inheritDoc
	 */
	get _reverseDeltaClass() {
		return __WEBPACK_IMPORTED_MODULE_2__splitdelta__["a" /* default */];
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.MergeDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MergeDelta;


/**
 * Merges two siblings at the given position.
 *
 * Node before and after the position have to be an element. Otherwise `batch-merge-no-element-before` or
 * `batch-merge-no-element-after` error will be thrown.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#merge
 * @param {module:engine/model/position~Position} position Position of merge.
 */
Object(__WEBPACK_IMPORTED_MODULE_3__batch__["b" /* register */])( 'merge', function( position ) {
	const delta = new MergeDelta();
	this.addDelta( delta );

	const nodeBefore = position.nodeBefore;
	const nodeAfter = position.nodeAfter;

	if ( !( nodeBefore instanceof __WEBPACK_IMPORTED_MODULE_5__element__["a" /* default */] ) ) {
		/**
		 * Node before merge position must be an element.
		 *
		 * @error batch-merge-no-element-before
		 */
		throw new __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-merge-no-element-before: Node before merge position must be an element.' );
	}

	if ( !( nodeAfter instanceof __WEBPACK_IMPORTED_MODULE_5__element__["a" /* default */] ) ) {
		/**
		 * Node after merge position must be an element.
		 *
		 * @error batch-merge-no-element-after
		 */
		throw new __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-merge-no-element-after: Node after merge position must be an element.' );
	}

	const positionAfter = __WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */].createFromParentAndOffset( nodeAfter, 0 );
	const positionBefore = __WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */].createFromParentAndOffset( nodeBefore, nodeBefore.maxOffset );

	const move = new __WEBPACK_IMPORTED_MODULE_7__operation_moveoperation__["a" /* default */](
		positionAfter,
		nodeAfter.maxOffset,
		positionBefore,
		this.document.version
	);

	move.isSticky = true;
	delta.addOperation( move );
	this.document.applyOperation( move );

	const graveyard = this.document.graveyard;
	const gyPosition = new __WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */]( graveyard, [ 0 ] );

	const remove = new __WEBPACK_IMPORTED_MODULE_6__operation_removeoperation__["a" /* default */]( position, 1, gyPosition, this.document.version );
	delta.addOperation( remove );
	this.document.applyOperation( remove );

	return this;
} );

__WEBPACK_IMPORTED_MODULE_1__deltafactory__["a" /* default */].register( MergeDelta );


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__operation_insertoperation__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__operation_moveoperation__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__delta_mergedelta__ = __webpack_require__(99);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/splitdelta
 */











/**
 * To provide specific OT behavior and better collisions solving, the {@link module:engine/model/batch~Batch#split} method
 * uses `SplitDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class SplitDelta extends __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	get type() {
		return 'split';
	}

	/**
	 * Position of split or `null` if there are no operations in the delta.
	 *
	 * @type {module:engine/model/position~Position|null}
	 */
	get position() {
		return this._moveOperation ? this._moveOperation.sourcePosition : null;
	}

	/**
	 * Operation in the delta that adds to model an element into which split nodes will be moved, or `null` if
	 * there are no operations in the delta.
	 *
	 * Most commonly this will be {@link module:engine/model/operation/insertoperation~InsertOperation an insert operation},
	 * as `SplitDelta` has to create a new node. If `SplitDelta` was created through
	 * {@link module:engine/model/delta/delta~Delta#getReversed reversing}
	 * a {@link module:engine/model/delta/mergedelta~MergeDelta merge delta},
	 * this will be a {@link module:engine/model/operation/reinsertoperation~ReinsertOperation reinsert operation},
	 * as we will want to re-insert the exact element that was removed by that merge delta.
	 *
	 * @protected
	 * @type {module:engine/model/operation/insertoperation~InsertOperation|
	 * module:engine/model/operation/reinsertoperation~ReinsertOperation|null}
	 */
	get _cloneOperation() {
		return this.operations[ 0 ] || null;
	}

	/**
	 * Operation in the delta that moves model items, that are after split position, to their new parent or `null`
	 * if there are no operations in the delta.
	 *
	 * @protected
	 * @type {module:engine/model/operation/moveoperation~MoveOperation|null}
	 */
	get _moveOperation() {
		return this.operations[ 1 ] && this.operations[ 1 ] instanceof __WEBPACK_IMPORTED_MODULE_6__operation_moveoperation__["a" /* default */] ? this.operations[ 1 ] : null;
	}

	/**
	 * @inheritDoc
	 */
	get _reverseDeltaClass() {
		return __WEBPACK_IMPORTED_MODULE_8__delta_mergedelta__["a" /* default */];
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.SplitDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = SplitDelta;


/**
 * Splits an element at the given position.
 *
 * The element cannot be a root element, as root element cannot be split. The `batch-split-root` error will be thrown if
 * you try to split the root element.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#split
 * @param {module:engine/model/position~Position} position Position of split.
 */
Object(__WEBPACK_IMPORTED_MODULE_2__batch__["b" /* register */])( 'split', function( position ) {
	const delta = new SplitDelta();
	this.addDelta( delta );

	const splitElement = position.parent;

	if ( !splitElement.parent ) {
		/**
		 * Root element can not be split.
		 *
		 * @error batch-split-root
		 */
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-split-root: Root element can not be split.' );
	}

	const copy = new __WEBPACK_IMPORTED_MODULE_4__element__["a" /* default */]( splitElement.name, splitElement.getAttributes() );

	const insert = new __WEBPACK_IMPORTED_MODULE_5__operation_insertoperation__["a" /* default */](
		__WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createAfter( splitElement ),
		copy,
		this.document.version
	);

	delta.addOperation( insert );
	this.document.applyOperation( insert );

	const move = new __WEBPACK_IMPORTED_MODULE_6__operation_moveoperation__["a" /* default */](
		position,
		splitElement.maxOffset - position.offset,
		__WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromParentAndOffset( copy, 0 ),
		this.document.version
	);
	move.isSticky = true;

	delta.addOperation( move );
	this.document.applyOperation( move );

	return this;
} );

__WEBPACK_IMPORTED_MODULE_1__deltafactory__["a" /* default */].register( SplitDelta );


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__wrapdelta__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__operation_removeoperation__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__operation_moveoperation__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/unwrapdelta
 */










/**
 * To provide specific OT behavior and better collisions solving, {@link module:engine/model/batch~Batch#merge} method
 * uses the `UnwrapDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class UnwrapDelta extends __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	get type() {
		return 'unwrap';
	}

	/**
	 * Position before unwrapped element or `null` if there are no operations in the delta.
	 *
	 * @type {module:engine/model/position~Position|null}
	 */
	get position() {
		return this._moveOperation ? this._moveOperation.targetPosition : null;
	}

	/**
	 * Operation in the delta that moves unwrapped nodes to their new parent or `null` if there are no operations in the delta.
	 *
	 * @protected
	 * @type {module:engine/model/operation/moveoperation~MoveOperation|null}
	 */
	get _moveOperation() {
		return this.operations[ 0 ] || null;
	}

	/**
	 * @inheritDoc
	 */
	get _reverseDeltaClass() {
		return __WEBPACK_IMPORTED_MODULE_2__wrapdelta__["a" /* default */];
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.UnwrapDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = UnwrapDelta;


/**
 * Unwraps children of the given element  all its children are moved before it and then the element is removed.
 * Throws error if you try to unwrap an element which does not have a parent.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#unwrap
 * @param {module:engine/model/element~Element} position Element to unwrap.
 */
Object(__WEBPACK_IMPORTED_MODULE_3__batch__["b" /* register */])( 'unwrap', function( element ) {
	if ( element.parent === null ) {
		/**
		 * Trying to unwrap an element which has no parent.
		 *
		 * @error batch-unwrap-element-no-parent
		 */
		throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-unwrap-element-no-parent: Trying to unwrap an element which has no parent.' );
	}

	const delta = new UnwrapDelta();
	this.addDelta( delta );

	const sourcePosition = __WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */].createFromParentAndOffset( element, 0 );

	const move = new __WEBPACK_IMPORTED_MODULE_6__operation_moveoperation__["a" /* default */](
		sourcePosition,
		element.maxOffset,
		__WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */].createBefore( element ),
		this.document.version
	);

	move.isSticky = true;
	delta.addOperation( move );
	this.document.applyOperation( move );

	// Computing new position because we moved some nodes before `element`.
	// If we would cache `Position.createBefore( element )` we remove wrong node.
	const graveyard = this.document.graveyard;
	const gyPosition = new __WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */]( graveyard, [ 0 ] );

	const remove = new __WEBPACK_IMPORTED_MODULE_5__operation_removeoperation__["a" /* default */]( __WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */].createBefore( element ), 1, gyPosition, this.document.version );
	delta.addOperation( remove );
	this.document.applyOperation( remove );

	return this;
} );

__WEBPACK_IMPORTED_MODULE_1__deltafactory__["a" /* default */].register( UnwrapDelta );


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__unwrapdelta__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__operation_insertoperation__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__operation_moveoperation__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/wrapdelta
 */












/**
 * To provide specific OT behavior and better collisions solving, {@link module:engine/model/batch~Batch#merge} method
 * uses the `WrapDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class WrapDelta extends __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	get type() {
		return 'wrap';
	}

	/**
	 * Range to wrap or `null` if there are no operations in the delta.
	 *
	 * @type {module:engine/model/range~Range|null}
	 */
	get range() {
		const moveOp = this._moveOperation;

		return moveOp ? __WEBPACK_IMPORTED_MODULE_5__range__["a" /* default */].createFromPositionAndShift( moveOp.sourcePosition, moveOp.howMany ) : null;
	}

	/**
	 * Offset size of range to wrap by the delta or `null` if there are no operations in delta.
	 *
	 * @type {Number}
	 */
	get howMany() {
		const range = this.range;

		return range ? range.end.offset - range.start.offset : 0;
	}

	/* eslint-disable max-len */
	/**
	 * Operation that inserts wrapping element or `null` if there are no operations in the delta.
	 *
	 * @protected
	 * @type {module:engine/model/operation/insertoperation~InsertOperation|module:engine/model/operation/reinsertoperation~ReinsertOperation}
	 */
	/* eslint-enable max-len */
	get _insertOperation() {
		return this.operations[ 0 ] || null;
	}

	/**
	 * Operation that moves wrapped nodes to their new parent or `null` if there are no operations in the delta.
	 *
	 * @protected
	 * @type {module:engine/model/operation/moveoperation~MoveOperation|null}
	 */
	get _moveOperation() {
		return this.operations[ 1 ] || null;
	}

	/**
	 * @inheritDoc
	 */
	get _reverseDeltaClass() {
		return __WEBPACK_IMPORTED_MODULE_2__unwrapdelta__["a" /* default */];
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.WrapDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = WrapDelta;


/**
 * Wraps given range with given element or with a new element with specified name, if string has been passed.
 * **Note:** range to wrap should be a "flat range" (see {@link module:engine/model/range~Range#isFlat}). If not, error will be thrown.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#wrap
 * @param {module:engine/model/range~Range} range Range to wrap.
 * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.
 */
Object(__WEBPACK_IMPORTED_MODULE_3__batch__["b" /* register */])( 'wrap', function( range, elementOrString ) {
	if ( !range.isFlat ) {
		/**
		 * Range to wrap is not flat.
		 *
		 * @error batch-wrap-range-not-flat
		 */
		throw new __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-wrap-range-not-flat: Range to wrap is not flat.' );
	}

	const element = elementOrString instanceof __WEBPACK_IMPORTED_MODULE_6__element__["a" /* default */] ? elementOrString : new __WEBPACK_IMPORTED_MODULE_6__element__["a" /* default */]( elementOrString );

	if ( element.childCount > 0 ) {
		/**
		 * Element to wrap with is not empty.
		 *
		 * @error batch-wrap-element-not-empty
		 */
		throw new __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-wrap-element-not-empty: Element to wrap with is not empty.' );
	}

	if ( element.parent !== null ) {
		/**
		 * Element to wrap with is already attached to a tree model.
		 *
		 * @error batch-wrap-element-attached
		 */
		throw new __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-wrap-element-attached: Element to wrap with is already attached to tree model.' );
	}

	const delta = new WrapDelta();
	this.addDelta( delta );

	const insert = new __WEBPACK_IMPORTED_MODULE_7__operation_insertoperation__["a" /* default */]( range.end, element, this.document.version );
	delta.addOperation( insert );
	this.document.applyOperation( insert );

	const targetPosition = __WEBPACK_IMPORTED_MODULE_4__position__["a" /* default */].createFromParentAndOffset( element, 0 );
	const move = new __WEBPACK_IMPORTED_MODULE_8__operation_moveoperation__["a" /* default */](
		range.start,
		range.end.offset - range.start.offset,
		targetPosition,
		this.document.version
	);
	delta.addOperation( move );
	this.document.applyOperation( move );

	return this;
} );

__WEBPACK_IMPORTED_MODULE_1__deltafactory__["a" /* default */].register( WrapDelta );


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArray__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__stringToPath__ = __webpack_require__(390);



/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__isArray__["a" /* default */])(value) ? value : Object(__WEBPACK_IMPORTED_MODULE_1__stringToPath__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (castPath);


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSlice__ = __webpack_require__(41);


/**
 * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
 * without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {Function} predicate The function invoked per iteration.
 * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the slice of `array`.
 */
function baseWhile(array, predicate, isDrop, fromRight) {
  var length = array.length,
      index = fromRight ? length : -1;

  while ((fromRight ? index-- : ++index < length) &&
    predicate(array[index], index, array)) {}

  return isDrop
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice__["a" /* default */])(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
    : Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice__["a" /* default */])(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
}

/* harmony default export */ __webpack_exports__["a"] = (baseWhile);


/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSortedIndexBy__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__identity__ = __webpack_require__(198);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isSymbol__ = __webpack_require__(45);




/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295,
    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

/**
 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
 * performs a binary search of `array` to determine the index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndex(array, value, retHighest) {
  var low = 0,
      high = array ? array.length : low;

  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = (low + high) >>> 1,
          computed = array[mid];

      if (computed !== null && !Object(__WEBPACK_IMPORTED_MODULE_2__isSymbol__["a" /* default */])(computed) &&
          (retHighest ? (computed <= value) : (computed < value))) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSortedIndexBy__["a" /* default */])(array, value, __WEBPACK_IMPORTED_MODULE_1__identity__["a" /* default */], retHighest);
}

/* harmony default export */ __webpack_exports__["a"] = (baseSortedIndex);


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayFilter__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayMap__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseProperty__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__baseTimes__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isArrayLikeObject__ = __webpack_require__(13);






/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.zip` except that it accepts an array of grouped
 * elements and creates an array regrouping the elements to their pre-zip
 * configuration.
 *
 * @static
 * @memberOf _
 * @since 1.2.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
 * // => [['fred', 30, true], ['barney', 40, false]]
 *
 * _.unzip(zipped);
 * // => [['fred', 'barney'], [30, 40], [true, false]]
 */
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = Object(__WEBPACK_IMPORTED_MODULE_0__arrayFilter__["a" /* default */])(array, function(group) {
    if (Object(__WEBPACK_IMPORTED_MODULE_4__isArrayLikeObject__["a" /* default */])(group)) {
      length = nativeMax(group.length, length);
      return true;
    }
  });
  return Object(__WEBPACK_IMPORTED_MODULE_3__baseTimes__["a" /* default */])(length, function(index) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__arrayMap__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_2__baseProperty__["a" /* default */])(index));
  });
}

/* harmony default export */ __webpack_exports__["a"] = (unzip);


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayFilter);


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_tomap__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_mapsequal__ = __webpack_require__(414);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_isiterable__ = __webpack_require__(34);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/selection
 */











/**
 * `Selection` is a group of {@link module:engine/model/range~Range ranges} which has a direction specified by
 * {@link module:engine/model/selection~Selection#anchor anchor} and {@link module:engine/model/selection~Selection#focus focus}.
 * Additionally, `Selection` may have it's own attributes.
 */
class Selection {
	/**
	 * Creates new selection instance.
	 *
	 * @param {Iterable.<module:engine/view/range~Range>} [ranges] An optional iterable object of ranges to set.
	 * @param {Boolean} [isLastBackward] An optional flag describing if last added range was selected forward - from start to end
	 * (`false`) or backward - from end to start (`true`). Defaults to `false`.
	 */
	constructor( ranges, isLastBackward ) {
		/**
		 * Specifies whether the last added range was added as a backward or forward range.
		 *
		 * @private
		 * @member {Boolean}
		 */
		this._lastRangeBackward = false;

		/**
		 * Stores selection ranges.
		 *
		 * @protected
		 * @member {Array.<module:engine/model/range~Range>}
		 */
		this._ranges = [];

		/**
		 * List of attributes set on current selection.
		 *
		 * @protected
		 * @member {Map} module:engine/model/selection~Selection#_attrs
		 */
		this._attrs = new Map();

		if ( ranges ) {
			this.setRanges( ranges, isLastBackward );
		}
	}

	/**
	 * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.
	 * Together with {@link #focus} they define the direction of selection, which is important
	 * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or
	 * {@link module:engine/model/range~Range#end end} position of the most recently added range.
	 *
	 * Is set to `null` if there are no ranges in selection.
	 *
	 * @see #focus
	 * @readonly
	 * @type {module:engine/model/position~Position|null}
	 */
	get anchor() {
		if ( this._ranges.length > 0 ) {
			const range = this._ranges[ this._ranges.length - 1 ];

			return this._lastRangeBackward ? range.end : range.start;
		}

		return null;
	}

	/**
	 * Selection focus. Focus is a position where the selection ends.
	 *
	 * Is set to `null` if there are no ranges in selection.
	 *
	 * @see #anchor
	 * @readonly
	 * @type {module:engine/model/position~Position|null}
	 */
	get focus() {
		if ( this._ranges.length > 0 ) {
			const range = this._ranges[ this._ranges.length - 1 ];

			return this._lastRangeBackward ? range.start : range.end;
		}

		return null;
	}

	/**
	 * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
	 * collapsed.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isCollapsed() {
		const length = this._ranges.length;

		if ( length === 1 ) {
			return this._ranges[ 0 ].isCollapsed;
		} else {
			return false;
		}
	}

	/**
	 * Returns number of ranges in selection.
	 *
	 * @type {Number}
	 */
	get rangeCount() {
		return this._ranges.length;
	}

	/**
	 * Specifies whether the {@link #focus}
	 * precedes {@link #anchor}.
	 *
	 * @type {Boolean}
	 */
	get isBackward() {
		return !this.isCollapsed && this._lastRangeBackward;
	}

	/**
	 * Checks whether this selection is equal to given selection. Selections are equal if they have same directions,
	 * same number of ranges and all ranges from one selection equal to a range from other selection.
	 *
	 * @param {module:engine/model/selection~Selection} otherSelection Selection to compare with.
	 * @returns {Boolean} `true` if selections are equal, `false` otherwise.
	 */
	isEqual( otherSelection ) {
		if ( this.rangeCount != otherSelection.rangeCount ) {
			return false;
		} else if ( this.rangeCount === 0 ) {
			return true;
		}

		if ( !this.anchor.isEqual( otherSelection.anchor ) || !this.focus.isEqual( otherSelection.focus ) ) {
			return false;
		}

		for ( const thisRange of this._ranges ) {
			let found = false;

			for ( const otherRange of otherSelection._ranges ) {
				if ( thisRange.isEqual( otherRange ) ) {
					found = true;
					break;
				}
			}

			if ( !found ) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Returns an iterator that iterates over copies of selection ranges.
	 *
	 * @returns {Iterator.<module:engine/model/range~Range>}
	 */
	* getRanges() {
		for ( const range of this._ranges ) {
			yield __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */].createFromRange( range );
		}
	}

	/**
	 * Returns a copy of the first range in the selection.
	 * First range is the one which {@link module:engine/model/range~Range#start start} position
	 * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
	 * (not to confuse with the first range added to the selection).
	 *
	 * Returns `null` if there are no ranges in selection.
	 *
	 * @returns {module:engine/model/range~Range|null}
	 */
	getFirstRange() {
		let first = null;

		for ( const range of this._ranges ) {
			if ( !first || range.start.isBefore( first.start ) ) {
				first = range;
			}
		}

		return first ? __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */].createFromRange( first ) : null;
	}

	/**
	 * Returns a copy of the last range in the selection.
	 * Last range is the one which {@link module:engine/model/range~Range#end end} position
	 * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
	 * recently added to the selection).
	 *
	 * Returns `null` if there are no ranges in selection.
	 *
	 * @returns {module:engine/model/range~Range|null}
	 */
	getLastRange() {
		let last = null;

		for ( const range of this._ranges ) {
			if ( !last || range.end.isAfter( last.end ) ) {
				last = range;
			}
		}

		return last ? __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */].createFromRange( last ) : null;
	}

	/**
	 * Returns the first position in the selection.
	 * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
	 * any other position in the selection.
	 *
	 * Returns `null` if there are no ranges in selection.
	 *
	 * @returns {module:engine/model/position~Position|null}
	 */
	getFirstPosition() {
		const first = this.getFirstRange();

		return first ? __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( first.start ) : null;
	}

	/**
	 * Returns the last position in the selection.
	 * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
	 * any other position in the selection.
	 *
	 * Returns `null` if there are no ranges in selection.
	 *
	 * @returns {module:engine/model/position~Position|null}
	 */
	getLastPosition() {
		const lastRange = this.getLastRange();

		return lastRange ? __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( lastRange.end ) : null;
	}

	/**
	 * Adds a range to this selection. Added range is copied. This means that passed range is not saved in `Selection`
	 * instance and operating on it will not change `Selection` state.
	 *
	 * Accepts a flag describing in which way the selection is made - passed range might be selected from
	 * {@link module:engine/model/range~Range#start start} to {@link module:engine/model/range~Range#end end}
	 * or from {@link module:engine/model/range~Range#end end}
	 * to {@link module:engine/model/range~Range#start start}.
	 * The flag is used to set {@link #anchor} and
	 * {@link #focus} properties.
	 *
	 * @fires change:range
	 * @param {module:engine/model/range~Range} range Range to add.
	 * @param {Boolean} [isBackward=false] Flag describing if added range was selected forward - from start to end (`false`)
	 * or backward - from end to start (`true`).
	 */
	addRange( range, isBackward = false ) {
		this._pushRange( range );
		this._lastRangeBackward = !!isBackward;

		this.fire( 'change:range', { directChange: true } );
	}

	/**
	 * Removes all ranges that were added to the selection.
	 *
	 * @fires change:range
	 */
	removeAllRanges() {
		if ( this._ranges.length > 0 ) {
			this._removeAllRanges();
			this.fire( 'change:range', { directChange: true } );
		}
	}

	/**
	 * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
	 * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and
	 * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made
	 * (see {@link module:engine/model/selection~Selection#addRange}).
	 *
	 * @fires change:range
	 * @param {Iterable.<module:engine/model/range~Range>} newRanges Ranges to set.
	 * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end (`false`)
	 * or backward - from end to start (`true`).
	 */
	setRanges( newRanges, isLastBackward = false ) {
		newRanges = Array.from( newRanges );

		// Check whether there is any range in new ranges set that is different than all already added ranges.
		const anyNewRange = newRanges.some( newRange => {
			if ( !( newRange instanceof __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */] ) ) {
				throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-selection-added-not-range: Trying to add an object that is not an instance of Range.' );
			}

			return this._ranges.every( oldRange => {
				return !oldRange.isEqual( newRange );
			} );
		} );

		// Don't do anything if nothing changed.
		if ( newRanges.length === this._ranges.length && !anyNewRange ) {
			return;
		}

		this._removeAllRanges();

		for ( const range of newRanges ) {
			this._pushRange( range );
		}

		this._lastRangeBackward = !!isLastBackward;

		this.fire( 'change:range', { directChange: true } );
	}

	/**
	 * Sets this selection's ranges and direction to the specified location based on the given
	 * {@link module:engine/model/selection~Selection selection}, {@link module:engine/model/position~Position position},
	 * {@link module:engine/model/range~Range range} or an iterable of {@link module:engine/model/range~Range ranges}.
	 *
	 * @param {module:engine/model/selection~Selection|module:engine/model/position~Position|
	 * Iterable.<module:engine/model/range~Range>|module:engine/model/range~Range} selectable
	 */
	setTo( selectable ) {
		if ( selectable instanceof Selection ) {
			this.setRanges( selectable.getRanges(), selectable.isBackward );
		} else if ( selectable instanceof __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */] ) {
			this.setRanges( [ selectable ] );
		} else if ( Object(__WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_isiterable__["a" /* default */])( selectable ) ) {
			// We assume that the selectable is an iterable of ranges.
			this.setRanges( selectable );
		} else {
			// We assume that the selectable is a position.
			this.setRanges( [ new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( selectable ) ] );
		}
	}

	/**
	 * Sets this selection in the provided element.
	 *
	 * @param {module:engine/model/element~Element} element
	 */
	setIn( element ) {
		this.setRanges( [ __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */].createIn( element ) ] );
	}

	/**
	 * Sets this selection on the provided item.
	 *
	 * @param {module:engine/model/item~Item} item
	 */
	setOn( item ) {
		this.setRanges( [ __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */].createOn( item ) ] );
	}

	/**
	 * Sets collapsed selection at the specified location.
	 *
	 * The location can be specified in the same form as {@link module:engine/model/position~Position.createAt} parameters.
	 *
	 * @fires change:range
	 * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
	 * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
	 * first parameter is a {@link module:engine/model/item~Item model item}.
	 */
	setCollapsedAt( itemOrPosition, offset ) {
		const pos = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( itemOrPosition, offset );
		const range = new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( pos, pos );

		this.setRanges( [ range ] );
	}

	/**
	 * Collapses selection to the selection's {@link module:engine/model/selection~Selection#getFirstPosition first position}.
	 * All ranges, besides the collapsed one, will be removed. Nothing will change if there are no ranges stored
	 * inside selection.
	 *
	 * @fires change
	 */
	collapseToStart() {
		const startPosition = this.getFirstPosition();

		if ( startPosition !== null ) {
			this.setRanges( [ new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( startPosition, startPosition ) ] );
		}
	}

	/**
	 * Collapses selection to the selection's {@link module:engine/model/selection~Selection#getLastPosition last position}.
	 * All ranges, besides the collapsed one, will be removed. Nothing will change if there are no ranges stored
	 * inside selection.
	 *
	 * @fires change
	 */
	collapseToEnd() {
		const endPosition = this.getLastPosition();

		if ( endPosition !== null ) {
			this.setRanges( [ new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( endPosition, endPosition ) ] );
		}
	}

	/**
	 * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.
	 *
	 * The location can be specified in the same form as {@link module:engine/model/position~Position.createAt} parameters.
	 *
	 * @fires change:range
	 * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
	 * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
	 * first parameter is a {@link module:engine/model/item~Item model item}.
	 */
	moveFocusTo( itemOrPosition, offset ) {
		if ( this.anchor === null ) {
			/**
			 * Cannot set selection focus if there are no ranges in selection.
			 *
			 * @error model-selection-moveFocusTo-no-ranges
			 */
			throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'model-selection-moveFocusTo-no-ranges: Cannot set selection focus if there are no ranges in selection.'
			);
		}

		const newFocus = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( itemOrPosition, offset );

		if ( newFocus.compareWith( this.focus ) == 'same' ) {
			return;
		}

		const anchor = this.anchor;

		if ( this._ranges.length ) {
			this._popRange();
		}

		if ( newFocus.compareWith( anchor ) == 'before' ) {
			this.addRange( new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( newFocus, anchor ), true );
		} else {
			this.addRange( new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( anchor, newFocus ) );
		}
	}

	/**
	 * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
	 *
	 * @param {String} key Key of attribute to look for.
	 * @returns {*} Attribute value or `undefined`.
	 */
	getAttribute( key ) {
		return this._attrs.get( key );
	}

	/**
	 * Returns iterator that iterates over this selection's attributes.
	 *
	 * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
	 * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
	 *
	 * @returns {Iterable.<*>}
	 */
	getAttributes() {
		return this._attrs.entries();
	}

	/**
	 * Returns iterator that iterates over this selection's attribute keys.
	 *
	 * @returns {Iterator.<String>}
	 */
	getAttributeKeys() {
		return this._attrs.keys();
	}

	/**
	 * Checks if the selection has an attribute for given key.
	 *
	 * @param {String} key Key of attribute to check.
	 * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.
	 */
	hasAttribute( key ) {
		return this._attrs.has( key );
	}

	/**
	 * Removes all attributes from the selection.
	 *
	 * If there were any attributes in selection, fires the {@link #event:change} event with
	 * removed attributes' keys.
	 *
	 * @fires change:attribute
	 */
	clearAttributes() {
		if ( this._attrs.size > 0 ) {
			const attributeKeys = Array.from( this._attrs.keys() );
			this._attrs.clear();

			this.fire( 'change:attribute', { attributeKeys, directChange: true } );
		}
	}

	/**
	 * Removes an attribute with given key from the selection.
	 *
	 * If given attribute was set on the selection, fires the {@link #event:change} event with
	 * removed attribute key.
	 *
	 * @fires change:attribute
	 * @param {String} key Key of attribute to remove.
	 */
	removeAttribute( key ) {
		if ( this.hasAttribute( key ) ) {
			this._attrs.delete( key );

			this.fire( 'change:attribute', { attributeKeys: [ key ], directChange: true } );
		}
	}

	/**
	 * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
	 *
	 * If the attribute value has changed, fires the {@link #event:change} event with
	 * the attribute key.
	 *
	 * @fires change:attribute
	 * @param {String} key Key of attribute to set.
	 * @param {*} value Attribute value.
	 */
	setAttribute( key, value ) {
		if ( this.getAttribute( key ) !== value ) {
			this._attrs.set( key, value );

			this.fire( 'change:attribute', { attributeKeys: [ key ], directChange: true } );
		}
	}

	/**
	 * Removes all attributes from the selection and sets given attributes.
	 *
	 * If given set of attributes is different than set of attributes already added to selection, fires
	 * {@link #event:change change event} with keys of attributes that changed.
	 *
	 * @fires event:change:attribute
	 * @param {Iterable|Object} attrs Iterable object containing attributes to be set.
	 */
	setAttributesTo( attrs ) {
		attrs = Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_tomap__["a" /* default */])( attrs );

		if ( !Object(__WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_mapsequal__["a" /* default */])( attrs, this._attrs ) ) {
			// Create a set from keys of old and new attributes.
			const changed = new Set( Array.from( attrs.keys() ).concat( Array.from( this._attrs.keys() ) ) );

			for ( const [ key, value ] of attrs ) {
				// If the attribute remains unchanged, remove it from changed set.
				if ( this._attrs.get( key ) === value ) {
					changed.delete( key );
				}
			}

			this._attrs = attrs;

			this.fire( 'change:attribute', { attributeKeys: Array.from( changed ), directChange: true } );
		}
	}

	/**
	 * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
	 * one range in the selection, and that range contains exactly one element.
	 * Returns `null` if there is no selected element.
	 *
	 * @returns {module:engine/model/element~Element|null}
	 */
	getSelectedElement() {
		if ( this.rangeCount !== 1 ) {
			return null;
		}

		const range = this.getFirstRange();
		const nodeAfterStart = range.start.nodeAfter;
		const nodeBeforeEnd = range.end.nodeBefore;

		return ( nodeAfterStart instanceof __WEBPACK_IMPORTED_MODULE_1__element__["a" /* default */] && nodeAfterStart == nodeBeforeEnd ) ? nodeAfterStart : null;
	}

	/**
	 * Gets elements of type "block" touched by the selection.
	 *
	 * This method's result can be used for example to apply block styling to all blocks covered by this selection.
	 *
	 * **Note:** `getSelectedBlocks()` always returns the deepest block.
	 *
	 * In this case the function will return exactly all 3 paragraphs:
	 *
	 *		<paragraph>[a</paragraph>
	 *		<quote>
	 *			<paragraph>b</paragraph>
	 *		</quote>
	 *		<paragraph>c]d</paragraph>
	 *
	 * In this case the paragraph will also be returned, despite the collapsed selection:
	 *
	 *		<paragraph>[]a</paragraph>
	 *
	 * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective
	 * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.
	 *
	 *		<paragraph>[a</paragraph>
	 *		<paragraph>b</paragraph>
	 *		<paragraph>]c</paragraph> // this block will not be returned
	 *
	 * @returns {Iterator.<module:engine/model/element~Element>}
	 */
	* getSelectedBlocks() {
		const visited = new WeakSet();

		for ( const range of this.getRanges() ) {
			const startBlock = getParentBlock( range.start, visited );

			if ( startBlock ) {
				yield startBlock;
			}

			for ( const value of range.getWalker() ) {
				if ( value.type == 'elementEnd' && isUnvisitedBlockContainer( value.item, visited ) ) {
					yield value.item;
				}
			}

			const endBlock = getParentBlock( range.end, visited );

			// #984. Don't return the end block if the range ends right at its beginning.
			if ( endBlock && !range.end.isTouching( __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( endBlock ) ) ) {
				yield endBlock;
			}
		}
	}

	/**
	 * Checks whether the selection contains the entire content of the given element. This means that selection must start
	 * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
	 * touching the element's end.
	 *
	 * By default, this method will check whether the entire content of the selection's current root is selected.
	 * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
	 *
	 * @param {module:engine/model/element~Element} [element=this.anchor.root]
	 * @returns {Boolean}
	 */
	containsEntireContent( element = this.anchor.root ) {
		const limitStartPosition = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( element );
		const limitEndPosition = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createAt( element, 'end' );

		return limitStartPosition.isTouching( this.getFirstPosition() ) &&
			limitEndPosition.isTouching( this.getLastPosition() );
	}

	/**
	 * Creates and returns an instance of `Selection` that is a clone of given selection, meaning that it has same
	 * ranges and same direction as this selection.
	 *
	 * @params {module:engine/model/selection~Selection} otherSelection Selection to be cloned.
	 * @returns {module:engine/model/selection~Selection} `Selection` instance that is a clone of given selection.
	 */
	static createFromSelection( otherSelection ) {
		const selection = new this();
		selection.setTo( otherSelection );

		return selection;
	}

	/**
	 * Adds given range to internal {@link #_ranges ranges array}. Throws an error
	 * if given range is intersecting with any range that is already stored in this selection.
	 *
	 * @protected
	 * @param {module:engine/model/range~Range} range Range to add.
	 */
	_pushRange( range ) {
		if ( !( range instanceof __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */] ) ) {
			throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-selection-added-not-range: Trying to add an object that is not an instance of Range.' );
		}

		this._checkRange( range );
		this._ranges.push( __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */].createFromRange( range ) );
	}

	/**
	 * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
	 *
	 * @protected
	 * @param {module:engine/model/range~Range} range Range to check.
	 */
	_checkRange( range ) {
		for ( let i = 0; i < this._ranges.length; i++ ) {
			if ( range.isIntersecting( this._ranges[ i ] ) ) {
				/**
				 * Trying to add a range that intersects with another range from selection.
				 *
				 * @error model-selection-range-intersects
				 * @param {module:engine/model/range~Range} addedRange Range that was added to the selection.
				 * @param {module:engine/model/range~Range} intersectingRange Range from selection that intersects with `addedRange`.
				 */
				throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
					'model-selection-range-intersects: Trying to add a range that intersects with another range from selection.',
					{ addedRange: range, intersectingRange: this._ranges[ i ] }
				);
			}
		}
	}

	/**
	 * Removes most recently added range from the selection.
	 *
	 * @protected
	 */
	_popRange() {
		this._ranges.pop();
	}

	/**
	 * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to
	 * ensure proper ranges removal.
	 *
	 * @private
	 */
	_removeAllRanges() {
		while ( this._ranges.length > 0 ) {
			this._popRange();
		}
	}

	/**
	 * @event change
	 */

	/**
	 * Fired whenever selection ranges are changed.
	 *
	 * @event change:range
	 * @param {Boolean} directChange Specifies whether the range change was caused by direct usage of `Selection` API (`true`)
	 * or by changes done to {@link module:engine/model/document~Document model document}
	 * using {@link module:engine/model/batch~Batch Batch} API (`false`).
	 */

	/**
	 * Fired whenever selection attributes are changed.
	 *
	 * @event change:attribute
	 * @param {Boolean} directChange Specifies whether the attributes changed by direct usage of the Selection API (`true`)
	 * or by changes done to the {@link module:engine/model/document~Document model document}
	 * using the {@link module:engine/model/batch~Batch Batch} API (`false`).
	 * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Selection;


Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Selection, __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

// Checks whether the given element extends $block in the schema and has a parent (is not a root).
// Marks it as already visited.
function isUnvisitedBlockContainer( element, visited ) {
	if ( visited.has( element ) ) {
		return false;
	}

	visited.add( element );

	// TODO https://github.com/ckeditor/ckeditor5-engine/issues/532#issuecomment-278900072.
	// This should not be a `$block` check.
	return element.document.schema.itemExtends( element.name, '$block' ) && element.parent;
}

// Finds the lowest element in position's ancestors which is a block.
// Marks all ancestors as already visited to not include any of them later on.
function getParentBlock( position, visited ) {
	const ancestors = position.parent.getAncestors( { parentFirst: true, includeSelf: true } );
	const block = ancestors.find( element => isUnvisitedBlockContainer( element, visited ) );

	// Mark all ancestors of this position's parent, because find() might've stopped early and
	// the found block may be a child of another block.
	ancestors.forEach( element => visited.add( element ) );

	return block;
}


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uid__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_lodash_extend__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isdomnode__ = __webpack_require__(257);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/emittermixin
 */






/**
 * Mixin that injects the DOM events API into its host. It provides the API
 * compatible with {@link module:utils/emittermixin~EmitterMixin}.
 *
 * DOM emitter mixin is by default available in the {@link module:ui/view~View} class,
 * but it can also be mixed into any other class:
 *
 *		import mix from '../utils/mix.js';
 *		import DomEmitterMixin from '../utils/dom/emittermixin.js';
 *
 *		class SomeView {}
 *		mix( SomeView, DomEmitterMixin );
 *
 *		const view = new SomeView();
 *		view.listenTo( domElement, ( evt, domEvt ) => {
 *			console.log( evt, domEvt );
 *		} );
 *
 * @mixin module:utils/dom/emittermixin~EmitterMixin
 * @mixes module:utils/emittermixin~EmitterMixin
 * @implements module:utils/dom/emittermixin~Emitter
 */
const DomEmitterMixin = Object(__WEBPACK_IMPORTED_MODULE_2__lib_lodash_extend__["a" /* default */])( {}, __WEBPACK_IMPORTED_MODULE_0__emittermixin__["c" /* default */], {
	/**
	 * Registers a callback function to be executed when an event is fired in a specific Emitter or DOM Node.
	 * It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#listenTo}.
	 *
	 * @param {module:utils/emittermixin~Emitter|Node} emitter The object that fires the event.
	 * @param {String} event The name of the event.
	 * @param {Function} callback The function to be called on event.
	 * @param {Object} [options={}] Additional options.
	 * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
	 * the priority value the sooner the callback will be fired. Events having the same priority are called in the
	 * order they were added.
	 * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered
	 * listener before being dispatched to any EventTarget beneath it in the DOM tree.
	 *
	 * @method module:utils/dom/emittermixin~EmitterMixin#listenTo
	 */
	listenTo( ...args ) {
		const emitter = args[ 0 ];

		// Check if emitter is an instance of DOM Node. If so, replace the argument with
		// corresponding ProxyEmitter (or create one if not existing).
		if ( Object(__WEBPACK_IMPORTED_MODULE_3__isdomnode__["a" /* default */])( emitter ) ) {
			args[ 0 ] = this._getProxyEmitter( emitter ) || new ProxyEmitter( emitter );
		}

		// Execute parent class method with Emitter (or ProxyEmitter) instance.
		__WEBPACK_IMPORTED_MODULE_0__emittermixin__["c" /* default */].listenTo.apply( this, args );
	},

	/**
	 * Stops listening for events. It can be used at different levels:
	 * It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#listenTo}.
	 *
	 * * To stop listening to a specific callback.
	 * * To stop listening to a specific event.
	 * * To stop listening to all events fired by a specific object.
	 * * To stop listening to all events fired by all object.
	 *
	 * @param {module:utils/emittermixin~Emitter|Node} [emitter] The object to stop listening to. If omitted, stops it for all objects.
	 * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it
	 * for all events from `emitter`.
	 * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given
	 * `event`.
	 *
	 * @method module:utils/dom/emittermixin~EmitterMixin#stopListening
	 */
	stopListening( ...args ) {
		const emitter = args[ 0 ];

		// Check if emitter is an instance of DOM Node. If so, replace the argument with corresponding ProxyEmitter.
		if ( Object(__WEBPACK_IMPORTED_MODULE_3__isdomnode__["a" /* default */])( emitter ) ) {
			const proxy = this._getProxyEmitter( emitter );

			// Element has no listeners.
			if ( !proxy ) {
				return;
			}

			args[ 0 ] = proxy;
		}

		// Execute parent class method with Emitter (or ProxyEmitter) instance.
		__WEBPACK_IMPORTED_MODULE_0__emittermixin__["c" /* default */].stopListening.apply( this, args );
	},

	/**
	 * Retrieves ProxyEmitter instance for given DOM Node residing in this Host.
	 *
	 * @param {Node} node DOM Node of the ProxyEmitter.
	 * @method module:utils/dom/emittermixin~EmitterMixin#_getProxyEmitter
	 * @return {module:utils/dom/emittermixin~ProxyEmitter} ProxyEmitter instance or null.
	 */
	_getProxyEmitter( node ) {
		return Object(__WEBPACK_IMPORTED_MODULE_0__emittermixin__["a" /* _getEmitterListenedTo */])( this, getNodeUID( node ) );
	}
} );

/* harmony default export */ __webpack_exports__["a"] = (DomEmitterMixin);

/**
 * Creates a ProxyEmitter instance. Such an instance is a bridge between a DOM Node firing events
 * and any Host listening to them. It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#on}.
 *
 *                                  listenTo( click, ... )
 *                    +-----------------------------------------+
 *                    |              stopListening( ... )       |
 *     +----------------------------+                           |             addEventListener( click, ... )
 *     | Host                       |                           |   +---------------------------------------------+
 *     +----------------------------+                           |   |       removeEventListener( click, ... )     |
 *     | _listeningTo: {            |                +----------v-------------+                                   |
 *     |   UID: {                   |                | ProxyEmitter           |                                   |
 *     |     emitter: ProxyEmitter, |                +------------------------+                      +------------v----------+
 *     |     callbacks: {           |                | events: {              |                      | Node (HTMLElement)    |
 *     |       click: [ callbacks ] |                |   click: [ callbacks ] |                      +-----------------------+
 *     |     }                      |                | },                     |                      | data-ck-expando: UID  |
 *     |   }                        |                | _domNode: Node,        |                      +-----------------------+
 *     | }                          |                | _domListeners: {},     |                                   |
 *     | +------------------------+ |                | _emitterId: UID        |                                   |
 *     | | DomEmitterMixin        | |                +--------------^---------+                                   |
 *     | +------------------------+ |                           |   |                                             |
 *     +--------------^-------------+                           |   +---------------------------------------------+
 *                    |                                         |                  click (DOM Event)
 *                    +-----------------------------------------+
 *                                fire( click, DOM Event )
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 * @implements module:utils/dom/emittermixin~Emitter
 * @private
 */
class ProxyEmitter {
	/**
	 * @param {Node} node DOM Node that fires events.
	 * @returns {Object} ProxyEmitter instance bound to the DOM Node.
	 */
	constructor( node ) {
		// Set emitter ID to match DOM Node "expando" property.
		Object(__WEBPACK_IMPORTED_MODULE_0__emittermixin__["b" /* _setEmitterId */])( this, getNodeUID( node ) );

		// Remember the DOM Node this ProxyEmitter is bound to.
		this._domNode = node;
	}
}

Object(__WEBPACK_IMPORTED_MODULE_2__lib_lodash_extend__["a" /* default */])( ProxyEmitter.prototype, __WEBPACK_IMPORTED_MODULE_0__emittermixin__["c" /* default */], {
	/**
	 * Collection of native DOM listeners.
	 *
	 * @private
	 * @member {Object} module:utils/dom/emittermixin~ProxyEmitter#_domListeners
	 */

	/**
	 * Registers a callback function to be executed when an event is fired.
	 *
	 * It attaches a native DOM listener to the DOM Node. When fired,
	 * a corresponding Emitter event will also fire with DOM Event object as an argument.
	 *
	 * @param {String} event The name of the event.
	 * @param {Function} callback The function to be called on event.
	 * @param {Object} [options={}] Additional options.
	 * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
	 * the priority value the sooner the callback will be fired. Events having the same priority are called in the
	 * order they were added.
	 * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered
	 * listener before being dispatched to any EventTarget beneath it in the DOM tree.
	 *
	 * @method module:utils/dom/emittermixin~ProxyEmitter#on
	 */
	on( event, callback, options = {} ) {
		// Execute parent class method first.
		__WEBPACK_IMPORTED_MODULE_0__emittermixin__["c" /* default */].on.call( this, event, callback, options );

		// If the DOM Listener for given event already exist it is pointless
		// to attach another one.
		if ( this._domListeners && this._domListeners[ event ] ) {
			return;
		}

		const domListener = this._createDomListener( event, !!options.useCapture );

		// Attach the native DOM listener to DOM Node.
		this._domNode.addEventListener( event, domListener, !!options.useCapture );

		if ( !this._domListeners ) {
			this._domListeners = {};
		}

		// Store the native DOM listener in this ProxyEmitter. It will be helpful
		// when stopping listening to the event.
		this._domListeners[ event ] = domListener;
	},

	/**
	 * Stops executing the callback on the given event.
	 *
	 * @param {String} event The name of the event.
	 * @param {Function} callback The function to stop being called.
	 *
	 * @method module:utils/dom/emittermixin~ProxyEmitter#off
	 */
	off( event, callback ) {
		// Execute parent class method first.
		__WEBPACK_IMPORTED_MODULE_0__emittermixin__["c" /* default */].off.call( this, event, callback );

		let events;

		// Remove native DOM listeners which are orphans. If no callbacks
		// are awaiting given event, detach native DOM listener from DOM Node.
		// See: {@link on}.

		if ( this._domListeners[ event ] && ( !( events = this._events[ event ] ) || !events.callbacks.length ) ) {
			this._domListeners[ event ].removeListener();
		}
	},

	/**
	 * Create a native DOM listener callback. When the native DOM event
	 * is fired it will fire corresponding event on this ProxyEmitter.
	 * Note: A native DOM Event is passed as an argument.
	 *
	 * @private
	 * @param {String} event
	 *
	 * @method module:utils/dom/emittermixin~ProxyEmitter#_createDomListener
	 * @param {String} event The name of the event.
	 * @param {Boolean} useCapture Indicates whether the listener was created for capturing event.
	 * @returns {Function} The DOM listener callback.
	 */
	_createDomListener( event, useCapture ) {
		const domListener = domEvt => {
			this.fire( event, domEvt );
		};

		// Supply the DOM listener callback with a function that will help
		// detach it from the DOM Node, when it is no longer necessary.
		// See: {@link off}.
		domListener.removeListener = () => {
			this._domNode.removeEventListener( event, domListener, useCapture );
			delete this._domListeners[ event ];
		};

		return domListener;
	}
} );

// Gets an unique DOM Node identifier. The identifier will be set if not defined.
//
// @private
// @param {Node} node
// @return {String} UID for given DOM Node.
function getNodeUID( node ) {
	return node[ 'data-ck-expando' ] || ( node[ 'data-ck-expando' ] = Object(__WEBPACK_IMPORTED_MODULE_1__uid__["a" /* default */])() );
}

/**
 * Interface representing classes which mix in {@link module:utils/dom/emittermixin~EmitterMixin}.
 *
 * @interface Emitter
 */


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__range__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__element__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_count__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_isiterable__ = __webpack_require__(34);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/selection
 */










/**
 * Class representing selection in tree view.
 *
 * Selection can consist of {@link module:engine/view/range~Range ranges} that can be added using
 * {@link module:engine/view/selection~Selection#addRange addRange}
 * and {@link module:engine/view/selection~Selection#setRanges setRanges} methods.
 * Both methods create copies of provided ranges and store those copies internally. Further modifications to passed
 * ranges will not change selection's state.
 * Selection's ranges can be obtained via {@link module:engine/view/selection~Selection#getRanges getRanges},
 * {@link module:engine/view/selection~Selection#getFirstRange getFirstRange}
 * and {@link module:engine/view/selection~Selection#getLastRange getLastRange}
 * methods, which return copies of ranges stored inside selection. Modifications made on these copies will not change
 * selection's state. Similar situation occurs when getting {@link module:engine/view/selection~Selection#anchor anchor},
 * {@link module:engine/view/selection~Selection#focus focus}, {@link module:engine/view/selection~Selection#getFirstPosition first} and
 * {@link module:engine/view/selection~Selection#getLastPosition last} positions - all will return copies of requested positions.
 */
class Selection {
	/**
	 * Creates new selection instance.
	 *
	 * @param {Iterable.<module:engine/view/range~Range>} [ranges] An optional array of ranges to set.
	 * @param {Boolean} [isLastBackward] An optional flag describing if last added range was selected forward - from start to end
	 * (`false`) or backward - from end to start (`true`). Defaults to `false`.
	 */
	constructor( ranges, isLastBackward ) {
		/**
		 * Stores all ranges that are selected.
		 *
		 * @protected
		 * @member {Array.<module:engine/view/range~Range>}
		 */
		this._ranges = [];

		/**
		 * Specifies whether the last added range was added as a backward or forward range.
		 *
		 * @protected
		 * @member {Boolean}
		 */
		this._lastRangeBackward = false;

		/**
		 * Specifies whether selection instance is fake.
		 *
		 * @private
		 * @member {Boolean}
		 */
		this._isFake = false;

		/**
		 * Fake selection's label.
		 *
		 * @private
		 * @member {String}
		 */
		this._fakeSelectionLabel = '';

		if ( ranges ) {
			this.setRanges( ranges, isLastBackward );
		}
	}

	/**
	 * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
	 * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
	 * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
	 *
	 * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
	 * properly handled by screen readers).
	 *
	 * @fires change
	 * @param {Boolean} [value=true] If set to true selection will be marked as `fake`.
	 * @param {Object} [options] Additional options.
	 * @param {String} [options.label=''] Fake selection label.
	 */
	setFake( value = true, options = {} ) {
		this._isFake = value;
		this._fakeSelectionLabel = value ? options.label || '' : '';

		this.fire( 'change' );
	}

	/**
	 * Returns true if selection instance is marked as `fake`.
	 *
	 * @see #setFake
	 * @returns {Boolean}
	 */
	get isFake() {
		return this._isFake;
	}

	/**
	 * Returns fake selection label.
	 *
	 * @see #setFake
	 * @returns {String}
	 */
	get fakeSelectionLabel() {
		return this._fakeSelectionLabel;
	}

	/**
	 * Selection anchor. Anchor may be described as a position where the selection starts. Together with
	 * {@link #focus focus} they define the direction of selection, which is important
	 * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
	 * It may be a bit unintuitive when there are multiple ranges in selection.
	 *
	 * @see #focus
	 * @type {module:engine/view/position~Position}
	 */
	get anchor() {
		if ( !this._ranges.length ) {
			return null;
		}
		const range = this._ranges[ this._ranges.length - 1 ];
		const anchor = this._lastRangeBackward ? range.end : range.start;

		return __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createFromPosition( anchor );
	}

	/**
	 * Selection focus. Focus is a position where the selection ends.
	 *
	 * @see #anchor
	 * @type {module:engine/view/position~Position}
	 */
	get focus() {
		if ( !this._ranges.length ) {
			return null;
		}
		const range = this._ranges[ this._ranges.length - 1 ];
		const focus = this._lastRangeBackward ? range.start : range.end;

		return __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createFromPosition( focus );
	}

	/**
	 * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
	 * collapsed.
	 *
	 * @type {Boolean}
	 */
	get isCollapsed() {
		return this.rangeCount === 1 && this._ranges[ 0 ].isCollapsed;
	}

	/**
	 * Returns number of ranges in selection.
	 *
	 * @type {Number}
     */
	get rangeCount() {
		return this._ranges.length;
	}

	/**
	 * Specifies whether the {@link #focus} precedes {@link #anchor}.
	 *
	 * @type {Boolean}
	 */
	get isBackward() {
		return !this.isCollapsed && this._lastRangeBackward;
	}

	/**
	 * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
	 * if the selection is not inside an editable element.
	 *
	 * @type {module:engine/view/editableelement~EditableElement|null}
	 */
	get editableElement() {
		if ( this.anchor ) {
			return this.anchor.editableElement;
		}

		return null;
	}

	/**
	 * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
	 * selection instance and you can safely operate on it.
	 *
	 * Accepts a flag describing in which way the selection is made - passed range might be selected from
	 * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}
	 * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.
	 * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
	 * with ranges already stored in Selection instance.
	 *
	 * @fires change
	 * @param {module:engine/view/range~Range} range
	 * @param {Boolean} isBackward
	 */
	addRange( range, isBackward ) {
		if ( !( range instanceof __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */] ) ) {
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-selection-invalid-range: Invalid Range.' );
		}

		this._pushRange( range );
		this._lastRangeBackward = !!isBackward;
		this.fire( 'change' );
	}

	/**
	 * Returns an iterator that contains copies of all ranges added to the selection.
	 *
	 * @returns {Iterator.<module:engine/view/range~Range>}
	 */
	* getRanges() {
		for ( const range of this._ranges ) {
			yield __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createFromRange( range );
		}
	}

	/**
	 * Returns copy of the first range in the selection. First range is the one which
	 * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
	 * position of all other ranges (not to confuse with the first range added to the selection).
	 * Returns `null` if no ranges are added to selection.
	 *
	 * @returns {module:engine/view/range~Range|null}
	 */
	getFirstRange() {
		let first = null;

		for ( const range of this._ranges ) {
			if ( !first || range.start.isBefore( first.start ) ) {
				first = range;
			}
		}

		return first ? __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createFromRange( first ) : null;
	}

	/**
	 * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
	 * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
	 * with the last range added to the selection). Returns `null` if no ranges are added to selection.
	 *
	 * @returns {module:engine/view/range~Range|null}
	 */
	getLastRange() {
		let last = null;

		for ( const range of this._ranges ) {
			if ( !last || range.end.isAfter( last.end ) ) {
				last = range;
			}
		}

		return last ? __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createFromRange( last ) : null;
	}

	/**
	 * Returns copy of the first position in the selection. First position is the position that
	 * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
	 * Returns `null` if no ranges are added to selection.
	 *
	 * @returns {module:engine/view/position~Position|null}
	 */
	getFirstPosition() {
		const firstRange = this.getFirstRange();

		return firstRange ? __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createFromPosition( firstRange.start ) : null;
	}

	/**
	 * Returns copy of the last position in the selection. Last position is the position that
	 * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
	 * Returns `null` if no ranges are added to selection.
	 *
	 * @returns {module:engine/view/position~Position|null}
	 */
	getLastPosition() {
		const lastRange = this.getLastRange();

		return lastRange ? __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createFromPosition( lastRange.end ) : null;
	}

	/**
	 * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
	 * same number of ranges and all ranges from one selection equal to a range from other selection.
	 *
	 * @param {module:engine/view/selection~Selection} otherSelection Selection to compare with.
	 * @returns {Boolean} `true` if selections are equal, `false` otherwise.
	 */
	isEqual( otherSelection ) {
		if ( this.isFake != otherSelection.isFake ) {
			return false;
		}

		if ( this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel ) {
			return false;
		}

		if ( this.rangeCount != otherSelection.rangeCount ) {
			return false;
		} else if ( this.rangeCount === 0 ) {
			return true;
		}

		if ( !this.anchor.isEqual( otherSelection.anchor ) || !this.focus.isEqual( otherSelection.focus ) ) {
			return false;
		}

		for ( const thisRange of this._ranges ) {
			let found = false;

			for ( const otherRange of otherSelection._ranges ) {
				if ( thisRange.isEqual( otherRange ) ) {
					found = true;
					break;
				}
			}

			if ( !found ) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
	 * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
	 * equal to any trimmed range from other selection.
	 *
	 * @param {module:engine/view/selection~Selection} otherSelection Selection to compare with.
	 * @returns {Boolean} `true` if selections are similar, `false` otherwise.
	 */
	isSimilar( otherSelection ) {
		if ( this.isBackward != otherSelection.isBackward ) {
			return false;
		}

		const numOfRangesA = Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_count__["a" /* default */])( this.getRanges() );
		const numOfRangesB = Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_count__["a" /* default */])( otherSelection.getRanges() );

		// If selections have different number of ranges, they cannot be similar.
		if ( numOfRangesA != numOfRangesB ) {
			return false;
		}

		// If both selections have no ranges, they are similar.
		if ( numOfRangesA == 0 ) {
			return true;
		}

		// Check if each range in one selection has a similar range in other selection.
		for ( let rangeA of this.getRanges() ) {
			rangeA = rangeA.getTrimmed();

			let found = false;

			for ( let rangeB of otherSelection.getRanges() ) {
				rangeB = rangeB.getTrimmed();

				if ( rangeA.start.isEqual( rangeB.start ) && rangeA.end.isEqual( rangeB.end ) ) {
					found = true;
					break;
				}
			}

			// For `rangeA`, neither range in `otherSelection` was similar. So selections are not similar.
			if ( !found ) {
				return false;
			}
		}

		// There were no ranges that weren't matched. Selections are similar.
		return true;
	}

	/**
	 * Removes all ranges that were added to the selection.
	 *
	 * @fires change
	 */
	removeAllRanges() {
		if ( this._ranges.length ) {
			this._ranges = [];
			this.fire( 'change' );
		}
	}

	/**
	 * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
	 * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
	 * Accepts a flag describing in which way the selection is made (see {@link #addRange addRange}).
	 *
	 * @fires change
	 * @param {Iterable.<module:engine/view/range~Range>} newRanges Iterable object of ranges to set.
	 * @param {Boolean} [isLastBackward] Flag describing if last added range was selected forward - from start to end
	 * (`false`) or backward - from end to start (`true`). Defaults to `false`.
	 */
	setRanges( newRanges, isLastBackward ) {
		this._ranges = [];

		for ( const range of newRanges ) {
			if ( !( range instanceof __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */] ) ) {
				throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-selection-invalid-range: Invalid Range.' );
			}

			this._pushRange( range );
		}

		this._lastRangeBackward = !!isLastBackward;
		this.fire( 'change' );
	}

	/**
	 * Sets this selection's ranges and direction to the specified location based on the given
	 * {@link module:engine/view/selection~Selection selection}, {@link module:engine/view/position~Position position},
	 * {@link module:engine/view/range~Range range} or an iterable of {@link module:engine/view/range~Range ranges}.
	 *
	 * @param {module:engine/view/selection~Selection|module:engine/view/position~Position|
	 * Iterable.<module:engine/view/range~Range>|module:engine/view/range~Range} selectable
	 */
	setTo( selectable ) {
		if ( selectable instanceof Selection ) {
			this._isFake = selectable._isFake;
			this._fakeSelectionLabel = selectable._fakeSelectionLabel;
			this.setRanges( selectable.getRanges(), selectable.isBackward );
		} else if ( selectable instanceof __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */] ) {
			this.setRanges( [ selectable ] );
		} else if ( Object(__WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_isiterable__["a" /* default */])( selectable ) ) {
			// We assume that the selectable is an iterable of ranges.
			this.setRanges( selectable );
		} else {
			// We assume that the selectable is a position.
			this.setRanges( [ new __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */]( selectable ) ] );
		}
	}

	/**
	 * Sets this selection in the provided element.
	 *
	 * @param {module:engine/view/element~Element} element
	 */
	setIn( element ) {
		this.setRanges( [ __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createIn( element ) ] );
	}

	/**
	 * Sets this selection on the provided item.
	 *
	 * @param {module:engine/view/item~Item} item
	 */
	setOn( item ) {
		this.setRanges( [ __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createOn( item ) ] );
	}

	/**
	 * Sets collapsed selection at the specified location.
	 *
	 * The location can be specified in the same form as {@link module:engine/view/position~Position.createAt} parameters.
	 *
	 * @fires change
	 * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition
	 * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
	 * first parameter is a {@link module:engine/view/item~Item view item}.
	 */
	setCollapsedAt( itemOrPosition, offset ) {
		const pos = __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createAt( itemOrPosition, offset );
		const range = new __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */]( pos, pos );

		this.setRanges( [ range ] );
	}

	/**
	 * Collapses selection to the selection's {@link #getFirstPosition first position}.
	 * All ranges, besides the collapsed one, will be removed. Nothing will change if there are no ranges stored
	 * inside selection.
	 *
	 * @fires change
	 */
	collapseToStart() {
		const startPosition = this.getFirstPosition();

		if ( startPosition !== null ) {
			this.setRanges( [ new __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */]( startPosition, startPosition ) ] );
		}
	}

	/**
	 * Collapses selection to the selection's {@link #getLastPosition last position}.
	 * All ranges, besides the collapsed one, will be removed. Nothing will change if there are no ranges stored
	 * inside selection.
	 *
	 * @fires change
	 */
	collapseToEnd() {
		const endPosition = this.getLastPosition();

		if ( endPosition !== null ) {
			this.setRanges( [ new __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */]( endPosition, endPosition ) ] );
		}
	}

	/**
	 * Moves {@link #focus} to the specified location.
	 *
	 * The location can be specified in the same form as {@link module:engine/view/position~Position.createAt} parameters.
	 *
	 * @fires change
	 * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition
	 * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
	 * first parameter is a {@link module:engine/view/item~Item view item}.
	 */
	moveFocusTo( itemOrPosition, offset ) {
		if ( this.anchor === null ) {
			/**
			 * Cannot set selection focus if there are no ranges in selection.
			 *
			 * @error view-selection-moveFocusTo-no-ranges
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'view-selection-moveFocusTo-no-ranges: Cannot set selection focus if there are no ranges in selection.'
			);
		}

		const newFocus = __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createAt( itemOrPosition, offset );

		if ( newFocus.compareWith( this.focus ) == 'same' ) {
			return;
		}

		const anchor = this.anchor;

		this._ranges.pop();

		if ( newFocus.compareWith( anchor ) == 'before' ) {
			this.addRange( new __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */]( newFocus, anchor ), true );
		} else {
			this.addRange( new __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */]( anchor, newFocus ) );
		}
	}

	/**
	 * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
	 * one range in the selection, and that range contains exactly one element.
	 * Returns `null` if there is no selected element.
	 *
	 * @returns {module:engine/view/element~Element|null}
	 */
	getSelectedElement() {
		if ( this.rangeCount !== 1 ) {
			return null;
		}

		const range = this.getFirstRange();
		const nodeAfterStart = range.start.nodeAfter;
		const nodeBeforeEnd = range.end.nodeBefore;

		return ( nodeAfterStart instanceof __WEBPACK_IMPORTED_MODULE_5__element__["a" /* default */] && nodeAfterStart == nodeBeforeEnd ) ? nodeAfterStart : null;
	}

	/**
	 * Creates and returns an instance of `Selection` that is a clone of given selection, meaning that it has same
	 * ranges and same direction as this selection.
	 *
	 * @params {module:engine/view/selection~Selection} otherSelection Selection to be cloned.
	 * @returns {module:engine/view/selection~Selection} `Selection` instance that is a clone of given selection.
	 */
	static createFromSelection( otherSelection ) {
		const selection = new Selection();
		selection.setTo( otherSelection );

		return selection;
	}

	/**
	 * Adds range to selection - creates copy of given range so it can be safely used and modified.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
	 * with ranges already stored in selection instance.
	 *
	 * @private
	 * @param {module:engine/view/range~Range} range
	 */
	_pushRange( range ) {
		for ( const storedRange of this._ranges ) {
			if ( range.isIntersecting( storedRange ) ) {
				/**
				 * Trying to add a range that intersects with another range from selection.
				 *
				 * @error view-selection-range-intersects
				 * @param {module:engine/view/range~Range} addedRange Range that was added to the selection.
				 * @param {module:engine/view/range~Range} intersectingRange Range from selection that intersects with `addedRange`.
				 */
				throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
					'view-selection-range-intersects: Trying to add a range that intersects with another range from selection.',
					{ addedRange: range, intersectingRange: storedRange }
				);
			}
		}

		this._ranges.push( __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createFromRange( range ) );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Selection;


Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Selection, __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

/**
 * Fired whenever selection ranges are changed through {@link ~Selection Selection API}.
 *
 * @event change
 */


/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__text__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__element__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__range__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__selection__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__documentfragment__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__treewalker__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__filler__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_dom_global__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_dom_indexof__ = __webpack_require__(423);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ckeditor_ckeditor5_utils_src_dom_getancestors__ = __webpack_require__(259);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ckeditor_ckeditor5_utils_src_dom_getcommonancestor__ = __webpack_require__(424);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/domconverter
 */

/* globals document, Node, NodeFilter */















/**
 * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles
 * {@link module:engine/view/domconverter~DomConverter#bindElements binding} these nodes.
 *
 * DomConverter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep a
 * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link module:engine/view/document~Document}).
 *
 * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will
 * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.
 */
class DomConverter {
	/**
	 * Creates DOM converter.
	 *
	 * @param {Object} options Object with configuration options.
	 * @param {Function} [options.blockFiller=module:engine/view/filler~BR_FILLER] Block filler creator.
	 */
	constructor( options = {} ) {
		// Using WeakMap prevent memory leaks: when the converter will be destroyed all referenced between View and DOM
		// will be removed. Also because it is a *Weak*Map when both view and DOM elements will be removed referenced
		// will be also removed, isn't it brilliant?
		//
		// Yes, PJ. It is.
		//
		// You guys so smart.
		//
		// I've been here. Seen stuff. Afraid of code now.

		/**
		 * Block {@link module:engine/view/filler filler} creator, which is used to create all block fillers during the
		 * view to DOM conversion and to recognize block fillers during the DOM to view conversion.
		 *
		 * @readonly
		 * @member {Function} module:engine/view/domconverter~DomConverter#blockFiller
		 */
		this.blockFiller = options.blockFiller || __WEBPACK_IMPORTED_MODULE_7__filler__["a" /* BR_FILLER */];

		/**
		 * Tag names of DOM `Element`s which are considered pre-formatted elements.
		 *
		 * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements
		 */
		this.preElements = [ 'pre' ];

		/**
		 * Tag names of DOM `Element`s which are considered block elements.
		 *
		 * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements
		 */
		this.blockElements = [ 'p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6' ];

		/**
		 * DOM to View mapping.
		 *
		 * @private
		 * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping
		 */
		this._domToViewMapping = new WeakMap();

		/**
		 * View to DOM mapping.
		 *
		 * @private
		 * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping
		 */
		this._viewToDomMapping = new WeakMap();

		/**
		 * Holds mapping between fake selection containers and corresponding view selections.
		 *
		 * @private
		 * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping
		 */
		this._fakeSelectionMapping = new WeakMap();
	}

	/**
	 * Binds given DOM element that represents fake selection to {@link module:engine/view/selection~Selection view selection}.
	 * View selection copy is stored and can be retrieved by {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView}
	 * method.
	 *
	 * @param {HTMLElement} domElement
	 * @param {module:engine/view/selection~Selection} viewSelection
	 */
	bindFakeSelection( domElement, viewSelection ) {
		this._fakeSelectionMapping.set( domElement, __WEBPACK_IMPORTED_MODULE_4__selection__["a" /* default */].createFromSelection( viewSelection ) );
	}

	/**
	 * Returns {@link module:engine/view/selection~Selection view selection} instance corresponding to given DOM element that represents
	 * fake selection. Returns `undefined` if binding to given DOM element does not exists.
	 *
	 * @param {HTMLElement} domElement
	 * @returns {module:engine/view/selection~Selection|undefined}
	 */
	fakeSelectionToView( domElement ) {
		return this._fakeSelectionMapping.get( domElement );
	}

	/**
	 * Binds DOM and View elements, so it will be possible to get corresponding elements using
	 * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
	 * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
	 *
	 * @param {HTMLElement} domElement DOM element to bind.
	 * @param {module:engine/view/element~Element} viewElement View element to bind.
	 */
	bindElements( domElement, viewElement ) {
		this._domToViewMapping.set( domElement, viewElement );
		this._viewToDomMapping.set( viewElement, domElement );
	}

	/**
	 * Unbinds given `domElement` from the view element it was bound to. Unbinding is deep, meaning that all children of
	 * `domElement` will be unbound too.
	 *
	 * @param {HTMLElement} domElement DOM element to unbind.
	 */
	unbindDomElement( domElement ) {
		const viewElement = this._domToViewMapping.get( domElement );

		if ( viewElement ) {
			this._domToViewMapping.delete( domElement );
			this._viewToDomMapping.delete( viewElement );

			// Use Array.from because of MS Edge (#923).
			for ( const child of Array.from( domElement.childNodes ) ) {
				this.unbindDomElement( child );
			}
		}
	}

	/**
	 * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using
	 * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
	 * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
	 *
	 * @param {DocumentFragment} domFragment DOM document fragment to bind.
	 * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment View document fragment to bind.
	 */
	bindDocumentFragments( domFragment, viewFragment ) {
		this._domToViewMapping.set( domFragment, viewFragment );
		this._viewToDomMapping.set( viewFragment, domFragment );
	}

	/**
	 * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will
	 * be created. For bound elements and document fragments function will return corresponding items.
	 *
	 * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode
	 * View node or document fragment to transform.
	 * @param {Document} domDocument Document which will be used to create DOM nodes.
	 * @param {Object} [options] Conversion options.
	 * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.
	 * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.
	 * @returns {Node|DocumentFragment} Converted node or DocumentFragment.
	 */
	viewToDom( viewNode, domDocument, options = {} ) {
		if ( viewNode.is( 'text' ) ) {
			const textData = this._processDataFromViewText( viewNode );

			return domDocument.createTextNode( textData );
		} else {
			if ( this.mapViewToDom( viewNode ) ) {
				return this.mapViewToDom( viewNode );
			}

			let domElement;

			if ( viewNode.is( 'documentFragment' ) ) {
				// Create DOM document fragment.
				domElement = domDocument.createDocumentFragment();

				if ( options.bind ) {
					this.bindDocumentFragments( domElement, viewNode );
				}
			} else if ( viewNode.is( 'uiElement' ) ) {
				// UIElement has its own render() method (see #799).
				domElement = viewNode.render( domDocument );

				if ( options.bind ) {
					this.bindElements( domElement, viewNode );
				}

				return domElement;
			} else {
				// Create DOM element.
				domElement = domDocument.createElement( viewNode.name );

				if ( options.bind ) {
					this.bindElements( domElement, viewNode );
				}

				// Copy element's attributes.
				for ( const key of viewNode.getAttributeKeys() ) {
					domElement.setAttribute( key, viewNode.getAttribute( key ) );
				}
			}

			if ( options.withChildren || options.withChildren === undefined ) {
				for ( const child of this.viewChildrenToDom( viewNode, domDocument, options ) ) {
					domElement.appendChild( child );
				}
			}

			return domElement;
		}
	}

	/**
	 * Converts children of the view element to DOM using the
	 * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.
	 * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.
	 *
	 * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.
	 * @param {Document} domDocument Document which will be used to create DOM nodes.
	 * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.
	 * @returns {Iterable.<Node>} DOM nodes.
	 */
	* viewChildrenToDom( viewElement, domDocument, options = {} ) {
		const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();
		let offset = 0;

		for ( const childView of viewElement.getChildren() ) {
			if ( fillerPositionOffset === offset ) {
				yield this.blockFiller( domDocument );
			}

			yield this.viewToDom( childView, domDocument, options );

			offset++;
		}

		if ( fillerPositionOffset === offset ) {
			yield this.blockFiller( domDocument );
		}
	}

	/**
	 * Converts view {@link module:engine/view/range~Range} to DOM range.
	 * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
	 *
	 * @param {module:engine/view/range~Range} viewRange View range.
	 * @returns {Range} DOM range.
	 */
	viewRangeToDom( viewRange ) {
		const domStart = this.viewPositionToDom( viewRange.start );
		const domEnd = this.viewPositionToDom( viewRange.end );

		const domRange = document.createRange();
		domRange.setStart( domStart.parent, domStart.offset );
		domRange.setEnd( domEnd.parent, domEnd.offset );

		return domRange;
	}

	/**
	 * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.
	 *
	 * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
	 * If the converted position is directly before inline filler it is moved inside the filler.
	 *
	 * @param {module:engine/view/position~Position} viewPosition View position.
	 * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.
	 * @returns {Node} position.parent DOM position parent.
	 * @returns {Number} position.offset DOM position offset.
	 */
	viewPositionToDom( viewPosition ) {
		const viewParent = viewPosition.parent;

		if ( viewParent.is( 'text' ) ) {
			const domParent = this.findCorrespondingDomText( viewParent );

			if ( !domParent ) {
				// Position is in a view text node that has not been rendered to DOM yet.
				return null;
			}

			let offset = viewPosition.offset;

			if ( Object(__WEBPACK_IMPORTED_MODULE_7__filler__["i" /* startsWithFiller */])( domParent ) ) {
				offset += __WEBPACK_IMPORTED_MODULE_7__filler__["c" /* INLINE_FILLER_LENGTH */];
			}

			return { parent: domParent, offset };
		} else {
			// viewParent is instance of ViewElement.
			let domParent, domBefore, domAfter;

			if ( viewPosition.offset === 0 ) {
				domParent = this.mapViewToDom( viewParent );

				if ( !domParent ) {
					// Position is in a view element that has not been rendered to DOM yet.
					return null;
				}

				domAfter = domParent.childNodes[ 0 ];
			} else {
				const nodeBefore = viewPosition.nodeBefore;

				domBefore = nodeBefore.is( 'text' ) ?
					this.findCorrespondingDomText( nodeBefore ) :
					this.mapViewToDom( viewPosition.nodeBefore );

				if ( !domBefore ) {
					// Position is after a view element that has not been rendered to DOM yet.
					return null;
				}

				domParent = domBefore.parentNode;
				domAfter = domBefore.nextSibling;
			}

			// If there is an inline filler at position return position inside the filler. We should never return
			// the position before the inline filler.
			if ( this.isText( domAfter ) && Object(__WEBPACK_IMPORTED_MODULE_7__filler__["i" /* startsWithFiller */])( domAfter ) ) {
				return { parent: domAfter, offset: __WEBPACK_IMPORTED_MODULE_7__filler__["c" /* INLINE_FILLER_LENGTH */] };
			}

			const offset = domBefore ? Object(__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_dom_indexof__["a" /* default */])( domBefore ) + 1 : 0;

			return { parent: domParent, offset };
		}
	}

	/**
	 * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
	 * be created. For bound elements and document fragments function will return corresponding items. For
	 * {@link module:engine/view/filler fillers} `null` will be returned.
	 * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
	 *
	 * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.
	 * @param {Object} [options] Conversion options.
	 * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.
	 * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.
	 * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.
	 * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment
	 * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.
	 */
	domToView( domNode, options = {} ) {
		if ( Object(__WEBPACK_IMPORTED_MODULE_7__filler__["g" /* isBlockFiller */])( domNode, this.blockFiller ) ) {
			return null;
		}

		// When node is inside UIElement return that UIElement as it's view representation.
		const uiElement = this.getParentUIElement( domNode, this._domToViewMapping );

		if ( uiElement ) {
			return uiElement;
		}

		if ( this.isText( domNode ) ) {
			if ( Object(__WEBPACK_IMPORTED_MODULE_7__filler__["h" /* isInlineFiller */])( domNode ) ) {
				return null;
			} else {
				const textData = this._processDataFromDomText( domNode );

				return textData === '' ? null : new __WEBPACK_IMPORTED_MODULE_0__text__["a" /* default */]( textData );
			}
		} else if ( this.isComment( domNode ) ) {
			return null;
		} else {
			if ( this.mapDomToView( domNode ) ) {
				return this.mapDomToView( domNode );
			}

			let viewElement;

			if ( this.isDocumentFragment( domNode ) ) {
				// Create view document fragment.
				viewElement = new __WEBPACK_IMPORTED_MODULE_5__documentfragment__["a" /* default */]();

				if ( options.bind ) {
					this.bindDocumentFragments( domNode, viewElement );
				}
			} else {
				// Create view element.
				const viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();
				viewElement = new __WEBPACK_IMPORTED_MODULE_1__element__["a" /* default */]( viewName );

				if ( options.bind ) {
					this.bindElements( domNode, viewElement );
				}

				// Copy element's attributes.
				const attrs = domNode.attributes;

				for ( let i = attrs.length - 1; i >= 0; i-- ) {
					viewElement.setAttribute( attrs[ i ].name, attrs[ i ].value );
				}
			}

			if ( options.withChildren || options.withChildren === undefined ) {
				for ( const child of this.domChildrenToView( domNode, options ) ) {
					viewElement.appendChildren( child );
				}
			}

			return viewElement;
		}
	}

	/**
	 * Converts children of the DOM element to view nodes using
	 * the {@link module:engine/view/domconverter~DomConverter#domToView} method.
	 * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.
	 *
	 * @param {HTMLElement} domElement Parent DOM element.
	 * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
	 * @returns {Iterable.<module:engine/view/node~Node>} View nodes.
	 */
	* domChildrenToView( domElement, options = {} ) {
		for ( let i = 0; i < domElement.childNodes.length; i++ ) {
			const domChild = domElement.childNodes[ i ];
			const viewChild = this.domToView( domChild, options );

			if ( viewChild !== null ) {
				yield viewChild;
			}
		}
	}

	/**
	 * Converts DOM selection to view {@link module:engine/view/selection~Selection}.
	 * Ranges which cannot be converted will be omitted.
	 *
	 * @param {Selection} domSelection DOM selection.
	 * @returns {module:engine/view/selection~Selection} View selection.
	 */
	domSelectionToView( domSelection ) {
		// DOM selection might be placed in fake selection container.
		// If container contains fake selection - return corresponding view selection.
		if ( domSelection.rangeCount === 1 ) {
			let container = domSelection.getRangeAt( 0 ).startContainer;

			// The DOM selection might be moved to the text node inside the fake selection container.
			if ( this.isText( container ) ) {
				container = container.parentNode;
			}

			const viewSelection = this.fakeSelectionToView( container );

			if ( viewSelection ) {
				return viewSelection;
			}
		}

		const viewSelection = new __WEBPACK_IMPORTED_MODULE_4__selection__["a" /* default */]();
		const isBackward = this.isDomSelectionBackward( domSelection );

		for ( let i = 0; i < domSelection.rangeCount; i++ ) {
			// DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.
			const domRange = domSelection.getRangeAt( i );
			const viewRange = this.domRangeToView( domRange );

			if ( viewRange ) {
				viewSelection.addRange( viewRange, isBackward );
			}
		}

		return viewSelection;
	}

	/**
	 * Converts DOM Range to view {@link module:engine/view/range~Range}.
	 * If the start or end position can not be converted `null` is returned.
	 *
	 * @param {Range} domRange DOM range.
	 * @returns {module:engine/view/range~Range|null} View range.
	 */
	domRangeToView( domRange ) {
		const viewStart = this.domPositionToView( domRange.startContainer, domRange.startOffset );
		const viewEnd = this.domPositionToView( domRange.endContainer, domRange.endOffset );

		if ( viewStart && viewEnd ) {
			return new __WEBPACK_IMPORTED_MODULE_3__range__["a" /* default */]( viewStart, viewEnd );
		}

		return null;
	}

	/**
	 * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.
	 *
	 * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,
	 * position of the filler will be converted and returned.
	 *
	 * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}
	 * that position will be converted to view position before that UIElement.
	 *
	 * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
	 *
	 * @param {Node} domParent DOM position parent.
	 * @param {Number} domOffset DOM position offset.
	 * @returns {module:engine/view/position~Position} viewPosition View position.
	 */
	domPositionToView( domParent, domOffset ) {
		if ( Object(__WEBPACK_IMPORTED_MODULE_7__filler__["g" /* isBlockFiller */])( domParent, this.blockFiller ) ) {
			return this.domPositionToView( domParent.parentNode, Object(__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_dom_indexof__["a" /* default */])( domParent ) );
		}

		// If position is somewhere inside UIElement - return position before that element.
		const viewElement = this.mapDomToView( domParent );

		if ( viewElement && viewElement.is( 'uiElement' ) ) {
			return __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createBefore( viewElement );
		}

		if ( this.isText( domParent ) ) {
			if ( Object(__WEBPACK_IMPORTED_MODULE_7__filler__["h" /* isInlineFiller */])( domParent ) ) {
				return this.domPositionToView( domParent.parentNode, Object(__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_dom_indexof__["a" /* default */])( domParent ) );
			}

			const viewParent = this.findCorrespondingViewText( domParent );
			let offset = domOffset;

			if ( !viewParent ) {
				return null;
			}

			if ( Object(__WEBPACK_IMPORTED_MODULE_7__filler__["i" /* startsWithFiller */])( domParent ) ) {
				offset -= __WEBPACK_IMPORTED_MODULE_7__filler__["c" /* INLINE_FILLER_LENGTH */];
				offset = offset < 0 ? 0 : offset;
			}

			return new __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */]( viewParent, offset );
		}
		// domParent instanceof HTMLElement.
		else {
			if ( domOffset === 0 ) {
				const viewParent = this.mapDomToView( domParent );

				if ( viewParent ) {
					return new __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */]( viewParent, 0 );
				}
			} else {
				const domBefore = domParent.childNodes[ domOffset - 1 ];
				const viewBefore = this.isText( domBefore ) ?
					this.findCorrespondingViewText( domBefore ) :
					this.mapDomToView( domBefore );

				// TODO #663
				if ( viewBefore && viewBefore.parent ) {
					return new __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */]( viewBefore.parent, viewBefore.index + 1 );
				}
			}

			return null;
		}
	}

	/**
	 * Returns corresponding view {@link module:engine/view/element~Element Element} or
	 * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or
	 * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}
	 * to the given DOM - `undefined` is returned.
	 * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
	 *
	 * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.
	 * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}
	 * Corresponding view element, document fragment or `undefined` if no element was bound.
	 */
	mapDomToView( domElementOrDocumentFragment ) {
		return this.getParentUIElement( domElementOrDocumentFragment ) || this._domToViewMapping.get( domElementOrDocumentFragment );
	}

	/**
	 * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
	 * corresponding text node is returned based on the sibling or parent.
	 *
	 * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
	 * to find the corresponding text node.
	 *
	 * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
	 * element, it is used to find the corresponding text node.
	 *
	 * For all text nodes rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
	 *
	 * Otherwise `null` is returned.
	 *
	 * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.
	 *
	 * @param {Text} domText DOM text node.
	 * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a
	 * corresponding node.
	 */
	findCorrespondingViewText( domText ) {
		if ( Object(__WEBPACK_IMPORTED_MODULE_7__filler__["h" /* isInlineFiller */])( domText ) ) {
			return null;
		}

		// If DOM text was rendered by UIElement - return that element.
		const uiElement = this.getParentUIElement( domText );

		if ( uiElement ) {
			return uiElement;
		}

		const previousSibling = domText.previousSibling;

		// Try to use previous sibling to find the corresponding text node.
		if ( previousSibling ) {
			if ( !( this.isElement( previousSibling ) ) ) {
				// The previous is text or comment.
				return null;
			}

			const viewElement = this.mapDomToView( previousSibling );

			if ( viewElement ) {
				const nextSibling = viewElement.nextSibling;

				// It might be filler which has no corresponding view node.
				if ( nextSibling instanceof __WEBPACK_IMPORTED_MODULE_0__text__["a" /* default */] ) {
					return viewElement.nextSibling;
				} else {
					return null;
				}
			}
		}
		// Try to use parent to find the corresponding text node.
		else {
			const viewElement = this.mapDomToView( domText.parentNode );

			if ( viewElement ) {
				const firstChild = viewElement.getChild( 0 );

				// It might be filler which has no corresponding view node.
				if ( firstChild instanceof __WEBPACK_IMPORTED_MODULE_0__text__["a" /* default */] ) {
					return firstChild;
				} else {
					return null;
				}
			}
		}

		return null;
	}

	/**
	 * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or
	 * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.
	 * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}
	 * use {@link #findCorrespondingDomText}.
	 *
	 * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode
	 * View element or document fragment.
	 * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.
	 */
	mapViewToDom( documentFragmentOrElement ) {
		return this._viewToDomMapping.get( documentFragmentOrElement );
	}

	/**
	 * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
	 * corresponding text node is returned based on the sibling or parent.
	 *
	 * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
	 * to find the corresponding text node.
	 *
	 * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
	 * element, it is used to find the corresponding text node.
	 *
	 * Otherwise `null` is returned.
	 *
	 * @param {module:engine/view/text~Text} viewText View text node.
	 * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
	 */
	findCorrespondingDomText( viewText ) {
		const previousSibling = viewText.previousSibling;

		// Try to use previous sibling to find the corresponding text node.
		if ( previousSibling && this.mapViewToDom( previousSibling ) ) {
			return this.mapViewToDom( previousSibling ).nextSibling;
		}

		// If this is a first node, try to use parent to find the corresponding text node.
		if ( !previousSibling && viewText.parent && this.mapViewToDom( viewText.parent ) ) {
			return this.mapViewToDom( viewText.parent ).childNodes[ 0 ];
		}

		return null;
	}

	/**
	 * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.
	 *
	 * @param {module:engine/view/editableelement~EditableElement} viewEditable
	 */
	focus( viewEditable ) {
		const domEditable = this.mapViewToDom( viewEditable );

		if ( domEditable && domEditable.ownerDocument.activeElement !== domEditable ) {
			// Save the scrollX and scrollY positions before the focus.
			const { scrollX, scrollY } = __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].window;
			const scrollPositions = [];

			// Save all scrollLeft and scrollTop values starting from domEditable up to
			// document#documentElement.
			forEachDomNodeAncestor( domEditable, node => {
				const { scrollLeft, scrollTop } = node;

				scrollPositions.push( [ scrollLeft, scrollTop ] );
			} );

			domEditable.focus();

			// Restore scrollLeft and scrollTop values starting from domEditable up to
			// document#documentElement.
			// https://github.com/ckeditor/ckeditor5-engine/issues/951
			// https://github.com/ckeditor/ckeditor5-engine/issues/957
			forEachDomNodeAncestor( domEditable, node => {
				const [ scrollLeft, scrollTop ] = scrollPositions.shift();

				node.scrollLeft = scrollLeft;
				node.scrollTop = scrollTop;
			} );

			// Restore the scrollX and scrollY positions after the focus.
			// https://github.com/ckeditor/ckeditor5-engine/issues/951
			__WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].window.scrollTo( scrollX, scrollY );
		}
	}

	/**
	 * Returns `true` when `node.nodeType` equals `Node.TEXT_NODE`.
	 *
	 * @param {Node} node Node to check.
	 * @returns {Boolean}
	 */
	isText( node ) {
		return node && node.nodeType == Node.TEXT_NODE;
	}

	/**
	 * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
	 *
	 * @param {Node} node Node to check.
	 * @returns {Boolean}
	 */
	isElement( node ) {
		return node && node.nodeType == Node.ELEMENT_NODE;
	}

	/**
	 * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
	 *
	 * @param {Node} node Node to check.
	 * @returns {Boolean}
	 */
	isDocumentFragment( node ) {
		return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
	}

	/**
	 * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.
	 *
	 * @param {Node} node Node to check.
	 * @returns {Boolean}
	 */
	isComment( node ) {
		return node && node.nodeType == Node.COMMENT_NODE;
	}

	/**
	 * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
	 *
	 * @param {Selection} DOM Selection instance to check.
	 * @returns {Boolean}
	 */
	isDomSelectionBackward( selection ) {
		if ( selection.isCollapsed ) {
			return false;
		}

		// Since it takes multiple lines of code to check whether a "DOM Position" is before/after another "DOM Position",
		// we will use the fact that range will collapse if it's end is before it's start.
		const range = document.createRange();

		range.setStart( selection.anchorNode, selection.anchorOffset );
		range.setEnd( selection.focusNode, selection.focusOffset );

		const backward = range.collapsed;

		range.detach();

		return backward;
	}

	/**
	 * Returns parent {@link module:engine/view/uielement~UIElement} for provided DOM node. Returns `null` if there is no
	 * parent UIElement.
	 *
	 * @param {Node} domNode
	 * @return {module:engine/view/uielement~UIElement|null}
	 */
	getParentUIElement( domNode ) {
		const ancestors = Object(__WEBPACK_IMPORTED_MODULE_10__ckeditor_ckeditor5_utils_src_dom_getancestors__["a" /* default */])( domNode );

		// Remove domNode from the list.
		ancestors.pop();

		while ( ancestors.length ) {
			const domNode = ancestors.pop();
			const viewNode = this._domToViewMapping.get( domNode );

			if ( viewNode && viewNode.is( 'uiElement' ) ) {
				return viewNode;
			}
		}

		return null;
	}

	/**
	 * Checks if given selection's boundaries are at correct places.
	 *
	 * The following places are considered as incorrect for selection boundaries:
	 * * before or in the middle of the inline filler sequence,
	 * * inside the DOM element which represents {@link module:engine/view/uielement~UIElement a view ui element}.
	 *
	 * @param {Selection} domSelection DOM Selection object to be checked.
	 * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.
	 */
	isDomSelectionCorrect( domSelection ) {
		return this._isDomSelectionPositionCorrect( domSelection.anchorNode, domSelection.anchorOffset ) &&
			this._isDomSelectionPositionCorrect( domSelection.focusNode, domSelection.focusOffset );
	}

	/**
	 * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.
	 *
	 * @private
	 * @param {Element} domParent Position parent.
	 * @param {Number} offset Position offset.
	 * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.
	 */
	_isDomSelectionPositionCorrect( domParent, offset ) {
		// If selection is before or in the middle of inline filler string, it is incorrect.
		if ( this.isText( domParent ) && Object(__WEBPACK_IMPORTED_MODULE_7__filler__["i" /* startsWithFiller */])( domParent ) && offset < __WEBPACK_IMPORTED_MODULE_7__filler__["c" /* INLINE_FILLER_LENGTH */] ) {
			// Selection in a text node, at wrong position (before or in the middle of filler).
			return false;
		}

		if ( this.isElement( domParent ) && Object(__WEBPACK_IMPORTED_MODULE_7__filler__["i" /* startsWithFiller */])( domParent.childNodes[ offset ] ) ) {
			// Selection in an element node, before filler text node.
			return false;
		}

		const viewParent = this.mapDomToView( domParent );

		// If selection is in `view.UIElement`, it is incorrect. Note that `mapDomToView()` returns `view.UIElement`
		// also for any dom element that is inside the view ui element (so we don't need to perform any additional checks).
		if ( viewParent && viewParent.is( 'uiElement' ) ) {
			return false;
		}

		return true;
	}

	/**
	 * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so
	 * it is correctly displayed in the DOM.
	 *
	 * Following changes are done:
	 *
	 * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container
	 * element or if a previous text node ends with a space character,
	 * * space at the end of the text node is changed to `&nbsp;` if this is the last text node in its container,
	 * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).
	 *
	 * Content of {@link #preElements} is not processed.
	 *
	 * @private
	 * @param {module:engine/view/text~Text} node View text node to process.
	 * @returns {String} Processed text data.
	 */
	_processDataFromViewText( node ) {
		let data = node.data;

		// If any of node ancestors has a name which is in `preElements` array, then currently processed
		// view text node is (will be) in preformatted element. We should not change whitespaces then.
		if ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {
			return data;
		}

		// 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node
		// (container element boundary).
		if ( data.charAt( 0 ) == ' ' ) {
			const prevNode = this._getTouchingViewTextNode( node, false );
			const prevEndsWithSpace = prevNode && this._nodeEndsWithSpace( prevNode );

			if ( prevEndsWithSpace || !prevNode ) {
				data = '\u00A0' + data.substr( 1 );
			}
		}

		// 2. Replace the last space with a nbsp if this is the last text node (container element boundary).
		if ( data.charAt( data.length - 1 ) == ' ' ) {
			const nextNode = this._getTouchingViewTextNode( node, true );

			if ( !nextNode ) {
				data = data.substr( 0, data.length - 1 ) + '\u00A0';
			}
		}

		return data.replace( / {2}/g, ' \u00A0' );
	}

	/**
	 * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.
	 *
	 * @private
	 * @param {module:engine/view/text~Text} node Node to check.
	 * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.
	 */
	_nodeEndsWithSpace( node ) {
		if ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {
			return false;
		}

		const data = this._processDataFromViewText( node );

		return data.charAt( data.length - 1 ) == ' ';
	}

	/**
	 * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.
	 *
	 * Following changes are done:
	 * * multiple whitespaces are replaced to a single space,
	 * * space at the beginning of the text node is removed, if it is a first text node in it's container
	 * element or if previous text node ends by space character,
	 * * space at the end of the text node is removed, if it is a last text node in it's container.
	 *
	 * @param {Node} node DOM text node to process.
	 * @returns {String} Processed data.
	 * @private
	 */
	_processDataFromDomText( node ) {
		let data = Object(__WEBPACK_IMPORTED_MODULE_7__filler__["e" /* getDataWithoutFiller */])( node );

		if ( _hasDomParentOfType( node, this.preElements ) ) {
			return data;
		}

		// Change all consecutive whitespace characters (from the [ \n\t\r] set 
		// see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.
		// That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.
		// We're replacing 1+ (and not 2+) to also normalize singular \n\t\r characters (#822).
		data = data.replace( /[ \n\t\r]{1,}/g, ' ' );

		const prevNode = this._getTouchingDomTextNode( node, false );
		const nextNode = this._getTouchingDomTextNode( node, true );

		// If previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning
		// of this text node. Such space character is treated as a whitespace.
		if ( !prevNode || /[^\S\u00A0]/.test( prevNode.data.charAt( prevNode.data.length - 1 ) ) ) {
			data = data.replace( /^ /, '' );
		}

		// If next text node does not exist remove space character from the end of this text node.
		if ( !nextNode ) {
			data = data.replace( / $/, '' );
		}
		// At this point we should have removed all whitespaces from DOM text data.

		// Now we have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.
		// First, change all ` \u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view as
		// ` \u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them
		// to `  ` which is what we expect to have in model/view.
		data = data.replace( / \u00A0/g, '  ' );

		// Then, change &nbsp; character that is at the beginning of the text node to space character.
		// As above, that &nbsp; was created for rendering reasons but it's real meaning is just a space character.
		// We do that replacement only if this is the first node or the previous node ends on whitespace character.
		if ( !prevNode || /[^\S\u00A0]/.test( prevNode.data.charAt( prevNode.data.length - 1 ) ) ) {
			data = data.replace( /^\u00A0/, ' ' );
		}

		// Since input text data could be: `x_ _`, we would not replace the first &nbsp; after `x` character.
		// We have to fix it. Since we already change all ` &nbsp;`, we will have something like this at the end of text data:
		// `x_ _ _` -> `x_    `. Find &nbsp; at the end of string (can be followed only by spaces).
		// We do that replacement only if this is the last node or the next node starts by &nbsp;.
		if ( !nextNode || nextNode.data.charAt( 0 ) == '\u00A0' ) {
			data = data.replace( /\u00A0( *)$/, ' $1' );
		}

		// At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be
		// changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.
		return data;
	}

	/**
	 * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling
	 * that is contained in the same container element. If there is no such sibling, `null` is returned.
	 *
	 * @param {module:engine/view/text~Text} node Reference node.
	 * @param {Boolean} getNext
	 * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.
	 */
	_getTouchingViewTextNode( node, getNext ) {
		const treeWalker = new __WEBPACK_IMPORTED_MODULE_6__treewalker__["a" /* default */]( {
			startPosition: getNext ? __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createAfter( node ) : __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createBefore( node ),
			direction: getNext ? 'forward' : 'backward'
		} );

		for ( const value of treeWalker ) {
			if ( value.item.is( 'containerElement' ) ) {
				// ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last
				// text node in its container element.
				return null;
			} else if ( value.item.is( 'text' ) ) {
				// Found a text node in the same container element.
				return value.item;
			}
		}

		return null;
	}

	/**
	 * Helper function. For given `Text` node, it finds previous or next sibling that is contained in the same block element.
	 * If there is no such sibling, `null` is returned.
	 *
	 * @private
	 * @param {Text} node
	 * @param {Boolean} getNext
	 * @returns {Text|null}
	 */
	_getTouchingDomTextNode( node, getNext ) {
		if ( !node.parentNode ) {
			return null;
		}

		const direction = getNext ? 'nextNode' : 'previousNode';
		const document = node.ownerDocument;
		const treeWalker = document.createTreeWalker( document.childNodes[ 0 ], NodeFilter.SHOW_TEXT );

		treeWalker.currentNode = node;

		const touchingNode = treeWalker[ direction ]();

		if ( touchingNode !== null ) {
			const lca = Object(__WEBPACK_IMPORTED_MODULE_11__ckeditor_ckeditor5_utils_src_dom_getcommonancestor__["a" /* default */])( node, touchingNode );

			// If there is common ancestor between the text node and next/prev text node,
			// and there are no block elements on a way from the text node to that ancestor,
			// and there are no block elements on a way from next/prev text node to that ancestor...
			if (
				lca &&
				!_hasDomParentOfType( node, this.blockElements, lca ) &&
				!_hasDomParentOfType( touchingNode, this.blockElements, lca )
			) {
				// Then they are in the same container element.
				return touchingNode;
			}
		}

		return null;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DomConverter;


// Helper function.
// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.
//
// @param {Node} node
// @param {Array.<String>} types
// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).
// @returns {Boolean} `true` if such parent exists or `false` if it does not.
function _hasDomParentOfType( node, types, boundaryParent ) {
	let parents = Object(__WEBPACK_IMPORTED_MODULE_10__ckeditor_ckeditor5_utils_src_dom_getancestors__["a" /* default */])( node );

	if ( boundaryParent ) {
		parents = parents.slice( parents.indexOf( boundaryParent ) + 1 );
	}

	return parents.some( parent => parent.tagName && types.includes( parent.tagName.toLowerCase() ) );
}

// A helper that executes given callback for each DOM node's ancestor, starting from the given node
// and ending in document#documentElement.
//
// @param {Node} node
// @param {Function} callback A callback to be executed for each ancestor.
function forEachDomNodeAncestor( node, callback ) {
	while ( node && node != __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].document ) {
		callback( node );
		node = node.parentNode;
	}
}


/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basichtmlwriter__ = __webpack_require__(435);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__view_domconverter__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__view_filler__ = __webpack_require__(73);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/dataprocessor/htmldataprocessor
 */

/* globals document, DOMParser */





/**
 * HtmlDataProcessor class.
 * This data processor implementation uses HTML as input/output data.
 *
 * @implements module:engine/dataprocessor/dataprocessor~DataProcessor
 */
class HtmlDataProcessor {
	/**
	 * Creates a new instance of the HtmlDataProcessor class.
	 */
	constructor() {
		/**
		 * DOMParser instance used to parse HTML string to HTMLDocument.
		 *
		 * @private
		 * @member {DOMParser}
		 */
		this._domParser = new DOMParser();

		/**
		 * DOM converter used to convert DOM elements to view elements.
		 *
		 * @private
		 * @member
		 */
		this._domConverter = new __WEBPACK_IMPORTED_MODULE_1__view_domconverter__["a" /* default */]( { blockFiller: __WEBPACK_IMPORTED_MODULE_2__view_filler__["d" /* NBSP_FILLER */] } );

		/**
		 * BasicHtmlWriter instance used to convert DOM elements to HTML string.
		 *
		 * @private
		 * @member {module:engine/dataprocessor/basichtmlwriter~BasicHtmlWriter}
		 */
		this._htmlWriter = new __WEBPACK_IMPORTED_MODULE_0__basichtmlwriter__["a" /* default */]();
	}

	/**
	 * Converts provided {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}
	 * to data format - in this case HTML string.
	 *
	 * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment
	 * @returns {String} HTML string.
	 */
	toData( viewFragment ) {
		// Convert view DocumentFragment to DOM DocumentFragment.
		const domFragment = this._domConverter.viewToDom( viewFragment, document );

		// Convert DOM DocumentFragment to HTML output.
		return this._htmlWriter.getHtml( domFragment );
	}

	/**
	 * Converts provided HTML string to view tree.
	 *
	 * @param {String} data HTML string.
	 * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted view element.
	 */
	toView( data ) {
		// Convert input HTML data to DOM DocumentFragment.
		const domFragment = this._toDom( data );

		// Convert DOM DocumentFragment to view DocumentFragment.
		return this._domConverter.domToView( domFragment );
	}

	/**
	 * Converts HTML String to its DOM representation. Returns DocumentFragment, containing nodes parsed from
	 * provided data.
	 *
	 * @private
	 * @param {String} data
	 * @returns {DocumentFragment}
	 */
	_toDom( data ) {
		const document = this._domParser.parseFromString( data, 'text/html' );
		const fragment = document.createDocumentFragment();
		const nodes = document.body.childNodes;

		while ( nodes.length > 0 ) {
			fragment.appendChild( nodes[ 0 ] );
		}

		return fragment;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = HtmlDataProcessor;



/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_collection__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/viewcollection
 */






/**
 * Collects {@link module:ui/view~View} instances.
 *
 *		const parentView = new ParentView( locale );
 *		const collection = new ViewCollection( locale );
 *
 *		collection.setParent( parentView.element );
 *
 *		const viewA = new ChildView( locale );
 *		const viewB = new ChildView( locale );
 *
 * View collection renders and manages view {@link module:ui/view~View#element elements}:
 *
 *		collection.add( viewA );
 *		collection.add( viewB );
 *
 *		console.log( parentView.element.firsChild ); // -> viewA.element
 *		console.log( parentView.element.lastChild ); // -> viewB.element
 *
 * It {@link module:ui/viewcollection~ViewCollection#delegate propagates} DOM events too:
 *
 *		// Delegate #click and #keydown events from viewA and viewB to the parentView.
 *		collection.delegate( 'click' ).to( parentView );
 *
 *		parentView.on( 'click', ( evt ) => {
 *			console.log( `${ evt.source } has been clicked.` );
 *		} );
 *
 *		// This event will be delegated to the parentView.
 *		viewB.fire( 'click' );
 *
 * **Note**: A view collection can be used directly in the {@link module:ui/template~TemplateDefinition definition}
 * of a {@link module:ui/template~Template template}.
 *
 * @extends module:utils/collection~Collection
 * @mixes module:utils/observablemixin~ObservableMixin
 */
class ViewCollection extends __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_collection__["a" /* default */] {
	/**
	 * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
	 *
	 * @param {module:utils/locale~Locale} [locale] The {@link module:core/editor~Editor editor's locale} instance.
	 */
	constructor( locale ) {
		super( {
			// An #id Number attribute should be legal and not break the `ViewCollection` instance.
			// https://github.com/ckeditor/ckeditor5-ui/issues/93
			idProperty: 'viewUid'
		} );

		// Handle {@link module:ui/view~View#element} in DOM when a new view is added to the collection.
		this.on( 'add', ( evt, view, index ) => {
			if ( !view.isRendered ) {
				view.render();
			}

			if ( view.element && this._parentElement ) {
				this._parentElement.insertBefore( view.element, this._parentElement.children[ index ] );
			}
		} );

		// Handle {@link module:ui/view~View#element} in DOM when a view is removed from the collection.
		this.on( 'remove', ( evt, view ) => {
			if ( view.element && this._parentElement ) {
				view.element.remove();
			}
		} );

		/**
		 * The {@link module:core/editor/editor~Editor#locale editor's locale} instance.
		 * See the view {@link module:ui/view~View#locale locale} property.
		 *
		 * @member {module:utils/locale~Locale}
		 */
		this.locale = locale;

		/**
		 * A parent element within which child views are rendered and managed in DOM.
		 *
		 * @protected
		 * @member {HTMLElement}
		 */
		this._parentElement = null;
	}

	/**
	 * Destroys the view collection along with child views.
	 * See the view {@link module:ui/view~View#destroy} method.
	 */
	destroy() {
		this.map( view => view.destroy() );
	}

	/**
	 * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
	 * {@link #remove removing} views in the collection synchronizes their
	 * {@link module:ui/view~View#element elements} in the parent element.
	 *
	 * @param {HTMLElement} element A new parent element.
	 */
	setParent( elementOrDocFragment ) {
		this._parentElement = elementOrDocFragment;
	}

	/**
	 * Delegates selected events coming from within views in the collection to any
	 * {@link module:utils/emittermixin~Emitter}.
	 *
	 * For the following views and collection:
	 *
	 *		const viewA = new View();
	 *		const viewB = new View();
	 *		const viewC = new View();
	 *
	 *		const views = parentView.createCollection();
	 *
	 *		views.delegate( 'eventX' ).to( viewB );
	 *		views.delegate( 'eventX', 'eventY' ).to( viewC );
	 *
	 *		views.add( viewA );
	 *
	 * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
	 *
	 *		viewA.fire( 'eventX', customData );
	 *
	 * and `eventY` is delegated (fired by) `viewC` along with `customData`:
	 *
	 *		viewA.fire( 'eventY', customData );
	 *
	 * See {@link module:utils/emittermixin~EmitterMixin#delegate}.
	 *
	 * @param {...String} events {@link module:ui/view~View} event names to be delegated to another
	 * {@link module:utils/emittermixin~Emitter}.
	 * @returns {Object}
	 * @returns {Function} return.to A function which accepts the destination of
	 * {@link module:utils/emittermixin~EmitterMixin#delegate delegated} events.
	 */
	delegate( ...events ) {
		if ( !events.length || !isStringArray( events ) ) {
			/**
			 * All event names must be strings.
			 *
			 * @error ui-viewcollection-delegate-wrong-events
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'ui-viewcollection-delegate-wrong-events: All event names must be strings.' );
		}

		return {
			/**
			 * Selects destination for {@link module:utils/emittermixin~EmitterMixin#delegate} events.
			 *
			 * @memberOf module:ui/viewcollection~ViewCollection#delegate
			 * @function module:ui/viewcollection~ViewCollection#delegate.to
			 * @param {module:utils/emittermixin~EmitterMixin} dest An `EmitterMixin` instance which is
			 * the destination for delegated events.
			 */
			to: dest => {
				// Activate delegating on existing views in this collection.
				for ( const view of this ) {
					for ( const evtName of events ) {
						view.delegate( evtName ).to( dest );
					}
				}

				// Activate delegating on future views in this collection.
				this.on( 'add', ( evt, view ) => {
					for ( const evtName of events ) {
						view.delegate( evtName ).to( dest );
					}
				} );

				// Deactivate delegating when view is removed from this collection.
				this.on( 'remove', ( evt, view ) => {
					for ( const evtName of events ) {
						view.stopDelegating( evtName, dest );
					}
				} );
			}
		};
	}

	/**
	 * Removes a child view from the collection. If the {@link #setParent parent element} of the
	 * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
	 * in DOM, reflecting the order of the collection.
	 *
	 * See the {@link #add} method.
	 *
	 * @method #remove
	 * @param {module:ui/view~View|Number|String} subject The view to remove, its id or index in the collection.
	 * @returns {Object} The removed view.
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ViewCollection;


Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_collection__["a" /* default */], __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );

// Check if all entries of the array are of `String` type.
//
// @private
// @param {Array} arr An array to be checked.
// @returns {Boolean}
function isStringArray( arr ) {
	return arr.every( a => typeof a == 'string' );
}


/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_dom_global__ = __webpack_require__(58);
/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/focuscycler
 */



/**
 * A utility class that helps cycling over focusable {@link module:ui/view~View views} in a
 * {@link module:ui/viewcollection~ViewCollection} when the focus is tracked by the
 * {@link module:utils/focustracker~FocusTracker} instance. It helps implementing keyboard
 * navigation in HTML forms, toolbars, lists and the like.
 *
 * To work properly it requires:
 * * a collection of focusable (HTML `tabindex` attribute) views that implement the `focus()` method,
 * * an associated focus tracker to determine which view is focused.
 *
 * A simple cycler setup can look like this:
 *
 *		const focusables = new ViewCollection();
 *		const focusTracker = new FocusTracker();
 *
 *		// Add focusable views to the focus tracker.
 *		focusTracker.add( ... );
 *
 * Then, the cycler can be used manually:
 *
 *		const cycler = new FocusCycler( { focusables, focusTracker } );
 *
 *		// Will focus the first focusable view in #focusables.
 *		cycler.focusFirst();
 *
 *		// Will log the next focusable item in #focusables.
 *		console.log( cycler.next );
 *
 * Alternatively, it can work side by side with the {@link module:utils/keystrokehandler~KeystrokeHandler}:
 *
 *		const keystrokeHandler = new KeystrokeHandler();
 *
 *		// Activate the keystroke handler.
 *		keystrokeHandler.listenTo( sourceOfEvents );
 *
 *		const cycler = new FocusCycler( {
 *			focusables, focusTracker, keystrokeHandler,
 *			actions: {
 *				// When arrowup of arrowleft is detected by the #keystrokeHandler,
 *				// focusPrevious() will be called on the cycler.
 *				focusPrevious: [ 'arrowup', 'arrowleft' ],
 *			}
 *		} );
 */
class FocusCycler {
	/**
	 * Creates an instance of the focus cycler utility.
	 *
	 * @param {Object} options Configuration options.
	 * @param {module:utils/collection~Collection|Object} options.focusables
	 * @param {module:utils/focustracker~FocusTracker} options.focusTracker
	 * @param {module:utils/keystrokehandler~KeystrokeHandler} [options.keystrokeHandler]
	 * @param {Object} [options.actions]
	 */
	constructor( options ) {
		Object.assign( this, options );

		/**
		 * A {@link module:ui/view~View view} collection that the cycler operates on.
		 *
		 * @readonly
		 * @member {module:utils/collection~Collection} #focusables
		 */

		/**
		 * A focus tracker instance that the cycler uses to determine the current focus
		 * state in {@link #focusables}.
		 *
		 * @readonly
		 * @member {module:utils/focustracker~FocusTracker} #focusTracker
		 */

		/**
		 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}
		 * which can respond to certain keystrokes and cycle the focus.
		 *
		 * @readonly
		 * @member {module:utils/keystrokehandler~KeystrokeHandler} #keystrokeHandler
		 */

		/**
		 * Actions that the cycler can take when a keystroke is pressed. Requires
		 * `options.keystrokeHandler` to be passed and working. When an action is
		 * performed, `preventDefault` and `stopPropagation` will be called on the event
		 * the keystroke fired in the DOM.
		 *
		 *		actions: {
		 *			// Will call #focusPrevious() when arrowleft or arrowup is pressed.
		 *			focusPrevious: [ 'arrowleft', 'arrowup' ],
		 *
		 *			// Will call #focusNext() when arrowdown is pressed.
		 *			focusNext: 'arrowdown'
		 *		}
		 *
		 * @readonly
		 * @member {Object} #actions
		 */

		if ( options.actions && options.keystrokeHandler ) {
			for ( const methodName in options.actions ) {
				let actions = options.actions[ methodName ];

				if ( typeof actions == 'string' ) {
					actions = [ actions ];
				}

				for ( const keystroke of actions ) {
					options.keystrokeHandler.set( keystroke, ( data, cancel ) => {
						this[ methodName ]();
						cancel();
					} );
				}
			}
		}
	}

	/**
	 * Returns the first focusable view in {@link #focusables}.
	 * Returns `null` if there is none.
	 *
	 * @readonly
	 * @member {module:ui/view~View|null} #first
	 */
	get first() {
		return this.focusables.find( isFocusable ) || null;
	}

	/**
	 * Returns the last focusable view in {@link #focusables}.
	 * Returns `null` if there is none.
	 *
	 * @readonly
	 * @member {module:ui/view~View|null} #last
	 */
	get last() {
		return this.focusables.filter( isFocusable ).slice( -1 )[ 0 ] || null;
	}

	/**
	 * Returns the next focusable view in {@link #focusables} based on {@link #current}.
	 * Returns `null` if there is none.
	 *
	 * @readonly
	 * @member {module:ui/view~View|null} #next
	 */
	get next() {
		return this._getFocusableItem( 1 );
	}

	/**
	 * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
	 * Returns `null` if there is none.
	 *
	 * @readonly
	 * @member {module:ui/view~View|null} #previous
	 */
	get previous() {
		return this._getFocusableItem( -1 );
	}

	/**
	 * An index of the view in the {@link #focusables} which is focused according
	 * to {@link #focusTracker}. Returns `null` when there is no such view.
	 *
	 * @readonly
	 * @member {Number|null} #current
	 */
	get current() {
		let index = null;

		// There's no focused view in the focusables.
		if ( this.focusTracker.focusedElement === null ) {
			return null;
		}

		this.focusables.find( ( view, viewIndex ) => {
			const focused = view.element === this.focusTracker.focusedElement;

			if ( focused ) {
				index = viewIndex;
			}

			return focused;
		} );

		return index;
	}

	/**
	 * Focuses the {@link #first} item in {@link #focusables}.
	 */
	focusFirst() {
		this._focus( this.first );
	}

	/**
	 * Focuses the {@link #last} item in {@link #focusables}.
	 */
	focusLast() {
		this._focus( this.last );
	}

	/**
	 * Focuses the {@link #next} item in {@link #focusables}.
	 */
	focusNext() {
		this._focus( this.next );
	}

	/**
	 * Focuses the {@link #previous} item in {@link #focusables}.
	 */
	focusPrevious() {
		this._focus( this.previous );
	}

	/**
	 * Focuses the given view if it exists.
	 *
	 * @protected
	 * @param {module:ui/view~View} view
	 */
	_focus( view ) {
		if ( view ) {
			view.focus();
		}
	}

	/**
	 * Returns the next or previous focusable view in {@link #focusables} with respect
	 * to {@link #current}.
	 *
	 * @protected
	 * @param {Number} step Either `1` for checking forward from {@link #current} or
	 * `-1` for checking backwards.
	 * @returns {module:ui/view~View|null}
	 */
	_getFocusableItem( step ) {
		// Cache for speed.
		const current = this.current;
		const collectionLength = this.focusables.length;

		if ( !collectionLength ) {
			return null;
		}

		// Start from the beginning if no view is focused.
		// https://github.com/ckeditor/ckeditor5-ui/issues/206
		if ( current === null ) {
			return this[ step === 1 ? 'first' : 'last' ];
		}

		// Cycle in both directions.
		let index = ( current + collectionLength + step ) % collectionLength;

		do {
			const view = this.focusables.get( index );

			// TODO: Check if view is visible.
			if ( isFocusable( view ) ) {
				return view;
			}

			// Cycle in both directions.
			index = ( index + collectionLength + step ) % collectionLength;
		} while ( index !== current );

		return null;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FocusCycler;


// Checks whether a view is focusable.
//
// @private
// @param {module:ui/view~View} view A view to be checked.
// @returns {Boolean}
function isFocusable( view ) {
	return !!( view.focus && __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].window.getComputedStyle( view.element ).display != 'none' );
}


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__balloonpanelview__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_first__ = __webpack_require__(60);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/panel/balloon/contextualballoon
 */






/**
 * Provides the common contextual balloon panel for the editor.
 *
 * This plugin allows reusing a single {module:ui/panel/balloon/balloonpanelview~BalloonPanelView} instance
 * to display multiple contextual balloon panels in the editor.
 *
 * Child views of such a panel are stored in the stack and the last one in the stack is visible. When the
 * visible view is removed from the stack, the previous view becomes visible, etc. If there are no more
 * views in the stack, the balloon panel will hide.
 *
 * It simplifies managing the views and helps
 * avoid the unnecessary complexity of handling multiple {module:ui/panel/balloon/balloonpanelview~BalloonPanelView}
 * instances in the editor.
 *
 * @extends module:core/plugin~Plugin
 */
class ContextualBalloon extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'ContextualBalloon';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		/**
		 * The common balloon panel view.
		 *
		 * @readonly
		 * @member {module:ui/panel/balloon/balloonpanelview~BalloonPanelView} #view
		 */
		this.view = new __WEBPACK_IMPORTED_MODULE_1__balloonpanelview__["a" /* default */]();

		/**
		 * The {@link module:utils/dom/position~Options#limiter position limiter}
		 * for the {@link #view}, used when no `limiter` has been passed into {@link #add}
		 * or {@link #updatePosition}.
		 *
		 * By default, a function, which obtains the farthest DOM
		 * {@link module:engine/view/rooteditableelement~RootEditableElement}
		 * of the {@link module:engine/view/document~Document#selection}.
		 *
		 * @member {module:utils/dom/position~Options#limiter} #positionLimiter
		 */
		this.positionLimiter = () => {
			const view = this.editor.editing.view;
			const editableElement = view.selection.editableElement;

			if ( editableElement ) {
				return view.domConverter.mapViewToDom( editableElement.root );
			}

			return null;
		};

		/**
		 * Stack of the views injected into the balloon. Last one in the stack is displayed
		 * as a content of {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon#view}.
		 *
		 * @private
		 * @member {Map} #_stack
		 */
		this._stack = new Map();

		// Add balloon panel view to editor `body` collection and wait until view will be ready.
		this.editor.ui.view.body.add( this.view );

		// Editor should be focused when contextual balloon is focused.
		this.editor.ui.focusTracker.add( this.view.element );
	}

	/**
	 * Returns the currently visible view or `null` when there are no
	 * views in the stack.
	 *
	 * @returns {module:ui/view~View|null}
	 */
	get visibleView() {
		const item = this._stack.get( this.view.content.get( 0 ) );

		return item ? item.view : null;
	}

	/**
	 * Returns `true` when the given view is in the stack. Otherwise returns `false`.
	 *
	 * @param {module:ui/view~View} view
	 * @returns {Boolean}
	 */
	hasView( view ) {
		return this._stack.has( view );
	}

	/**
	 * Adds a new view to the stack and makes it visible.
	 *
	 * @param {Object} data Configuration of the view.
	 * @param {module:ui/view~View} [data.view] Content of the balloon.
	 * @param {module:utils/dom/position~Options} [data.position] Positioning options.
	 * @param {String} [data.balloonClassName] Additional css class for {@link #view} added when given view is visible.
	 */
	add( data ) {
		if ( this.hasView( data.view ) ) {
			/**
			 * Trying to add configuration of the same view more than once.
			 *
			 * @error contextualballoon-add-view-exist
			 */
			throw new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'contextualballoon-add-view-exist: Cannot add configuration of the same view twice.' );
		}

		// When adding view to the not empty balloon.
		if ( this.visibleView ) {
			// Remove displayed content from the view.
			this.view.content.remove( this.visibleView );
		}

		// Add new view to the stack.
		this._stack.set( data.view, data );

		// And display it.
		this._show( data );
	}

	/**
	 * Removes the given view from the stack. If the removed view was visible,
	 * then the view preceding it in the stack will become visible instead.
	 * When there is no view in the stack then balloon will hide.
	 *
	 * @param {module:ui/view~View} view A view to be removed from the balloon.
	 */
	remove( view ) {
		if ( !this.hasView( view ) ) {
			/**
			 * Trying to remove configuration of the view not defined in the stack.
			 *
			 * @error contextualballoon-remove-view-not-exist
			 */
			throw new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'contextualballoon-remove-view-not-exist: Cannot remove configuration of not existing view.' );
		}

		// When visible view is being removed.
		if ( this.visibleView === view ) {
			// We need to remove it from the view content.
			this.view.content.remove( view );

			// And then remove from the stack.
			this._stack.delete( view );

			// Next we need to check if there is other view in stack to show.
			const last = Array.from( this._stack.values() ).pop();

			// If it is some other view.
			if ( last ) {
				// Just show it.
				this._show( last );
			} else {
				// Hide the balloon panel.
				this.view.hide();
			}
		} else {
			// Just remove given view from the stack.
			this._stack.delete( view );
		}
	}

	/**
	 * Updates the position of the balloon using position data of the first visible view in the stack.
	 * When new position data is given then position data of currently visible panel will be updated.
	 *
	 * @param {module:utils/dom/position~Options} [position] position options.
	 */
	updatePosition( position ) {
		if ( position ) {
			this._stack.get( this.visibleView ).position = position;
		}

		this.view.pin( this._getBalloonPosition() );
	}

	/**
	 * Sets the view as a content of the balloon and attaches balloon using position
	 * options of the first view.
	 *
	 * @private
	 * @param {Object} data Configuration.
	 * @param {module:ui/view~View} [data.view] View to show in the balloon.
	 * @param {String} [data.balloonClassName=''] Additional class name which will added to the {#_balloon} view.
	 */
	_show( { view, balloonClassName = '' } ) {
		this.view.className = balloonClassName;

		this.view.content.add( view );
		this.view.pin( this._getBalloonPosition() );
	}

	/**
	 * Returns position options of the first view in the stack.
	 * This keeps the balloon in the same position when view is changed.
	 *
	 * @private
	 * @returns {module:utils/dom/position~Options}
	 */
	_getBalloonPosition() {
		let position = Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_first__["a" /* default */])( this._stack.values() ).position;

		// Use the default limiter if none has been specified.
		if ( position && !position.limiter ) {
			// Don't modify the original options object.
			position = Object.assign( {}, position, {
				limiter: this.positionLimiter
			} );
		}

		return position;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ContextualBalloon;



/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__paragraphcommand__ = __webpack_require__(497);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__ = __webpack_require__(42);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module paragraph/paragraph
 */










/**
 * The paragraph feature for the editor.
 * It introduces the `<paragraph>` element in the model which renders as a `<p>` element in the DOM and data.
 *
 * @extends module:core/plugin~Plugin
 */
class Paragraph extends __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Paragraph';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const doc = editor.document;
		const data = editor.data;
		const editing = editor.editing;

		editor.commands.add( 'paragraph', new __WEBPACK_IMPORTED_MODULE_0__paragraphcommand__["a" /* default */]( editor ) );

		// Schema.
		doc.schema.registerItem( 'paragraph', '$block' );

		// Build converter from model to view for data and editing pipelines.
		Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__["a" /* default */])().for( data.modelToView, editing.modelToView )
			.fromElement( 'paragraph' )
			.toElement( 'p' );

		// Build converter from view to model for data pipeline.
		Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__["a" /* default */])().for( data.viewToModel )
			.fromElement( 'p' )
			.toElement( 'paragraph' );

		// Content autoparagraphing. --------------------------------------------------

		// Step 1.
		// "Second chance" converters for elements and texts which were not allowed in their original locations.
		// They check if this element/text could be converted if it was in a paragraph.
		// Forcefully converted items will be temporarily in an invalid context. It's going to be fixed in step 2.

		// Executed after converter added by a feature, but before "default" to-model-fragment converter.
		data.viewToModel.on( 'element', convertAutoparagraphableItem, { priority: 'low' } );
		// Executed after default text converter.
		data.viewToModel.on( 'text', convertAutoparagraphableItem, { priority: 'lowest' } );

		// Step 2.
		// After an item is "forced" to be converted by `convertAutoparagraphableItem`, we need to actually take
		// care of adding the paragraph (assumed in `convertAutoparagraphableItem`) and wrap that item in it.

		// Executed after all converters (even default ones).
		data.viewToModel.on( 'element', autoparagraphItems, { priority: 'lowest' } );
		data.viewToModel.on( 'documentFragment', autoparagraphItems, { priority: 'lowest' } );

		// Empty roots autoparagraphing. -----------------------------------------------

		// Post-fixer which takes care of adding empty paragraph elements to empty roots.
		// Besides fixing content on #changesDone we also need to handle #dataReady because
		// if initial data is empty or setData() wasn't even called there will be no #change fired.
		doc.on( 'change', ( evt, type, changes, batch ) => {
			if ( batch.type == 'transparent' ) {
				return;
			}

			findEmptyRoots( doc, batch );
		} );
		doc.on( 'changesDone', autoparagraphEmptyRoots, { priority: 'lowest' } );
		editor.on( 'dataReady', () => {
			findEmptyRoots( doc, doc.batch( 'transparent' ) );
			autoparagraphEmptyRoots();
		}, { priority: 'lowest' } );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Paragraph;


/**
 * A list of element names which should be treated by the autoparagraphing algorithms as
 * paragraph-like. This means that e.g. the following content:
 *
 *		<h1>Foo</h1>
 *		<table>
 *			<tr>
 *				<td>X</td>
 *				<td>
 *					<ul>
 *						<li>Y</li>
 *						<li>Z</li>
 *					</ul>
 *				</td>
 *			</tr>
 *		</table>
 *
 * contains five paragraph-like elements: `<h1>`, two `<td>`s and two `<li>`s.
 * Hence, if none of the features is going to convert those elements the above content will be automatically handled
 * by the paragraph feature and converted to:
 *
 *		<p>Foo</p>
 *		<p>X</p>
 *		<p>Y</p>
 *		<p>Z</p>
 *
 * Note: The `<td>` containing two `<li>` elements was ignored as the innermost paragraph-like elements
 * have a priority upon conversion.
 *
 * @member {Set.<String>} module:paragraph/paragraph~Paragraph.paragraphLikeElements
 */
Paragraph.paragraphLikeElements = new Set( [
	'blockquote',
	'dd',
	'div',
	'dt',
	'h1',
	'h2',
	'h3',
	'h4',
	'h5',
	'h6',
	'li',
	'p',
	'td'
] );

// This converter forces a conversion of a non-consumed view item, if that item would be allowed by schema and converted it if was
// inside a paragraph element. The converter checks whether conversion would be possible if there was a paragraph element
// between `data.input` item and its parent. If the conversion would be allowed, the converter adds `"paragraph"` to the
// context and fires conversion for `data.input` again.
function convertAutoparagraphableItem( evt, data, consumable, conversionApi ) {
	// If the item wasn't consumed by some of the dedicated converters...
	if ( !consumable.test( data.input, { name: data.input.name } ) ) {
		return;
	}

	// But would be allowed if it was in a paragraph...
	if ( !isParagraphable( data.input, data.context, conversionApi.schema, false ) ) {
		return;
	}

	// Convert that item in a paragraph context.
	data.context.push( 'paragraph' );
	const item = conversionApi.convertItem( data.input, consumable, data );
	data.context.pop();

	data.output = item;
}

// This converter checks all children of an element or document fragment that has been converted and wraps
// children in a paragraph element if it is allowed by schema.
//
// Basically, after an item is "forced" to be converted by `convertAutoparagraphableItem`, we need to actually take
// care of adding the paragraph (assumed in `convertAutoparagraphableItem`) and wrap that item in it.
function autoparagraphItems( evt, data, consumable, conversionApi ) {
	// Autoparagraph only if the element has been converted.
	if ( !data.output ) {
		return;
	}

	const isParagraphLike = Paragraph.paragraphLikeElements.has( data.input.name ) && !data.output.is( 'element' );

	// Keep in mind that this converter is added to all elements and document fragments.
	// This means that we have to make a smart decision in which elements (at what level) auto-paragraph should be inserted.
	// There are three situations when it is correct to add paragraph:
	//   -	we are converting a view document fragment: this means that we are at the top level of conversion and we should
	//		add paragraph elements for "bare" texts (unless converting in $clipboardHolder, but this is covered by schema),
	//   -	we are converting an element that was converted to model element: this means that it will be represented in model
	//		and has added its context when converting children - we should add paragraph for those items that passed
	//		in `convertAutoparagraphableItem`, because it is correct for them to be autoparagraphed,
	//	 -	we are converting "paragraph-like" element, which children should always be autoparagraphed (if it is allowed by schema,
	//		so we won't end up with, i.e., paragraph inside paragraph, if paragraph was in paragraph-like element).
	const shouldAutoparagraph =
		( data.input.is( 'documentFragment' ) ) ||
		( data.input.is( 'element' ) && data.output.is( 'element' ) ) ||
		isParagraphLike;

	if ( !shouldAutoparagraph ) {
		return;
	}

	// Take care of proper context. This is important for `isParagraphable` checks.
	const needsNewContext = data.output.is( 'element' );

	if ( needsNewContext ) {
		data.context.push( data.output );
	}

	// `paragraph` element that will wrap auto-paragraphable children.
	let autoParagraph = null;

	// Check children and wrap them in a `paragraph` element if they need to be wrapped.
	// Be smart when wrapping children and put all auto-paragraphable siblings in one `paragraph` parent:
	// foo<$text bold="true">bar</$text><paragraph>xxx</paragraph>baz      --->
	// <paragraph>foo<$text bold="true">bar</$text></paragraph><paragraph>xxx</paragraph><paragraph>baz</paragraph>
	for ( let i = 0; i < data.output.childCount; i++ ) {
		const child = data.output.getChild( i );

		if ( isParagraphable( child, data.context, conversionApi.schema, isParagraphLike ) ) {
			// If there is no wrapping `paragraph` element, create it.
			if ( !autoParagraph ) {
				autoParagraph = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */]( 'paragraph' );
				data.output.insertChildren( child.index, autoParagraph );
			}
			// Otherwise, use existing `paragraph` and just fix iterator.
			// Thanks to reusing `paragraph` element, multiple siblings ends up in same container.
			else {
				i--;
			}

			child.remove();
			autoParagraph.appendChildren( child );
		} else {
			// That was not a paragraphable children, reset `paragraph` wrapper - following auto-paragraphable children
			// need to be placed in a new `paragraph` element.
			autoParagraph = null;
		}
	}

	if ( needsNewContext ) {
		data.context.pop();
	}
}

function isParagraphable( node, context, schema, insideParagraphLikeElement ) {
	const name = node.name || '$text';

	// Node is paragraphable if it is inside paragraph like element, or...
	// It is not allowed at this context...
	if ( !insideParagraphLikeElement && schema.check( { name, inside: context } ) ) {
		return false;
	}

	// And paragraph is allowed in this context...
	if ( !schema.check( { name: 'paragraph', inside: context } ) ) {
		return false;
	}

	// And a node would be allowed in this paragraph...
	if ( !schema.check( { name, inside: context.concat( 'paragraph' ) } ) ) {
		return false;
	}

	return true;
}

// Looks through all roots created in document and marks every empty root, saving which batch made it empty.
const rootsToFix = new Map();

function findEmptyRoots( doc, batch ) {
	for ( const rootName of doc.getRootNames() ) {
		const root = doc.getRoot( rootName );

		if ( root.isEmpty ) {
			if ( !rootsToFix.has( root ) ) {
				rootsToFix.set( root, batch );
			}
		} else {
			rootsToFix.delete( root );
		}
	}
}

// Fixes all empty roots.
function autoparagraphEmptyRoots() {
	for ( const [ root, batch ] of rootsToFix ) {
		// Only empty roots are in `rootsToFix`. Even if root got content during `changesDone` event (because of, for example
		// other feature), this will fire `findEmptyRoots` and remove that root from `rootsToFix`. So we are guaranteed
		// to have only empty roots here.
		const query = { name: 'paragraph', inside: [ root ] };
		const doc = batch.document;
		const schema = doc.schema;

		// If paragraph element is allowed in the root, create paragraph element.
		if ( schema.check( query ) ) {
			doc.enqueueChanges( () => {
				// Remove root from `rootsToFix` here, before executing batch, to prevent infinite loops.
				rootsToFix.delete( root );

				// Fix empty root.
				batch.insert( __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAt( root ), new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */]( 'paragraph' ) );
			} );
		}
	}
}


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetPrototype = Object.getPrototypeOf;

/**
 * Gets the `[[Prototype]]` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {null|Object} Returns the `[[Prototype]]`.
 */
function getPrototype(value) {
  return nativeGetPrototype(Object(value));
}

/* harmony default export */ __webpack_exports__["a"] = (getPrototype);


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assignValue__ = __webpack_require__(63);


/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : source[key];

    Object(__WEBPACK_IMPORTED_MODULE_0__assignValue__["a" /* default */])(object, key, newValue);
  }
  return object;
}

/* harmony default export */ __webpack_exports__["a"] = (copyObject);


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/* harmony default export */ __webpack_exports__["a"] = (baseProperty);


/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArrayLikeObject__ = __webpack_require__(13);


/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
  return Object(__WEBPACK_IMPORTED_MODULE_0__isArrayLikeObject__["a" /* default */])(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/* harmony default export */ __webpack_exports__["a"] = (isArguments);


/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArray__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike__ = __webpack_require__(43);



/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!Object(__WEBPACK_IMPORTED_MODULE_0__isArray__["a" /* default */])(value) && Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike__["a" /* default */])(value) && objectToString.call(value) == stringTag);
}

/* harmony default export */ __webpack_exports__["a"] = (isString);


/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = toMap;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_lodash_isPlainObject__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__objecttomap__ = __webpack_require__(171);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/tomap
 */




/**
 * Transforms object or iterable to map. Iterable needs to be in the format acceptable by the `Map` constructor.
 *
 *		map = toMap( { 'foo': 1, 'bar': 2 } );
 *		map = toMap( [ [ 'foo', 1 ], [ 'bar', 2 ] ] );
 *		map = toMap( anotherMap );
 *
 * @param {Object|Iterable} data Object or iterable to transform.
 * @returns {Map} Map created from data.
 */
function toMap( data ) {
	if ( Object(__WEBPACK_IMPORTED_MODULE_0__lib_lodash_isPlainObject__["a" /* default */])( data ) ) {
		return Object(__WEBPACK_IMPORTED_MODULE_1__objecttomap__["a" /* default */])( data );
	} else {
		return new Map( data );
	}
}


/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ListCache__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__stackClear__ = __webpack_require__(315);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__stackDelete__ = __webpack_require__(316);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__stackGet__ = __webpack_require__(317);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__stackHas__ = __webpack_require__(318);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__stackSet__ = __webpack_require__(319);







/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new __WEBPACK_IMPORTED_MODULE_0__ListCache__["a" /* default */](entries);
}

// Add methods to `Stack`.
Stack.prototype.clear = __WEBPACK_IMPORTED_MODULE_1__stackClear__["a" /* default */];
Stack.prototype['delete'] = __WEBPACK_IMPORTED_MODULE_2__stackDelete__["a" /* default */];
Stack.prototype.get = __WEBPACK_IMPORTED_MODULE_3__stackGet__["a" /* default */];
Stack.prototype.has = __WEBPACK_IMPORTED_MODULE_4__stackHas__["a" /* default */];
Stack.prototype.set = __WEBPACK_IMPORTED_MODULE_5__stackSet__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (Stack);


/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mapCacheClear__ = __webpack_require__(320);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mapCacheDelete__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mapCacheGet__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mapCacheHas__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mapCacheSet__ = __webpack_require__(332);






/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = __WEBPACK_IMPORTED_MODULE_0__mapCacheClear__["a" /* default */];
MapCache.prototype['delete'] = __WEBPACK_IMPORTED_MODULE_1__mapCacheDelete__["a" /* default */];
MapCache.prototype.get = __WEBPACK_IMPORTED_MODULE_2__mapCacheGet__["a" /* default */];
MapCache.prototype.has = __WEBPACK_IMPORTED_MODULE_3__mapCacheHas__["a" /* default */];
MapCache.prototype.set = __WEBPACK_IMPORTED_MODULE_4__mapCacheSet__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (MapCache);


/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__DataView__ = __webpack_require__(340);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Map__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Promise__ = __webpack_require__(341);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Set__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__WeakMap__ = __webpack_require__(342);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__toSource__ = __webpack_require__(173);







/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = Object(__WEBPACK_IMPORTED_MODULE_5__toSource__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__DataView__["a" /* default */]),
    mapCtorString = Object(__WEBPACK_IMPORTED_MODULE_5__toSource__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__Map__["a" /* default */]),
    promiseCtorString = Object(__WEBPACK_IMPORTED_MODULE_5__toSource__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_2__Promise__["a" /* default */]),
    setCtorString = Object(__WEBPACK_IMPORTED_MODULE_5__toSource__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_3__Set__["a" /* default */]),
    weakMapCtorString = Object(__WEBPACK_IMPORTED_MODULE_5__toSource__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_4__WeakMap__["a" /* default */]);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function getTag(value) {
  return objectToString.call(value);
}

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge, and promises in Node.js.
if ((__WEBPACK_IMPORTED_MODULE_0__DataView__["a" /* default */] && getTag(new __WEBPACK_IMPORTED_MODULE_0__DataView__["a" /* default */](new ArrayBuffer(1))) != dataViewTag) ||
    (__WEBPACK_IMPORTED_MODULE_1__Map__["a" /* default */] && getTag(new __WEBPACK_IMPORTED_MODULE_1__Map__["a" /* default */]) != mapTag) ||
    (__WEBPACK_IMPORTED_MODULE_2__Promise__["a" /* default */] && getTag(__WEBPACK_IMPORTED_MODULE_2__Promise__["a" /* default */].resolve()) != promiseTag) ||
    (__WEBPACK_IMPORTED_MODULE_3__Set__["a" /* default */] && getTag(new __WEBPACK_IMPORTED_MODULE_3__Set__["a" /* default */]) != setTag) ||
    (__WEBPACK_IMPORTED_MODULE_4__WeakMap__["a" /* default */] && getTag(new __WEBPACK_IMPORTED_MODULE_4__WeakMap__["a" /* default */]) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? Object(__WEBPACK_IMPORTED_MODULE_5__toSource__["a" /* default */])(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (getTag);


/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Uint8Array__ = __webpack_require__(179);


/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new __WEBPACK_IMPORTED_MODULE_0__Uint8Array__["a" /* default */](result).set(new __WEBPACK_IMPORTED_MODULE_0__Uint8Array__["a" /* default */](arrayBuffer));
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (cloneArrayBuffer);


/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (mapToArray);


/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root__ = __webpack_require__(33);


/** Built-in value references. */
var Symbol = __WEBPACK_IMPORTED_MODULE_0__root__["a" /* default */].Symbol;

/* harmony default export */ __webpack_exports__["a"] = (Symbol);


/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = injectUiElementHandling;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__element__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_keyboard__ = __webpack_require__(28);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/uielement
 */






/**
 * UIElement class. It is used to represent UI not a content of the document.
 * This element can't be split and selection can't be placed inside this element.
 */
class UIElement extends __WEBPACK_IMPORTED_MODULE_0__element__["a" /* default */] {
	/**
	 * Creates new instance of UIElement.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
	 * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
	 *
	 * @param {String} name Node name.
	 * @param {Object|Iterable} [attributes] Collection of attributes.
	 */
	constructor( name, attributes, children ) {
		super( name, attributes, children );

		/**
		 * Returns `null` because filler is not needed for UIElements.
		 *
		 * @method #getFillerOffset
		 * @returns {null} Always returns null.
		 */
		this.getFillerOffset = getFillerOffset;
	}

	/**
	 * @inheritDoc
	 */
	is( type, name = null ) {
		if ( !name ) {
			return type == 'uiElement' || super.is( type );
		} else {
			return ( type == 'uiElement' && name == this.name ) || super.is( type, name );
		}
	}

	/**
	 * Overrides {@link module:engine/view/element~Element#insertChildren} method.
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
	 * to UIElement.
	 */
	insertChildren( index, nodes ) {
		if ( nodes && ( nodes instanceof __WEBPACK_IMPORTED_MODULE_2__node__["a" /* default */] || Array.from( nodes ).length > 0 ) ) {
			/**
			 * Cannot add children to {@link module:engine/view/uielement~UIElement}.
			 *
			 * @error view-uielement-cannot-add
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-uielement-cannot-add: Cannot add child nodes to UIElement instance.' );
		}
	}

	/**
	 * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by
	 * {@link module:engine/view/domconverter~DomConverter}.
	 *
	 * @param {Document} domDocument
	 * @return {HTMLElement}
	 */
	render( domDocument ) {
		const domElement = domDocument.createElement( this.name );

		for ( const key of this.getAttributeKeys() ) {
			domElement.setAttribute( key, this.getAttribute( key ) );
		}

		return domElement;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = UIElement;


/**
 * This function injects UI element handling to the given {@link module:engine/view/document~Document document}.
 *
 * A callback is added to {@link module:engine/view/document~Document#event:keydown document keydown event}.
 * The callback handles the situation when right arrow key is pressed and selection is collapsed before a UI element.
 * Without this handler, it would be impossible to "jump over" UI element using right arrow key.
 *
 * @param {module:engine/view/document~Document} document Document to which the quirks handling will be injected.
 */
function injectUiElementHandling( document ) {
	document.on( 'keydown', ( evt, data ) => jumpOverUiElement( evt, data, document.domConverter ) );
}

// Returns `null` because block filler is not needed for UIElements.
//
// @returns {null}
function getFillerOffset() {
	return null;
}

// Selection cannot be placed in a `UIElement`. Whenever it is placed there, it is moved before it. This
// causes a situation when it is impossible to jump over `UIElement` using right arrow key, because the selection
// ends up in ui element (in DOM) and is moved back to the left. This handler fixes this situation.
function jumpOverUiElement( evt, data, domConverter ) {
	if ( data.keyCode == __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowright ) {
		const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
		const domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt( 0 ).collapsed;

		// Jump over UI element if selection is collapsed or shift key is pressed. These are the cases when selection would extend.
		if ( domSelectionCollapsed || data.shiftKey ) {
			const domParent = domSelection.focusNode;
			const domOffset = domSelection.focusOffset;

			const viewPosition = domConverter.domPositionToView( domParent, domOffset );

			// In case if dom element is not converted to view or is not mapped or something. Happens for example in some tests.
			if ( viewPosition === null ) {
				return;
			}

			// Skip all following ui elements.
			let jumpedOverAnyUiElement = false;

			const nextViewPosition = viewPosition.getLastMatchingPosition( value => {
				if ( value.item.is( 'uiElement' ) ) {
					// Remember that there was at least one ui element.
					jumpedOverAnyUiElement = true;
				}

				// Jump over ui elements, jump over empty attribute elements, move up from inside of attribute element.
				if ( value.item.is( 'uiElement' ) || value.item.is( 'attributeElement' ) ) {
					return true;
				}

				// Don't jump over text or don't get out of container element.
				return false;
			} );

			// If anything has been skipped, fix position.
			// This `if` could be possibly omitted but maybe it is better not to mess with DOM selection if not needed.
			if ( jumpedOverAnyUiElement ) {
				const newDomPosition = domConverter.viewPositionToDom( nextViewPosition );

				if ( domSelectionCollapsed ) {
					// Selection was collapsed, so collapse it at further position.
					domSelection.collapse( newDomPosition.parent, newDomPosition.offset );
				} else {
					// Selection was not collapse, so extend it instead of collapsing.
					domSelection.extend( newDomPosition.parent, newDomPosition.offset );
				}
			}
		}
	}
}


/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_attributeoperation__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__operation_rootattributeoperation__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__operation_nooperation__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__range__ = __webpack_require__(2);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/attributedelta
 */










/**
 * To provide specific OT behavior and better collisions solving, methods to change attributes
 * ({@link module:engine/model/batch~Batch#setAttribute} and {@link module:engine/model/batch~Batch#removeAttribute})
 * use `AttributeDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class AttributeDelta extends __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	get type() {
		return 'attribute';
	}

	/**
	 * The attribute key that is changed by the delta or `null` if the delta has no operations.
	 *
	 * @readonly
	 * @type {String|null}
	 */
	get key() {
		return this.operations[ 0 ] ? this.operations[ 0 ].key : null;
	}

	/**
	 * The attribute value that is set by the delta or `null` if the delta has no operations.
	 *
	 * @readonly
	 * @type {*|null}
	 */
	get value() {
		return this.operations[ 0 ] ? this.operations[ 0 ].newValue : null;
	}

	/**
	 * The range on which delta operates or `null` if the delta has no operations.
	 *
	 * @readonly
	 * @type {module:engine/model/range~Range|null}
	 */
	get range() {
		// Check if it is cached.
		if ( this._range ) {
			return this._range;
		}

		let start = null;
		let end = null;

		for ( const operation of this.operations ) {
			if ( operation instanceof __WEBPACK_IMPORTED_MODULE_5__operation_nooperation__["a" /* default */] ) {
				continue;
			}

			if ( start === null || start.isAfter( operation.range.start ) ) {
				start = operation.range.start;
			}

			if ( end === null || end.isBefore( operation.range.end ) ) {
				end = operation.range.end;
			}
		}

		if ( start && end ) {
			this._range = new __WEBPACK_IMPORTED_MODULE_7__range__["a" /* default */]( start, end );

			return this._range;
		}

		return null;
	}

	get _reverseDeltaClass() {
		return AttributeDelta;
	}

	/**
	 * @inheritDoc
	 */
	toJSON() {
		const json = super.toJSON();

		delete json._range;

		return json;
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.AttributeDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AttributeDelta;


/**
 * To provide specific OT behavior and better collisions solving, methods to change attributes
 * ({@link module:engine/model/batch~Batch#setAttribute} and {@link module:engine/model/batch~Batch#removeAttribute})
 * use `RootAttributeDelta` class which inherits from the `Delta` class and may
 * overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class RootAttributeDelta extends __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.RootAttributeDelta';
	}
}
/* unused harmony export RootAttributeDelta */


/**
 * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}
 * or on a {@link module:engine/model/range~Range range}.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#setAttribute
 * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange
 * Model item or range on which the attribute will be set.
 * @param {String} key Attribute key.
 * @param {*} value Attribute new value.
 */
Object(__WEBPACK_IMPORTED_MODULE_2__batch__["b" /* register */])( 'setAttribute', function( itemOrRange, key, value ) {
	attribute( this, key, value, itemOrRange );

	return this;
} );

/**
 * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}
 * or from a {@link module:engine/model/range~Range range}.
 *
 * @chainable
 * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange
 * Model item or range from which the attribute will be removed.
 * @method module:engine/model/batch~Batch#removeAttribute
 * @param {String} key Attribute key.
 */
Object(__WEBPACK_IMPORTED_MODULE_2__batch__["b" /* register */])( 'removeAttribute', function( itemOrRange, key ) {
	attribute( this, key, null, itemOrRange );

	return this;
} );

function attribute( batch, key, value, itemOrRange ) {
	if ( itemOrRange instanceof __WEBPACK_IMPORTED_MODULE_7__range__["a" /* default */] ) {
		changeRange( batch, batch.document, key, value, itemOrRange );
	} else {
		changeItem( batch, batch.document, key, value, itemOrRange );
	}
}

function changeItem( batch, doc, key, value, item ) {
	const previousValue = item.getAttribute( key );
	let range, operation;

	const delta = item.is( 'rootElement' ) ? new RootAttributeDelta() : new AttributeDelta();

	if ( previousValue != value ) {
		batch.addDelta( delta );

		if ( item.is( 'rootElement' ) ) {
			// If we change attributes of root element, we have to use `RootAttributeOperation`.
			operation = new __WEBPACK_IMPORTED_MODULE_4__operation_rootattributeoperation__["a" /* default */]( item, key, previousValue, value, doc.version );
		} else {
			if ( item.is( 'element' ) ) {
				// If we change the attribute of the element, we do not want to change attributes of its children, so
				// the end of the range cannot be after the closing tag, it should be inside that element, before any of
				// it's children, so the range will contain only the opening tag.
				range = new __WEBPACK_IMPORTED_MODULE_7__range__["a" /* default */]( __WEBPACK_IMPORTED_MODULE_6__position__["a" /* default */].createBefore( item ), __WEBPACK_IMPORTED_MODULE_6__position__["a" /* default */].createFromParentAndOffset( item, 0 ) );
			} else {
				// If `item` is text proxy, we create a range from the beginning to the end of that text proxy, to change
				// all characters represented by it.
				range = new __WEBPACK_IMPORTED_MODULE_7__range__["a" /* default */]( __WEBPACK_IMPORTED_MODULE_6__position__["a" /* default */].createBefore( item ), __WEBPACK_IMPORTED_MODULE_6__position__["a" /* default */].createAfter( item ) );
			}

			operation = new __WEBPACK_IMPORTED_MODULE_3__operation_attributeoperation__["a" /* default */]( range, key, previousValue, value, doc.version );
		}

		delta.addOperation( operation );
		doc.applyOperation( operation );
	}
}

// Because attribute operation needs to have the same attribute value on the whole range, this function splits the range
// into smaller parts.
function changeRange( batch, doc, attributeKey, attributeValue, range ) {
	const delta = new AttributeDelta();

	// Position of the last split, the beginning of the new range.
	let lastSplitPosition = range.start;

	// Currently position in the scanning range. Because we need value after the position, it is not a current
	// position of the iterator but the previous one (we need to iterate one more time to get the value after).
	let position,
		// Value before the currently position.
		attributeValueBefore,
		// Value after the currently position.
		attributeValueAfter;

	for ( const value of range ) {
		attributeValueAfter = value.item.getAttribute( attributeKey );

		// At the first run of the iterator the position in undefined. We also do not have a attributeValueBefore, but
		// because attributeValueAfter may be null, attributeValueBefore may be equal attributeValueAfter ( undefined == null ).
		if ( position && attributeValueBefore != attributeValueAfter ) {
			// if attributeValueBefore == attributeValue there is nothing to change, so we add operation only if these values are different.
			if ( attributeValueBefore != attributeValue ) {
				addOperation();
			}

			lastSplitPosition = position;
		}

		position = value.nextPosition;
		attributeValueBefore = attributeValueAfter;
	}

	// Because position in the loop is not the iterator position (see let position comment), the last position in
	// the while loop will be last but one position in the range. We need to check the last position manually.
	if ( position instanceof __WEBPACK_IMPORTED_MODULE_6__position__["a" /* default */] && position != lastSplitPosition && attributeValueBefore != attributeValue ) {
		addOperation();
	}

	function addOperation() {
		// Add delta to the batch only if there is at least operation in the delta. Add delta only once.
		if ( delta.operations.length === 0 ) {
			batch.addDelta( delta );
		}

		const range = new __WEBPACK_IMPORTED_MODULE_7__range__["a" /* default */]( lastSplitPosition, position );
		const operation = new __WEBPACK_IMPORTED_MODULE_3__operation_attributeoperation__["a" /* default */]( range, attributeKey, attributeValueBefore, attributeValue, doc.version );

		delta.addOperation( operation );
		doc.applyOperation( operation );
	}
}

__WEBPACK_IMPORTED_MODULE_1__deltafactory__["a" /* default */].register( AttributeDelta );
__WEBPACK_IMPORTED_MODULE_1__deltafactory__["a" /* default */].register( RootAttributeDelta );


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__operation__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__range__ = __webpack_require__(2);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/markeroperation
 */




/**
 * @extends module:engine/model/operation/operation~Operation
 */
class MarkerOperation extends __WEBPACK_IMPORTED_MODULE_0__operation__["a" /* default */] {
	/**
	 * @param {String} name Marker name.
	 * @param {module:engine/model/range~Range} oldRange Marker range before the change.
	 * @param {module:engine/model/range~Range} newRange Marker range after the change.
	 * @param {module:engine/model/markercollection~MarkerCollection} markers Marker collection on which change should be executed.
	 * @param {Number} baseVersion {@link module:engine/model/document~Document#version} on which the operation can be applied.
	 */
	constructor( name, oldRange, newRange, markers, baseVersion ) {
		super( baseVersion );

		/**
		 * Marker name.
		 *
		 * @readonly
		 * @member {String}
		 */
		this.name = name;

		/**
		 * Marker range before the change.
		 *
		 * @readonly
		 * @member {module:engine/model/range~Range}
		 */
		this.oldRange = oldRange ? __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createFromRange( oldRange ) : null;

		/**
		 * Marker range after the change.
		 *
		 * @readonly
		 * @member {module:engine/model/range~Range}
		 */
		this.newRange = newRange ? __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createFromRange( newRange ) : null;

		/**
		 * Marker collection on which change should be executed.
		 *
		 * @private
		 * @member {module:engine/model/markercollection~MarkerCollection}
		 */
		this._markers = markers;
	}

	/**
	 * @inheritDoc
	 */
	get type() {
		return 'marker';
	}

	/**
	 * Creates and returns an operation that has the same parameters as this operation.
	 *
	 * @returns {module:engine/model/operation/markeroperation~MarkerOperation} Clone of this operation.
	 */
	clone() {
		return new MarkerOperation( this.name, this.oldRange, this.newRange, this._markers, this.baseVersion );
	}

	/**
	 * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
	 *
	 * @returns {module:engine/model/operation/markeroperation~MarkerOperation}
	 */
	getReversed() {
		return new MarkerOperation( this.name, this.newRange, this.oldRange, this._markers, this.baseVersion + 1 );
	}

	/**
	 * @inheritDoc
	 */
	_execute() {
		const type = this.newRange ? 'set' : 'remove';

		this._markers[ type ]( this.name, this.newRange );

		return { name: this.name, type };
	}

	/**
	 * @inheritDoc
	 */
	toJSON() {
		const json = super.toJSON();

		delete json._markers;

		return json;
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.operation.MarkerOperation';
	}

	/**
	 * Creates `MarkerOperation` object from deserilized object, i.e. from parsed JSON string.
	 *
	 * @param {Object} json Deserialized JSON object.
	 * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
	 * @returns {module:engine/model/operation/markeroperation~MarkerOperation}
	 */
	static fromJSON( json, document ) {
		return new MarkerOperation(
			json.name,
			json.oldRange ? __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].fromJSON( json.oldRange, document ) : null,
			json.newRange ? __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].fromJSON( json.newRange, document ) : null,
			document.markers,
			json.baseVersion
		);
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MarkerOperation;



/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__operation__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__position__ = __webpack_require__(1);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/renameoperation
 */






/**
 * Operation to change element's name.
 *
 * Using this class you can change element's name.
 *
 * @extends module:engine/model/operation/operation~Operation
 */
class RenameOperation extends __WEBPACK_IMPORTED_MODULE_0__operation__["a" /* default */] {
	/**
	 * Creates an operation that changes element's name.
	 *
	 * @param {module:engine/model/position~Position} position Position before an element to change.
	 * @param {String} oldName Current name of the element.
	 * @param {String} newName New name for the element.
	 * @param {Number} baseVersion {@link module:engine/model/document~Document#version} on which the operation can be applied.
	 */
	constructor( position, oldName, newName, baseVersion ) {
		super( baseVersion );

		/**
		 * Position before an element to change.
		 *
		 * @member {module:engine/model/position~Position} module:engine/model/operation/renameoperation~RenameOperation#position
		 */
		this.position = position;

		/**
		 * Current name of the element.
		 *
		 * @member {String} module:engine/model/operation/renameoperation~RenameOperation#oldName
		 */
		this.oldName = oldName;

		/**
		 * New name for the element.
		 *
		 * @member {String} module:engine/model/operation/renameoperation~RenameOperation#newName
		 */
		this.newName = newName;
	}

	/**
	 * @inheritDoc
	 */
	get type() {
		return 'rename';
	}

	/**
	 * Creates and returns an operation that has the same parameters as this operation.
	 *
	 * @returns {module:engine/model/operation/renameoperation~RenameOperation} Clone of this operation.
	 */
	clone() {
		return new RenameOperation( __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromPosition( this.position ), this.oldName, this.newName, this.baseVersion );
	}

	/**
	 * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
	 *
	 * @returns {module:engine/model/operation/renameoperation~RenameOperation}
	 */
	getReversed() {
		return new RenameOperation( __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].createFromPosition( this.position ), this.newName, this.oldName, this.baseVersion + 1 );
	}

	/**
	 * @inheritDoc
	 */
	_execute() {
		// Validation.
		const element = this.position.nodeAfter;

		if ( !( element instanceof __WEBPACK_IMPORTED_MODULE_1__element__["a" /* default */] ) ) {
			/**
			 * Given position is invalid or node after it is not instance of Element.
			 *
			 * @error rename-operation-wrong-position
			 */
			throw new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'rename-operation-wrong-position: Given position is invalid or node after it is not an instance of Element.'
			);
		} else if ( element.name !== this.oldName ) {
			/**
			 * Element to change has different name than operation's old name.
			 *
			 * @error rename-operation-wrong-name
			 */
			throw new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'rename-operation-wrong-name: Element to change has different name than operation\'s old name.'
			);
		}

		// If value to set is same as old value, don't do anything.
		if ( element.name != this.newName ) {
			// Execution.
			element.name = this.newName;
		}

		return { element, oldName: this.oldName };
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.operation.RenameOperation';
	}

	/**
	 * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.
	 *
	 * @param {Object} json Deserialized JSON object.
	 * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
	 * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}
	 */
	static fromJSON( json, document ) {
		return new RenameOperation( __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */].fromJSON( json.position, document ), json.oldName, json.newName, json.baseVersion );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenameOperation;



/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__operation__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/rootattributeoperation
 */




/**
 * Operation to change root element's attribute. Using this class you can add, remove or change value of the attribute.
 *
 * This operation is needed, because root elements can't be changed through
 * @link module:engine/model/operation/attributeoperation~AttributeOperation}.
 * It is because {@link module:engine/model/operation/attributeoperation~AttributeOperation}
 * requires a range to change and root element can't
 * be a part of range because every {@link module:engine/model/position~Position} has to be inside a root.
 * {@link module:engine/model/position~Position} can't be created before a root element.
 *
 * @extends module:engine/model/operation/operation~Operation
 */
class RootAttributeOperation extends __WEBPACK_IMPORTED_MODULE_0__operation__["a" /* default */] {
	/**
	 * Creates an operation that changes, removes or adds attributes on root element.
	 *
	 * @see module:engine/model/operation/attributeoperation~AttributeOperation
	 * @param {module:engine/model/rootelement~RootElement} root Root element to change.
	 * @param {String} key Key of an attribute to change or remove.
	 * @param {*} oldValue Old value of the attribute with given key or `null` if adding a new attribute.
	 * @param {*} newValue New value to set for the attribute. If `null`, then the operation just removes the attribute.
	 * @param {Number} baseVersion {@link module:engine/model/document~Document#version} on which the operation can be applied.
	 */
	constructor( root, key, oldValue, newValue, baseVersion ) {
		super( baseVersion );

		/**
		 * Root element to change.
		 *
		 * @readonly
		 * @member {module:engine/model/rootelement~RootElement}
		 */
		this.root = root;

		/**
		 * Key of an attribute to change or remove.
		 *
		 * @readonly
		 * @member {String}
		 */
		this.key = key;

		/**
		 * Old value of the attribute with given key or `null` if adding a new attribute.
		 *
		 * @readonly
		 * @member {*}
		 */
		this.oldValue = oldValue;

		/**
		 * New value to set for the attribute. If `null`, then the operation just removes the attribute.
		 *
		 * @readonly
		 * @member {*}
		 */
		this.newValue = newValue;
	}

	get type() {
		if ( this.oldValue === null ) {
			return 'addRootAttribute';
		} else if ( this.newValue === null ) {
			return 'removeRootAttribute';
		} else {
			return 'changeRootAttribute';
		}
	}

	/**
	 * Creates and returns an operation that has the same parameters as this operation.
	 *
	 * @returns {module:engine/model/operation/rootattributeoperation~RootAttributeOperation} Clone of this operation.
	 */
	clone() {
		return new RootAttributeOperation( this.root, this.key, this.oldValue, this.newValue, this.baseVersion );
	}

	/**
	 * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
	 *
	 * @returns {module:engine/model/operation/rootattributeoperation~RootAttributeOperation}
	 */
	getReversed() {
		return new RootAttributeOperation( this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1 );
	}

	_execute() {
		if ( this.oldValue !== null && this.root.getAttribute( this.key ) !== this.oldValue ) {
			/**
			 * The attribute which should be removed does not exists for the given node.
			 *
			 * @error rootattribute-operation-wrong-old-value
			 * @param {module:engine/model/rootelement~RootElement} root
			 * @param {String} key
			 * @param {*} value
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'rootattribute-operation-wrong-old-value: Changed node has different attribute value than operation\'s ' +
				'old attribute value.',
				{ root: this.root, key: this.key }
			);
		}

		if ( this.oldValue === null && this.newValue !== null && this.root.hasAttribute( this.key ) ) {
			/**
			 * The attribute with given key already exists for the given node.
			 *
			 * @error rootattribute-operation-attribute-exists
			 * @param {module:engine/model/rootelement~RootElement} root
			 * @param {String} key
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'rootattribute-operation-attribute-exists: The attribute with given key already exists.',
				{ root: this.root, key: this.key }
			);
		}

		if ( this.newValue !== null ) {
			this.root.setAttribute( this.key, this.newValue );
		} else {
			this.root.removeAttribute( this.key );
		}

		return { root: this.root, key: this.key, oldValue: this.oldValue, newValue: this.newValue };
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.operation.RootAttributeOperation';
	}

	/**
	 * Creates RootAttributeOperation object from deserilized object, i.e. from parsed JSON string.
	 *
	 * @param {Object} json Deserialized JSON object.
	 * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
	 * @returns {module:engine/model/operation/rootattributeoperation~RootAttributeOperation}
	 */
	static fromJSON( json, document ) {
		if ( !document.hasRoot( json.root ) ) {
			/**
			 * Cannot create RootAttributeOperation for document. Root with specified name does not exist.
			 *
			 * @error rootattributeoperation-fromjson-no-root
			 * @param {String} rootName
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'rootattribute-operation-fromjson-no-root: Cannot create RootAttributeOperation. Root with specified name does not exist.',
				{ rootName: json }
			);
		}

		return new RootAttributeOperation( document.getRoot( json.root ), json.key, json.oldValue, json.newValue, json.baseVersion );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RootAttributeOperation;



/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__removedelta__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_insertoperation__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__writer__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__documentfragment__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__model_range_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__model_position_js__ = __webpack_require__(1);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/insertdelta
 */












/**
 * To provide specific OT behavior and better collisions solving, the {@link module:engine/model/batch~Batch#insert Batch#insert} method
 * uses the `InsertDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class InsertDelta extends __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	get type() {
		return 'insert';
	}

	/**
	 * Position where the delta inserts nodes or `null` if there are no operations in the delta.
	 *
	 * @readonly
	 * @type {module:engine/model/position~Position|null}
	 */
	get position() {
		return this._insertOperation ? this._insertOperation.position : null;
	}

	/**
	 * Node list containing all the nodes inserted by the delta or `null` if there are no operations in the delta.
	 *
	 * @readonly
	 * @type {module:engine/model/nodelist~NodeList|null}
	 */
	get nodes() {
		return this._insertOperation ? this._insertOperation.nodes : null;
	}

	/**
	 * Insert operation that is saved in this delta or `null` if there are no operations in the delta.
	 *
	 * @readonly
	 * @protected
	 * @type {module:engine/model/operation/insertoperation~InsertOperation|null}
	 */
	get _insertOperation() {
		return this.operations[ 0 ] || null;
	}

	/**
	 * @inheritDoc
	 */
	get _reverseDeltaClass() {
		return __WEBPACK_IMPORTED_MODULE_1__removedelta__["a" /* default */];
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.InsertDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = InsertDelta;


/**
 * Inserts a node or nodes at the given position.
 *
 * When inserted element is a {@link module:engine/model/documentfragment~DocumentFragment} and has markers its markers will
 * be set to {@link module:engine/model/document~Document#markers}.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#insert
 * @param {module:engine/model/position~Position} position Position of insertion.
 * @param {module:engine/model/node~NodeSet} nodes The list of nodes to be inserted.
 */
Object(__WEBPACK_IMPORTED_MODULE_4__batch__["b" /* register */])( 'insert', function( position, nodes ) {
	const normalizedNodes = Object(__WEBPACK_IMPORTED_MODULE_5__writer__["c" /* normalizeNodes */])( nodes );

	// If nothing is inserted do not create delta and operation.
	if ( normalizedNodes.length === 0 ) {
		return this;
	}

	const delta = new InsertDelta();
	const insert = new __WEBPACK_IMPORTED_MODULE_3__operation_insertoperation__["a" /* default */]( position, normalizedNodes, this.document.version );

	this.addDelta( delta );
	delta.addOperation( insert );
	this.document.applyOperation( insert );

	// When element is a DocumentFragment we need to move its markers to Document#markers.
	if ( nodes instanceof __WEBPACK_IMPORTED_MODULE_6__documentfragment__["a" /* default */] ) {
		for ( const [ markerName, markerRange ] of nodes.markers ) {
			// We need to migrate marker range from DocumentFragment to Document.
			const rangeRootPosition = __WEBPACK_IMPORTED_MODULE_8__model_position_js__["a" /* default */].createAt( markerRange.root );
			const range = new __WEBPACK_IMPORTED_MODULE_7__model_range_js__["a" /* default */](
				markerRange.start._getCombined( rangeRootPosition, position ),
				markerRange.end._getCombined( rangeRootPosition, position )
			);

			this.setMarker( markerName, range );
		}
	}

	return this;
} );

__WEBPACK_IMPORTED_MODULE_2__deltafactory__["a" /* default */].register( InsertDelta );


/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_renameoperation__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/renamedelta
 */









/**
 * To provide specific OT behavior and better collisions solving, the {@link module:engine/model/batch~Batch#rename Batch#rename} method
 * uses the `RenameDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class RenameDelta extends __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	get type() {
		return 'rename';
	}

	/**
	 * @inheritDoc
	 */
	get _reverseDeltaClass() {
		return RenameDelta;
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.RenameDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenameDelta;


function apply( batch, delta, operation ) {
	delta.addOperation( operation );
	batch.document.applyOperation( operation );
}

/**
 * Renames given element.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#rename
 * @param {module:engine/model/element~Element} element The element to rename.
 * @param {String} newName New element name.
 */
Object(__WEBPACK_IMPORTED_MODULE_2__batch__["b" /* register */])( 'rename', function( element, newName ) {
	if ( !( element instanceof __WEBPACK_IMPORTED_MODULE_4__element__["a" /* default */] ) ) {
		/**
		 * Trying to rename an object which is not an instance of Element.
		 *
		 * @error batch-rename-not-element-instance
		 */
		throw new __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-rename-not-element-instance: Trying to rename an object which is not an instance of Element.' );
	}

	const delta = new RenameDelta();
	this.addDelta( delta );

	const renameOperation = new __WEBPACK_IMPORTED_MODULE_3__operation_renameoperation__["a" /* default */]( __WEBPACK_IMPORTED_MODULE_5__position__["a" /* default */].createBefore( element ), element.name, newName, this.document.version );
	apply( this, delta, renameOperation );

	return this;
} );

__WEBPACK_IMPORTED_MODULE_1__deltafactory__["a" /* default */].register( RenameDelta );


/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIndexOf__ = __webpack_require__(137);


/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  return !!array.length && Object(__WEBPACK_IMPORTED_MODULE_0__baseIndexOf__["a" /* default */])(array, value, 0) > -1;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayIncludes);


/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__indexOfNaN__ = __webpack_require__(193);


/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__indexOfNaN__["a" /* default */])(array, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (baseIndexOf);


/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayIncludesWith);


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.unary` without support for storing wrapper metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (baseUnary);


/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/* harmony default export */ __webpack_exports__["a"] = (cacheHas);


/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__castPath__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isKey__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__toKey__ = __webpack_require__(57);




/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = Object(__WEBPACK_IMPORTED_MODULE_1__isKey__["a" /* default */])(path, object) ? [path] : Object(__WEBPACK_IMPORTED_MODULE_0__castPath__["a" /* default */])(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[Object(__WEBPACK_IMPORTED_MODULE_2__toKey__["a" /* default */])(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (baseGet);


/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSlice__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger__ = __webpack_require__(12);



/**
 * Creates a slice of `array` with `n` elements dropped from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.drop([1, 2, 3]);
 * // => [2, 3]
 *
 * _.drop([1, 2, 3], 2);
 * // => [3]
 *
 * _.drop([1, 2, 3], 5);
 * // => []
 *
 * _.drop([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function drop(array, n, guard) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : Object(__WEBPACK_IMPORTED_MODULE_1__toInteger__["a" /* default */])(n);
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice__["a" /* default */])(array, n < 0 ? 0 : n, length);
}

/* harmony default export */ __webpack_exports__["a"] = (drop);


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSlice__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger__ = __webpack_require__(12);



/**
 * Creates a slice of `array` with `n` elements dropped from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.dropRight([1, 2, 3]);
 * // => [1, 2]
 *
 * _.dropRight([1, 2, 3], 2);
 * // => [1]
 *
 * _.dropRight([1, 2, 3], 5);
 * // => []
 *
 * _.dropRight([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function dropRight(array, n, guard) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : Object(__WEBPACK_IMPORTED_MODULE_1__toInteger__["a" /* default */])(n);
  n = length - n;
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice__["a" /* default */])(array, 0, n < 0 ? 0 : n);
}

/* harmony default export */ __webpack_exports__["a"] = (dropRight);


/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (head);


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SetCache__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayIncludes__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__arrayMap__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__baseUnary__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__cacheHas__ = __webpack_require__(140);







/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith__["a" /* default */] : __WEBPACK_IMPORTED_MODULE_1__arrayIncludes__["a" /* default */],
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = Object(__WEBPACK_IMPORTED_MODULE_3__arrayMap__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_4__baseUnary__["a" /* default */])(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new __WEBPACK_IMPORTED_MODULE_0__SetCache__["a" /* default */](othIndex && array)
      : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer:
  while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (!(seen
          ? Object(__WEBPACK_IMPORTED_MODULE_5__cacheHas__["a" /* default */])(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache
              ? Object(__WEBPACK_IMPORTED_MODULE_5__cacheHas__["a" /* default */])(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseIntersection);


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArrayLikeObject__ = __webpack_require__(13);


/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__isArrayLikeObject__["a" /* default */])(value) ? value : [];
}

/* harmony default export */ __webpack_exports__["a"] = (castArrayLikeObject);


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basePullAll__ = __webpack_require__(148);


/**
 * This method is like `_.pull` except that it accepts an array of values to remove.
 *
 * **Note:** Unlike `_.difference`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3, 1, 2, 3];
 *
 * _.pullAll(array, [2, 3]);
 * console.log(array);
 * // => [1, 1]
 */
function pullAll(array, values) {
  return (array && array.length && values && values.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__basePullAll__["a" /* default */])(array, values)
    : array;
}

/* harmony default export */ __webpack_exports__["a"] = (pullAll);


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIndexOf__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseIndexOfWith__ = __webpack_require__(403);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__baseUnary__ = __webpack_require__(139);





/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * The base implementation of `_.pullAllBy` without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 */
function basePullAll(array, values, iteratee, comparator) {
  var indexOf = comparator ? __WEBPACK_IMPORTED_MODULE_2__baseIndexOfWith__["a" /* default */] : __WEBPACK_IMPORTED_MODULE_1__baseIndexOf__["a" /* default */],
      index = -1,
      length = values.length,
      seen = array;

  if (iteratee) {
    seen = Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_3__baseUnary__["a" /* default */])(iteratee));
  }
  while (++index < length) {
    var fromIndex = 0,
        value = values[index],
        computed = iteratee ? iteratee(value) : value;

    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice.call(seen, fromIndex, 1);
      }
      splice.call(array, fromIndex, 1);
    }
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (basePullAll);


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isSymbol__ = __webpack_require__(45);


/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295,
    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeMin = Math.min;

/**
 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
 * which invokes `iteratee` for `value` and each element of `array` to compute
 * their sort ranking. The iteratee is invoked with one argument; (value).
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndexBy(array, value, iteratee, retHighest) {
  value = iteratee(value);

  var low = 0,
      high = array ? array.length : 0,
      valIsNaN = value !== value,
      valIsNull = value === null,
      valIsSymbol = Object(__WEBPACK_IMPORTED_MODULE_0__isSymbol__["a" /* default */])(value),
      valIsUndefined = value === undefined;

  while (low < high) {
    var mid = nativeFloor((low + high) / 2),
        computed = iteratee(array[mid]),
        othIsDefined = computed !== undefined,
        othIsNull = computed === null,
        othIsReflexive = computed === computed,
        othIsSymbol = Object(__WEBPACK_IMPORTED_MODULE_0__isSymbol__["a" /* default */])(computed);

    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? (computed <= value) : (computed < value);
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin(high, MAX_ARRAY_INDEX);
}

/* harmony default export */ __webpack_exports__["a"] = (baseSortedIndexBy);


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__apply__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayMap__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__unzip__ = __webpack_require__(106);




/**
 * This method is like `_.unzip` except that it accepts `iteratee` to specify
 * how regrouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  regrouped values.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
 * // => [[1, 10, 100], [2, 20, 200]]
 *
 * _.unzipWith(zipped, _.add);
 * // => [3, 30, 300]
 */
function unzipWith(array, iteratee) {
  if (!(array && array.length)) {
    return [];
  }
  var result = Object(__WEBPACK_IMPORTED_MODULE_2__unzip__["a" /* default */])(array);
  if (iteratee == null) {
    return result;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_1__arrayMap__["a" /* default */])(result, function(group) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__apply__["a" /* default */])(iteratee, undefined, group);
  });
}

/* harmony default export */ __webpack_exports__["a"] = (unzipWith);


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayPush__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseDifference__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseUniq__ = __webpack_require__(48);




/**
 * The base implementation of methods like `_.xor`, without support for
 * iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of values.
 */
function baseXor(arrays, iteratee, comparator) {
  var index = -1,
      length = arrays.length;

  while (++index < length) {
    var result = result
      ? Object(__WEBPACK_IMPORTED_MODULE_0__arrayPush__["a" /* default */])(
          Object(__WEBPACK_IMPORTED_MODULE_1__baseDifference__["a" /* default */])(result, arrays[index], iteratee, comparator),
          Object(__WEBPACK_IMPORTED_MODULE_1__baseDifference__["a" /* default */])(arrays[index], result, iteratee, comparator)
        )
      : arrays[index];
  }
  return (result && result.length) ? Object(__WEBPACK_IMPORTED_MODULE_2__baseUniq__["a" /* default */])(result, iteratee, comparator) : [];
}

/* harmony default export */ __webpack_exports__["a"] = (baseXor);


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/liverange
 */





/**
 * `LiveRange` is a type of {@link module:engine/model/range~Range Range}
 * that updates itself as {@link module:engine/model/document~Document document}
 * is changed through operations. It may be used as a bookmark.
 *
 * **Note:** Be very careful when dealing with `LiveRange`. Each `LiveRange` instance bind events that might
 * have to be unbound. Use {@link module:engine/model/liverange~LiveRange#detach detach} whenever you don't need `LiveRange` anymore.
 */
class LiveRange extends __WEBPACK_IMPORTED_MODULE_0__range__["a" /* default */] {
	/**
	 * Creates a live range.
	 *
	 * @see module:engine/model/range~Range
	 */
	constructor( start, end ) {
		super( start, end );

		bindWithDocument.call( this );
	}

	/**
	 * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance
	 * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
	 * referring to it).
	 */
	detach() {
		this.stopListening();
	}

	/**
	 * @see module:engine/model/range~Range.createIn
	 * @static
	 * @method module:engine/model/liverange~LiveRange.createIn
	 * @param {module:engine/model/element~Element} element
	 * @returns {module:engine/model/liverange~LiveRange}
	 */

	/**
	 * @see module:engine/model/range~Range.createFromPositionAndShift
	 * @static
	 * @method module:engine/model/liverange~LiveRange.createFromPositionAndShift
	 * @param {module:engine/model/position~Position} position
	 * @param {Number} shift
	 * @returns {module:engine/model/liverange~LiveRange}
	 */

	/**
	 * @see module:engine/model/range~Range.createFromParentsAndOffsets
	 * @static
	 * @method module:engine/model/liverange~LiveRange.createFromParentsAndOffsets
	 * @param {module:engine/model/element~Element} startElement
	 * @param {Number} startOffset
	 * @param {module:engine/model/element~Element} endElement
	 * @param {Number} endOffset
	 * @returns {module:engine/model/liverange~LiveRange}
	 */

	/**
	 * @see module:engine/model/range~Range.createFromRange
	 * @static
	 * @method module:engine/model/liverange~LiveRange.createFromRange
	 * @param {module:engine/model/range~Range} range
	 * @returns {module:engine/model/liverange~LiveRange}
	 */

	/**
	 * Fired when `LiveRange` instance boundaries have changed due to changes in the
	 * {@link module:engine/model/document~Document document}.
	 *
	 * @event change:range
	 * @param {module:engine/model/range~Range} oldRange Range with start and end position equal to start and end position of this live
	 * range before it got changed.
	 * @param {Object} data Object with additional information about the change. Those parameters are passed from
	 * {@link module:engine/model/document~Document#event:change document change event}.
	 * @param {String} data.type Change type.
	 * @param {module:engine/model/batch~Batch} data.batch Batch which changed the live range.
	 * @param {module:engine/model/range~Range} data.range Range containing the result of applied change.
	 * @param {module:engine/model/position~Position} data.sourcePosition Source position for move, remove and reinsert change types.
	 */

	/**
	 * Fired when `LiveRange` instance boundaries have not changed after a change in {@link module:engine/model/document~Document document}
	 * but the change took place inside the range, effectively changing its content.
	 *
	 * @event change:content
	 * @param {module:engine/model/range~Range} range Range with start and end position equal to start and end position of
	 * change range.
	 * @param {Object} data Object with additional information about the change. Those parameters are passed from
	 * {@link module:engine/model/document~Document#event:change document change event}.
	 * @param {String} data.type Change type.
	 * @param {module:engine/model/batch~Batch} data.batch Batch which changed the live range.
	 * @param {module:engine/model/range~Range} data.range Range containing the result of applied change.
	 * @param {module:engine/model/position~Position} data.sourcePosition Source position for move, remove and reinsert change types.
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LiveRange;


/**
 * Binds this `LiveRange` to the {@link module:engine/model/document~Document document}
 * that owns this range's {@link module:engine/model/range~Range#root root}.
 *
 * @ignore
 * @private
 * @method module:engine/model/liverange~LiveRange#bindWithDocument
 */
function bindWithDocument() {
	// Operation types that a range can be transformed by.
	const supportedTypes = new Set( [ 'insert', 'move', 'remove', 'reinsert' ] );

	this.listenTo(
		this.root.document,
		'change',
		( event, type, changes, batch, deltaType ) => {
			if ( supportedTypes.has( type ) ) {
				transform.call( this, type, deltaType, batch, changes.range, changes.sourcePosition );
			}
		},
		{ priority: 'high' }
	);
}

/**
 * Updates this range accordingly to the updates applied to the model. Bases on change events.
 *
 * @ignore
 * @private
 * @method transform
 * @param {String} [changeType] Type of change applied to the model document.
 * @param {String} [deltaType] Type of delta which introduced the change.
 * @param {module:engine/model/batch~Batch} batch Batch which changes the live range.
 * @param {module:engine/model/range~Range} targetRange Range containing the result of applied change.
 * @param {module:engine/model/position~Position} [sourcePosition] Source position for move, remove and reinsert change types.
 */
function transform( changeType, deltaType, batch, targetRange, sourcePosition ) {
	const howMany = targetRange.end.offset - targetRange.start.offset;
	let targetPosition = targetRange.start;

	if ( changeType == 'move' || changeType == 'remove' || changeType == 'reinsert' ) {
		// Range._getTransformedByDocumentChange is expecting `targetPosition` to be "before" move
		// (before transformation). `targetRange.start` is already after the move happened.
		// We have to revert `targetPosition` to the state before the move.
		targetPosition = targetPosition._getTransformedByInsertion( sourcePosition, howMany );
	}

	const result = this._getTransformedByDocumentChange( changeType, deltaType, targetPosition, howMany, sourcePosition );

	// Decide whether moved part should be included in the range.
	//
	// First, this concerns only `move` change, because insert change includes inserted part always (changeType == 'move').
	// Second, this is a case only if moved range was intersecting with this range and was inserted into this range (result.length == 3).
	if ( ( changeType == 'move' || changeType == 'remove' || changeType == 'reinsert' ) && result.length == 3 ) {
		// `result[ 2 ]` is a "common part" of this range and moved range. We substitute that common part with the whole
		// `targetRange` because we want to include whole `targetRange` in this range.
		result[ 2 ] = targetRange;
	}

	const updated = __WEBPACK_IMPORTED_MODULE_0__range__["a" /* default */].createFromRanges( result );

	const boundariesChanged = !updated.isEqual( this );

	const rangeExpanded = this.containsPosition( targetPosition );
	const rangeShrunk = sourcePosition && ( this.containsPosition( sourcePosition ) || this.start.isEqual( sourcePosition ) );
	const contentChanged = rangeExpanded || rangeShrunk;

	if ( boundariesChanged ) {
		// If range boundaries have changed, fire `change:range` event.
		const oldRange = __WEBPACK_IMPORTED_MODULE_0__range__["a" /* default */].createFromRange( this );

		this.start = updated.start;
		this.end = updated.end;

		this.fire( 'change:range', oldRange, {
			type: changeType,
			batch,
			range: targetRange,
			sourcePosition
		} );
	} else if ( contentChanged ) {
		// If range boundaries have not changed, but there was change inside the range, fire `change:content` event.
		this.fire( 'change:content', __WEBPACK_IMPORTED_MODULE_0__range__["a" /* default */].createFromRange( this ), {
			type: changeType,
			batch,
			range: targetRange,
			sourcePosition
		} );
	}
}

Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( LiveRange, __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = count;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/count
 */

/**
 * Returns the number of items return by the iterator.
 *
 *		count( [ 1, 2, 3, 4, 5 ] ); // 5;
 *
 * @param {Iterable.<*>} iterator Any iterator.
 * @returns {Number} Number of items returned by that iterator.
 */
function count( iterator ) {
	let count = 0;

	for ( const _ of iterator ) { // eslint-disable-line no-unused-vars
		count++;
	}

	return count;
}


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isObject__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__now__ = __webpack_require__(427);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__toNumber__ = __webpack_require__(166);




/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide an options object to indicate whether `func` should be invoked on
 * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent calls
 * to the debounced function return the result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
 * on the trailing edge of the timeout only if the debounced function is
 * invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime = 0,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = Object(__WEBPACK_IMPORTED_MODULE_2__toNumber__["a" /* default */])(wait) || 0;
  if (Object(__WEBPACK_IMPORTED_MODULE_0__isObject__["a" /* default */])(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(Object(__WEBPACK_IMPORTED_MODULE_2__toNumber__["a" /* default */])(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (!lastCallTime || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = Object(__WEBPACK_IMPORTED_MODULE_1__now__["a" /* default */])();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    clearTimeout(timerId);
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastCallTime = lastInvokeTime = 0;
    lastArgs = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(Object(__WEBPACK_IMPORTED_MODULE_1__now__["a" /* default */])());
  }

  function debounced() {
    var time = Object(__WEBPACK_IMPORTED_MODULE_1__now__["a" /* default */])(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/* harmony default export */ __webpack_exports__["a"] = (debounce);


/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_extend__ = __webpack_require__(44);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/domeventdata
 */



/**
 * Information about a DOM event in context of the {@link module:engine/view/document~Document}.
 * It wraps the native event, which usually should not be used as the wrapper contains
 * additional data (like key code for keyboard events).
 */
class DomEventData {
	/**
	 * @param {module:engine/view/document~Document} document The instance of the tree view Document.
	 * @param {Event} domEvent The DOM event.
	 * @param {Object} [additionalData] Additional properties that the instance should contain.
	 */
	constructor( document, domEvent, additionalData ) {
		/**
		 * The instance of the document.
		 *
		 * @readonly
		 * @member {module:engine/view/document~Document} module:engine/view/observer/observer~Observer.DomEvent#view
		 */
		this.document = document;

		/**
		 * The DOM event.
		 *
		 * @readonly
		 * @member {Event} module:engine/view/observer/observer~Observer.DomEvent#domEvent
		 */
		this.domEvent = domEvent;

		/**
		 * The DOM target.
		 *
		 * @readonly
		 * @member {HTMLElement} module:engine/view/observer/observer~Observer.DomEvent#target
		 */
		this.domTarget = domEvent.target;

		Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_extend__["a" /* default */])( this, additionalData );
	}

	/**
	 * The tree view element representing the target.
	 *
	 * @readonly
	 * @type module:engine/view/element~Element
	 */
	get target() {
		return this.document.domConverter.mapDomToView( this.domTarget );
	}

	/**
	 * Prevents the native's event default action.
	 */
	preventDefault() {
		this.domEvent.preventDefault();
	}

	/**
	 * Stops native event propagation.
	 */
	stopPropagation() {
		this.domEvent.stopPropagation();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DomEventData;



/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isRange;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/isrange
 */

/**
 * Checks if the object is a native DOM Range.
 *
 * @param {*} obj
 * @returns {Boolean}
 */
function isRange( obj ) {
	return Object.prototype.toString.apply( obj ) == '[object Range]';
}


/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isrange__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iswindow__ = __webpack_require__(432);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_lodash_isElement__ = __webpack_require__(262);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__getborderwidths__ = __webpack_require__(263);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__log__ = __webpack_require__(26);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/rect
 */







/**
 * A helper class representing a `ClientRect` object, e.g. value returned by
 * the native `object.getBoundingClientRect()` method. Provides a set of methods
 * to manipulate the rect and compare it against other rect instances.
 */
class Rect {
	/**
	 * Creates an instance of rect.
	 *
	 *		// Rect of an HTMLElement.
	 *		const rectA = new Rect( document.body );
	 *
	 *		// Rect of a DOM Range.
	 *		const rectB = new Rect( document.getSelection().getRangeAt( 0 ) );
	 *
	 *		// Rect of a window (web browser viewport).
	 *		const rectC = new Rect( window );
	 *
	 *		// Rect out of an object.
	 *		const rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );
	 *
	 *		// Rect out of another Rect instance.
	 *		const rectE = new Rect( rectD );
	 *
	 *		// Rect out of a ClientRect.
	 *		const rectF = new Rect( document.body.getClientRects().item( 0 ) );
	 *
	 * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)
	 * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}
	 * to get the inner part of the rect.
	 *
	 * @param {HTMLElement|Range|Window|ClientRect|module:utils/dom/rect~Rect|Object} source A source object to create the rect.
	 */
	constructor( source ) {
		const isSourceRange = Object(__WEBPACK_IMPORTED_MODULE_0__isrange__["a" /* default */])( source );

		/**
		 * The object this rect is for.
		 *
		 * @protected
		 * @readonly
		 * @member {HTMLElement|Range|ClientRect|module:utils/dom/rect~Rect|Object} #_source
		 */
		Object.defineProperty( this, '_source', {
			// If the source is a Rect instance, copy it's #_source.
			value: source._source || source,
			writable: true,
			enumerable: false
		} );

		if ( Object(__WEBPACK_IMPORTED_MODULE_2__lib_lodash_isElement__["a" /* default */])( source ) || isSourceRange ) {
			const sourceNode = isSourceRange ? source.startContainer : source;

			if ( !sourceNode.ownerDocument || !sourceNode.ownerDocument.body.contains( sourceNode ) ) {
				/**
				 * The `Rect` class depends on `getBoundingClientRect` and `getClientRects` DOM methods.
				 * If the {@link #constructor source} of a rect in an HTML element or a DOM range but it does
				 * not belong to any rendered DOM tree, these methods will fail to obtain the geometry and
				 * the rect instance makes little sense to the features using it.
				 *
				 * To get rid of this warning make sure the source passed to the constructor
				 * is a descendant of `window.document.body`.
				 *
				 * @error rect-source-not-in-dom
				 * @param {String} source The source of the Rect instance.
				 */
				__WEBPACK_IMPORTED_MODULE_4__log__["a" /* default */].warn(
					'rect-source-not-in-dom: The source of this rect does not belong to any rendered DOM tree.',
					{ source }
				);
			}

			if ( isSourceRange ) {
				copyRectProperties( this, Rect.getDomRangeRects( source )[ 0 ] );
			} else {
				copyRectProperties( this, source.getBoundingClientRect() );
			}
		} else if ( Object(__WEBPACK_IMPORTED_MODULE_1__iswindow__["a" /* default */])( source ) ) {
			const { innerWidth, innerHeight } = source;

			copyRectProperties( this, {
				top: 0,
				right: innerWidth,
				bottom: innerHeight,
				left: 0,
				width: innerWidth,
				height: innerHeight
			} );
		} else {
			copyRectProperties( this, source );
		}

		/**
		 * The "top" value of the rect.
		 *
		 * @readonly
		 * @member {Number} #top
		 */

		/**
		 * The "right" value of the rect.
		 *
		 * @readonly
		 * @member {Number} #right
		 */

		/**
		 * The "bottom" value of the rect.
		 *
		 * @readonly
		 * @member {Number} #bottom
		 */

		/**
		 * The "left" value of the rect.
		 *
		 * @readonly
		 * @member {Number} #left
		 */

		/**
		 * The "width" value of the rect.
		 *
		 * @readonly
		 * @member {Number} #width
		 */

		/**
		 * The "height" value of the rect.
		 *
		 * @readonly
		 * @member {Number} #height
		 */
	}

	/**
	 * Returns a clone of the rect.
	 *
	 * @returns {module:utils/dom/rect~Rect} A cloned rect.
	 */
	clone() {
		return new Rect( this );
	}

	/**
	 * Moves the rect so that its upperleft corner lands in desired `[ x, y ]` location.
	 *
	 * @param {Number} x Desired horizontal location.
	 * @param {Number} y Desired vertical location.
	 * @returns {module:utils/dom/rect~Rect} A rect which has been moved.
	 */
	moveTo( x, y ) {
		this.top = y;
		this.right = x + this.width;
		this.bottom = y + this.height;
		this.left = x;

		return this;
	}

	/**
	 * Moves the rect inplace by a dedicated offset.
	 *
	 * @param {Number} x A horizontal offset.
	 * @param {Number} y A vertical offset
	 * @returns {module:utils/dom/rect~Rect} A rect which has been moved.
	 */
	moveBy( x, y ) {
		this.top += y;
		this.right += x;
		this.left += x;
		this.bottom += y;

		return this;
	}

	/**
	 * Returns a new rect a a result of intersection with another rect.
	 *
	 * @param {module:utils/dom/rect~Rect} anotherRect
	 * @returns {module:utils/dom/rect~Rect}
	 */
	getIntersection( anotherRect ) {
		const rect = {
			top: Math.max( this.top, anotherRect.top ),
			right: Math.min( this.right, anotherRect.right ),
			bottom: Math.min( this.bottom, anotherRect.bottom ),
			left: Math.max( this.left, anotherRect.left )
		};

		rect.width = rect.right - rect.left;
		rect.height = rect.bottom - rect.top;

		if ( rect.width < 0 || rect.height < 0 ) {
			return null;
		} else {
			return new Rect( rect );
		}
	}

	/**
	 * Returns the area of intersection with another rect.
	 *
	 * @param {module:utils/dom/rect~Rect} anotherRect [description]
	 * @returns {Number} Area of intersection.
	 */
	getIntersectionArea( anotherRect ) {
		const rect = this.getIntersection( anotherRect );

		if ( rect ) {
			return rect.getArea();
		} else {
			return 0;
		}
	}

	/**
	 * Returns the area of the rect.
	 *
	 * @returns {Number}
	 */
	getArea() {
		return this.width * this.height;
	}

	/**
	 * Returns a new rect, a part of the original rect, which is actually visible to the user,
	 * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS
	 * other than `"visible"`.
	 *
	 * If there's no such visible rect, which is when the rect is limited by one or many of
	 * the ancestors, `null` is returned.
	 *
	 * @returns {module:utils/dom/rect~Rect|null} A visible rect instance or `null`, if there's none.
	 */
	getVisible() {
		const source = this._source;
		let visibleRect = this.clone();

		// There's no ancestor to crop <body> with the overflow.
		if ( !isBody( source ) ) {
			let parent = source.parentNode || source.commonAncestorContainer;

			// Check the ancestors all the way up to the <body>.
			while ( parent && !isBody( parent ) ) {
				const parentRect = new Rect( parent );
				const intersectionRect = visibleRect.getIntersection( parentRect );

				if ( intersectionRect ) {
					if ( intersectionRect.getArea() < visibleRect.getArea() ) {
						// Reduce the visible rect to the intersection.
						visibleRect = intersectionRect;
					}
				} else {
					// There's no intersection, the rect is completely invisible.
					return null;
				}

				parent = parent.parentNode;
			}
		}

		return visibleRect;
	}

	/**
	 * Checks if all property values ({@link #top}, {@link #left}, {@link #right},
	 * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect
	 * instances.
	 *
	 * @param {module:utils/dom/rect~Rect} rect A rect instance to compare with.
	 * @returns {Boolean} `true` when Rects are equal. `false` otherwise.
	 */
	isEqual( anotherRect ) {
		for ( const prop of rectProperties ) {
			if ( this[ prop ] !== anotherRect[ prop ] ) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Checks whether a rect fully contains another rect instance.
	 *
	 * @param {module:utils/dom/rect~Rect} anotherRect
	 * @returns {Boolean} `true` if contains, `false` otherwise.
	 */
	contains( anotherRect ) {
		const intersectRect = this.getIntersection( anotherRect );

		return !!( intersectRect && intersectRect.isEqual( anotherRect ) );
	}

	/**
	 * Excludes scrollbars and CSS borders from the rect.
	 *
	 * * Borders are removed when {@link #_source} is an HTML element.
	 * * Scrollbars are excluded from HTML elements and the `window`.
	 *
	 * @returns {module:utils/dom/rect~Rect} A rect which has been updated.
	 */
	excludeScrollbarsAndBorders() {
		const source = this._source;
		let scrollBarWidth, scrollBarHeight;

		if ( Object(__WEBPACK_IMPORTED_MODULE_1__iswindow__["a" /* default */])( source ) ) {
			scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;
			scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;
		} else {
			const borderWidths = Object(__WEBPACK_IMPORTED_MODULE_3__getborderwidths__["a" /* default */])( this._source );

			scrollBarWidth = source.offsetWidth - source.clientWidth;
			scrollBarHeight = source.offsetHeight - source.clientHeight;

			this.moveBy( borderWidths.left, borderWidths.top );
		}

		// Assuming LTR scrollbars. TODO: RTL.
		this.width -= scrollBarWidth;
		this.right -= scrollBarWidth;

		this.height -= scrollBarHeight;
		this.bottom -= scrollBarHeight;

		return this;
	}

	/**
	 * Returns an array of rects of the given native DOM Range.
	 *
	 * @param {Range} range A native DOM range.
	 * @returns {Array.<module:utils/dom/rect~Rect>} DOM Range rects.
	 */
	static getDomRangeRects( range ) {
		const rects = [];
		// Safari does not iterate over ClientRectList using for...of loop.
		const clientRects = Array.from( range.getClientRects() );

		if ( clientRects.length ) {
			for ( const rect of clientRects ) {
				rects.push( new Rect( rect ) );
			}
		}
		// If there's no client rects for the Range, use parent container's bounding rect
		// instead and adjust rect's width to simulate the actual geometry of such range.
		// https://github.com/ckeditor/ckeditor5-utils/issues/153
		else {
			const startContainerRect = new Rect( range.startContainer.getBoundingClientRect() );
			startContainerRect.right = startContainerRect.left;
			startContainerRect.width = 0;

			rects.push( startContainerRect );
		}

		return rects;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Rect;


const rectProperties = [ 'top', 'right', 'bottom', 'left', 'width', 'height' ];

// Acquires all the rect properties from the passed source.
//
// @private
// @param {module:utils/dom/rect~Rect} rect
// @param {ClientRect|module:utils/dom/rect~Rect|Object} source
function copyRectProperties( rect, source ) {
	for ( const p of rectProperties ) {
		rect[ p ] = source[ p ];
	}
}

// Checks if provided object is a <body> HTML element.
//
// @private
// @param {HTMLElement|Range} elementOrRange
// @returns {Boolean}
function isBody( elementOrRange ) {
	if ( !Object(__WEBPACK_IMPORTED_MODULE_2__lib_lodash_isElement__["a" /* default */])( elementOrRange ) ) {
		return false;
	}

	return elementOrRange === elementOrRange.ownerDocument.body;
}


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uid__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/collection
 */






/**
 * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes
 * in the collection (like in an array) or by their ids.
 *
 * If an object without an `id` property is being added to the collection, the `id` property will be generated
 * automatically. Note that the automatically generated id is unique only within this single collection instance.
 *
 * By default an item in the collection is identified by its `id` property. The name of the identifier can be
 * configured through the constructor of the collection.
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 */
class Collection {
	/**
	 * Creates a new Collection instance.
	 *
	 * @param {Object} [options={}] The options object.
	 * @param {String} [options.idProperty='id'] The name of the property which is considered to identify an item.
	 */
	constructor( options = {} ) {
		/**
		 * The internal list of items in the collection.
		 *
		 * @private
		 * @member {Object[]}
		 */
		this._items = [];

		/**
		 * The internal map of items in the collection.
		 *
		 * @private
		 * @member {Map}
		 */
		this._itemMap = new Map();

		/**
		 * The name of the property which is considered to identify an item.
		 *
		 * @private
		 * @member {String}
		 */
		this._idProperty = options.idProperty || 'id';

		/**
		 * A helper mapping external items of a bound collection ({@link #bindTo})
		 * and actual items of this collection. It provides information
		 * necessary to properly remove items bound to another collection.
		 *
		 * See {@link #_bindToInternalToExternalMap}.
		 *
		 * @protected
		 * @member {WeakMap}
		 */
		this._bindToExternalToInternalMap = new WeakMap();

		/**
		 * A helper mapping items of this collection to external items of a bound collection
		 * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.
		 * to avoid loops in twoway bindings.
		 *
		 * See {@link #_bindToExternalToInternalMap}.
		 *
		 * @protected
		 * @member {WeakMap}
		 */
		this._bindToInternalToExternalMap = new WeakMap();

		/**
		 * A collection instance this collection is bound to as a result
		 * of calling {@link #bindTo} method.
		 *
		 * @protected
		 * @member {module:utils/collection~Collection} #_bindToCollection
		 */
	}

	/**
	 * The number of items available in the collection.
	 *
	 * @member {Number} #length
	 */
	get length() {
		return this._items.length;
	}

	/**
	 * Returns the first item from the collection or null when collection is empty.
	 *
	 * @returns {Object|null} The first item or `null` if collection is empty.
	 */
	get first() {
		return this._items[ 0 ] || null;
	}

	/**
	 * Returns the last item from the collection or null when collection is empty.
	 *
	 * @returns {Object|null} The last item or `null` if collection is empty.
	 */
	get last() {
		return this._items[ this.length - 1 ] || null;
	}

	/**
	 * Adds an item into the collection.
	 *
	 * If the item does not have an id, then it will be automatically generated and set on the item.
	 *
	 * @chainable
	 * @param {Object} item
	 * @param {Number} [index] The position of the item in the collection. The item
	 * is pushed to the collection when `index` not specified.
	 * @fires add
	 */
	add( item, index ) {
		let itemId;
		const idProperty = this._idProperty;

		if ( ( idProperty in item ) ) {
			itemId = item[ idProperty ];

			if ( typeof itemId != 'string' ) {
				/**
				 * This item's id should be a string.
				 *
				 * @error collection-add-invalid-id
				 */
				throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'collection-add-invalid-id' );
			}

			if ( this.get( itemId ) ) {
				/**
				 * This item already exists in the collection.
				 *
				 * @error collection-add-item-already-exists
				 */
				throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'collection-add-item-already-exists' );
			}
		} else {
			item[ idProperty ] = itemId = Object(__WEBPACK_IMPORTED_MODULE_2__uid__["a" /* default */])();
		}

		// TODO: Use ES6 default function argument.
		if ( index === undefined ) {
			index = this._items.length;
		} else if ( index > this._items.length || index < 0 ) {
			/**
			 * The index number has invalid value.
			 *
			 * @error collection-add-item-bad-index
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'collection-add-item-invalid-index' );
		}

		this._items.splice( index, 0, item );

		this._itemMap.set( itemId, item );

		this.fire( 'add', item, index );

		return this;
	}

	/**
	 * Gets item by its id or index.
	 *
	 * @param {String|Number} idOrIndex The item id or index in the collection.
	 * @returns {Object|null} The requested item or `null` if such item does not exist.
	 */
	get( idOrIndex ) {
		let item;

		if ( typeof idOrIndex == 'string' ) {
			item = this._itemMap.get( idOrIndex );
		} else if ( typeof idOrIndex == 'number' ) {
			item = this._items[ idOrIndex ];
		} else {
			/**
			 * Index or id must be given.
			 *
			 * @error collection-get-invalid-arg
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'collection-get-invalid-arg: Index or id must be given.' );
		}

		return item || null;
	}

	/**
	 * Gets index of item in the collection.
	 * When item is not defined in the collection then index will be equal -1.
	 *
	 * @param {String|Object} idOrItem The item or its id in the collection.
	 * @returns {Number} Index of given item.
	 */
	getIndex( idOrItem ) {
		let item;

		if ( typeof idOrItem == 'string' ) {
			item = this._itemMap.get( idOrItem );
		} else {
			item = idOrItem;
		}

		return this._items.indexOf( item );
	}

	/**
	 * Removes an item from the collection.
	 *
	 * @param {Object|Number|String} subject The item to remove, its id or index in the collection.
	 * @returns {Object} The removed item.
	 * @fires remove
	 */
	remove( subject ) {
		let index, id, item;
		let itemDoesNotExist = false;
		const idProperty = this._idProperty;

		if ( typeof subject == 'string' ) {
			id = subject;
			item = this._itemMap.get( id );
			itemDoesNotExist = !item;

			if ( item ) {
				index = this._items.indexOf( item );
			}
		} else if ( typeof subject == 'number' ) {
			index = subject;
			item = this._items[ index ];
			itemDoesNotExist = !item;

			if ( item ) {
				id = item[ idProperty ];
			}
		} else {
			item = subject;
			id = item[ idProperty ];
			index = this._items.indexOf( item );
			itemDoesNotExist = ( index == -1 || !this._itemMap.get( id ) );
		}

		if ( itemDoesNotExist ) {
			/**
			 * Item not found.
			 *
			 * @error collection-remove-404
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'collection-remove-404: Item not found.' );
		}

		this._items.splice( index, 1 );
		this._itemMap.delete( id );

		const externalItem = this._bindToInternalToExternalMap.get( item );
		this._bindToInternalToExternalMap.delete( item );
		this._bindToExternalToInternalMap.delete( externalItem );

		this.fire( 'remove', item );

		return item;
	}

	/**
	 * Executes the callback for each item in the collection and composes an array or values returned by this callback.
	 *
	 * @param {Function} callback
	 * @param {Object} callback.item
	 * @param {Number} callback.index
	 * @params {Object} ctx Context in which the `callback` will be called.
	 * @returns {Array} The result of mapping.
	 */
	map( callback, ctx ) {
		return this._items.map( callback, ctx );
	}

	/**
	 * Finds the first item in the collection for which the `callback` returns a true value.
	 *
	 * @param {Function} callback
	 * @param {Object} callback.item
	 * @param {Number} callback.index
	 * @returns {Object} The item for which `callback` returned a true value.
	 * @params {Object} ctx Context in which the `callback` will be called.
	 */
	find( callback, ctx ) {
		return this._items.find( callback, ctx );
	}

	/**
	 * Returns an array with items for which the `callback` returned a true value.
	 *
	 * @param {Function} callback
	 * @param {Object} callback.item
	 * @param {Number} callback.index
	 * @params {Object} ctx Context in which the `callback` will be called.
	 * @returns {Object[]} The array with matching items.
	 */
	filter( callback, ctx ) {
		return this._items.filter( callback, ctx );
	}

	/**
	 * Removes all items from the collection and destroys the binding created using
	 * {@link #bindTo}.
	 */
	clear() {
		if ( this._bindToCollection ) {
			this.stopListening( this._bindToCollection );
			this._bindToCollection = null;
		}

		while ( this.length ) {
			this.remove( 0 );
		}
	}

	/**
	 * Binds and synchronizes the collection with another one.
	 *
	 * The binding can be a simple factory:
	 *
	 *		class FactoryClass {
	 *			constructor( data ) {
	 *				this.label = data.label;
	 *			}
	 *		}
	 *
	 *		const source = new Collection( { idProperty: 'label' } );
	 *		const target = new Collection();
	 *
	 *		target.bindTo( source ).as( FactoryClass );
	 *
	 *		source.add( { label: 'foo' } );
	 *		source.add( { label: 'bar' } );
	 *
	 *		console.log( target.length ); // 2
	 *		console.log( target.get( 1 ).label ); // 'bar'
	 *
	 *		source.remove( 0 );
	 *		console.log( target.length ); // 1
	 *		console.log( target.get( 0 ).label ); // 'bar'
	 *
	 * or the factory driven by a custom callback:
	 *
	 *		class FooClass {
	 *			constructor( data ) {
	 *				this.label = data.label;
	 *			}
	 *		}
	 *
	 *		class BarClass {
	 *			constructor( data ) {
	 *				this.label = data.label;
	 *			}
	 *		}
	 *
	 *		const source = new Collection( { idProperty: 'label' } );
	 *		const target = new Collection();
	 *
	 *		target.bindTo( source ).using( ( item ) => {
	 *			if ( item.label == 'foo' ) {
	 *				return new FooClass( item );
	 *			} else {
	 *				return new BarClass( item );
	 *			}
	 *		} );
	 *
	 *		source.add( { label: 'foo' } );
	 *		source.add( { label: 'bar' } );
	 *
	 *		console.log( target.length ); // 2
	 *		console.log( target.get( 0 ) instanceof FooClass ); // true
	 *		console.log( target.get( 1 ) instanceof BarClass ); // true
	 *
	 * or the factory out of property name:
	 *
	 *		const source = new Collection( { idProperty: 'label' } );
	 *		const target = new Collection();
	 *
	 *		target.bindTo( source ).using( 'label' );
	 *
	 *		source.add( { label: { value: 'foo' } } );
	 *		source.add( { label: { value: 'bar' } } );
	 *
	 *		console.log( target.length ); // 2
	 *		console.log( target.get( 0 ).value ); // 'foo'
	 *		console.log( target.get( 1 ).value ); // 'bar'
	 *
	 * **Note**: {@link #clear} can be used to break the binding.
	 *
	 * @param {module:utils/collection~Collection} collection A collection to be bound.
	 * @returns {Object}
	 * @returns {module:utils/collection~Collection#bindTo#as} return.as
	 * @returns {module:utils/collection~Collection#bindTo#using} return.using
	 */
	bindTo( externalCollection ) {
		if ( this._bindToCollection ) {
			/**
			 * The collection cannot be bound more than once.
			 *
			 * @error collection-bind-to-rebind
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditorerror__["b" /* default */]( 'collection-bind-to-rebind: The collection cannot be bound more than once.' );
		}

		this._bindToCollection = externalCollection;

		return {
			/**
			 * Creates the class factory binding.
			 *
			 * @static
			 * @param {Function} Class Specifies which class factory is to be initialized.
			 */
			as: Class => {
				this._setUpBindToBinding( item => new Class( item ) );
			},

			/**
			 * Creates callback or property binding.
			 *
			 * @static
			 * @param {Function|String} callbackOrProperty When the function is passed, it is used to
			 * produce the items. When the string is provided, the property value is used to create
			 * the bound collection items.
			 */
			using: callbackOrProperty => {
				if ( typeof callbackOrProperty == 'function' ) {
					this._setUpBindToBinding( item => callbackOrProperty( item ) );
				} else {
					this._setUpBindToBinding( item => item[ callbackOrProperty ] );
				}
			}
		};
	}

	/**
	 * Finalizes and activates a binding initiated by {#bindTo}.
	 *
	 * @protected
	 * @param {Function} factory A function which produces collection items.
	 */
	_setUpBindToBinding( factory ) {
		const externalCollection = this._bindToCollection;

		// Adds the item to the collection once a change has been done to the external collection.
		//
		// @private
		const addItem = ( evt, externalItem, index ) => {
			const isExternalBoundToThis = externalCollection._bindToCollection == this;
			const externalItemBound = externalCollection._bindToInternalToExternalMap.get( externalItem );

			// If an external collection is bound to this collection, which makes it a 2way binding,
			// and the particular external collection item is already bound, don't add it here.
			// The external item has been created **out of this collection's item** and (re)adding it will
			// cause a loop.
			if ( isExternalBoundToThis && externalItemBound ) {
				this._bindToExternalToInternalMap.set( externalItem, externalItemBound );
				this._bindToInternalToExternalMap.set( externalItemBound, externalItem );
			} else {
				const item = factory( externalItem );

				this._bindToExternalToInternalMap.set( externalItem, item );
				this._bindToInternalToExternalMap.set( item, externalItem );

				this.add( item, index );
			}
		};

		// Load the initial content of the collection.
		for ( const externalItem of externalCollection ) {
			addItem( null, externalItem );
		}

		// Synchronize the with collection as new items are added.
		this.listenTo( externalCollection, 'add', addItem );

		// Synchronize the with collection as new items are removed.
		this.listenTo( externalCollection, 'remove', ( evt, externalItem ) => {
			const item = this._bindToExternalToInternalMap.get( externalItem );

			if ( item ) {
				this.remove( item );
			}
		} );
	}

	/**
	 * Collection iterator.
	 */
	[ Symbol.iterator ]() {
		return this._items[ Symbol.iterator ]();
	}

	/**
	 * Fired when an item is added to the collection.
	 *
	 * @event add
	 * @param {Object} item The added item.
	 */

	/**
	 * Fired when an item is removed from the collection.
	 *
	 * @event remove
	 * @param {Object} item The removed item.
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Collection;


Object(__WEBPACK_IMPORTED_MODULE_3__mix__["a" /* default */])( Collection, __WEBPACK_IMPORTED_MODULE_0__emittermixin__["c" /* default */] );


/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__viewcollection__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_lib_lodash_cloneDeepWith__ = __webpack_require__(439);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_lib_lodash_isObject__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_dom_isdomnode__ = __webpack_require__(257);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_log__ = __webpack_require__(26);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/template
 */

/* global document */











const xhtmlNs = 'http://www.w3.org/1999/xhtml';

/**
 * A basic Template class. It renders a DOM HTML element or text from a
 * {@link module:ui/template~TemplateDefinition definition} and supports element attributes, children,
 * bindings to {@link module:utils/observablemixin~Observable observables} and DOM event propagation.
 *
 * A simple template can look like this:
 *
 *		const bind = Template.bind( observable, emitter );
 *
 *		new Template( {
 *			tag: 'p',
 *			attributes: {
 *				class: 'foo',
 *				style: {
 *					backgroundColor: 'yellow'
 *				}
 *			},
 *			on: {
 *				click: bind.to( 'clicked' )
 *			}
 *			children: [
 *				'A paragraph.'
 *			]
 *		} ).render();
 *
 * and it will render the following HTML element:
 *
 *		<p class="foo" style="background-color: yellow;">A paragraph.</p>
 *
 * Additionally, the `observable` will always fire `clicked` upon clicking `<p>` in the DOM.
 *
 * See {@link module:ui/template~TemplateDefinition} to know more about templates and complex
 * template definitions.
 *
* @mixes module:utils/emittermixin~EmitterMixin
 */
class Template {
	/**
	 * Creates an instance of the {@link ~Template} class.
	 *
	 * @param {module:ui/template~TemplateDefinition} def The definition of the template.
	 */
	constructor( def ) {
		Object.assign( this, normalize( clone( def ) ) );

		/**
		 * Indicates whether this particular Template instance has been
		 * {@link #render rendered}.
		 *
		 * @readonly
		 * @protected
		 * @member {Boolean}
		 */
		this._isRendered = false;

		/**
		 * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template
		 * renders to an HTML element.
		 *
		 * @member {String} #tag
		 */

		/**
		 * The text of the template. It also indicates that the template renders to a DOM text node.
		 *
		 * @member {Array.<String|module:ui/template~TemplateValueSchema>} #text
		 */

		/**
		 * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with
		 * the attributes of an HTML element.
		 *
		 * **Note**: This property only makes sense when {@link #tag} is defined.
		 *
		 * @member {Object} #attributes
		 */

		/**
		 * The children of the template. They can be either:
		 * * independent instances of {@link ~Template} (subtemplates),
		 * * native DOM Nodes.
		 *
		 * **Note**: This property only makes sense when {@link #tag} is defined.
		 *
		 * @member {Array.<module:ui/template~Template|Node>} #children
		 */

		/**
		 * The DOM event listeners of the template.
		 *
		 * @member {Object} #eventListeners
		 */

		/**
		 * The data used by the {@link #revert} method to restore a node to its original state.
		 *
		 * See: {@link #apply}.
		 *
		 * @readonly
		 * @protected
		 * @member {module:ui/template~RenderData}
		 */
		this._revertData = null;
	}

	/**
	 * Renders a DOM Node (an HTML element or text) out of the template.
	 *
	 *		const domNode = new Template( { ... } ).render();
	 *
	 * See: {@link #apply}.
	 *
	 * @returns {HTMLElement|Text}
	 */
	render() {
		const node = this._renderNode( {
			intoFragment: true
		} );

		this._isRendered = true;

		return node;
	}

	/**
	 * Applies the template to an existing DOM Node, either HTML element or text.
	 *
	 * **Note:** No new DOM nodes will be created. Applying extends
	 * {@link module:ui/template~TemplateDefinition attributes} and
	 * {@link module:ui/template~TemplateDefinition event listeners} only.
	 *
	 * **Note:** Existing `class` and `style` attributes are extended when a template
	 * is applied to an HTML element, while other attributes and `textContent` are overridden.
	 *
	 * **Note:** The process of applying a template can be easily reverted using the
	 * {@link module:ui/template~Template#revert} method.
	 *
	 *		const element = document.createElement( 'div' );
	 *		const bind = Template.bind( observable, emitter );
	 *
	 *		new Template( {
	 *			attrs: {
	 *				id: 'first-div',
	 *				class: bind.to( 'divClass' )
	 *			},
	 *			on: {
	 *				click: bind( 'elementClicked' ) // Will be fired by the observable.
	 *			}
	 *			children: [
	 *				'Div text.'
	 *			]
	 *		} ).apply( element );
	 *
	 *		element.outerHTML == "<div id="first-div" class="my-div">Div text.</div>"
	 *
	 * @see module:ui/template~Template#render
	 * @see module:ui/template~Template#revert
	 * @param {Node} node Root node for the template to apply.
	 */
	apply( node ) {
		this._revertData = getEmptyRevertData();

		this._renderNode( {
			node,
			isApplying: true,
			revertData: this._revertData
		} );

		return node;
	}

	/**
	 * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
	 *
	 * @param {Node} node The root node for the template to revert. In most of the cases, it is the
	 * same node used by {@link module:ui/template~Template#apply}.
	 */
	revert( node ) {
		if ( !this._revertData ) {
			/**
			 * Attempting to revert a template which has not been applied yet.
			 *
			 * @error ui-template-revert-not-applied
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'ui-template-revert-not-applied: Attempting to revert a template which has not been applied yet.' );
		}

		this._revertTemplateFromNode( node, this._revertData );
	}

	/**
	 * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
	 * instances and returns them one by one.
	 *
	 *		const viewFoo = new View();
	 *		const viewBar = new View();
	 *		const viewBaz = new View();
	 *		const template = new Template( {
	 *			tag: 'div',
	 *			children: [
	 *				viewFoo,
	 *				{
	 *					tag: 'div',
	 *					children: [
	 *						viewBar
	 *					]
	 *				},
	 *				viewBaz
	 *			]
	 *		} );
	 *
	 *		// Logs: viewFoo, viewBar, viewBaz
	 *		for ( const view of template.getViews() ) {
	 *			console.log( view );
	 *		}
	 *
	 * @returns {Iterator.<module:ui/view~View>}
	 */
	* getViews() {
		function* search( def ) {
			if ( def.children ) {
				for ( const child of def.children ) {
					if ( isView( child ) ) {
						yield child;
					} else if ( isTemplate( child ) ) {
						yield* search( child );
					}
				}
			}
		}

		yield* search( this );
	}

	/**
	 * An entry point to the interface which binds DOM nodes to
	 * {@link module:utils/observablemixin~Observable observables}.
	 * There are two types of bindings:
	 *
	 * * HTML element attributes or text `textContent` synchronized with attributes of an
	 * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
	 * and {@link module:ui/template~BindChain#if}.
	 *
	 *		const bind = Template.bind( observable, emitter );
	 *
	 *		new Template( {
	 *			attrs: {
	 *				// Binds the element "class" attribute to observable#classAttribute.
	 *				class: bind.to( 'classAttribute' )
	 *			}
	 *		} ).render();
	 *
	 * * DOM events fired on HTML element propagated through
	 * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
	 *
	 *		const bind = Template.bind( observable, emitter );
	 *
	 *		new Template( {
	 *			on: {
	 *				// Will be fired by the observable.
	 *				click: bind( 'elementClicked' )
	 *			}
	 *		} ).render();
	 *
	 * Also see {@link module:ui/view~View#bindTemplate}.
	 *
	 * @param {module:utils/observablemixin~Observable} observable An observable which provides boundable attributes.
	 * @param {module:utils/emittermixin~Emitter} emitter An emitter that listens to observable attribute
	 * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
	 * @returns {module:ui/template~BindChain}
	 */
	static bind( observable, emitter ) {
		return {
			to( eventNameOrFunctionOrAttribute, callback ) {
				return new TemplateToBinding( {
					eventNameOrFunction: eventNameOrFunctionOrAttribute,
					attribute: eventNameOrFunctionOrAttribute,
					observable, emitter, callback
				} );
			},

			if( attribute, valueIfTrue, callback ) {
				return new TemplateIfBinding( {
					observable, emitter, attribute, valueIfTrue, callback
				} );
			}
		};
	}

	/**
	 * Extends an existing {@link module:ui/template~Template} instance with some additional content
	 * from another {@link module:ui/template~TemplateDefinition}.
	 *
	 *		const bind = Template.bind( observable, emitter );
	 *
	 *		const template = new Template( {
	 *			tag: 'p',
	 *			attributes: {
	 *				class: 'a',
	 *				data-x: bind.to( 'foo' )
	 *			},
	 *			children: [
	 *				{
	 *					tag: 'span',
	 *					attributes: {
	 *						class: 'b'
	 *					},
	 *					children: [
	 *						'Span'
	 *					]
	 *				}
	 *			]
	 *		 } );
	 *
	 *		// Instance-level extension.
	 *		Template.extend( template, {
	 *			attributes: {
	 *				class: 'b',
	 *				data-x: bind.to( 'bar' )
	 *			},
	 *			children: [
	 *				{
	 *					attributes: {
	 *						class: 'c'
	 *					}
	 *				}
	 *			]
	 *		} );
	 *
	 *		// Child extension.
	 *		Template.extend( template.children[ 0 ], {
	 *			attributes: {
	 *				class: 'd'
	 *			}
	 *		} );
	 *
	 * the `outerHTML` of `template.render()` is:
	 *
	 *		<p class="a b" data-x="{ observable.foo } { observable.bar }">
	 *			<span class="b c d">Span</span>
	 *		</p>
	 *
	 * @param {module:ui/template~Template} template An existing template instance to be extended.
	 * @param {module:ui/template~TemplateDefinition} def Additional definition to be applied to a template.
	 */
	static extend( template, def ) {
		if ( template._isRendered ) {
			/**
			 * Extending a template after rendering may not work as expected. To make sure
			 * the {@link module:ui/template~Template.extend extending} works for an element,
			 * make sure it happens before {@link #render} is called.
			 *
			 * @error template-extend-render
			 */
			__WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_log__["a" /* default */].warn( 'template-extend-render: Attempting to extend a template which has already been rendered.' );
		}

		extendTemplate( template, normalize( clone( def ) ) );
	}

	/**
	 * Renders a DOM Node (either an HTML element or text) out of the template.
	 *
	 * @protected
	 * @param {module:ui/template~RenderData} data Rendering data.
	 */
	_renderNode( data ) {
		let isInvalid;

		if ( data.node ) {
			// When applying, a definition cannot have "tag" and "text" at the same time.
			isInvalid = this.tag && this.text;
		} else {
			// When rendering, a definition must have either "tag" or "text": XOR( this.tag, this.text ).
			isInvalid = this.tag ? this.text : !this.text;
		}

		if ( isInvalid ) {
			/**
			 * Node definition cannot have the "tag" and "text" properties at the same time.
			 * Node definition must have either "tag" or "text" when rendering a new Node.
			 *
			 * @error ui-template-wrong-syntax
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'ui-template-wrong-syntax: Node definition must have either "tag" or "text" when rendering a new Node.'
			);
		}

		if ( this.text ) {
			return this._renderText( data );
		} else {
			return this._renderElement( data );
		}
	}

	/**
	 * Renders an HTML element out of the template.
	 *
	 * @protected
	 * @param {module:ui/template~RenderData} data Rendering data.
	 */
	_renderElement( data ) {
		let node = data.node;

		if ( !node ) {
			node = data.node = document.createElementNS( this.ns || xhtmlNs, this.tag );
		}

		this._renderAttributes( data );
		this._renderElementChildren( data );
		this._setUpListeners( data );

		return node;
	}

	/**
	 * Renders a text node out of {@link module:ui/template~Template#text}.
	 *
	 * @protected
	 * @param {module:ui/template~RenderData} data Rendering data.
	 */
	_renderText( data ) {
		let node = data.node;

		// Save the original textContent to revert it in #revert().
		if ( node ) {
			data.revertData.text = node.textContent;
		} else {
			node = data.node = document.createTextNode( '' );
		}

		// Check if this Text Node is bound to Observable. Cases:
		//
		//		text: [ Template.bind( ... ).to( ... ) ]
		//
		//		text: [
		//			'foo',
		//			Template.bind( ... ).to( ... ),
		//			...
		//		]
		//
		if ( hasTemplateBinding( this.text ) ) {
			this._bindToObservable( {
				schema: this.text,
				updater: getTextUpdater( node ),
				data
			} );
		}
		// Simply set text. Cases:
		//
		//		text: [ 'all', 'are', 'static' ]
		//
		//		text: [ 'foo' ]
		//
		else {
			node.textContent = this.text.join( '' );
		}

		return node;
	}

	/**
	 * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
	 *
	 * @protected
	 * @param {module:ui/template~RenderData} data Rendering data.
	 */
	_renderAttributes( data ) {
		let attrName, attrValue, domAttrValue, attrNs;

		if ( !this.attributes ) {
			return;
		}

		const node = data.node;
		const revertData = data.revertData;

		for ( attrName in this.attributes ) {
			// Current attribute value in DOM.
			domAttrValue = node.getAttribute( attrName );

			// The value to be set.
			attrValue = this.attributes[ attrName ];

			// Save revert data.
			if ( revertData ) {
				revertData.attributes[ attrName ] = domAttrValue;
			}

			// Detect custom namespace:
			//
			//		class: {
			//			ns: 'abc',
			//			value: Template.bind( ... ).to( ... )
			//		}
			//
			attrNs = ( Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_lib_lodash_isObject__["a" /* default */])( attrValue[ 0 ] ) && attrValue[ 0 ].ns ) ? attrValue[ 0 ].ns : null;

			// Activate binding if one is found. Cases:
			//
			//		class: [
			//			Template.bind( ... ).to( ... )
			//		]
			//
			//		class: [
			//			'bar',
			//			Template.bind( ... ).to( ... ),
			//			'baz'
			//		]
			//
			//		class: {
			//			ns: 'abc',
			//			value: Template.bind( ... ).to( ... )
			//		}
			//
			if ( hasTemplateBinding( attrValue ) ) {
				// Normalize attributes with additional data like namespace:
				//
				//		class: {
				//			ns: 'abc',
				//			value: [ ... ]
				//		}
				//
				const valueToBind = attrNs ? attrValue[ 0 ].value : attrValue;

				// Extend the original value of attributes like "style" and "class",
				// don't override them.
				if ( revertData && shouldExtend( attrName ) ) {
					valueToBind.unshift( domAttrValue );
				}

				this._bindToObservable( {
					schema: valueToBind,
					updater: getAttributeUpdater( node, attrName, attrNs ),
					data
				} );
			}

			// Style attribute could be an Object so it needs to be parsed in a specific way.
			//
			//		style: {
			//			width: '100px',
			//			height: Template.bind( ... ).to( ... )
			//		}
			//
			else if ( attrName == 'style' && typeof attrValue[ 0 ] !== 'string' ) {
				this._renderStyleAttribute( attrValue[ 0 ], data );
			}

			// Otherwise simply set the static attribute:
			//
			//		class: [ 'foo' ]
			//
			//		class: [ 'all', 'are', 'static' ]
			//
			//		class: [
			//			{
			//				ns: 'abc',
			//				value: [ 'foo' ]
			//			}
			//		]
			//
			else {
				// Extend the original value of attributes like "style" and "class",
				// don't override them.
				if ( revertData && domAttrValue && shouldExtend( attrName ) ) {
					attrValue.unshift( domAttrValue );
				}

				attrValue = attrValue
					// Retrieve "values" from:
					//
					//		class: [
					//			{
					//				ns: 'abc',
					//				value: [ ... ]
					//			}
					//		]
					//
					.map( val => val ? ( val.value || val ) : val )
					// Flatten the array.
					.reduce( ( prev, next ) => prev.concat( next ), [] )
					// Convert into string.
					.reduce( arrayValueReducer, '' );

				if ( !isFalsy( attrValue ) ) {
					node.setAttributeNS( attrNs, attrName, attrValue );
				}
			}
		}
	}

	/**
	 * Renders the `style` attribute of an HTML element based on
	 * {@link module:ui/template~Template#attributes}.
	 *
	 * A style attribute is an {Object} with static values:
	 *
	 *		attributes: {
	 *			style: {
	 *				color: 'red'
	 *			}
	 *		}
	 *
	 * or values bound to {@link module:ui/model~Model} properties:
	 *
	 *		attributes: {
	 *			style: {
	 *				color: bind.to( ... )
	 *			}
	 *		}
	 *
	 * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
	 * needed.
	 *
	 * @private
	 * @param {Object} styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
	 * @param {module:ui/template~RenderData} data Rendering data.
	 */
	_renderStyleAttribute( styles, data ) {
		const node = data.node;

		for ( const styleName in styles ) {
			const styleValue = styles[ styleName ];

			// Cases:
			//
			//		style: {
			//			color: bind.to( 'attribute' )
			//		}
			//
			if ( hasTemplateBinding( styleValue ) ) {
				this._bindToObservable( {
					schema: [ styleValue ],
					updater: getStyleUpdater( node, styleName ),
					data
				} );
			}

			// Cases:
			//
			//		style: {
			//			color: 'red'
			//		}
			//
			else {
				node.style[ styleName ] = styleValue;
			}
		}
	}

	/**
	 * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
	 *
	 * @protected
	 * @param {module:ui/template~RenderData} data Rendering data.
	 */
	_renderElementChildren( data ) {
		const node = data.node;
		const container = data.intoFragment ? document.createDocumentFragment() : node;
		const isApplying = data.isApplying;
		let childIndex = 0;

		for ( const child of this.children ) {
			if ( isViewCollection( child ) ) {
				if ( !isApplying ) {
					child.setParent( node );

					// Note: ViewCollection renders its children.
					for ( const view of child ) {
						container.appendChild( view.element );
					}
				}
			} else if ( isView( child ) ) {
				if ( !isApplying ) {
					if ( !child.isRendered ) {
						child.render();
					}

					container.appendChild( child.element );
				}
			} else if ( Object(__WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_dom_isdomnode__["a" /* default */])( child ) ) {
				container.appendChild( child );
			} else {
				if ( isApplying ) {
					const revertData = data.revertData;
					const childRevertData = getEmptyRevertData();

					revertData.children.push( childRevertData );

					child._renderNode( {
						node: container.childNodes[ childIndex++ ],
						isApplying: true,
						revertData: childRevertData
					} );
				} else {
					container.appendChild( child.render() );
				}
			}
		}

		if ( data.intoFragment ) {
			node.appendChild( container );
		}
	}

	/**
	 * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
	 * on an HTML element.
	 *
	 * @protected
	 * @param {module:ui/template~RenderData} data Rendering data.
	 */
	_setUpListeners( data ) {
		if ( !this.eventListeners ) {
			return;
		}

		for ( const key in this.eventListeners ) {
			const revertBindings = this.eventListeners[ key ].map( schemaItem => {
				const [ domEvtName, domSelector ] = key.split( '@' );

				return schemaItem.activateDomEventListener( domEvtName, domSelector, data );
			} );

			if ( data.revertData ) {
				data.revertData.bindings.push( revertBindings );
			}
		}
	}

	/**
	 * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
	 * activates the binding and sets its initial value.
	 *
	 * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
	 * text node `textContent`.
	 *
	 * @protected
	 * @param {Object} options Binding options.
	 * @param {module:ui/template~TemplateValueSchema} options.schema
	 * @param {Function} options.updater A function which updates the DOM (like attribute or text).
	 * @param {module:ui/template~RenderData} options.data Rendering data.
	 */
	_bindToObservable( { schema, updater, data } ) {
		const revertData = data.revertData;

		// Set initial values.
		syncValueSchemaValue( schema, updater, data );

		const revertBindings = schema
			// Filter "falsy" (false, undefined, null, '') value schema components out.
			.filter( item => !isFalsy( item ) )
			// Filter inactive bindings from schema, like static strings ('foo'), numbers (42), etc.
			.filter( item => item.observable )
			// Once only the actual binding are left, let the emitter listen to observable change:attribute event.
			// TODO: Reduce the number of listeners attached as many bindings may listen
			// to the same observable attribute.
			.map( templateBinding => templateBinding.activateAttributeListener( schema, updater, data ) );

		if ( revertData ) {
			revertData.bindings.push( revertBindings );
		}
	}

	/**
	 * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
	 * return it to the original state.
	 *
	 * @protected
	 * @param {HTMLElement|Text} node A node to be reverted.
	 * @param {module:ui/template~RenderData#revertData} revertData Stores information about
	 * what changes have been made by {@link #apply} to the node.
	 */
	_revertTemplateFromNode( node, revertData ) {
		for ( const binding of revertData.bindings ) {
			// Each binding may consist of several observable+observable#attribute.
			// like the following has 2:
			//
			//		class: [
			//			'x',
			//			bind.to( 'foo' ),
			//			'y',
			//			bind.to( 'bar' )
			//		]
			//
			for ( const revertBinding of binding ) {
				revertBinding();
			}
		}

		if ( revertData.text ) {
			node.textContent = revertData.text;

			return;
		}

		for ( const attrName in revertData.attributes ) {
			const attrValue = revertData.attributes[ attrName ];

			// When the attribute has **not** been set before #apply().
			if ( attrValue === null ) {
				node.removeAttribute( attrName );
			} else {
				node.setAttribute( attrName, attrValue );
			}
		}

		for ( let i = 0; i < revertData.children.length; ++i ) {
			this._revertTemplateFromNode( node.childNodes[ i ], revertData.children[ i ] );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Template;


Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Template, __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

/**
 * Describes a binding created by the {@link module:ui/template~Template.bind} interface.
 *
 * @protected
 */
class TemplateBinding {
	/**
	 * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
	 *
	 * @param {module:ui/template~TemplateDefinition} def The definition of the binding.
	 */
	constructor( def ) {
		Object.assign( this, def );

		/**
		 * An observable instance of the binding. It either:
		 *
		 * * provides the attribute with the value,
		 * * or passes the event when a corresponding DOM event is fired.
		 *
		 * @member {module:utils/observablemixin~ObservableMixin} module:ui/template~TemplateBinding#observable
		 */

		/**
		 * An {@link module:utils/emittermixin~Emitter} used by the binding to:
		 *
		 * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},
		 * * or listen to the event in the DOM.
		 *
		 * @member {module:utils/emittermixin~EmitterMixin} module:ui/template~TemplateBinding#emitter
		 */

		/**
		 * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.
		 *
		 * @member {String} module:ui/template~TemplateBinding#attribute
		 */

		/**
		 * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.
		 *
		 * @member {Function} [module:ui/template~TemplateBinding#callback]
		 */
	}

	/**
	 * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
	 * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
	 * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
	 *
	 * @param {Node} [node] A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
	 * @returns {*} The value of {@link module:ui/template~TemplateBinding#attribute} in
	 * {@link module:ui/template~TemplateBinding#observable}.
	 */
	getValue( node ) {
		const value = this.observable[ this.attribute ];

		return this.callback ? this.callback( value, node ) : value;
	}

	/**
	 * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
	 * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
	 * value of {@link module:ui/template~TemplateValueSchema}.
	 *
	 * @param {module:ui/template~TemplateValueSchema} schema A full schema to generate an attribute or text in the DOM.
	 * @param {Function} updater A DOM updater function used to update the native DOM attribute or text.
	 * @param {module:ui/template~RenderData} data Rendering data.
	 * @returns {Function} A function to sever the listener binding.
	 */
	activateAttributeListener( schema, updater, data ) {
		const callback = () => syncValueSchemaValue( schema, updater, data );

		this.emitter.listenTo( this.observable, 'change:' + this.attribute, callback );

		// Allows revert of the listener.
		return () => {
			this.emitter.stopListening( this.observable, 'change:' + this.attribute, callback );
		};
	}
}
/* unused harmony export TemplateBinding */


/**
 * Describes either:
 *
 * * a binding to an {@link module:utils/observablemixin~Observable},
 * * or a native DOM event binding.
 *
 * It is created by the {@link module:ui/template~BindChain#to} method.
 *
 * @protected
 */
class TemplateToBinding extends TemplateBinding {
	/**
	 * Activates the listener for the native DOM event, which when fired, is propagated by
	 * the {@link module:ui/template~TemplateBinding#emitter}.
	 *
	 * @param {String} domEvtName The name of the native DOM event.
	 * @param {String} domSelector The selector in the DOM to filter delegated events.
	 * @param {module:ui/template~RenderData} data Rendering data.
	 * @returns {Function} A function to sever the listener binding.
	 */
	activateDomEventListener( domEvtName, domSelector, data ) {
		const callback = ( evt, domEvt ) => {
			if ( !domSelector || domEvt.target.matches( domSelector ) ) {
				if ( typeof this.eventNameOrFunction == 'function' ) {
					this.eventNameOrFunction( domEvt );
				} else {
					this.observable.fire( this.eventNameOrFunction, domEvt );
				}
			}
		};

		this.emitter.listenTo( data.node, domEvtName, callback );

		// Allows revert of the listener.
		return () => {
			this.emitter.stopListening( data.node, domEvtName, callback );
		};
	}
}
/* unused harmony export TemplateToBinding */


/**
 * Describes a binding to {@link module:utils/observablemixin~ObservableMixin} created by the {@link module:ui/template~BindChain#if}
 * method.
 *
 * @protected
 */
class TemplateIfBinding extends TemplateBinding {
	/**
	 * @inheritDoc
	 */
	getValue( node ) {
		const value = super.getValue( node );

		return isFalsy( value ) ? false : ( this.valueIfTrue || true );
	}

	/**
	 * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in
	 * {@link module:ui/template~TemplateBinding#observable} is `true`.
	 *
	 * @member {String} [module:ui/template~TemplateIfBinding#valueIfTrue]
	 */
}
/* unused harmony export TemplateIfBinding */


// Checks whether given {@link module:ui/template~TemplateValueSchema} contains a
// {@link module:ui/template~TemplateBinding}.
//
// @param {module:ui/template~TemplateValueSchema} schema
// @returns {Boolean}
function hasTemplateBinding( schema ) {
	if ( !schema ) {
		return false;
	}

	// Normalize attributes with additional data like namespace:
	//
	//		class: {
	//			ns: 'abc',
	//			value: [ ... ]
	//		}
	//
	if ( schema.value ) {
		schema = schema.value;
	}

	if ( Array.isArray( schema ) ) {
		return schema.some( hasTemplateBinding );
	} else if ( schema instanceof TemplateBinding ) {
		return true;
	}

	return false;
}

// Assembles the value using {@link module:ui/template~TemplateValueSchema} and stores it in a form of
// an Array. Each entry of the Array corresponds to one of {@link module:ui/template~TemplateValueSchema}
// items.
//
// @param {module:ui/template~TemplateValueSchema} schema
// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.
// @return {Array}
function getValueSchemaValue( schema, node ) {
	return schema.map( schemaItem => {
		// Process {@link module:ui/template~TemplateBinding} bindings.
		if ( schemaItem instanceof TemplateBinding ) {
			return schemaItem.getValue( node );
		}

		// All static values like strings, numbers, and "falsy" values (false, null, undefined, '', etc.) just pass.
		return schemaItem;
	} );
}

// A function executed each time the bound Observable attribute changes, which updates the DOM with a value
// constructed from {@link module:ui/template~TemplateValueSchema}.
//
// @param {module:ui/template~TemplateValueSchema} schema
// @param {Function} updater A function which updates the DOM (like attribute or text).
// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.
function syncValueSchemaValue( schema, updater, { node } ) {
	let value = getValueSchemaValue( schema, node );

	// Check if schema is a single Template.bind.if, like:
	//
	//		class: Template.bind.if( 'foo' )
	//
	if ( schema.length == 1 && schema[ 0 ] instanceof TemplateIfBinding ) {
		value = value[ 0 ];
	} else {
		value = value.reduce( arrayValueReducer, '' );
	}

	if ( isFalsy( value ) ) {
		updater.remove();
	} else {
		updater.set( value );
	}
}

// Returns an object consisting of `set` and `remove` functions, which
// can be used in the context of DOM Node to set or reset `textContent`.
// @see module:ui/view~View#_bindToObservable
//
// @param {Node} node DOM Node to be modified.
// @returns {Object}
function getTextUpdater( node ) {
	return {
		set( value ) {
			node.textContent = value;
		},

		remove() {
			node.textContent = '';
		}
	};
}

// Returns an object consisting of `set` and `remove` functions, which
// can be used in the context of DOM Node to set or reset an attribute.
// @see module:ui/view~View#_bindToObservable
//
// @param {Node} node DOM Node to be modified.
// @param {String} attrName Name of the attribute to be modified.
// @param {String} [ns=null] Namespace to use.
// @returns {Object}
function getAttributeUpdater( el, attrName, ns ) {
	return {
		set( value ) {
			el.setAttributeNS( ns, attrName, value );
		},

		remove() {
			el.removeAttributeNS( ns, attrName );
		}
	};
}

// Returns an object consisting of `set` and `remove` functions, which
// can be used in the context of CSSStyleDeclaration to set or remove a style.
// @see module:ui/view~View#_bindToObservable
//
// @param {Node} node DOM Node to be modified.
// @param {String} styleName Name of the style to be modified.
// @returns {Object}
function getStyleUpdater( el, styleName ) {
	return {
		set( value ) {
			el.style[ styleName ] = value;
		},

		remove() {
			el.style[ styleName ] = null;
		}
	};
}

// Clones definition of the template.
//
// @param {module:ui/template~TemplateDefinition} def
// @returns {module:ui/template~TemplateDefinition}
function clone( def ) {
	const clone = Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_lib_lodash_cloneDeepWith__["a" /* default */])( def, value => {
		// Don't clone the `Template.bind`* bindings because of the references to Observable
		// and DomEmitterMixin instances inside, which would also be traversed and cloned by greedy
		// cloneDeepWith algorithm. There's no point in cloning Observable/DomEmitterMixins
		// along with the definition.
		//
		// Don't clone Template instances if provided as a child. They're simply #render()ed
		// and nothing should interfere.
		//
		// Also don't clone View instances if provided as a child of the Template. The template
		// instance will be extracted from the View during the normalization and there's no need
		// to clone it.
		if ( value && ( value instanceof TemplateBinding || isTemplate( value ) || isView( value ) || isViewCollection( value ) ) ) {
			return value;
		}
	} );

	return clone;
}

// Normalizes given {@link module:ui/template~TemplateDefinition}.
//
// See:
//  * {@link normalizeAttributes}
//  * {@link normalizeListeners}
//  * {@link normalizePlainTextDefinition}
//  * {@link normalizeTextDefinition}
//
// @param {module:ui/template~TemplateDefinition} def
// @returns {module:ui/template~TemplateDefinition} Normalized definition.
function normalize( def ) {
	if ( typeof def == 'string' ) {
		def = normalizePlainTextDefinition( def );
	} else if ( def.text ) {
		normalizeTextDefinition( def );
	}

	if ( def.on ) {
		def.eventListeners = normalizeListeners( def.on );

		// Template mixes EmitterMixin, so delete #on to avoid collision.
		delete def.on;
	}

	if ( !def.text ) {
		if ( def.attributes ) {
			normalizeAttributes( def.attributes );
		}

		const children = [];

		if ( def.children ) {
			if ( isViewCollection( def.children ) ) {
				children.push( def.children );
			} else {
				for ( const child of def.children ) {
					if ( isTemplate( child ) || isView( child ) || Object(__WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_dom_isdomnode__["a" /* default */])( child ) ) {
						children.push( child );
					} else {
						children.push( new Template( child ) );
					}
				}
			}
		}

		def.children = children;
	}

	return def;
}

// Normalizes "attributes" section of {@link module:ui/template~TemplateDefinition}.
//
//		attributes: {
//			a: 'bar',
//			b: {@link module:ui/template~TemplateBinding},
//			c: {
//				value: 'bar'
//			}
//		}
//
// becomes
//
//		attributes: {
//			a: [ 'bar' ],
//			b: [ {@link module:ui/template~TemplateBinding} ],
//			c: {
//				value: [ 'bar' ]
//			}
//		}
//
// @param {Object} attrs
function normalizeAttributes( attrs ) {
	for ( const a in attrs ) {
		if ( attrs[ a ].value ) {
			attrs[ a ].value = [].concat( attrs[ a ].value );
		}

		arrayify( attrs, a );
	}
}

// Normalizes "on" section of {@link module:ui/template~TemplateDefinition}.
//
//		on: {
//			a: 'bar',
//			b: {@link module:ui/template~TemplateBinding},
//			c: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]
//		}
//
// becomes
//
//		on: {
//			a: [ 'bar' ],
//			b: [ {@link module:ui/template~TemplateBinding} ],
//			c: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]
//		}
//
// @param {Object} listeners
// @returns {Object} Object containing normalized listeners.
function normalizeListeners( listeners ) {
	for ( const l in listeners ) {
		arrayify( listeners, l );
	}

	return listeners;
}

// Normalizes "string" {@link module:ui/template~TemplateDefinition}.
//
//		"foo"
//
// becomes
//
//		{ text: [ 'foo' ] },
//
// @param {String} def
// @returns {module:ui/template~TemplateDefinition} Normalized template definition.
function normalizePlainTextDefinition( def ) {
	return {
		text: [ def ]
	};
}

// Normalizes text {@link module:ui/template~TemplateDefinition}.
//
//		children: [
//			{ text: 'def' },
//			{ text: {@link module:ui/template~TemplateBinding} }
//		]
//
// becomes
//
//		children: [
//			{ text: [ 'def' ] },
//			{ text: [ {@link module:ui/template~TemplateBinding} ] }
//		]
//
// @param {module:ui/template~TemplateDefinition} def
function normalizeTextDefinition( def ) {
	if ( !Array.isArray( def.text ) ) {
		def.text = [ def.text ];
	}
}

// Wraps an entry in Object in an Array, if not already one.
//
//		{
//			x: 'y',
//			a: [ 'b' ]
//		}
//
// becomes
//
//		{
//			x: [ 'y' ],
//			a: [ 'b' ]
//		}
//
// @param {Object} obj
// @param {String} key
function arrayify( obj, key ) {
	if ( !Array.isArray( obj[ key ] ) ) {
		obj[ key ] = [ obj[ key ] ];
	}
}

// A helper which concatenates the value avoiding unwanted
// leading white spaces.
//
// @param {String} prev
// @param {String} cur
// @returns {String}
function arrayValueReducer( prev, cur ) {
	if ( isFalsy( cur ) ) {
		return prev;
	} else if ( isFalsy( prev ) ) {
		return cur;
	} else {
		return `${ prev } ${ cur }`;
	}
}

// Extends one object defined in the following format:
//
//		{
//			key1: [Array1],
//			key2: [Array2],
//			...
//			keyN: [ArrayN]
//		}
//
// with another object of the same data format.
//
// @param {Object} obj Base object.
// @param {Object} ext Object extending base.
// @returns {String}
function extendObjectValueArray( obj, ext ) {
	for ( const a in ext ) {
		if ( obj[ a ] ) {
			obj[ a ].push( ...ext[ a ] );
		} else {
			obj[ a ] = ext[ a ];
		}
	}
}

// A helper for {@link module:ui/template~Template#extend}. Recursively extends {@link module:ui/template~Template} instance
// with content from {module:ui/template~TemplateDefinition}. See {@link module:ui/template~Template#extend} to learn more.
//
// @param {module:ui/template~Template} def A template instance to be extended.
// @param {module:ui/template~TemplateDefinition} def A definition which is to extend the template instance.
function extendTemplate( template, def ) {
	if ( def.attributes ) {
		if ( !template.attributes ) {
			template.attributes = {};
		}

		extendObjectValueArray( template.attributes, def.attributes );
	}

	if ( def.eventListeners ) {
		if ( !template.eventListeners ) {
			template.eventListeners = {};
		}

		extendObjectValueArray( template.eventListeners, def.eventListeners );
	}

	if ( def.text ) {
		template.text.push( ...def.text );
	}

	if ( def.children && def.children.length ) {
		if ( template.children.length != def.children.length ) {
			/**
			 * The number of children in extended definition does not match.
			 *
			 * @error ui-template-extend-children-mismatch
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'ui-template-extend-children-mismatch: The number of children in extended definition does not match.'
			);
		}

		let childIndex = 0;

		for ( const childDef of def.children ) {
			extendTemplate( template.children[ childIndex++ ], childDef );
		}
	}
}

// Checks if value is "falsy".
// Note: 0 (Number) is not "falsy" in this context.
//
// @private
// @param {*} value Value to be checked.
function isFalsy( value ) {
	return !value && value !== 0;
}

// Checks if the item is an instance of {@link module:ui/view~View}
//
// @private
// @param {*} value Value to be checked.
function isView( item ) {
	return item instanceof __WEBPACK_IMPORTED_MODULE_3__view__["a" /* default */];
}

// Checks if the item is an instance of {@link module:ui/template~Template}
//
// @private
// @param {*} value Value to be checked.
function isTemplate( item ) {
	return item instanceof Template;
}

// Checks if the item is an instance of {@link module:ui/viewcollection~ViewCollection}
//
// @private
// @param {*} value Value to be checked.
function isViewCollection( item ) {
	return item instanceof __WEBPACK_IMPORTED_MODULE_4__viewcollection__["a" /* default */];
}

// Creates an empty skeleton for {@link module:ui/template~Template#revert}
// data.
//
// @private
function getEmptyRevertData() {
	return {
		children: [],
		bindings: [],
		attributes: {}
	};
}

// Checks whether an attribute should be extended when
// {@link module:ui/template~Template#apply} is called.
//
// @private
// @param {String} attrName Attribute name to check.
function shouldExtend( attrName ) {
	return attrName == 'class' || attrName == 'style';
}

/**
 * A definition of the {@link module:ui/template~Template}. It describes what kind of
 * node a template will render (HTML element or text), attributes of an element, DOM event
 * listeners and children.
 *
 * Also see:
 * * {@link module:ui/template~TemplateValueSchema} to learn about HTML element attributes,
 * * {@link module:ui/template~TemplateListenerSchema} to learn about DOM event listeners.
 *
 * A sample definition on an HTML element can look like this:
 *
 *		new Template( {
 *			tag: 'p',
 *			children: [
 *				{
 *					tag: 'span',
 *					attributes: { ... },
 *					children: [ ... ],
 *				},
 *				{
 *					text: 'statictext'
 *				},
 *				'also-statictext',
 *			],
 *			attributes: {
 *				class: {@link module:ui/template~TemplateValueSchema},
 *				id: {@link module:ui/template~TemplateValueSchema},
 *				style: {@link module:ui/template~TemplateValueSchema}
 *
 *				// ...
 *			},
 *			on: {
 *				'click': {@link module:ui/template~TemplateListenerSchema}
 *
 *				// Document.querySelector format is also accepted.
 *				'keyup@a.some-class': {@link module:ui/template~TemplateListenerSchema}
 *
 *				// ...
 *			}
 *		} );
 *
 * A {@link module:ui/view~View}, another {@link module:ui/template~Template} or a native DOM node
 * can also become a child of a template. When a view is passed, its {@link module:ui/view~View#element} is used:
 *
 *		const view = new SomeView();
 *		const childTemplate = new Template( { ... } );
 *		const childNode = document.createElement( 'b' );
 *
 *		new Template( {
 *			tag: 'p',
 *
 *			children: [
 *				// view#element will be added as a child of this <p>.
 *				view,
 *
 * 				// The output of childTemplate.render() will be added here.
 *				childTemplate,
 *
 *				// Native DOM nodes are included directly in the rendered output.
 *				childNode
 *			]
 *		} );
 *
 * An entire {@link module:ui/viewcollection~ViewCollection} can be used as a child in the definition:
 *
 *		const collection = new ViewCollection();
 *		collection.add( someView );
 *
 *		new Template( {
 *			tag: 'p',
 *
 *			children: collection
 *		} );
 *
 * @typedef module:ui/template~TemplateDefinition
 * @type Object
 *
 * @property {String} tag See the template {@link module:ui/template~Template#tag} property.
 *
 * @property {Array.<module:ui/template~TemplateDefinition>} [children]
 * See the template {@link module:ui/template~Template#children} property.
 *
 * @property {Object.<String, module:ui/template~TemplateValueSchema>} [attributes]
 * See the template {@link module:ui/template~Template#attributes} property.
 *
 * @property {String|module:ui/template~TemplateValueSchema|Array.<String|module:ui/template~TemplateValueSchema>} [text]
 * See the template {@link module:ui/template~Template#text} property.
 *
 * @property {Object.<String, module:ui/template~TemplateListenerSchema>} [on]
 * See the template {@link module:ui/template~Template#eventListeners} property.
 */

/**
 * Describes a value of an HTML element attribute or `textContent`. It allows combining multiple
 * data sources like static values and {@link module:utils/observablemixin~Observable} attributes.
 *
 * Also see:
 * * {@link module:ui/template~TemplateDefinition} to learn where to use it,
 * * {@link module:ui/template~Template.bind} to learn how to configure
 * {@link module:utils/observablemixin~Observable} attribute bindings,
 * * {@link module:ui/template~Template#render} to learn how to render a template,
 * * {@link module:ui/template~BindChain#to `to()`} and {@link module:ui/template~BindChain#if `if()`}
 * methods to learn more about bindings.
 *
 * Attribute values can be described in many different ways:
 *
 *		// Bind helper will create bindings to attributes of the observable.
 *		const bind = Template.bind( observable, emitter );
 *
 *		new Template( {
 *			tag: 'p',
 *			attributes: {
 *				// A plain string schema.
 *				'class': 'static-text',
 *
 *				// An object schema, binds to the "foo" attribute of the
 *				// observable and follows its value.
 *				'class': bind.to( 'foo' ),
 *
 *				// An array schema, combines the above.
 *				'class': [
 *					'static-text',
 *					bind.to( 'bar', () => { ... } ),
 *
 * 					// Bindings can also be conditional.
 *					bind.if( 'baz', 'class-when-baz-is-true' )
 *				],
 *
 *				// An array schema, with a custom namespace, e.g. useful for creating SVGs.
 *				'class': {
 *					ns: 'http://ns.url',
 *					value: [
 *						bind.if( 'baz', 'value-when-true' ),
 *						'static-text'
 *					]
 *				},
 *
 *				// An object schema, specific for styles.
 *				style: {
 *					color: 'red',
 *					backgroundColor: bind.to( 'qux', () => { ... } )
 *				}
 *			}
 *		} );
 *
 * Text nodes can also have complex values:
 *
 *		const bind = Template.bind( observable, emitter );
 *
 *		// Will render a "foo" text node.
 *		new Template( {
 *			text: 'foo'
 *		} );
 *
 *		// Will render a "static text: {observable.foo}" text node.
 *		// The text of the node will be updated as the "foo" attribute changes.
 *		new Template( {
 *			text: [
 *				'static text: ',
 *				bind.to( 'foo', () => { ... } )
 *			]
 *		} );
 *
 * @typedef module:ui/template~TemplateValueSchema
 * @type {Object|String|Array}
 */

/**
 * Describes an event listener attached to an HTML element. Such listener can propagate DOM events
 * through an {@link module:utils/observablemixin~Observable} instance, execute custom callbacks
 * or both, if necessary.
 *
 * Also see:
 * * {@link module:ui/template~TemplateDefinition} to learn more about template definitions,
 * * {@link module:ui/template~BindChain#to `to()`} method to learn more about bindings.
 *
 * Check out different ways of attaching event listeners below:
 *
 *		// Bind helper will propagate events through the observable.
 *		const bind = Template.bind( observable, emitter );
 *
 *		new Template( {
 *			tag: 'p',
 *			on: {
 *				// An object schema. The observable will fire the "clicked" event upon DOM "click".
 *				click: bind.to( 'clicked' )
 *
 *				// An object schema. It will work for "click" event on "a.foo" children only.
 *				'click@a.foo': bind.to( 'clicked' )
 *
 *				// An array schema, makes the observable propagate multiple events.
 *				click: [
 *					bind.to( 'clicked' ),
 *					bind.to( 'executed' )
 *				],
 *
 *				// An array schema with a custom callback.
 *				'click@a.foo': {
 *					bind.to( 'clicked' ),
 *					bind.to( evt => {
 *						console.log( `${ evt.target } has been clicked!` );
 *					} }
 *				}
 *			}
 *		} );
 *
 * @typedef module:ui/template~TemplateListenerSchema
 * @type {Object|String|Array}
 */

/**
 * The return value of {@link ~Template.bind `Template.bind()`}. It provides `to()` and `if()`
 * methods to create the {@link module:utils/observablemixin~Observable observable} attribute and event bindings.
 *
 * @interface module:ui/template~BindChain
 */

/**
 * Binds an {@link module:utils/observablemixin~Observable observable} to either:
 *
 * * an HTML element attribute or a text node `textContent`, so it remains in sync with the observable
 * attribute as it changes,
 * * or an HTML element DOM event, so the DOM events are propagated through an observable.
 *
 * Some common use cases of `to()` bindings are presented below:
 *
 *		const bind = Template.bind( observable, emitter );
 *
 *		new Template( {
 *			tag: 'p',
 *			attributes: {
 *				// class="..." attribute gets bound to `observable#a`
 *				class: bind.to( 'a' )
 *			},
 *			children: [
 *				// <p>...</p> gets bound to observable#b; always `toUpperCase()`.
 *				{
 *					text: bind.to( 'b', ( value, node ) => value.toUpperCase() )
 *				}
 *			],
 *			on: {
 *				click: [
 *					// An observable will fire "clicked" upon "click" in the DOM.
 *					bind.to( 'clicked' ),
 *
 *					// A custom callback will be executed upon "click" in the DOM.
 *					bind.to( () => {
 *						...
 *					} )
 *				]
 *			}
 *		} ).render();
 *
 * Learn more about using `to()` in the {@link module:ui/template~TemplateValueSchema} and
 * {@link module:ui/template~TemplateListenerSchema}.
 *
 * @method #to
 * @param {String|Function} eventNameOrFunctionOrAttribute An attribute name of
 * {@link module:utils/observablemixin~Observable} or a DOM event name or an event callback.
 * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.
 * @return {module:ui/template~TemplateBinding}
 */

/**
 * Binds an {@link module:utils/observablemixin~Observable observable} to an HTML element attribute or a text
 * node `textContent` so it remains in sync with the observable attribute as it changes.
 *
 * Unlike {@link module:ui/template~BindChain#to}, it controls the presence of the attribute or `textContent`
 * depending on the "falseness" of an {@link module:utils/observablemixin~Observable} attribute.
 *
 *		const bind = Template.bind( observable, emitter );
 *
 *		new Template( {
 *			tag: 'input',
 *			attributes: {
 *				// <input checked> when `observable#a` is not undefined/null/false/''
 *				// <input> when `observable#a` is undefined/null/false
 *				checked: bind.if( 'a' )
 *			},
 *			children: [
 *				{
 *					// <input>"b-is-not-set"</input> when `observable#b` is undefined/null/false/''
 *					// <input></input> when `observable#b` is not "falsy"
 *					text: bind.if( 'b', 'b-is-not-set', ( value, node ) => !value )
 *				}
 *			]
 *		} ).render();
 *
 * Learn more about using `if()` in the {@link module:ui/template~TemplateValueSchema}.
 *
 * @method #if
 * @param {String} attribute An attribute name of {@link module:utils/observablemixin~Observable} used in the binding.
 * @param {String} [valueIfTrue] Value set when the {@link module:utils/observablemixin~Observable} attribute is not
 * undefined/null/false/'' (empty string).
 * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.
 * @return {module:ui/template~TemplateBinding}
 */

/**
 * The {@link module:ui/template~Template#_renderNode} configuration.
 *
 * @private
 * @interface module:ui/template~RenderData
 */

/**
 * Tells {@link module:ui/template~Template#_renderNode} to render
 * children into `DocumentFragment` first and then append the fragment
 * to the parent element. It is a speed optimization.
 *
 * @member {Boolean} #intoFragment
 */

/**
 * A node which is being rendered.
 *
 * @member {HTMLElement|Text} #node
 */

/**
 * Indicates whether the {@module:ui/template~RenderNodeOptions#node} has
 * been provided by {@module:ui/template~Template#apply}.
 *
 * @member {Boolean} #isApplying
 */

/**
 * An object storing the data that helps {@module:ui/template~Template#revert}
 * bringing back an element to its initial state, i.e. before
 * {@module:ui/template~Template#apply} was called.
 *
 * @member {Object} #revertData
 */


/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_focustracker__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__focuscycler__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_keystrokehandler__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__toolbarseparatorview__ = __webpack_require__(442);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__bindings_preventdefault_js__ = __webpack_require__(443);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_log__ = __webpack_require__(26);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/toolbar/toolbarview
 */









/**
 * The toolbar view class.
 *
 * @extends module:ui/view~View
 */
class ToolbarView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		/**
		 * Collection of the toolbar items (like buttons).
		 *
		 * @readonly
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this.items = this.createCollection();

		/**
		 * Tracks information about DOM focus in the list.
		 *
		 * @readonly
		 * @member {module:utils/focustracker~FocusTracker}
		 */
		this.focusTracker = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_focustracker__["a" /* default */]();

		/**
		 * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
		 *
		 * @readonly
		 * @member {module:utils/keystrokehandler~KeystrokeHandler}
		 */
		this.keystrokes = new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_keystrokehandler__["a" /* default */]();

		/**
		 * Helps cycling over focusable {@link #items} in the toolbar.
		 *
		 * @readonly
		 * @protected
		 * @member {module:ui/focuscycler~FocusCycler}
		 */
		this._focusCycler = new __WEBPACK_IMPORTED_MODULE_2__focuscycler__["a" /* default */]( {
			focusables: this.items,
			focusTracker: this.focusTracker,
			keystrokeHandler: this.keystrokes,
			actions: {
				// Navigate toolbar items backwards using the arrow[left,up] keys.
				focusPrevious: [ 'arrowleft', 'arrowup' ],

				// Navigate toolbar items forwards using the arrow[right,down] keys.
				focusNext: [ 'arrowright', 'arrowdown' ]
			}
		} );

		this.setTemplate( {
			tag: 'div',
			attributes: {
				class: [
					'ck-toolbar'
				]
			},

			children: this.items,

			on: {
				// https://github.com/ckeditor/ckeditor5-ui/issues/206
				mousedown: Object(__WEBPACK_IMPORTED_MODULE_5__bindings_preventdefault_js__["a" /* default */])( this )
			}
		} );
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		// Items added before rendering should be known to the #focusTracker.
		for ( const item of this.items ) {
			this.focusTracker.add( item.element );
		}

		this.items.on( 'add', ( evt, item ) => {
			this.focusTracker.add( item.element );
		} );

		this.items.on( 'remove', ( evt, item ) => {
			this.focusTracker.remove( item.element );
		} );

		// Start listening for the keystrokes coming from #element.
		this.keystrokes.listenTo( this.element );
	}

	/**
	 * Focuses the first focusable in {@link #items}.
	 */
	focus() {
		this._focusCycler.focusFirst();
	}

	/**
	 * A utility which expands a plain toolbar configuration into
	 * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.
	 *
	 * @param {Array.<String>} config The toolbar items config.
	 * @param {module:ui/componentfactory~ComponentFactory} factory A factory producing toolbar items.
	 */
	fillFromConfig( config, factory ) {
		config.map( name => {
			if ( name == '|' ) {
				this.items.add( new __WEBPACK_IMPORTED_MODULE_4__toolbarseparatorview__["a" /* default */]() );
			} else if ( factory.has( name ) ) {
				this.items.add( factory.create( name ) );
			} else {
				/**
				 * There was a problem processing the configuration of the toolbar. The item with the given
				 * name does not exist so it was omitted when rendering the toolbar.
				 *
				 * This warning usually shows up when the {@link module:core/plugin~Plugin} which is supposed
				 * to provide a toolbar item has not been loaded or there is a typo in the configuration.
				 *
				 * Make sure the plugin responsible for this toolbar item is loaded and the toolbar configuration
				 * is correct, e.g. {@link module:basic-styles/bold~Bold} is loaded for the `'bold'` toolbar item.
				 *
				 * You can use the following snippet to retrieve all available toolbar items:
				 *
				 *		Array.from( editor.ui.componentFactory.names );
				 *
				 * @error toolbarview-item-unavailable
				 * @param {String} name The name of the component.
				 */
				__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_log__["a" /* default */].warn(
					'toolbarview-item-unavailable: The requested toolbar item is unavailable.',
					{ name }
				);
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ToolbarView;




/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_dom_position__ = __webpack_require__(450);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_dom_isrange__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_isElement__ = __webpack_require__(262);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_dom_tounit__ = __webpack_require__(271);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_global__ = __webpack_require__(58);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/panel/balloon/balloonpanelview
 */








const toPx = Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_dom_tounit__["a" /* default */])( 'px' );
const defaultLimiterElement = __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].document.body;

/**
 * The balloon panel view class.
 *
 * A floating container which can
 * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#pin pin} to any
 * {@link module:utils/dom/position~Options#target target} in DOM and remain in that position
 * e.g. when the web page is scrolled.
 *
 * The balloon panel can be used to display contextual, non-blocking UI like forms, toolbars and
 * the like in its {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#content} view
 * collection.
 *
 * There is a number of {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}
 * that the balloon can use, automatically switching from one to another when the viewport space becomes
 * scarce to keep the balloon visible to the user as long as it is possible. The balloon will also
 * accept any custom position set provided by the user compatible with the
 * {@link module:utils/dom/position~Options options}.
 *
 *		const panel = new BalloonPanelView( locale );
 *		const childView = new ChildView();
 *		const positions = BalloonPanelView.defaultPositions;
 *
 *		panel.render();
 *
 *		// Add a child view to the panel's content collection.
 *		panel.content.add( childView );
 *
 *		// Start pinning the panel to an element with the "target" id DOM.
 *		// The balloon will remain pinned until unpin() is called.
 *		panel.pin( {
 *			target: document.querySelector( '#target' ),
 *			positions: [
 *				positions.northArrowSouth,
 *				positions.southArrowNorth
 *			]
 *		} );
 *
 * @extends module:ui/view~View
 */
class BalloonPanelView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		const bind = this.bindTemplate;

		/**
		 * The absolute top position of the balloon panel in pixels.
		 *
		 * @observable
		 * @default 0
		 * @member {Number} #top
		 */
		this.set( 'top', 0 );

		/**
		 * The absolute left position of the balloon panel in pixels.
		 *
		 * @observable
		 * @default 0
		 * @member {Number} #left
		 */
		this.set( 'left', 0 );

		/**
		 * Balloon panel's current position. The position name is reflected in the CSS class set
		 * to the balloon, i.e. `.ck-balloon-panel_arrow_nw` for "arrow_nw" position. The class
		 * controls the minor aspects of the balloon's visual appearance like placement
		 * of an {@link #withArrow arrow}. To support a new position, an additional CSS must be created.
		 *
		 * Default position names correspond with
		 * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
		 *
		 * See the {@link #attachTo} and {@link #pin} methods to learn about custom balloon positions.
		 *
		 * @observable
		 * @default 'arrow_nw'
		 * @member {'arrow_nw'|'arrow_ne'|'arrow_sw'|'arrow_se'} #position
		 */
		this.set( 'position', 'arrow_nw' );

		/**
		 * Controls whether the balloon panel is visible or not.
		 *
		 * @observable
		 * @default false
		 * @member {Boolean} #isVisible
		 */
		this.set( 'isVisible', false );

		/**
		 * Controls whether the balloon panel has an arrow. The presence of the arrow
		 * is reflected in `ck-balloon-panel_with-arrow` CSS class.
		 *
		 * @observable
		 * @default true
		 * @member {Boolean} #withArrow
		 */
		this.set( 'withArrow', true );

		/**
		 * An additional CSS class added to the {@link #element}.
		 *
		 * @observable
		 * @member {String} #className
		 */
		this.set( 'className' );

		/**
		 * A callback that starts pining the panel when {@link #isVisible} gets
		 * `true`. Used by {@link #pin}.
		 *
		 * @private
		 * @member {Function} #_pinWhenIsVisibleCallback
		 */

		/**
		 * Collection of the child views which creates balloon panel contents.
		 *
		 * @readonly
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this.content = this.createCollection();

		this.setTemplate( {
			tag: 'div',
			attributes: {
				class: [
					'ck-balloon-panel',
					bind.to( 'position', value => `ck-balloon-panel_${ value }` ),
					bind.if( 'isVisible', 'ck-balloon-panel_visible' ),
					bind.if( 'withArrow', 'ck-balloon-panel_with-arrow' ),
					bind.to( 'className' )
				],

				style: {
					top: bind.to( 'top', toPx ),
					left: bind.to( 'left', toPx )
				}
			},

			children: this.content
		} );
	}

	/**
	 * Shows the panel.
	 *
	 * See {@link #isVisible}.
	 */
	show() {
		this.isVisible = true;
	}

	/**
	 * Hides the panel.
	 *
	 * See {@link #isVisible}.
	 */
	hide() {
		this.isVisible = false;
	}

	/**
	 * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a
	 * smart positioning heuristics that choses from available positions to make sure the panel
	 * is visible to the user i.e. within the limits of the viewport.
	 *
	 * This method accepts configuration {@link module:utils/dom/position~Options options}
	 * to set the `target`, optional `limiter` and `positions` the balloon should chose from.
	 *
	 *		const panel = new BalloonPanelView( locale );
	 *		const positions = BalloonPanelView.defaultPositions;
	 *
	 *		panel.render();
	 *
	 *		// Attach the panel to an element with the "target" id DOM.
	 *		panel.attachTo( {
	 *			target: document.querySelector( '#target' ),
	 *			positions: [
	 *				positions.northArrowSouth,
	 *				positions.southArrowNorth
	 *			]
	 *		} );
	 *
	 * **Note**: Attaching the panel will also automatically {@link #show} it.
	 *
	 * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
	 * See the {@link #pin} method for more permanent positioning strategy.
	 *
	 * @param {module:utils/dom/position~Options} options Positioning options compatible with
	 * {@link module:utils/dom/position~getOptimalPosition}. Default `positions` array is
	 * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
	 */
	attachTo( options ) {
		this.show();

		const defaultPositions = BalloonPanelView.defaultPositions;
		const positionOptions = Object.assign( {}, {
			element: this.element,
			positions: [
				defaultPositions.southArrowNorthWest,
				defaultPositions.southArrowNorthEast,
				defaultPositions.northArrowSouthWest,
				defaultPositions.northArrowSouthEast
			],
			limiter: defaultLimiterElement,
			fitInViewport: true
		}, options );

		const { top, left, name: position } = Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_dom_position__["a" /* getOptimalPosition */])( positionOptions );

		Object.assign( this, { top, left, position } );
	}

	/**
	 * Works the same way as the {@link #attachTo} method except that the position of the panel is
	 * continuously updated when:
	 *
	 * * any ancestor of the {@link module:utils/dom/position~Options#target}
	 * or {@link module:utils/dom/position~Options#limiter} is scrolled,
	 * * the browser window gets resized or scrolled.
	 *
	 * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target},
	 * immune to the changing environment.
	 *
	 *		const panel = new BalloonPanelView( locale );
	 *		const positions = BalloonPanelView.defaultPositions;
	 *
	 *		panel.render();
	 *
	 *		// Pin the panel to an element with the "target" id DOM.
	 *		panel.pin( {
	 *			target: document.querySelector( '#target' ),
	 *			positions: [
	 *				positions.northArrowSouth,
	 *				positions.southArrowNorth
	 *			]
	 *		} );
	 *
	 * To leave the pinned state, use the {@link #unpin} method.
	 *
	 * **Note**: Pinning the panel will also automatically {@link #show} it.
	 *
	 * @param {module:utils/dom/position~Options} options Positioning options compatible with
	 * {@link module:utils/dom/position~getOptimalPosition}. Default `positions` array is
	 * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
	 */
	pin( options ) {
		this.unpin();

		this._pinWhenIsVisibleCallback = () => {
			if ( this.isVisible ) {
				this._startPinning( options );
			} else {
				this._stopPinning();
			}
		};

		this._startPinning( options );

		// Control the state of the listeners depending on whether the panel is visible
		// or not.
		// TODO: Use on() (https://github.com/ckeditor/ckeditor5-utils/issues/144).
		this.listenTo( this, 'change:isVisible', this._pinWhenIsVisibleCallback );
	}

	/**
	 * Stops pinning the panel, as set up by {@link #pin}.
	 */
	unpin() {
		if ( this._pinWhenIsVisibleCallback ) {
			// Deactivate listeners attached by pin().
			this._stopPinning();

			// Deactivate the panel pin() control logic.
			// TODO: Use off() (https://github.com/ckeditor/ckeditor5-utils/issues/144).
			this.stopListening( this, 'change:isVisible', this._pinWhenIsVisibleCallback );

			this._pinWhenIsVisibleCallback = null;

			this.hide();
		}
	}

	/**
	 * Starts managing the pinned state of the panel. See {@link #pin}.
	 *
	 * @private
	 * @param {module:utils/dom/position~Options} options Positioning options compatible with
	 * {@link module:utils/dom/position~getOptimalPosition}.
	 */
	_startPinning( options ) {
		this.attachTo( options );

		const targetElement = getDomElement( options.target );
		const limiterElement = options.limiter ? getDomElement( options.limiter ) : defaultLimiterElement;

		// Then we need to listen on scroll event of eny element in the document.
		this.listenTo( __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].document, 'scroll', ( evt, domEvt ) => {
			const scrollTarget = domEvt.target;

			// The position needs to be updated if the positioning target is within the scrolled element.
			const isWithinScrollTarget = targetElement && scrollTarget.contains( targetElement );

			// The position needs to be updated if the positioning limiter is within the scrolled element.
			const isLimiterWithinScrollTarget = limiterElement && scrollTarget.contains( limiterElement );

			// The positioning target and/or limiter can be a Rect, object etc..
			// There's no way to optimize the listener then.
			if ( isWithinScrollTarget || isLimiterWithinScrollTarget || !targetElement || !limiterElement ) {
				this.attachTo( options );
			}
		}, { useCapture: true } );

		// We need to listen on window resize event and update position.
		this.listenTo( __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].window, 'resize', () => {
			this.attachTo( options );
		} );
	}

	/**
	 * Stops managing the pinned state of the panel. See {@link #pin}.
	 *
	 * @private
	 */
	_stopPinning() {
		this.stopListening( __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].document, 'scroll' );
		this.stopListening( __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].window, 'resize' );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BalloonPanelView;


// Returns the DOM element for given object or null, if there's none,
// e.g. when passed object is a Rect instance or so.
//
// @private
// @param {*} object
// @returns {HTMLElement|null}
function getDomElement( object ) {
	if ( Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_isElement__["a" /* default */])( object ) ) {
		return object;
	}

	if ( Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_dom_isrange__["a" /* default */])( object ) ) {
		return object.commonAncestorContainer;
	}

	if ( typeof object == 'function' ) {
		return getDomElement( object() );
	}

	return null;
}

/**
 * A horizontal offset of the arrow tip from the edge of the balloon. Controlled by CSS.
 *
 *		 +-----|---------...
 *		 |     |
 *		 |     |
 *		 |     |
 *		 |     |
 *		 +--+  |  +------...
 *		     \ | /
 *		      \|/
 *	    >|-----|<---------------- horizontal offset
 *
 * @default 30
 * @member {Number} module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowHorizontalOffset
 */
BalloonPanelView.arrowHorizontalOffset = 30;

/**
 * A vertical offset of the arrow from the edge of the balloon. Controlled by CSS.
 *
 *		 +-------------...
 *		 |
 *		 |
 *		 |                      /-- vertical offset
 *		 |                     V
 *		 +--+    +-----...    ---------
 *		     \  /              |
 *		      \/               |
 *		-------------------------------
 *		                       ^
 *
 * @default 15
 * @member {Number} module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowVerticalOffset
 */
BalloonPanelView.arrowVerticalOffset = 15;

/**
 * A default set of positioning functions used by the balloon panel view
 * when attaching using {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo} method.
 *
 * The available positioning functions are as follow:
 *
 * **North**
 *
 * * `northArrowSouth`
 *
 * 		+-----------------+
 * 		|     Balloon     |
 * 		+-----------------+
 * 		         V
 * 		    [ Target ]
 *
 * * `northArrowSouthEast`
 *
 * 		+-----------------+
 * 		|     Balloon     |
 * 		+-----------------+
 * 		               V
 * 		          [ Target ]
 *
 * * `northArrowSouthWest`
 *
 * 		  +-----------------+
 * 		  |     Balloon     |
 * 		  +-----------------+
 * 		     V
 * 		[ Target ]
 *
 * **North west**
 *
 * * `northWestArrowSouth`
 *
 * 		+-----------------+
 * 		|     Balloon     |
 * 		+-----------------+
 * 		         V
 * 		         [ Target ]
 *
 * * `northWestArrowSouthWest`
 *
 * 		+-----------------+
 * 		|     Balloon     |
 * 		+-----------------+
 * 		   V
 * 		   [ Target ]
 *
 * * `northWestArrowSouthEast`
 *
 * 		+-----------------+
 * 		|     Balloon     |
 * 		+-----------------+
 * 		               V
 * 		               [ Target ]
 *
 * **North east**
 *
 * * `northEastArrowSouth`
 *
 * 		+-----------------+
 * 		|     Balloon     |
 * 		+-----------------+
 * 		         V
 * 		[ Target ]
 *
 * * `northEastArrowSouthEast`
 *
 * 		+-----------------+
 * 		|     Balloon     |
 * 		+-----------------+
 * 		               V
 * 		      [ Target ]
 *
 * * `northEastArrowSouthWest`
 *
 * 		      +-----------------+
 * 		      |     Balloon     |
 * 		      +-----------------+
 * 		         V
 * 		[ Target ]
 *
 * **South**
 *
 * * `southArrowNorth`
 *
 *		    [ Target ]
 *		         ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southArrowNorthEast`
 *
 *		          [ Target ]
 *		               ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southArrowNorthWest`
 *
 *		[ Target ]
 *		     ^
 *		   +-----------------+
 *		   |     Balloon     |
 *		   +-----------------+
 *
 * **South west**
 *
 * * `southWestArrowNorth`
 *
 *		         [ Target ]
 *		         ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southWestArrowNorthWest`
 *
 *		  [ Target ]
 *		  ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southWestArrowNorthEast`
 *
 *		               [ Target ]
 *		               ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * **South east**
 *
 * * `southEastArrowNorth`
 *
 *		[ Target ]
 *		         ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southEastArrowNorthEast`
 *
 *		       [ Target ]
 *		                ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southEastArrowNorthWest`
 *
 *		[ Target ]
 *		         ^
 *		       +-----------------+
 *		       |     Balloon     |
 *		       +-----------------+
 *
 * See {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo}.
 *
 * Positioning functions must be compatible with {@link module:utils/dom/position~Position}.
 *
 * The name that position function returns will be reflected in balloon panel's class that
 * controls the placement of the "arrow". See {@link #position} to learn more.
 *
 * @member {Object} module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions
 */
BalloonPanelView.defaultPositions = {
	// ------- North

	northArrowSouth: ( targetRect, balloonRect ) => ( {
		top: getNorthTop( targetRect, balloonRect ),
		left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
		name: 'arrow_s'
	} ),

	northArrowSouthEast: ( targetRect, balloonRect ) => ( {
		top: getNorthTop( targetRect, balloonRect ),
		left: targetRect.left + targetRect.width / 2 - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_se'
	} ),

	northArrowSouthWest: ( targetRect, balloonRect ) => ( {
		top: getNorthTop( targetRect, balloonRect ),
		left: targetRect.left + targetRect.width / 2 - BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_sw'
	} ),

	// ------- North west

	northWestArrowSouth: ( targetRect, balloonRect ) => ( {
		top: getNorthTop( targetRect, balloonRect ),
		left: targetRect.left - balloonRect.width / 2,
		name: 'arrow_s'
	} ),

	northWestArrowSouthWest: ( targetRect, balloonRect ) => ( {
		top: getNorthTop( targetRect, balloonRect ),
		left: targetRect.left - BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_sw'
	} ),

	northWestArrowSouthEast: ( targetRect, balloonRect ) => ( {
		top: getNorthTop( targetRect, balloonRect ),
		left: targetRect.left - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_se'
	} ),

	// ------- North east

	northEastArrowSouth: ( targetRect, balloonRect ) => ( {
		top: getNorthTop( targetRect, balloonRect ),
		left: targetRect.right - balloonRect.width / 2,
		name: 'arrow_s'
	} ),

	northEastArrowSouthEast: ( targetRect, balloonRect ) => ( {
		top: getNorthTop( targetRect, balloonRect ),
		left: targetRect.right - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_se'
	} ),

	northEastArrowSouthWest: ( targetRect, balloonRect ) => ( {
		top: getNorthTop( targetRect, balloonRect ),
		left: targetRect.right - BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_sw'
	} ),

	// ------- South

	southArrowNorth: ( targetRect, balloonRect ) => ( {
		top: getSouthTop( targetRect, balloonRect ),
		left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
		name: 'arrow_n'
	} ),

	southArrowNorthEast: ( targetRect, balloonRect ) => ( {
		top: getSouthTop( targetRect, balloonRect ),
		left: targetRect.left + targetRect.width / 2 - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_ne'
	} ),

	southArrowNorthWest: ( targetRect, balloonRect ) => ( {
		top: getSouthTop( targetRect, balloonRect ),
		left: targetRect.left + targetRect.width / 2 - BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_nw'
	} ),

	// ------- South west

	southWestArrowNorth: ( targetRect, balloonRect ) => ( {
		top: getSouthTop( targetRect, balloonRect ),
		left: targetRect.left - balloonRect.width / 2,
		name: 'arrow_n'
	} ),

	southWestArrowNorthWest: ( targetRect, balloonRect ) => ( {
		top: getSouthTop( targetRect, balloonRect ),
		left: targetRect.left - BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_nw'
	} ),

	southWestArrowNorthEast: ( targetRect, balloonRect ) => ( {
		top: getSouthTop( targetRect, balloonRect ),
		left: targetRect.left - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_ne'
	} ),

	// ------- South east

	southEastArrowNorth: ( targetRect, balloonRect ) => ( {
		top: getSouthTop( targetRect, balloonRect ),
		left: targetRect.right - balloonRect.width / 2,
		name: 'arrow_n'
	} ),

	southEastArrowNorthEast: ( targetRect, balloonRect ) => ( {
		top: getSouthTop( targetRect, balloonRect ),
		left: targetRect.right - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_ne'
	} ),

	southEastArrowNorthWest: ( targetRect, balloonRect ) => ( {
		top: getSouthTop( targetRect, balloonRect ),
		left: targetRect.right - BalloonPanelView.arrowHorizontalOffset,
		name: 'arrow_nw'
	} ),
};

// Returns the top coordinate for positions starting with `north*`.
//
// @private
// @param {utils/dom/rect~Rect} targetRect A rect of the target.
// @param {utils/dom/rect~Rect} elementRect A rect of the balloon.
// @returns {Number}
function getNorthTop( targetRect, balloonRect ) {
	return targetRect.top - balloonRect.height - BalloonPanelView.arrowVerticalOffset;
}

// Returns the top coordinate for positions starting with `south*`.
//
// @private
// @param {utils/dom/rect~Rect} targetRect A rect of the target.
// @param {utils/dom/rect~Rect} elementRect A rect of the balloon.
// @returns {Number}
function getSouthTop( targetRect ) {
	return targetRect.bottom + BalloonPanelView.arrowVerticalOffset;
}


/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = isWidget;
/* harmony export (immutable) */ __webpack_exports__["d"] = toWidget;
/* unused harmony export setHighlightHandling */
/* unused harmony export setLabel */
/* harmony export (immutable) */ __webpack_exports__["b"] = getLabel;
/* harmony export (immutable) */ __webpack_exports__["e"] = toWidgetEditable;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__highlightstack__ = __webpack_require__(511);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module widget/utils
 */



const widgetSymbol = Symbol( 'isWidget' );
const labelSymbol = Symbol( 'label' );

/**
 * CSS class added to each widget element.
 *
 * @const {String}
 */
const WIDGET_CLASS_NAME = 'ck-widget';
/* unused harmony export WIDGET_CLASS_NAME */


/**
 * CSS class added to currently selected widget element.
 *
 * @const {String}
 */
const WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';
/* harmony export (immutable) */ __webpack_exports__["a"] = WIDGET_SELECTED_CLASS_NAME;


/**
 * Returns `true` if given {@link module:engine/view/element~Element} is a widget.
 *
 * @param {module:engine/view/element~Element} element
 * @returns {Boolean}
 */
function isWidget( element ) {
	return !!element.getCustomProperty( widgetSymbol );
}

/**
 * Converts given {@link module:engine/view/element~Element} to widget in following way:
 * * sets `contenteditable` attribute to `"true"`,
 * * adds custom `getFillerOffset` method returning `null`,
 * * adds `ck-widget` CSS class,
 * * adds custom property allowing to recognize widget elements by using {@link ~isWidget},
 * * implements `addHighlight` and `removeHighlight` custom properties to handle view highlight on widgets.
 *
 * @param {module:engine/view/element~Element} element
 * @param {Object} [options={}]
 * @param {String|Function} [options.label] Element's label provided to {@link ~setLabel} function. It can be passed as
 * a plain string or a function returning a string.
 * @returns {module:engine/view/element~Element} Returns same element.
 */
function toWidget( element, options = {} ) {
	element.setAttribute( 'contenteditable', 'false' );
	element.getFillerOffset = getFillerOffset;
	element.addClass( WIDGET_CLASS_NAME );
	element.setCustomProperty( widgetSymbol, true );

	if ( options.label ) {
		setLabel( element, options.label );
	}

	setHighlightHandling(
		element,
		( element, descriptor ) => element.addClass( ...normalizeToArray( descriptor.class ) ),
		( element, descriptor ) => element.removeClass( ...normalizeToArray( descriptor.class ) )
	);

	return element;

	// Normalizes CSS class in descriptor that can be provided in form of an array or a string.
	function normalizeToArray( classes ) {
		return Array.isArray( classes ) ? classes : [ classes ];
	}
}

/**
 * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to
 * properly determine which highlight descriptor should be used at given time.
 *
 * @param {module:engine/view/element~Element} element
 * @param {Function} add
 * @param {Function} remove
 */
function setHighlightHandling( element, add, remove ) {
	const stack = new __WEBPACK_IMPORTED_MODULE_0__highlightstack__["a" /* default */]();

	stack.on( 'change:top', ( evt, data ) => {
		if ( data.oldDescriptor ) {
			remove( element, data.oldDescriptor );
		}

		if ( data.newDescriptor ) {
			add( element, data.newDescriptor );
		}
	} );

	element.setCustomProperty( 'addHighlight', ( element, descriptor ) => stack.add( descriptor ) );
	element.setCustomProperty( 'removeHighlight', ( element, id ) => stack.remove( id ) );
}

/**
 * Sets label for given element.
 * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by
 * {@link ~getLabel}.
 *
 * @param {module:engine/view/element~Element} element
 * @param {String|Function} labelOrCreator
 */
function setLabel( element, labelOrCreator ) {
	element.setCustomProperty( labelSymbol, labelOrCreator );
}

/**
 * Returns label for provided element.
 *
 * @param {module:engine/view/element~Element} element
 * @return {String}
 */
function getLabel( element ) {
	const labelCreator = element.getCustomProperty( labelSymbol );

	if ( !labelCreator ) {
		return '';
	}

	return typeof labelCreator == 'function' ? labelCreator() : labelCreator;
}

/**
 * Adds functionality to provided {module:engine/view/editableelement~EditableElement} to act as a widget's editable:
 * * adds `ck-editable` CSS class,
 * * sets `contenteditable` as `true` when {module:engine/view/editableelement~EditableElement#isReadOnly} is `false`
 * otherwise set `false`,
 * * adds `ck-editable_focused` CSS class when editable is focused and removes it when it's blurred.
 *
 * @param {module:engine/view/editableelement~EditableElement} editable
 * @returns {module:engine/view/editableelement~EditableElement} Returns same element that was provided in `editable` param.
 */
function toWidgetEditable( editable ) {
	editable.addClass( 'ck-editable' );

	// Set initial contenteditable value.
	editable.setAttribute( 'contenteditable', editable.isReadOnly ? 'false' : 'true' );

	// Bind contenteditable property to element#isReadOnly.
	editable.on( 'change:isReadOnly', ( evt, property, is ) => {
		editable.setAttribute( 'contenteditable', is ? 'false' : 'true' );
	} );

	editable.on( 'change:isFocused', ( evt, property, is ) => {
		if ( is ) {
			editable.addClass( 'ck-editable_focused' );
		} else {
			editable.removeClass( 'ck-editable_focused' );
		}
	} );

	return editable;
}

// Default filler offset function applied to all widget elements.
//
// @returns {null}
function getFillerOffset() {
	return null;
}


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isContainer(node) {
    switch (node._type) {
    case 'document':
    case 'block_quote':
    case 'list':
    case 'item':
    case 'paragraph':
    case 'heading':
    case 'emph':
    case 'strong':
    case 'link':
    case 'image':
    case 'custom_inline':
    case 'custom_block':
        return true;
    default:
        return false;
    }
}

var resumeAt = function(node, entering) {
    this.current = node;
    this.entering = (entering === true);
};

var next = function(){
    var cur = this.current;
    var entering = this.entering;

    if (cur === null) {
        return null;
    }

    var container = isContainer(cur);

    if (entering && container) {
        if (cur._firstChild) {
            this.current = cur._firstChild;
            this.entering = true;
        } else {
            // stay on node but exit
            this.entering = false;
        }

    } else if (cur === this.root) {
        this.current = null;

    } else if (cur._next === null) {
        this.current = cur._parent;
        this.entering = false;

    } else {
        this.current = cur._next;
        this.entering = true;
    }

    return {entering: entering, node: cur};
};

var NodeWalker = function(root) {
    return { current: root,
             root: root,
             entering: true,
             next: next,
             resumeAt: resumeAt };
};

var Node = function(nodeType, sourcepos) {
    this._type = nodeType;
    this._parent = null;
    this._firstChild = null;
    this._lastChild = null;
    this._prev = null;
    this._next = null;
    this._sourcepos = sourcepos;
    this._lastLineBlank = false;
    this._open = true;
    this._string_content = null;
    this._literal = null;
    this._listData = {};
    this._info = null;
    this._destination = null;
    this._title = null;
    this._isFenced = false;
    this._fenceChar = null;
    this._fenceLength = 0;
    this._fenceOffset = null;
    this._level = null;
    this._onEnter = null;
    this._onExit = null;
};

var proto = Node.prototype;

Object.defineProperty(proto, 'isContainer', {
    get: function () { return isContainer(this); }
});

Object.defineProperty(proto, 'type', {
    get: function() { return this._type; }
});

Object.defineProperty(proto, 'firstChild', {
    get: function() { return this._firstChild; }
});

Object.defineProperty(proto, 'lastChild', {
    get: function() { return this._lastChild; }
});

Object.defineProperty(proto, 'next', {
    get: function() { return this._next; }
});

Object.defineProperty(proto, 'prev', {
    get: function() { return this._prev; }
});

Object.defineProperty(proto, 'parent', {
    get: function() { return this._parent; }
});

Object.defineProperty(proto, 'sourcepos', {
    get: function() { return this._sourcepos; }
});

Object.defineProperty(proto, 'literal', {
    get: function() { return this._literal; },
    set: function(s) { this._literal = s; }
});

Object.defineProperty(proto, 'destination', {
    get: function() { return this._destination; },
    set: function(s) { this._destination = s; }
});

Object.defineProperty(proto, 'title', {
    get: function() { return this._title; },
    set: function(s) { this._title = s; }
});

Object.defineProperty(proto, 'info', {
    get: function() { return this._info; },
    set: function(s) { this._info = s; }
});

Object.defineProperty(proto, 'level', {
    get: function() { return this._level; },
    set: function(s) { this._level = s; }
});

Object.defineProperty(proto, 'listType', {
    get: function() { return this._listData.type; },
    set: function(t) { this._listData.type = t; }
});

Object.defineProperty(proto, 'listTight', {
    get: function() { return this._listData.tight; },
    set: function(t) { this._listData.tight = t; }
});

Object.defineProperty(proto, 'listStart', {
    get: function() { return this._listData.start; },
    set: function(n) { this._listData.start = n; }
});

Object.defineProperty(proto, 'listDelimiter', {
    get: function() { return this._listData.delimiter; },
    set: function(delim) { this._listData.delimiter = delim; }
});

Object.defineProperty(proto, 'onEnter', {
    get: function() { return this._onEnter; },
    set: function(s) { this._onEnter = s; }
});

Object.defineProperty(proto, 'onExit', {
    get: function() { return this._onExit; },
    set: function(s) { this._onExit = s; }
});

Node.prototype.appendChild = function(child) {
    child.unlink();
    child._parent = this;
    if (this._lastChild) {
        this._lastChild._next = child;
        child._prev = this._lastChild;
        this._lastChild = child;
    } else {
        this._firstChild = child;
        this._lastChild = child;
    }
};

Node.prototype.prependChild = function(child) {
    child.unlink();
    child._parent = this;
    if (this._firstChild) {
        this._firstChild._prev = child;
        child._next = this._firstChild;
        this._firstChild = child;
    } else {
        this._firstChild = child;
        this._lastChild = child;
    }
};

Node.prototype.unlink = function() {
    if (this._prev) {
        this._prev._next = this._next;
    } else if (this._parent) {
        this._parent._firstChild = this._next;
    }
    if (this._next) {
        this._next._prev = this._prev;
    } else if (this._parent) {
        this._parent._lastChild = this._prev;
    }
    this._parent = null;
    this._next = null;
    this._prev = null;
};

Node.prototype.insertAfter = function(sibling) {
    sibling.unlink();
    sibling._next = this._next;
    if (sibling._next) {
        sibling._next._prev = sibling;
    }
    sibling._prev = this;
    this._next = sibling;
    sibling._parent = this._parent;
    if (!sibling._next) {
        sibling._parent._lastChild = sibling;
    }
};

Node.prototype.insertBefore = function(sibling) {
    sibling.unlink();
    sibling._prev = this._prev;
    if (sibling._prev) {
        sibling._prev._next = sibling;
    }
    sibling._next = this;
    this._prev = sibling;
    sibling._parent = this._parent;
    if (!sibling._prev) {
        sibling._parent._firstChild = sibling;
    }
};

Node.prototype.walker = function() {
    var walker = new NodeWalker(this);
    return walker;
};

module.exports = Node;


/* Example of use of walker:

 var walker = w.walker();
 var event;

 while (event = walker.next()) {
 console.log(event.entering, event.node.type);
 }

 */


/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editor__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editingkeystrokehandler__ = __webpack_require__(417);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_controller_editingcontroller__ = __webpack_require__(418);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_isFunction__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_dom_getdatafromelement__ = __webpack_require__(434);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_setdatainelement__ = __webpack_require__(265);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module core/editor/standardeditor
 */









/**
 * Class representing a typical browser-based editor. It handles a single source element and
 * uses {@link module:engine/controller/editingcontroller~EditingController}.
 *
 * @extends module:core/editor/editor~Editor
 */
class StandardEditor extends __WEBPACK_IMPORTED_MODULE_0__editor__["a" /* default */] {
	/**
	 * Creates a new instance of the standard editor.
	 *
	 * @param {HTMLElement} element The DOM element that will be the source
	 * for the created editor.
	 * @param {Object} config The editor config.
	 */
	constructor( element, config ) {
		super( config );

		/**
		 * The element on which the editor has been initialized.
		 *
		 * @readonly
		 * @member {HTMLElement}
		 */
		this.element = element;

		// Documented in Editor.
		this.editing = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_controller_editingcontroller__["a" /* default */]( this.document );
		this.editing.view.bind( 'isReadOnly' ).to( this );

		/**
		 * Instance of the {@link module:core/editingkeystrokehandler~EditingKeystrokeHandler}.
		 *
		 * @readonly
		 * @member {module:core/editingkeystrokehandler~EditingKeystrokeHandler}
		 */
		this.keystrokes = new __WEBPACK_IMPORTED_MODULE_1__editingkeystrokehandler__["a" /* default */]( this );

		/**
		 * Editor UI instance.
		 *
		 * This property is set by more specialized editor constructors. However, it's required
		 * for plugins to work (their UI-related part will try to interact with editor UI),
		 * so every editor class which is meant to work with default plugins should set this property.
		 *
		 * @readonly
		 * @member {module:core/editor/editorui~EditorUI} #ui
		 */

		this.keystrokes.listenTo( this.editing.view );

		this._attachToForm();
	}

	/**
	 * @inheritDoc
	 */
	destroy() {
		return Promise.resolve()
			.then( () => this.keystrokes.destroy() )
			.then( () => this.editing.destroy() )
			.then( super.destroy() );
	}

	/**
	 * Sets the data in the editor's main root.
	 *
	 * @param {*} data The data to load.
	 */
	setData( data ) {
		this.data.set( data );
	}

	/**
	 * Gets the data from the editor's main root.
	 */
	getData() {
		return this.data.get();
	}

	/**
	 * Updates the {@link #element editor element}'s content with the data.
	 */
	updateEditorElement() {
		Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_setdatainelement__["a" /* default */])( this.element, this.getData() );
	}

	/**
	 * Loads the data from the {@link #element editor element} to the main root.
	 */
	loadDataFromEditorElement() {
		this.setData( Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_dom_getdatafromelement__["a" /* default */])( this.element ) );
	}

	/**
	 * Checks if editor is initialized on textarea element that belongs to a form. If yes - updates editor's element
	 * contents before submitting the form.
	 *
	 * @private
	 */
	_attachToForm() {
		const element = this.element;

		// Only when replacing a textarea which is inside of a form element.
		if ( element && element.tagName.toLowerCase() === 'textarea' && element.form ) {
			let originalSubmit;
			const form = element.form;
			const onSubmit = () => this.updateEditorElement();

			// Replace the original form#submit() to call a custom submit function first.
			// Check if #submit is a function because the form might have an input named "submit".
			if ( Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_isFunction__["a" /* default */])( form.submit ) ) {
				originalSubmit = form.submit;

				form.submit = () => {
					onSubmit();
					originalSubmit.apply( form );
				};
			}

			// Update the replaced textarea with data before each form#submit event.
			form.addEventListener( 'submit', onSubmit );

			// Remove the submit listener and revert the original submit method on
			// editor#destroy.
			this.on( 'destroy', () => {
				form.removeEventListener( 'submit', onSubmit );

				if ( originalSubmit ) {
					form.submit = originalSubmit;
				}
			} );
		}
	}

	/**
	 * Creates a standard editor instance.
	 *
	 * @param {HTMLElement} element See {@link module:core/editor/standardeditor~StandardEditor}'s param.
	 * @param {Object} config The editor config. You can find the list of config options in
	 * {@link module:core/editor/editorconfig~EditorConfig}.
	 * @returns {Promise} Promise resolved once editor is ready.
	 * @returns {module:core/editor/standardeditor~StandardEditor} return.editor The editor instance.
	 */
	static create( element, config ) {
		return new Promise( resolve => {
			const editor = new this( element, config );

			resolve(
				editor.initPlugins()
					.then( () => {
						editor.fire( 'dataReady' );
						editor.fire( 'ready' );
					} )
					.then( () => editor )
			);
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = StandardEditor;



/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  var length = args.length;
  switch (length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* harmony default export */ __webpack_exports__["a"] = (apply);


/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isFunction__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObject__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isSymbol__ = __webpack_require__(45);




/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (Object(__WEBPACK_IMPORTED_MODULE_2__isSymbol__["a" /* default */])(value)) {
    return NAN;
  }
  if (Object(__WEBPACK_IMPORTED_MODULE_1__isObject__["a" /* default */])(value)) {
    var other = Object(__WEBPACK_IMPORTED_MODULE_0__isFunction__["a" /* default */])(value.valueOf) ? value.valueOf() : value;
    value = Object(__WEBPACK_IMPORTED_MODULE_1__isObject__["a" /* default */])(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/* harmony default export */ __webpack_exports__["a"] = (toNumber);


/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseTimes__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArguments__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArray__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isLength__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isString__ = __webpack_require__(121);






/**
 * Creates an array of index keys for `object` values of arrays,
 * `arguments` objects, and strings, otherwise `null` is returned.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array|null} Returns index keys, else `null`.
 */
function indexKeys(object) {
  var length = object ? object.length : undefined;
  if (Object(__WEBPACK_IMPORTED_MODULE_3__isLength__["a" /* default */])(length) &&
      (Object(__WEBPACK_IMPORTED_MODULE_2__isArray__["a" /* default */])(object) || Object(__WEBPACK_IMPORTED_MODULE_4__isString__["a" /* default */])(object) || Object(__WEBPACK_IMPORTED_MODULE_1__isArguments__["a" /* default */])(object))) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__baseTimes__["a" /* default */])(length, String);
  }
  return null;
}

/* harmony default export */ __webpack_exports__["a"] = (indexKeys);


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseTimes);


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__view_position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__view_range__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__view_text__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/conversion/mapper
 */











/**
 * Maps elements and positions between {@link module:engine/view/document~Document view} and {@link module:engine/model/model model}.
 *
 * Mapper use bound elements to find corresponding elements and positions, so, to get proper results,
 * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.
 *
 * To map complex model to/from view relations, you may provide custom callbacks for
 * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and
 * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever
 * a position mapping request occurs.
 * Those events are fired by {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}
 * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds it's own default callbacks
 * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and
 * stop the event.
 */
class Mapper {
	/**
	 * Creates an instance of the mapper.
	 */
	constructor() {
		/**
		 * Model element to view element mapping.
		 *
		 * @private
		 * @member {WeakMap}
		 */
		this._modelToViewMapping = new WeakMap();

		/**
		 * View element to model element mapping.
		 *
		 * @private
		 * @member {WeakMap}
		 */
		this._viewToModelMapping = new WeakMap();

		/**
		 * A map containing callbacks between view element names and functions evaluating length of view elements
		 * in model.
		 *
		 * @private
		 * @member {Map}
		 */
		this._viewToModelLengthCallbacks = new Map();

		// Default mapper algorithm for mapping model position to view position.
		this.on( 'modelToViewPosition', ( evt, data ) => {
			if ( data.viewPosition ) {
				return;
			}

			const viewContainer = this._modelToViewMapping.get( data.modelPosition.parent );

			data.viewPosition = this._findPositionIn( viewContainer, data.modelPosition.offset );
		}, { priority: 'low' } );

		// Default mapper algorithm for mapping view position to model position.
		this.on( 'viewToModelPosition', ( evt, data ) => {
			if ( data.modelPosition ) {
				return;
			}

			let viewBlock = data.viewPosition.parent;
			let modelParent = this._viewToModelMapping.get( viewBlock );

			while ( !modelParent ) {
				viewBlock = viewBlock.parent;
				modelParent = this._viewToModelMapping.get( viewBlock );
			}

			const modelOffset = this._toModelOffset( data.viewPosition.parent, data.viewPosition.offset, viewBlock );

			data.modelPosition = __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createFromParentAndOffset( modelParent, modelOffset );
		}, { priority: 'low' } );
	}

	/**
	 * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
	 * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and
	 * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.
	 * The information that elements are bound is also used to translate positions.
	 *
	 * @param {module:engine/model/element~Element} modelElement Model element.
	 * @param {module:engine/view/element~Element} viewElement View element.
	 */
	bindElements( modelElement, viewElement ) {
		this._modelToViewMapping.set( modelElement, viewElement );
		this._viewToModelMapping.set( viewElement, modelElement );
	}

	/**
	 * Unbinds given {@link module:engine/view/element~Element view element} from the map.
	 *
	 * @param {module:engine/view/element~Element} viewElement View element to unbind.
	 */
	unbindViewElement( viewElement ) {
		const modelElement = this.toModelElement( viewElement );

		this._unbindElements( modelElement, viewElement );
	}

	/**
	 * Unbinds given {@link module:engine/model/element~Element model element} from the map.
	 *
	 * @param {module:engine/model/element~Element} modelElement Model element to unbind.
	 */
	unbindModelElement( modelElement ) {
		const viewElement = this.toViewElement( modelElement );

		this._unbindElements( modelElement, viewElement );
	}

	/**
	 * Removes all model to view and view to model bindings.
	 */
	clearBindings() {
		this._modelToViewMapping = new WeakMap();
		this._viewToModelMapping = new WeakMap();
	}

	/**
	 * Gets the corresponding model element.
	 *
	 * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.
	 *
	 * @param {module:engine/view/element~Element} viewElement View element.
	 * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.
	 */
	toModelElement( viewElement ) {
		return this._viewToModelMapping.get( viewElement );
	}

	/**
	 * Gets the corresponding view element.
	 *
	 * @param {module:engine/model/element~Element} modelElement Model element.
	 * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.
	 */
	toViewElement( modelElement ) {
		return this._modelToViewMapping.get( modelElement );
	}

	/**
	 * Gets the corresponding model range.
	 *
	 * @param {module:engine/view/range~Range} viewRange View range.
	 * @returns {module:engine/model/range~Range} Corresponding model range.
	 */
	toModelRange( viewRange ) {
		return new __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */]( this.toModelPosition( viewRange.start ), this.toModelPosition( viewRange.end ) );
	}

	/**
	 * Gets the corresponding view range.
	 *
	 * @param {module:engine/model/range~Range} modelRange Model range.
	 * @returns {module:engine/view/range~Range} Corresponding view range.
	 */
	toViewRange( modelRange ) {
		return new __WEBPACK_IMPORTED_MODULE_3__view_range__["a" /* default */]( this.toViewPosition( modelRange.start ), this.toViewPosition( modelRange.end ) );
	}

	/**
	 * Gets the corresponding model position.
	 *
	 * @fires viewToModelPosition
	 * @param {module:engine/view/position~Position} viewPosition View position.
	 * @returns {module:engine/model/position~Position} Corresponding model position.
	 */
	toModelPosition( viewPosition ) {
		const data = {
			viewPosition,
			mapper: this
		};

		this.fire( 'viewToModelPosition', data );

		return data.modelPosition;
	}

	/**
	 * Gets the corresponding view position.
	 *
	 * @fires modelToViewPosition
	 * @param {module:engine/model/position~Position} modelPosition Model position.
	 * @returns {module:engine/view/position~Position} Corresponding view position.
	 */
	toViewPosition( modelPosition ) {
		const data = {
			modelPosition,
			mapper: this
		};

		this.fire( 'modelToViewPosition', data );

		return data.viewPosition;
	}

	/**
	 * Registers a callback that evaluates the length in the model of a view element with given name.
	 *
	 * The callback is fired with one argument, which is a view element instance. The callback is expected to return
	 * a number representing the length of view element in model.
	 *
	 *		// List item in view may contain nested list, which have other list items. In model though,
	 *		// the lists are represented by flat structure. Because of those differences, length of list view element
	 *		// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.
	 *
	 *		function getViewListItemLength( element ) {
	 *			let length = 1;
	 *
	 *			for ( let child of element.getChildren() ) {
	 *				if ( child.name == 'ul' || child.name == 'ol' ) {
	 *					for ( let item of child.getChildren() ) {
	 *						length += getViewListItemLength( item );
	 *					}
	 *				}
	 *			}
	 *
	 *			return length;
	 *		}
	 *
	 *		mapper.registerViewToModelLength( 'li', getViewListItemLength );
	 *
	 * @param {String} viewElementName Name of view element for which callback is registered.
	 * @param {Function} lengthCallback Function return a length of view element instance in model.
	 */
	registerViewToModelLength( viewElementName, lengthCallback ) {
		this._viewToModelLengthCallbacks.set( viewElementName, lengthCallback );
	}

	/**
	 * Calculates model offset based on the view position and the block element.
	 *
	 * Example:
	 *
	 *		<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
	 *
	 * Is a sum of:
	 *
	 *		<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
	 *		<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
	 *
	 * @private
	 * @param {module:engine/view/element~Element} viewParent Position parent.
	 * @param {Number} viewOffset Position offset.
	 * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.
	 * @returns {Number} Offset in the model.
	 */
	_toModelOffset( viewParent, viewOffset, viewBlock ) {
		if ( viewBlock != viewParent ) {
			// See example.
			const offsetToParentStart = this._toModelOffset( viewParent.parent, viewParent.index, viewBlock );
			const offsetInParent = this._toModelOffset( viewParent, viewOffset, viewParent );

			return offsetToParentStart + offsetInParent;
		}

		// viewBlock == viewParent, so we need to calculate the offset in the parent element.

		// If the position is a text it is simple ("ba|r" -> 2).
		if ( viewParent.is( 'text' ) ) {
			return viewOffset;
		}

		// If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).
		let modelOffset = 0;

		for ( let i = 0; i < viewOffset; i++ ) {
			modelOffset += this.getModelLength( viewParent.getChild( i ) );
		}

		return modelOffset;
	}

	/**
	 * Removes binding between given elements.
	 *
	 * @private
	 * @param {module:engine/model/element~Element} modelElement Model element to unbind.
	 * @param {module:engine/view/element~Element} viewElement View element to unbind.
	 */
	_unbindElements( modelElement, viewElement ) {
		this._viewToModelMapping.delete( viewElement );
		this._modelToViewMapping.delete( modelElement );
	}

	/**
	 * Gets the length of the view element in the model.
	 *
	 * The length is calculated as follows:
	 * * if {@link #registerViewToModelLength length mapping callback} is provided for given `viewNode` it is used to
	 * evaluate model length (`viewNode` is used as first and only parameter passed to the callback),
	 * * length of a {@link module:engine/view/text~Text text node} is equal to the length of it's
	 * {@link module:engine/view/text~Text#data data},
	 * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,
	 * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,
	 * * length of a not-mapped {@link module:engine/view/element~Element element} is equal to the length of it's children.
	 *
	 * Examples:
	 *
	 *		foo                          -> 3 // Text length is equal to it's data length.
	 *		<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.
	 *		<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.
	 *		<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.
	 *
	 * @param {module:engine/view/element~Element} viewNode View node.
	 * @returns {Number} Length of the node in the tree model.
	 */
	getModelLength( viewNode ) {
		if ( this._viewToModelLengthCallbacks.get( viewNode.name ) ) {
			const callback = this._viewToModelLengthCallbacks.get( viewNode.name );

			return callback( viewNode );
		} else if ( this._viewToModelMapping.has( viewNode ) ) {
			return 1;
		} else if ( viewNode.is( 'text' ) ) {
			return viewNode.data.length;
		} else if ( viewNode.is( 'uiElement' ) ) {
			return 0;
		} else {
			let len = 0;

			for ( const child of viewNode.getChildren() ) {
				len += this.getModelLength( child );
			}

			return len;
		}
	}

	/**
	 * Finds the position in the view node (or its children) with the expected model offset.
	 *
	 * Example:
	 *
	 *		<p>fo<b>bar</b>bom</p> -> expected offset: 4
	 *
	 *		_findPositionIn( p, 4 ):
	 *		<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0
	 *		<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2
	 *		<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far
	 *
	 *		_findPositionIn( b, 4 - ( 5 - 3 ) ):
	 *		<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0
	 *		<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far
	 *
	 *		_findPositionIn( bar, 2 - ( 3 - 3 ) ):
	 *		We are in the text node so we can simple find the offset.
	 *		<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found
	 *
	 * @private
	 * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.
	 * @param {Number} expectedOffset Expected offset.
	 * @returns {module:engine/view/position~Position} Found position.
	 */
	_findPositionIn( viewParent, expectedOffset ) {
		// Last scanned view node.
		let viewNode;
		// Length of the last scanned view node.
		let lastLength = 0;

		let modelOffset = 0;
		let viewOffset = 0;

		// In the text node it is simple: offset in the model equals offset in the text.
		if ( viewParent.is( 'text' ) ) {
			return new __WEBPACK_IMPORTED_MODULE_2__view_position__["a" /* default */]( viewParent, expectedOffset );
		}

		// In other cases we add lengths of child nodes to find the proper offset.

		// If it is smaller we add the length.
		while ( modelOffset < expectedOffset ) {
			viewNode = viewParent.getChild( viewOffset );
			lastLength = this.getModelLength( viewNode );
			modelOffset += lastLength;
			viewOffset++;
		}

		// If it equals we found the position.
		if ( modelOffset == expectedOffset ) {
			return this._moveViewPositionToTextNode( new __WEBPACK_IMPORTED_MODULE_2__view_position__["a" /* default */]( viewParent, viewOffset ) );
		}
		// If it is higher we need to enter last child.
		else {
			// ( modelOffset - lastLength ) is the offset to the child we enter,
			// so we subtract it from the expected offset to fine the offset in the child.
			return this._findPositionIn( viewNode, expectedOffset - ( modelOffset - lastLength ) );
		}
	}

	/**
	 * Because we prefer positions in text nodes over positions next to text node moves view position to the text node
	 * if it was next to it.
	 *
	 *		<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
	 *		<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
	 *		<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
	 *
	 * @private
	 * @param {module:engine/view/position~Position} viewPosition Position potentially next to text node.
	 * @returns {module:engine/view/position~Position} Position in text node if possible.
	 */
	_moveViewPositionToTextNode( viewPosition ) {
		// If the position is just after text node, put it at the end of that text node.
		// If the position is just before text node, put it at the beginning of that text node.
		const nodeBefore = viewPosition.nodeBefore;
		const nodeAfter = viewPosition.nodeAfter;

		if ( nodeBefore instanceof __WEBPACK_IMPORTED_MODULE_4__view_text__["a" /* default */] ) {
			return new __WEBPACK_IMPORTED_MODULE_2__view_position__["a" /* default */]( nodeBefore, nodeBefore.data.length );
		} else if ( nodeAfter instanceof __WEBPACK_IMPORTED_MODULE_4__view_text__["a" /* default */] ) {
			return new __WEBPACK_IMPORTED_MODULE_2__view_position__["a" /* default */]( nodeAfter, 0 );
		}

		// Otherwise, just return the given position.
		return viewPosition;
	}

	/**
	 * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position
	 * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to
	 * calculate {@link module:engine/view/position~Position view position}. Calculated view position should be added as `viewPosition`
	 * value in `data` object that is passed as one of parameters to the event callback.
	 *
	 * 		// Assume that "captionedImage" model element is converted to <img> and following <span> elements in view,
	 * 		// and the model element is bound to <img> element. Force mapping model positions inside "captionedImage" to that
	 * 		// <span> element.
	 *		mapper.on( 'modelToViewPosition', ( evt, data ) => {
	 *			const positionParent = modelPosition.parent;
	 *
	 *			if ( positionParent.name == 'captionedImage' ) {
	 *				const viewImg = data.mapper.toViewElement( positionParent );
	 *				const viewCaption = viewImg.nextSibling; // The <span> element.
	 *
	 *				data.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );
	 *
	 *				// Stop the event if other callbacks should not modify calculated value.
	 *				evt.stop();
	 *			}
	 *		} );
	 *
	 * **Note:** keep in mind that custom callback provided for this event should use provided `data.modelPosition` only to check
	 * what is before the position (or position's parent). This is important when model-to-view position mapping is used in
	 * remove change conversion. Model after the removed position (that is being mapped) does not correspond to view, so it cannot be used:
	 *
	 *		// Incorrect:
	 *		const modelElement = data.modelPosition.nodeAfter;
	 *		const viewElement = data.mapper.toViewElement( modelElement );
	 *		// ... Do something with `viewElement` and set `data.viewPosition`.
	 *
	 *		// Correct:
	 *		const prevModelElement = data.modelPosition.nodeBefore;
	 *		const prevViewElement = data.mapper.toViewElement( prevModelElement );
	 *		// ... Use `prevViewElement` to find correct `data.viewPosition`.
	 *
	 * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to
	 * attach a custom callback after default callback and also use `data.viewPosition` calculated by default callback
	 * (for example to fix it).
	 *
	 * **Note:** default mapping callback will not fire if `data.viewPosition` is already set.
	 *
	 * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position
	 * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,
	 * the condition that checks if special case scenario happened should be as simple as possible.
	 *
	 * @event modelToViewPosition
	 * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add
	 * `viewPosition` value to that object with calculated {@link module:engine/view/position~Position view position}.
	 * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.
	 */

	/**
	 * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.
	 *
	 * 		// See example in `modelToViewPosition` event description.
	 * 		// This custom mapping will map positions from <span> element next to <img> to the "captionedImage" element.
	 *		mapper.on( 'viewToModelPosition', ( evt, data ) => {
	 *			const positionParent = viewPosition.parent;
	 *
	 *			if ( positionParent.hasClass( 'image-caption' ) ) {
	 *				const viewImg = positionParent.previousSibling;
	 *				const modelImg = data.mapper.toModelElement( viewImg );
	 *
	 *				data.modelPosition = new ModelPosition( modelImg, viewPosition.offset );
	 *				evt.stop();
	 *			}
	 *		} );
	 *
	 * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to
	 * attach a custom callback after default callback and also use `data.modelPosition` calculated by default callback
	 * (for example to fix it).
	 *
	 * **Note:** default mapping callback will not fire if `data.modelPosition` is already set.
	 *
	 * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position
	 * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,
	 * the condition that checks if special case scenario happened should be as simple as possible.
	 *
	 * @event viewToModelPosition
	 * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add
	 * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.
	 * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Mapper;


Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Mapper, __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = objectToMap;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/objecttomap
 */

/**
 * Transforms object to map.
 *
 *		const map = objectToMap( { 'foo': 1, 'bar': 2 } );
 *		map.get( 'foo' ); // 1
 *
 * @param {Object} obj Object to transform.
 * @returns {Map} Map created from object.
 */
function objectToMap( obj ) {
	const map = new Map();

	for ( const key in obj ) {
		map.set( key, obj[ key ] );
	}

	return map;
}


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Stack__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayEach__ = __webpack_require__(333);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__assignValue__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__baseAssign__ = __webpack_require__(334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__cloneBuffer__ = __webpack_require__(336);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__copyArray__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__copySymbols__ = __webpack_require__(337);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__getAllKeys__ = __webpack_require__(338);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__getTag__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__initCloneArray__ = __webpack_require__(343);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__initCloneByTag__ = __webpack_require__(344);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__initCloneObject__ = __webpack_require__(353);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__isArray__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__isBuffer__ = __webpack_require__(355);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__isHostObject__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__isObject__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__keys__ = __webpack_require__(69);


















/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!Object(__WEBPACK_IMPORTED_MODULE_15__isObject__["a" /* default */])(value)) {
    return value;
  }
  var isArr = Object(__WEBPACK_IMPORTED_MODULE_12__isArray__["a" /* default */])(value);
  if (isArr) {
    result = Object(__WEBPACK_IMPORTED_MODULE_9__initCloneArray__["a" /* default */])(value);
    if (!isDeep) {
      return Object(__WEBPACK_IMPORTED_MODULE_5__copyArray__["a" /* default */])(value, result);
    }
  } else {
    var tag = Object(__WEBPACK_IMPORTED_MODULE_8__getTag__["a" /* default */])(value),
        isFunc = tag == funcTag || tag == genTag;

    if (Object(__WEBPACK_IMPORTED_MODULE_13__isBuffer__["a" /* default */])(value)) {
      return Object(__WEBPACK_IMPORTED_MODULE_4__cloneBuffer__["a" /* default */])(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (Object(__WEBPACK_IMPORTED_MODULE_14__isHostObject__["a" /* default */])(value)) {
        return object ? value : {};
      }
      result = Object(__WEBPACK_IMPORTED_MODULE_11__initCloneObject__["a" /* default */])(isFunc ? {} : value);
      if (!isDeep) {
        return Object(__WEBPACK_IMPORTED_MODULE_6__copySymbols__["a" /* default */])(value, Object(__WEBPACK_IMPORTED_MODULE_3__baseAssign__["a" /* default */])(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = Object(__WEBPACK_IMPORTED_MODULE_10__initCloneByTag__["a" /* default */])(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new __WEBPACK_IMPORTED_MODULE_0__Stack__["a" /* default */]);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? Object(__WEBPACK_IMPORTED_MODULE_7__getAllKeys__["a" /* default */])(value) : Object(__WEBPACK_IMPORTED_MODULE_16__keys__["a" /* default */])(value);
  }
  // Recursively populate clone (susceptible to call stack limits).
  Object(__WEBPACK_IMPORTED_MODULE_1__arrayEach__["a" /* default */])(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    Object(__WEBPACK_IMPORTED_MODULE_2__assignValue__["a" /* default */])(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseClone);


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/* harmony default export */ __webpack_exports__["a"] = (toSource);


/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root__ = __webpack_require__(33);



/* Built-in method references that are verified to be native. */
var Map = Object(__WEBPACK_IMPORTED_MODULE_0__getNative__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__root__["a" /* default */], 'Map');

/* harmony default export */ __webpack_exports__["a"] = (Map);


/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getPrototype__ = __webpack_require__(117);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
  // that are composed entirely of index properties, return `false` for
  // `hasOwnProperty` checks of them.
  return hasOwnProperty.call(object, key) ||
    (typeof object == 'object' && key in object && Object(__WEBPACK_IMPORTED_MODULE_0__getPrototype__["a" /* default */])(object) === null);
}

/* harmony default export */ __webpack_exports__["a"] = (baseHas);


/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (copyArray);


/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Built-in value references. */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
function getSymbols(object) {
  // Coerce `object` to an object to avoid non-object errors in V8.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
  return getOwnPropertySymbols(Object(object));
}

// Fallback for IE < 11.
if (!getOwnPropertySymbols) {
  getSymbols = function() {
    return [];
  };
}

/* harmony default export */ __webpack_exports__["a"] = (getSymbols);


/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root__ = __webpack_require__(33);



/* Built-in method references that are verified to be native. */
var Set = Object(__WEBPACK_IMPORTED_MODULE_0__getNative__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__root__["a" /* default */], 'Set');

/* harmony default export */ __webpack_exports__["a"] = (Set);


/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root__ = __webpack_require__(33);


/** Built-in value references. */
var Uint8Array = __WEBPACK_IMPORTED_MODULE_0__root__["a" /* default */].Uint8Array;

/* harmony default export */ __webpack_exports__["a"] = (Uint8Array);


/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayReduce);


/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/matcher
 */

/**
 * View matcher class.
 * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.
 */
class Matcher {
	/**
	 * Creates new instance of Matcher.
	 *
	 * @param {String|RegExp|Object} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for
	 * more information.
	 */
	constructor( ...pattern ) {
		this._patterns = [];

		this.add( ...pattern );
	}

	/**
	 * Adds pattern or patterns to matcher instance.
	 *
	 * Example patterns matching element's name:
	 *
	 *		// String.
	 *		matcher.add( 'div' );
	 *		matcher.add( { name: 'div' } );
	 *
	 *		// Regular expression.
	 *		matcher.add( /^\w/ );
	 *		matcher.add( { name: /^\w/ } );
	 *
	 * Example pattern matching element's attributes:
	 *
	 *		matcher.add( {
	 *			attribute: {
	 *				title: 'foobar',
	 *				foo: /^\w+/
	 *			}
	 *		} );
	 *
	 * Example patterns matching element's classes:
	 *
	 *		// Single class.
	 *		matcher.add( {
	 *			class: 'foobar'
	 *		} );
	 *
	 *		// Single class using regular expression.
	 *		matcher.add( {
	 *			class: /foo.../
	 *		} );
	 *
	 *		// Multiple classes to match.
	 *		matcher.add( {
	 *			class: [ 'baz', 'bar', /foo.../ ]
	 *		} ):
	 *
	 * Example pattern matching element's styles:
	 *
	 *		matcher.add( {
	 *			style: {
	 *				position: 'absolute',
	 *				color: /^\w*blue$/
	 *			}
	 *		} );
	 *
	 * Example function pattern:
	 *
	 *		matcher.add( ( element ) => {
	 *			// Result of this function will be included in `match`
	 *			// property of the object returned from matcher.match() call.
	 *			if ( element.name === 'div' && element.childCount > 0 ) {
	 *				return { name: true };
	 *			}
	 *
	 *			return null;
	 *		} );
	 *
	 * Multiple patterns can be added in one call:
	 *
	 * 		matcher.add( 'div', { class: 'foobar' } );
	 *
	 * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression
	 * is provided it will be used to match element's name. Pattern can be also provided in a form
	 * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.
	 * Function's return value will be stored under `match` key of the object returned from
	 * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
	 * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.
	 * @param {Object} [pattern.attribute] Object with key-value pairs representing attributes to match. Each object key
	 * represents attribute name. Value under that key can be either a string or a regular expression and it will be
	 * used to match attribute value.
	 * @param {String|RegExp|Array} [pattern.class] Class name or array of class names to match. Each name can be
	 * provided in a form of string or regular expression.
	 * @param {Object} [pattern.style] Object with key-value pairs representing styles to match. Each object key
	 * represents style name. Value under that key can be either a string or a regular expression and it will be used
	 * to match style value.
	 */
	add( ...pattern ) {
		for ( let item of pattern ) {
			// String or RegExp pattern is used as element's name.
			if ( typeof item == 'string' || item instanceof RegExp ) {
				item = { name: item };
			}

			// Single class name/RegExp can be provided.
			if ( item.class && ( typeof item.class == 'string' || item.class instanceof RegExp ) ) {
				item.class = [ item.class ];
			}

			this._patterns.push( item );
		}
	}

	/**
	 * Matches elements for currently stored patterns. Returns match information about first found
	 * {@link module:engine/view/element~Element element}, otherwise returns `null`.
	 *
	 * Example of returned object:
	 *
	 *		{
	 *			element: <instance of found element>,
	 *			pattern: <pattern used to match found element>,
	 *			match: {
	 *				name: true,
	 *				attribute: [ 'title', 'href' ],
	 *				class: [ 'foo' ],
	 *				style: [ 'color', 'position' ]
	 *			}
	 *		}
	 *
	 * @see module:engine/view/matcher~Matcher#add
	 * @see module:engine/view/matcher~Matcher#matchAll
	 * @param {...module:engine/view/element~Element} element View element to match against stored patterns.
	 * @returns {Object|null} result
	 * @returns {module:engine/view/element~Element} result.element Matched view element.
	 * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.
	 * @returns {Object} result.match Object representing matched element parts.
	 * @returns {Boolean} [result.match.name] True if name of the element was matched.
	 * @returns {Array} [result.match.attribute] Array with matched attribute names.
	 * @returns {Array} [result.match.class] Array with matched class names.
	 * @returns {Array} [result.match.style] Array with matched style names.
	 */
	match( ...element ) {
		for ( const singleElement of element ) {
			for ( const pattern of this._patterns ) {
				const match = isElementMatching( singleElement, pattern );

				if ( match ) {
					return {
						element: singleElement,
						pattern,
						match
					};
				}
			}
		}

		return null;
	}

	/**
	 * Matches elements for currently stored patterns. Returns array of match information with all found
	 * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.
	 *
	 * @see module:engine/view/matcher~Matcher#add
	 * @see module:engine/view/matcher~Matcher#match
	 * @param {...module:engine/view/element~Element} element View element to match against stored patterns.
	 * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information
	 * see {@link module:engine/view/matcher~Matcher#match match method} description.
	 */
	matchAll( ...element ) {
		const results = [];

		for ( const singleElement of element ) {
			for ( const pattern of this._patterns ) {
				const match = isElementMatching( singleElement, pattern );

				if ( match ) {
					results.push( {
						element: singleElement,
						pattern,
						match
					} );
				}
			}
		}

		return results.length > 0 ? results : null;
	}

	/**
	 * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
	 * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
	 *
	 * @returns {String|null} Element name trying to match.
	 */
	getElementName() {
		if ( this._patterns.length !== 1 ) {
			return null;
		}

		const pattern = this._patterns[ 0 ];
		const name = pattern.name;

		return ( typeof pattern != 'function' && name && !( name instanceof RegExp ) ) ? name : null;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Matcher;


// Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.
// If element cannot be matched to provided pattern - returns `null`.
//
// @param {module:engine/view/element~Element} element
// @param {Object|String|RegExp|Function} pattern
// @returns {Object|null} Returns object with match information or null if element is not matching.
function isElementMatching( element, pattern ) {
	// If pattern is provided as function - return result of that function;
	if ( typeof pattern == 'function' ) {
		return pattern( element );
	}

	const match = {};
	// Check element's name.
	if ( pattern.name ) {
		match.name = matchName( pattern.name, element.name );

		if ( !match.name ) {
			return null;
		}
	}

	// Check element's attributes.
	if ( pattern.attribute ) {
		match.attribute = matchAttributes( pattern.attribute, element );

		if ( !match.attribute ) {
			return null;
		}
	}

	// Check element's classes.
	if ( pattern.class ) {
		match.class = matchClasses( pattern.class, element );

		if ( !match.class ) {
			return false;
		}
	}

	// Check element's styles.
	if ( pattern.style ) {
		match.style = matchStyles( pattern.style, element );

		if ( !match.style ) {
			return false;
		}
	}

	return match;
}

// Checks if name can be matched by provided pattern.
//
// @param {String|RegExp} pattern
// @param {String} name
// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.
function matchName( pattern, name ) {
	// If pattern is provided as RegExp - test against this regexp.
	if ( pattern instanceof RegExp ) {
		return pattern.test( name );
	}

	return pattern === name;
}

// Checks if attributes of provided element can be matched against provided patterns.
//
// @param {Object} patterns Object with information about attributes to match. Each key of the object will be
// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.
// @param {module:engine/view/element~Element} element Element which attributes will be tested.
// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.
function matchAttributes( patterns, element ) {
	const match = [];

	for ( const name in patterns ) {
		const pattern = patterns[ name ];

		if ( element.hasAttribute( name ) ) {
			const attribute = element.getAttribute( name );

			if ( pattern instanceof RegExp ) {
				if ( pattern.test( attribute ) ) {
					match.push( name );
				} else {
					return null;
				}
			} else if ( attribute === pattern ) {
				match.push( name );
			} else {
				return null;
			}
		} else {
			return null;
		}
	}

	return match;
}

// Checks if classes of provided element can be matched against provided patterns.
//
// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.
// @param {module:engine/view/element~Element} element Element which classes will be tested.
// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.
function matchClasses( patterns, element ) {
	const match = [];

	for ( const pattern of patterns ) {
		if ( pattern instanceof RegExp ) {
			const classes = element.getClassNames();

			for ( const name of classes ) {
				if ( pattern.test( name ) ) {
					match.push( name );
				}
			}

			if ( match.length === 0 ) {
				return null;
			}
		} else if ( element.hasClass( pattern ) ) {
			match.push( pattern );
		} else {
			return null;
		}
	}

	return match;
}

// Checks if styles of provided element can be matched against provided patterns.
//
// @param {Object} patterns Object with information about styles to match. Each key of the object will be
// used as style name. Value of each key can be a string or regular expression to match against style value.
// @param {module:engine/view/element~Element} element Element which styles will be tested.
// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.
function matchStyles( patterns, element ) {
	const match = [];

	for ( const name in patterns ) {
		const pattern = patterns[ name ];

		if ( element.hasStyle( name ) ) {
			const style = element.getStyle( name );

			if ( pattern instanceof RegExp ) {
				if ( pattern.test( style ) ) {
					match.push( name );
				} else {
					return null;
				}
			} else if ( style === pattern ) {
				match.push( name );
			} else {
				return null;
			}
		} else {
			return null;
		}
	}

	return match;
}


/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__modelconsumable__ = __webpack_require__(358);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_documentfragment__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_lib_lodash_extend__ = __webpack_require__(44);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/conversion/modelconversiondispatcher
 */









/**
 * `ModelConversionDispatcher` is a central point of {@link module:engine/model/model model} conversion, which is
 * a process of reacting to changes in the model and reflecting them by listeners that listen to those changes.
 * In default application, {@link module:engine/model/model model} is converted to {@link module:engine/view/view view}. This means
 * that changes in the model are reflected by changing the view (i.e. adding view nodes or changing attributes on view elements).
 *
 * During conversion process, `ModelConversionDispatcher` fires data-manipulation events, basing on state of the model and prepares
 * data for those events. It is important to note that the events are connected with "change actions" like "inserting"
 * or "removing" so one might say that we are converting "changes". This is in contrary to view to model conversion,
 * where we convert view nodes (the structure, not "changes" to the view). Note, that because changes are converted
 * and not the structure itself, there is a need to have a mapping between model and the structure on which changes are
 * reflected. To map elements during model to view conversion use {@link module:engine/conversion/mapper~Mapper}.
 *
 * The main use for this class is to listen to {@link module:engine/model/document~Document#event:change Document change event}, process it
 * and then fire specific events telling what exactly has changed. For those events, `ModelConversionDispatcher`
 * creates {@link module:engine/conversion/modelconsumable~ModelConsumable list of consumable values} that should be handled by event
 * callbacks. Those events are listened to by model-to-view converters which convert changes done in the
 * {@link module:engine/model/model model} to changes in the {@link module:engine/view/view view}. `ModelConversionController` also checks
 * the current state of consumables, so it won't fire events for parts of model that were already consumed. This is
 * especially important in callbacks that consume multiple values. See {@link module:engine/conversion/modelconsumable~ModelConsumable}
 * for an example of such callback.
 *
 * Although the primary usage for this class is the model-to-view conversion, `ModelConversionDispatcher` can be used
 * to build custom data processing pipelines that converts model to anything that is needed. Existing model structure can
 * be used to generate events (listening to {@link module:engine/model/document~Document#event:change Document change event} is not
 * required)
 * and custom callbacks can be added to the events (these does not have to be limited to changes in the view).
 *
 * When providing your own event listeners for `ModelConversionDispatcher` keep in mind that any callback that had
 * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} a value from consumable (and did some changes, i.e. to
 * the view) should also stop the event. This is because whenever a callback is fired it is assumed that there is something
 * to be consumed. Thanks to that approach, you do not have to test whether there is anything to consume at the beginning
 * of your listener callback.
 *
 * Example of providing a converter for `ModelConversionDispatcher`:
 *
 *		// We will convert inserting "paragraph" model element into the model.
 *		modelDispatcher.on( 'insert:paragraph', ( evt, data, consumable, conversionApi ) => {
 *			// Remember to consume the part of consumable.
 *			consumable.consume( data.item, 'insert' );
 *
 *			// Translate position in model to position in the view.
 *			const viewPosition = conversionApi.mapper.toViewPosition( data.range.start );
 *
 *			// Create a P element (note that this converter is for inserting P elements -> 'insert:paragraph').
 *			const viewElement = new ViewElement( 'p' );
 *
 *			// Bind the newly created view element to model element so positions will map accordingly in future.
 *			conversionApi.mapper.bindElements( data.item, viewElement );
 *
 *			// Add the newly created view element to the view.
 *			viewWriter.insert( viewPosition, viewElement );
 *
 *			// Remember to stop the event propagation if the data.item was consumed.
 *			evt.stop();
 *		} );
 *
 * Callback that "overrides" other callback:
 *
 *		// Special converter for `linkHref` attribute added on custom `quote` element. Note, that this
 *		// attribute may be the same as the attribute added by other features (link feature in this case).
 *		// It might be even added by that feature! It makes sense that a part of content that is a quote is linked
 *		// to an external source so it makes sense that link feature works on the custom quote element.
 *		// However, we have to make sure that the attributes added by link feature are correctly converted.
 *		// To block default `linkHref` conversion we have to:
 *		// 1) add this callback with higher priority than link feature callback,
 *		// 2) consume `linkHref` attribute add change.
 *		modelConversionDispatcher.on( 'addAttribute:linkHref:quote', ( evt, data, consumable, conversionApi ) => {
 *			consumable.consume( data.item, 'addAttribute:linkHref' );
 *
 *			// Create a button that will represent the `linkHref` attribute.
 *			let viewSourceBtn = new ViewElement( 'a', {
 *				href: data.item.getAttribute( 'linkHref' ),
 *				title: 'source'
 *			} );
 *
 *			// Add a class for the button.
 *			viewSourceBtn.addClass( 'source' );
 *
 *			// Insert the button using writer API.
 *			// If `addAttribute` event is fired by
 *			// `module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#convertInsert` it is fired
 *			// after `data.item` insert conversion was done. If the event is fired due to attribute insertion coming from
 *			// different source, `data.item` already existed. This means we are safe to get `viewQuote` from mapper.
 *			const viewQuote = conversionApi.mapper.toViewElement( data.item );
 *			const position = new ViewPosition( viewQuote, viewQuote.childCount );
 *			viewWriter.insert( position, viewSourceBtn );
 *
 *			evt.stop();
 *		}, { priority: 'high' } );
 */
class ModelConversionDispatcher {
	/**
	 * Creates a `ModelConversionDispatcher` that operates using passed API.
	 *
	 * @param {module:engine/model/document~Document} modelDocument Model document instance bound with this dispatcher.
	 * @param {Object} [conversionApi] Interface passed by dispatcher to the events callbacks.
	 */
	constructor( modelDocument, conversionApi = {} ) {
		/**
		 * Model document instance bound with this dispatcher.
		 *
		 * @private
		 * @member {module:engine/model/document~Document}
		 */
		this._modelDocument = modelDocument;

		/**
		 * Interface passed by dispatcher to the events callbacks.
		 *
		 * @member {Object}
		 */
		this.conversionApi = Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_lib_lodash_extend__["a" /* default */])( { dispatcher: this }, conversionApi );
	}

	/**
	 * Prepares data and fires a proper event.
	 *
	 * The method is crafted to take use of parameters passed in {@link module:engine/model/document~Document#event:change Document change
	 * event}.
	 *
	 * @see module:engine/model/document~Document#event:change
	 * @fires insert
	 * @fires remove
	 * @fires addAttribute
	 * @fires removeAttribute
	 * @fires changeAttribute
	 * @fires addMarker
	 * @param {String} type Change type.
	 * @param {Object} data Additional information about the change.
	 */
	convertChange( type, data ) {
		// Do not convert changes if they happen in graveyard.
		// Graveyard is a special root that has no view / no other representation and changes done in it should not be converted.
		if ( type !== 'remove' && data.range && data.range.root.rootName == '$graveyard' ) {
			return;
		}

		if ( type == 'remove' && data.sourcePosition.root.rootName == '$graveyard' ) {
			return;
		}

		if ( type == 'rename' && data.element.root.rootName == '$graveyard' ) {
			return;
		}

		// We can safely dispatch changes.
		if ( type == 'insert' || type == 'reinsert' ) {
			this.convertInsertion( data.range );
		} else if ( type == 'move' ) {
			this.convertMove( data.sourcePosition, data.range );
		} else if ( type == 'remove' ) {
			this.convertRemove( data.sourcePosition, data.range );
		} else if ( type == 'addAttribute' || type == 'removeAttribute' || type == 'changeAttribute' ) {
			this.convertAttribute( type, data.range, data.key, data.oldValue, data.newValue );
		} else if ( type == 'rename' ) {
			this.convertRename( data.element, data.oldName );
		}
	}

	/**
	 * Starts conversion of insertion-change on given `range`.
	 *
	 * Analyzes given range and fires insertion-connected events with data based on that range.
	 *
	 * **Note**: This method will fire separate events for node insertion and attributes insertion. All
	 * attributes that are set on inserted nodes are treated like they were added just after node insertion.
	 *
	 * @fires insert
	 * @fires addAttribute
	 * @fires addMarker
	 * @param {module:engine/model/range~Range} range Inserted range.
	 */
	convertInsertion( range ) {
		// Create a list of things that can be consumed, consisting of nodes and their attributes.
		const consumable = this._createInsertConsumable( range );

		// Fire a separate insert event for each node and text fragment contained in the range.
		for ( const value of range ) {
			const item = value.item;
			const itemRange = __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */].createFromPositionAndShift( value.previousPosition, value.length );
			const data = {
				item,
				range: itemRange
			};

			this._testAndFire( 'insert', data, consumable );

			// Fire a separate addAttribute event for each attribute that was set on inserted items.
			// This is important because most attributes converters will listen only to add/change/removeAttribute events.
			// If we would not add this part, attributes on inserted nodes would not be converted.
			for ( const key of item.getAttributeKeys() ) {
				data.attributeKey = key;
				data.attributeOldValue = null;
				data.attributeNewValue = item.getAttribute( key );

				this._testAndFire( `addAttribute:${ key }`, data, consumable );
			}
		}

		for ( const marker of this._modelDocument.markers ) {
			const markerRange = marker.getRange();
			const intersection = markerRange.getIntersection( range );

			// Check if inserted content is inserted into a marker.
			if ( intersection && shouldMarkerChangeBeConverted( range.start, marker, this.conversionApi.mapper ) ) {
				this.convertMarker( 'addMarker', marker.name, intersection );
			}
		}
	}

	/**
	 * Starts conversion of move-change of given `range`, that was moved from given `sourcePosition`.
	 *
	 * Fires {@link ~#event:remove remove event} and {@link ~#event:insert insert event} based on passed parameters.
	 *
	 * @fires remove
	 * @fires insert
	 * @param {module:engine/model/position~Position} sourcePosition The original position from which the range was moved.
	 * @param {module:engine/model/range~Range} range The range containing the moved content.
	 */
	convertMove( sourcePosition, range ) {
		// Move left  convert insertion first (#847).
		if ( range.start.isBefore( sourcePosition ) ) {
			this.convertInsertion( range );

			const sourcePositionAfterInsertion =
				sourcePosition._getTransformedByInsertion( range.start, range.end.offset - range.start.offset );

			this.convertRemove( sourcePositionAfterInsertion, range );
		} else {
			this.convertRemove( sourcePosition, range );
			this.convertInsertion( range );
		}
	}

	/**
	 * Starts conversion of remove-change of given `range`, that was removed from given `sourcePosition`.
	 *
	 * Fires {@link ~#event:remove remove event} with data based on passed values.
	 *
	 * @fires remove
	 * @param {module:engine/model/position~Position} sourcePosition Position from where the range has been removed.
	 * @param {module:engine/model/range~Range} range Removed range (after remove, in
	 * {@link module:engine/model/document~Document#graveyard graveyard root}).
	 */
	convertRemove( sourcePosition, range ) {
		const consumable = this._createConsumableForRange( range, 'remove' );

		for ( const item of range.getItems( { shallow: true } ) ) {
			const data = {
				sourcePosition,
				item
			};

			this._testAndFire( 'remove', data, consumable );
		}
	}

	/**
	 * Starts conversion of attribute-change on given `range`.
	 *
	 * Analyzes given attribute change and fires attributes-connected events with data based on passed values.
	 *
	 * @fires addAttribute
	 * @fires removeAttribute
	 * @fires changeAttribute
	 * @param {String} type Change type. Possible values: `addAttribute`, `removeAttribute`, `changeAttribute`.
	 * @param {module:engine/model/range~Range} range Changed range.
	 * @param {String} key Attribute key.
	 * @param {*} oldValue Attribute value before the change or `null` if attribute has not been set.
	 * @param {*} newValue New attribute value or `null` if attribute has been removed.
	 */
	convertAttribute( type, range, key, oldValue, newValue ) {
		if ( oldValue == newValue ) {
			// Do not convert if the attribute did not change.
			return;
		}

		// Create a list with attributes to consume.
		const consumable = this._createConsumableForRange( range, type + ':' + key );

		// Create a separate attribute event for each node in the range.
		for ( const value of range ) {
			const item = value.item;
			const itemRange = __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */].createFromPositionAndShift( value.previousPosition, value.length );
			const data = {
				item,
				range: itemRange,
				attributeKey: key,
				attributeOldValue: oldValue,
				attributeNewValue: newValue
			};

			this._testAndFire( `${ type }:${ key }`, data, consumable );
		}
	}

	/**
	 * Starts conversion of rename-change of given `element` that had given `oldName`.
	 *
	 * Fires {@link ~#event:remove remove event} and {@link ~#event:insert insert event} based on passed values.
	 *
	 * @fires remove
	 * @fires insert
	 * @param {module:engine/model/element~Element} element Renamed element.
	 * @param {String} oldName Name of the renamed element before it was renamed.
	 */
	convertRename( element, oldName ) {
		if ( element.name == oldName ) {
			// Do not convert if the name did not change.
			return;
		}

		// Create fake element that will be used to fire remove event. The fake element will have the old element name.
		const fakeElement = element.clone( true );
		fakeElement.name = oldName;

		// Bind fake element with original view element so the view element will be removed.
		this.conversionApi.mapper.bindElements(
			fakeElement,
			this.conversionApi.mapper.toViewElement( element )
		);

		// Create fake document fragment so a range can be created on fake element.
		const fakeDocumentFragment = new __WEBPACK_IMPORTED_MODULE_3__model_documentfragment__["a" /* default */]();
		fakeDocumentFragment.appendChildren( fakeElement );

		this.convertRemove( __WEBPACK_IMPORTED_MODULE_2__model_position__["a" /* default */].createBefore( element ), __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */].createOn( fakeElement ) );
		this.convertInsertion( __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */].createOn( element ) );
	}

	/**
	 * Starts selection conversion.
	 *
	 * Fires events for given {@link module:engine/model/selection~Selection selection} to start selection conversion.
	 *
	 * @fires selection
	 * @fires selectionAttribute
	 * @param {module:engine/model/selection~Selection} selection Selection to convert.
	 */
	convertSelection( selection ) {
		const markers = Array.from( this._modelDocument.markers.getMarkersAtPosition( selection.getFirstPosition() ) );
		const consumable = this._createSelectionConsumable( selection, markers );

		this.fire( 'selection', { selection }, consumable, this.conversionApi );

		for ( const marker of markers ) {
			const markerRange = marker.getRange();

			if ( !shouldMarkerChangeBeConverted( selection.getFirstPosition(), marker, this.conversionApi.mapper ) ) {
				continue;
			}

			const data = {
				selection,
				markerName: marker.name,
				markerRange
			};

			if ( consumable.test( selection, 'selectionMarker:' + marker.name ) ) {
				this.fire( 'selectionMarker:' + marker.name, data, consumable, this.conversionApi );
			}
		}

		for ( const key of selection.getAttributeKeys() ) {
			const data = {
				selection,
				key,
				value: selection.getAttribute( key )
			};

			// Do not fire event if the attribute has been consumed.
			if ( consumable.test( selection, 'selectionAttribute:' + data.key ) ) {
				this.fire( 'selectionAttribute:' + data.key, data, consumable, this.conversionApi );
			}
		}
	}

	/**
	 * Starts marker conversion.
	 *
	 * Fires {@link ~#event:addMarker addMarker} or {@link ~#event:removeMarker removeMarker} events for each item
	 * in marker's range. If range is collapsed single event is dispatched. See events description for more details.
	 *
	 * @fires addMarker
	 * @fires removeMarker
	 * @param {'addMarker'|'removeMarker'} type Change type.
	 * @param {String} name Marker name.
	 * @param {module:engine/model/range~Range} range Marker range.
	 */
	convertMarker( type, name, range ) {
		// Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).
		if ( !range.root.document || range.root.rootName == '$graveyard' ) {
			return;
		}

		// In markers case, event name == consumable name.
		const eventName = type + ':' + name;

		// When range is collapsed - fire single event with collapsed range in consumable.
		if ( range.isCollapsed ) {
			const consumable = new __WEBPACK_IMPORTED_MODULE_0__modelconsumable__["a" /* default */]();
			consumable.add( range, eventName );

			this.fire( eventName, {
				markerName: name,
				markerRange: range
			}, consumable, this.conversionApi );

			return;
		}

		// Create consumable for each item in range.
		const consumable = this._createConsumableForRange( range, eventName );

		// Create separate event for each node in the range.
		for ( const value of range ) {
			const item = value.item;

			// Do not fire event for already consumed items.
			if ( !consumable.test( item, eventName ) ) {
				continue;
			}

			const data = {
				item,
				range: __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */].createFromPositionAndShift( value.previousPosition, value.length ),
				markerName: name,
				markerRange: range
			};

			this.fire( eventName, data, consumable, this.conversionApi );
		}
	}

	/**
	 * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from given range, assuming that
	 * given range has just been inserted to the model.
	 *
	 * @private
	 * @param {module:engine/model/range~Range} range Inserted range.
	 * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.
	 */
	_createInsertConsumable( range ) {
		const consumable = new __WEBPACK_IMPORTED_MODULE_0__modelconsumable__["a" /* default */]();

		for ( const value of range ) {
			const item = value.item;

			consumable.add( item, 'insert' );

			for ( const key of item.getAttributeKeys() ) {
				consumable.add( item, 'addAttribute:' + key );
			}
		}

		return consumable;
	}

	/**
	 * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values of given `type`
	 * for each item from given `range`.
	 *
	 * @private
	 * @param {module:engine/model/range~Range} range Affected range.
	 * @param {String} type Consumable type.
	 * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.
	 */
	_createConsumableForRange( range, type ) {
		const consumable = new __WEBPACK_IMPORTED_MODULE_0__modelconsumable__["a" /* default */]();

		for ( const item of range.getItems() ) {
			consumable.add( item, type );
		}

		return consumable;
	}

	/**
	 * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.
	 *
	 * @private
	 * @param {module:engine/model/selection~Selection} selection Selection to create consumable from.
	 * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers which contains selection.
	 * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.
	 */
	_createSelectionConsumable( selection, markers ) {
		const consumable = new __WEBPACK_IMPORTED_MODULE_0__modelconsumable__["a" /* default */]();

		consumable.add( selection, 'selection' );

		for ( const marker of markers ) {
			consumable.add( selection, 'selectionMarker:' + marker.name );
		}

		for ( const key of selection.getAttributeKeys() ) {
			consumable.add( selection, 'selectionAttribute:' + key );
		}

		return consumable;
	}

	/**
	 * Tests passed `consumable` to check whether given event can be fired and if so, fires it.
	 *
	 * @private
	 * @fires insert
	 * @fires remove
	 * @fires addAttribute
	 * @fires removeAttribute
	 * @fires changeAttribute
	 * @param {String} type Event type.
	 * @param {Object} data Event data.
	 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
	 */
	_testAndFire( type, data, consumable ) {
		if ( !consumable.test( data.item, type ) ) {
			// Do not fire event if the item was consumed.
			return;
		}

		const name = data.item.name || '$text';

		this.fire( type + ':' + name, data, consumable, this.conversionApi );
	}

	/**
	 * Fired for inserted nodes.
	 *
	 * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:
	 * `insert:<name>`. `name` is either `'$text'` when one or more characters has been inserted or
	 * {@link module:engine/model/element~Element#name name} of inserted element.
	 *
	 * This way listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).
	 *
	 * @event insert
	 * @param {Object} data Additional information about the change.
	 * @param {module:engine/model/item~Item} data.item Inserted item.
	 * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.
	 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
	 * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
	 */

	/**
	 * Fired for removed nodes.
	 *
	 * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:
	 * `remove:<name>`. `name` is either `'$text'` when one or more characters has been removed or the
	 * {@link module:engine/model/element~Element#name name} of removed element.
	 *
	 * This way listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).
	 *
	 * @event remove
	 * @param {Object} data Additional information about the change.
	 * @param {module:engine/model/position~Position} data.sourcePosition Position from where the range has been removed.
	 * @param {module:engine/model/range~Range} data.range Removed range (in {@link module:engine/model/document~Document#graveyard
	 * graveyard root}).
	 * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
	 */

	/**
	 * Fired when attribute has been added on a node.
	 *
	 * `addAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
	 * `addAttribute:<attributeKey>:<name>`. `attributeKey` is the key of added attribute. `name` is either `'$text'`
	 * if attribute was added on one or more characters, or the {@link module:engine/model/element~Element#name name} of
	 * the element on which attribute was added.
	 *
	 * This way listeners can either listen to a general `addAttribute:bold` event or specific event
	 * (for example `addAttribute:link:image`).
	 *
	 * @event addAttribute
	 * @param {Object} data Additional information about the change.
	 * @param {module:engine/model/item~Item} data.item Changed item.
	 * @param {module:engine/model/range~Range} data.range Range spanning over changed item.
	 * @param {String} data.attributeKey Attribute key.
	 * @param {null} data.attributeOldValue Attribute value before the change - always `null`. Kept for the sake of unifying events.
	 * @param {*} data.attributeNewValue New attribute value.
	 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
	 * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
	 */

	/**
	 * Fired when attribute has been removed from a node.
	 *
	 * `removeAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
	 * `removeAttribute:<attributeKey>:<name>`. `attributeKey` is the key of removed attribute. `name` is either `'$text'`
	 * if attribute was removed from one or more characters, or the {@link module:engine/model/element~Element#name name} of
	 * the element from which attribute was removed.
	 *
	 * This way listeners can either listen to a general `removeAttribute:bold` event or specific event
	 * (for example `removeAttribute:link:image`).
	 *
	 * @event removeAttribute
	 * @param {Object} data Additional information about the change.
	 * @param {module:engine/model/item~Item} data.item Changed item.
	 * @param {module:engine/model/range~Range} data.range Range spanning over changed item.
	 * @param {String} data.attributeKey Attribute key.
	 * @param {*} data.attributeOldValue Attribute value before it was removed.
	 * @param {null} data.attributeNewValue New attribute value - always `null`. Kept for the sake of unifying events.
	 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
	 * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
	 */

	/**
	 * Fired when attribute of a node has been changed.
	 *
	 * `changeAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
	 * `changeAttribute:<attributeKey>:<name>`. `attributeKey` is the key of changed attribute. `name` is either `'$text'`
	 * if attribute was changed on one or more characters, or the {@link module:engine/model/element~Element#name name} of
	 * the element on which attribute was changed.
	 *
	 * This way listeners can either listen to a general `changeAttribute:link` event or specific event
	 * (for example `changeAttribute:link:image`).
	 *
	 * @event changeAttribute
	 * @param {Object} data Additional information about the change.
	 * @param {module:engine/model/item~Item} data.item Changed item.
	 * @param {module:engine/model/range~Range} data.range Range spanning over changed item.
	 * @param {String} data.attributeKey Attribute key.
	 * @param {*} data.attributeOldValue Attribute value before the change.
	 * @param {*} data.attributeNewValue New attribute value.
	 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
	 * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
	 */

	/**
	 * Fired for {@link module:engine/model/selection~Selection selection} changes.
	 *
	 * @event selection
	 * @param {module:engine/model/selection~Selection} selection `Selection` instance that is converted.
	 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
	 * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
	 */

	/**
	 * Fired for {@link module:engine/model/selection~Selection selection} attributes changes.
	 *
	 * `selectionAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
	 * `selectionAttribute:<attributeKey>`. `attributeKey` is the key of selection attribute. This way listen can listen to
	 * certain attribute, i.e. `addAttribute:bold`.
	 *
	 * @event selectionAttribute
	 * @param {Object} data Additional information about the change.
	 * @param {module:engine/model/selection~Selection} data.selection Selection that is converted.
	 * @param {String} data.attributeKey Key of changed attribute.
	 * @param {*} data.attributeValue Value of changed attribute.
	 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
	 * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
	 */

	/**
	 * Fired when a new marker is added to the model.
	 * * If marker's range is not collapsed, event is fired separately for each item contained in that range. In this
	 * situation, consumable contains all items from that range.
	 * * If marker's range is collapsed, single event is fired. In this situation, consumable contains only the collapsed range.
	 *
	 * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:
	 * `addMarker:<markerName>`. By specifying certain marker names, you can make the events even more gradual. For example,
	 * markers can be named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and
	 * `addMarker:foo:bar` events.
	 *
	 * @event addMarker
	 * @param {Object} data Additional information about the change.
	 * @param {module:engine/model/item~Item} [data.item] Item contained in marker's range. Not present if collapsed range
	 * is being converted.
	 * @param {module:engine/model/range~Range} [data.range] Range spanning over item. Not present if collapsed range
	 * is being converted.
	 * @param {String} data.markerName Name of the marker.
	 * @param {module:engine/model/range~Range} data.markerRange Marker's range spanning on all items.
	 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume. When non-collapsed
	 * marker is being converted then consumable contains all items in marker's range. For collapsed markers it contains
	 * only marker's range to consume.
	 * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
	 */

	/**
	 * Fired when marker is removed from the model.
	 * * If marker's range is not collapsed, event is fired separately for each item contained in that range. In this
	 * situation, consumable contains all items from that range.
	 * * If marker's range is collapsed, single event is fired. In this situation, consumable contains only the collapsed range.
	 *
	 * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:
	 * `removeMarker:<markerName>`. By specifying certain marker names, you can make the events even more gradual. For example,
	 * markers can be named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and
	 * `removeMarker:foo:bar` events.
	 *
	 * @event removeMarker
	 * @param {Object} data Additional information about the change.
	 * @param {module:engine/model/item~Item} [data.item] Item contained in marker's range. Not present if collapsed range
	 * is being converted.
	 * @param {module:engine/model/range~Range} [data.range] Range spanning over item. Not present if collapsed range
	 * is being converted.
	 * @param {String} data.markerName Name of the marker.
	 * @param {module:engine/model/range~Range} data.markerRange Whole marker's range.
	 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume. When non-collapsed
	 * marker is being converted then consumable contains all items in marker's range. For collapsed markers it contains
	 * only marker's range to consume.
	 * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ModelConversionDispatcher;


Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( ModelConversionDispatcher, __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

// Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not
// converted if they happen inside an element with custom conversion method.
//
// @param {module:engine/model/position~Position} modelPosition
// @param {module:engine/model/markercollection~Marker} marker
// @param {module:engine/conversion/mapper~Mapper} mapper
// @returns {Boolean}
function shouldMarkerChangeBeConverted( modelPosition, marker, mapper ) {
	const range = marker.getRange();
	const ancestors = Array.from( modelPosition.getAncestors() );
	ancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.
	ancestors.reverse();

	const hasCustomHandling = ancestors.some( element => {
		if ( range.containsItem( element ) ) {
			const viewElement = mapper.toViewElement( element );

			return !!viewElement.getCustomProperty( 'addHighlight' );
		}
	} );

	return !hasCustomHandling;
}


/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__element__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node__ = __webpack_require__(82);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/emptyelement
 */





/**
 * EmptyElement class. It is used to represent elements that cannot contain any child nodes.
 */
class EmptyElement extends __WEBPACK_IMPORTED_MODULE_0__element__["a" /* default */] {
	/**
	 * Creates new instance of EmptyElement.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,
	 * to inform that usage of EmptyElement is incorrect (adding child nodes to EmptyElement is forbidden).
	 *
	 * @param {String} name Node name.
	 * @param {Object|Iterable} [attributes] Collection of attributes.
	 */
	constructor( name, attributes, children ) {
		super( name, attributes, children );

		/**
		 * Returns `null` because filler is not needed for EmptyElements.
		 *
		 * @method #getFillerOffset
		 * @returns {null} Always returns null.
		 */
		this.getFillerOffset = getFillerOffset;
	}

	/**
	 * @inheritDoc
	 */
	is( type, name = null ) {
		if ( !name ) {
			return type == 'emptyElement' || super.is( type );
		} else {
			return ( type == 'emptyElement' && name == this.name ) || super.is( type, name );
		}
	}

	/**
	 * Overrides {@link module:engine/view/element~Element#insertChildren} method.
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent
	 * adding any child nodes to EmptyElement.
	 */
	insertChildren( index, nodes ) {
		if ( nodes && ( nodes instanceof __WEBPACK_IMPORTED_MODULE_2__node__["a" /* default */] || Array.from( nodes ).length > 0 ) ) {
			/**
			 * Cannot add children to {@link module:engine/view/emptyelement~EmptyElement}.
			 *
			 * @error view-emptyelement-cannot-add
			 */
			throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-emptyelement-cannot-add: Cannot add child nodes to EmptyElement instance.' );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EmptyElement;


// Returns `null` because block filler is not needed for EmptyElements.
//
// @returns {null}
function getFillerOffset() {
	return null;
}


/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/liveposition
 */







/**
 * `LivePosition` is a type of {@link module:engine/model/position~Position Position}
 * that updates itself as {@link module:engine/model/document~Document document}
 * is changed through operations. It may be used as a bookmark.
 *
 * **Note:** Contrary to {@link module:engine/model/position~Position}, `LivePosition` works only in roots that are
 * {@link module:engine/model/rootelement~RootElement}.
 * If {@link module:engine/model/documentfragment~DocumentFragment} is passed, error will be thrown.
 *
 * **Note:** Be very careful when dealing with `LivePosition`. Each `LivePosition` instance bind events that might
 * have to be unbound.
 * Use {@link module:engine/model/liveposition~LivePosition#detach} whenever you don't need `LivePosition` anymore.
 *
 * @extends module:engine/model/position~Position
 */
class LivePosition extends __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */] {
	/**
	 * Creates a live position.
	 *
	 * @see module:engine/model/position~Position
	 * @param {module:engine/model/rootelement~RootElement} root
	 * @param {Array.<Number>} path
	 * @param {module:engine/model/position~PositionStickiness} [stickiness] Defaults to `'sticksToNext'`.
	 * See {@link module:engine/model/liveposition~LivePosition#stickiness}.
	 */
	constructor( root, path, stickiness ) {
		super( root, path );

		if ( !this.root.is( 'rootElement' ) ) {
			/**
			 * LivePosition's root has to be an instance of RootElement.
			 *
			 * @error liveposition-root-not-rootelement
			 */
			throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'model-liveposition-root-not-rootelement: LivePosition\'s root has to be an instance of RootElement.'
			);
		}

		/**
		 * Flag representing `LivePosition` stickiness. `LivePosition` might be sticking to previous node or next node.
		 * Whenever some nodes are inserted at the same position as `LivePosition`, `stickiness` is checked to decide if
		 * LivePosition should be moved. Similar applies when a range of nodes is moved and one of it's boundary
		 * position is same as `LivePosition`.
		 *
		 * Examples:
		 *
		 *		Insert:
		 *		Position is at | and we insert at the same position, marked as ^:
		 *		- | sticks to previous node: `<p>f|^oo</p>` => `<p>f|baroo</p>`
		 *		- | sticks to next node: `<p>f^|oo</p>` => `<p>fbar|oo</p>`
		 *
		 *		Move:
		 *		Position is at | and range [ ] is moved to position ^:
		 *		- | sticks to previous node: `<p>f|[oo]</p><p>b^ar</p>` => `<p>f|</p><p>booar</p>`
		 *		- | sticks to next node: `<p>f|[oo]</p><p>b^ar</p>` => `<p>f</p><p>b|ooar</p>`
		 *
		 * @member {module:engine/model/position~PositionStickiness} module:engine/model/liveposition~LivePosition#stickiness
		 */
		this.stickiness = stickiness || 'sticksToNext';

		bindWithDocument.call( this );
	}

	/**
	 * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance
	 * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
	 * referring to it).
	 */
	detach() {
		this.stopListening();
	}

	/**
	 * @static
	 * @method module:engine/model/liveposition~LivePosition.createAfter
	 * @see module:engine/model/position~Position.createAfter
	 * @param {module:engine/model/node~Node} node
	 * @returns {module:engine/model/liveposition~LivePosition}
	 */

	/**
	 * @static
	 * @method module:engine/model/liveposition~LivePosition.createBefore
	 * @see module:engine/model/position~Position.createBefore
	 * @param {module:engine/model/node~Node} node
	 * @returns {module:engine/model/liveposition~LivePosition}
	 */

	/**
	 * @static
	 * @method module:engine/model/liveposition~LivePosition.createFromParentAndOffset
	 * @see module:engine/model/position~Position.createFromParentAndOffset
	 * @param {module:engine/model/element~Element} parent
	 * @param {Number} offset
	 * @returns {module:engine/model/liveposition~LivePosition}
	 */

	/**
	 * @static
	 * @method module:engine/model/liveposition~LivePosition.createFromPosition
	 * @see module:engine/model/position~Position.createFromPosition
	 * @param {module:engine/model/position~Position} position
	 * @returns {module:engine/model/liveposition~LivePosition}
	 */

	/**
	 * Fired when `LivePosition` instance is changed due to changes on {@link module:engine/model/document~Document}.
	 *
	 * @event module:engine/model/liveposition~LivePosition#change
	 * @param {module:engine/model/position~Position} oldPosition Position equal to this live position before it got changed.
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LivePosition;


/**
 * Binds this `LivePosition` to the {@link module:engine/model/document~Document document} that owns
 * this position's {@link module:engine/model/position~Position#root root}.
 *
 * @ignore
 * @private
 * @method module:engine/model/liveposition~LivePosition.bindWithDocument
 */
function bindWithDocument() {
	// Operation types handled by LivePosition (these are operations that change model tree structure).
	const supportedTypes = new Set( [ 'insert', 'move', 'remove', 'reinsert' ] );

	this.listenTo(
		this.root.document,
		'change',
		( event, type, changes ) => {
			if ( supportedTypes.has( type ) ) {
				transform.call( this, type, changes.range, changes.sourcePosition );
			}
		},
		{ priority: 'high' }
	);
}

/**
 * Updates this position accordingly to the updates applied to the model. Bases on change events.
 *
 * @ignore
 * @private
 * @method transform
 * @param {String} type Type of changes applied to the Tree Model.
 * @param {module:engine/model/range~Range} range Range containing the result of applied change.
 * @param {module:engine/model/position~Position} [position] Additional position parameter provided by some change events.
 */
function transform( type, range, position ) {
	/* eslint-disable no-case-declarations */
	const howMany = range.end.offset - range.start.offset;
	let transformed;

	switch ( type ) {
		case 'insert':
			const insertBefore = this.stickiness == 'sticksToNext';
			transformed = this._getTransformedByInsertion( range.start, howMany, insertBefore );
			break;

		case 'move':
		case 'remove':
		case 'reinsert':
			const originalRange = __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createFromPositionAndShift( position, howMany );

			const gotMoved = originalRange.containsPosition( this ) ||
				( originalRange.start.isEqual( this ) && this.stickiness == 'sticksToNext' ) ||
				( originalRange.end.isEqual( this ) && this.stickiness == 'sticksToPrevious' );

			// We can't use ._getTransformedByMove() because we have a different if-condition.
			if ( gotMoved ) {
				transformed = this._getCombined( position, range.start );
			} else {
				const insertBefore = this.stickiness == 'sticksToNext';
				transformed = this._getTransformedByMove( position, range.start, howMany, insertBefore );
			}
			break;
	}

	if ( !this.isEqual( transformed ) ) {
		const oldPosition = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( this );

		this.path = transformed.path;
		this.root = transformed.root;

		this.fire( 'change', oldPosition );
	}
	/* eslint-enable no-case-declarations */
}

Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( LivePosition, __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

/**
 * Enum representing how position is "sticking" with their neighbour nodes.
 * Possible values: `'sticksToNext'`, `'sticksToPrevious'`.
 *
 * @typedef {String} module:engine/model/position~PositionStickiness
 */



/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export isCombiningMark */
/* unused harmony export isHighSurrogateHalf */
/* unused harmony export isLowSurrogateHalf */
/* harmony export (immutable) */ __webpack_exports__["b"] = isInsideSurrogatePair;
/* harmony export (immutable) */ __webpack_exports__["a"] = isInsideCombinedSymbol;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Set of utils to handle unicode characters.
 *
 * @module utils/unicode
 */

/**
 * Checks whether given `character` is a combining mark.
 *
 * @param {String} character Character to check.
 * @returns {Boolean}
 */
function isCombiningMark( character ) {
	return !!character && character.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test( character );
}

/**
 * Checks whether given `character` is a high half of surrogate pair.
 *
 * Using UTF-16 terminology, a surrogate pair denotes UTF-16 character using two UTF-8 characters. The surrogate pair
 * consist of high surrogate pair character followed by low surrogate pair character.
 *
 * @param {String} character Character to check.
 * @returns {Boolean}
 */
function isHighSurrogateHalf( character ) {
	return !!character && character.length == 1 && /[\ud800-\udbff]/.test( character );
}

/**
 * Checks whether given `character` is a low half of surrogate pair.
 *
 * Using UTF-16 terminology, a surrogate pair denotes UTF-16 character using two UTF-8 characters. The surrogate pair
 * consist of high surrogate pair character followed by low surrogate pair character.
 *
 * @param {String} character Character to check.
 * @returns {Boolean}
 */
function isLowSurrogateHalf( character ) {
	return !!character && character.length == 1 && /[\udc00-\udfff]/.test( character );
}

/**
 * Checks whether given offset in a string is inside a surrogate pair (between two surrogate halves).
 *
 * @param {String} string String to check.
 * @param {Number} offset Offset to check.
 * @returns {Boolean}
 */
function isInsideSurrogatePair( string, offset ) {
	return isHighSurrogateHalf( string.charAt( offset - 1 ) ) && isLowSurrogateHalf( string.charAt( offset ) );
}

/**
 * Checks whether given offset in a string is between base character and combining mark or between two combining marks.
 *
 * @param {String} string String to check.
 * @param {Number} offset Offset to check.
 * @returns {Boolean}
 */
function isInsideCombinedSymbol( string, offset ) {
	return isCombiningMark( string.charAt( offset ) );
}


/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SetCache__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arraySome__ = __webpack_require__(374);



/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new __WEBPACK_IMPORTED_MODULE_0__SetCache__["a" /* default */] : undefined;

  stack.set(array, other);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!Object(__WEBPACK_IMPORTED_MODULE_1__arraySome__["a" /* default */])(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (equalArrays);


/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__insertdelta__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_insertoperation__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__writer__ = __webpack_require__(22);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/weakinsertdelta
 */







/**
 * To provide specific OT behavior and better collisions solving, the {@link module:engine/model/batch~Batch#insert} method
 * uses the `WeakInsertDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class WeakInsertDelta extends __WEBPACK_IMPORTED_MODULE_0__insertdelta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.WeakInsertDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = WeakInsertDelta;


/**
 * Inserts a node or nodes at given position. {@link module:engine/model/batch~Batch#weakInsert weakInsert} is commonly used for actions
 * like typing or plain-text paste (without formatting). There are two differences between
 * {@link module:engine/model/batch~Batch#insert insert} and {@link module:engine/model/batch~Batch#weakInsert weakInsert}:
 *
 * * When using `weakInsert`, inserted nodes will have same attributes as the current attributes of
 * {@link module:engine/model/document~Document#selection document selection}.
 * * If {@link module:engine/model/operation/insertoperation~InsertOperation insert operation} position is inside a range changed by
 * {@link module:engine/model/operation/attributeoperation~AttributeOperation attribute operation},
 * the attribute operation is split into two operations.
 * Thanks to this, attribute change "omits" the inserted nodes. The correct behavior for `WeakInsertDelta` is that
 * {@link module:engine/model/operation/attributeoperation~AttributeOperation AttributeOperation} does not "break" and also
 * applies attributes for inserted nodes. This behavior has to be reflected during
 * {@link module:engine/model/delta/transform~transform delta transformation}.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#weakInsert
 * @param {module:engine/model/position~Position} position Position of insertion.
 * @param {module:engine/model/node~NodeSet} nodes The list of nodes to be inserted.
 */
Object(__WEBPACK_IMPORTED_MODULE_1__batch__["b" /* register */])( 'weakInsert', function( position, nodes ) {
	const delta = new WeakInsertDelta();
	this.addDelta( delta );

	nodes = Object(__WEBPACK_IMPORTED_MODULE_4__writer__["c" /* normalizeNodes */])( nodes );

	for ( const node of nodes ) {
		node.setAttributesTo( this.document.selection.getAttributes() );
	}

	const operation = new __WEBPACK_IMPORTED_MODULE_3__operation_insertoperation__["a" /* default */]( position, nodes, this.document.version );
	delta.addOperation( operation );
	this.document.applyOperation( operation );

	return this;
} );

__WEBPACK_IMPORTED_MODULE_2__deltafactory__["a" /* default */].register( WeakInsertDelta );


/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__movedelta__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__removedelta__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mergedelta__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__splitdelta__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__wrapdelta__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__unwrapdelta__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__renamedelta__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__attributedelta__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__operation_transform__ = __webpack_require__(379);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__operation_nooperation__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__operation_moveoperation__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__operation_removeoperation__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ckeditor_ckeditor5_utils_src_lib_lodash_array__ = __webpack_require__(380);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_utils_src_comparearrays__ = __webpack_require__(54);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @protected
 * @module engine/model/delta/transform
 */

















const specialCases = new Map();

/**
 * @namespace
 */
const transform = {
	/**
	 * Transforms given {@link module:engine/model/delta/delta~Delta delta} by another {@link module:engine/model/delta/delta~Delta delta}
	 * and returns the result of that transformation as an array containing one or more {@link module:engine/model/delta/delta~Delta delta}
	 * instances.
	 *
	 * Delta transformations heavily base on {@link module:engine/model/operation/transform~transform operational transformations}. Since
	 * delta is a list of operations most situations can be handled thanks to operational transformation. Unfortunately,
	 * deltas are more complicated than operations and have they semantic meaning, as they represent user's editing intentions.
	 *
	 * Sometimes, simple operational transformation on deltas' operations might result in some unexpected results. Those
	 * results would be fine from OT point of view, but would not reflect user's intentions. Because of such conflicts
	 * we need to handle transformations in special cases in a custom way.
	 *
	 * The function itself looks whether two given delta types have a special case function registered. If so, the deltas are
	 * transformed using that function. If not,
	 * {@link module:engine/model/delta/transform~transform.defaultTransform default transformation algorithm} is used.
	 *
	 * @param {module:engine/model/delta/delta~Delta} a Delta that will be transformed.
	 * @param {module:engine/model/delta/delta~Delta} b Delta to transform by.
	 * @param {module:engine/model/delta/transform~transformationContext} context Transformation context object.
	 * @returns {Array.<module:engine/model/delta/delta~Delta>} Result of the transformation.
	 */
	transform( a, b, context ) {
		const transformAlgorithm = transform.getTransformationCase( a, b ) || transform.defaultTransform;

		// Make new instance of context object, so all changes done during transformation are not saved in original object.
		const transformed = transformAlgorithm( a, b, Object.assign( {}, context ) );
		const baseVersion = __WEBPACK_IMPORTED_MODULE_13__ckeditor_ckeditor5_utils_src_lib_lodash_array__["a" /* default */].last( b.operations ).baseVersion;

		return updateBaseVersion( baseVersion, transformed );
	},

	/**
	 * The default delta transformation function. It is used for those deltas that are not in special case conflict.
	 *
	 * This algorithm is similar to a popular `dOPT` algorithm used in operational transformation, as we are in fact
	 * transforming two sets of operations by each other.
	 *
	 * @param {module:engine/model/delta/delta~Delta} a Delta that will be transformed.
	 * @param {module:engine/model/delta/delta~Delta} b Delta to transform by.
	 * @param {module:engine/model/delta/transform~transformationContext} context Transformation context object.
	 * @returns {Array.<module:engine/model/delta/delta~Delta>} Result of the transformation.
	 */
	defaultTransform( a, b, context ) {
		// This will hold operations from delta `a` that will be transformed by operations from delta `b`.
		// Eventually, those operations will be used to create result delta(s).
		const transformed = [];

		// Array containing operations that we will transform by. At the beginning these are just operations from
		let byOps = b.operations;

		// This array is storing operations from `byOps` which got transformed by operation from delta `a`.
		let newByOps = [];

		// We take each operation from original set of operations to transform.
		for ( const opA of a.operations ) {
			// We wrap the operation in the array. This is important, because operation transformation algorithm returns
			// an array of operations so we need to make sure that our algorithm is ready to handle arrays.
			const ops = [ opA ];

			// Now the real algorithm takes place.
			for ( const opB of byOps ) {
				// For each operation that we need transform by...
				for ( let i = 0; i < ops.length; i++ ) {
					// We take each operation to transform...
					const op = ops[ i ];

					// And transform both of them by themselves.

					// The result of transforming operation from delta B by operation from delta A is saved in
					// `newByOps` array. We will use that array for transformations in next loops. We need delta B
					// operations after transformed by delta A operations to get correct results of transformations
					// of next operations from delta A.
					//
					// It's like this because 2nd operation from delta A assumes that 1st operation from delta A
					// is "already applied". When we transform 2nd operation from delta A by operations from delta B
					// we have to be sure that operations from delta B are in a state that acknowledges 1st operation
					// from delta A.
					//
					// This can be easier understood when operations sets to transform are represented by diamond diagrams:
					// http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation

					// Transform operation from delta A by operation from delta B.
					const results = Object(__WEBPACK_IMPORTED_MODULE_9__operation_transform__["a" /* default */])( op, opB, context );

					// We replace currently processed operation from `ops` array by the results of transformation.
					// Note, that we process single operation but `operationTransform` result is an array, so we
					// might have to splice-in more than one operation. Save them in `ops` array and move `i` pointer by a proper offset.
					Array.prototype.splice.apply( ops, [ i, 1 ].concat( results ) );

					i += results.length - 1;

					// Then, transform operation from delta B by operation from delta A.
					// Since this is a "mirror" transformation, first, we "mirror" some of context values.
					const reverseContext = Object.assign( {}, context );
					reverseContext.isStrong = !context.isStrong;
					reverseContext.insertBefore = context.insertBefore !== undefined ? !context.insertBefore : undefined;

					// Transform operations.
					const updatedOpB = Object(__WEBPACK_IMPORTED_MODULE_9__operation_transform__["a" /* default */])( opB, op, reverseContext );

					// Update `newByOps` by transformed, updated `opB`.
					// Using push.apply because `operationTransform` returns an array with one or multiple results.
					Array.prototype.push.apply( newByOps, updatedOpB );
				}

				// At this point a single operation from delta A got transformed by a single operation from delta B.
				// The transformation result is in `ops` array and it may be one or more operations. This was just the first step.
				// Operation from delta A has to be further transformed by the other operations from delta B.
				// So in next iterator loop we will take another operation from delta B and use transformed delta A (`ops`)
				// to transform it further.
			}

			// We got through all delta B operations and have a final transformed state of an operation from delta A.

			// As previously mentioned, we substitute operations from delta B by their transformed equivalents.
			byOps = newByOps;
			newByOps = [];

			// We add transformed operation from delta A to newly created delta.
			// Remember that transformed operation from delta A may consist of multiple operations.
			for ( const op of ops ) {
				transformed.push( op );
			}

			// In next loop, we will take another operation from delta A and transform it through (transformed) operations
			// from delta B...
		}

		return getNormalizedDeltas( a.constructor, transformed );
	},

	/**
	 * Adds a special case callback for given delta classes.
	 *
	 * @param {Function} A Delta constructor which instance will get transformed.
	 * @param {Function} B Delta constructor which instance will be transformed by.
	 * @param {Function} resolver A callback that will handle custom special case transformation for instances of given delta classes.
	 */
	addTransformationCase( A, B, resolver ) {
		let casesA = specialCases.get( A );

		if ( !casesA ) {
			casesA = new Map();
			specialCases.set( A, casesA );
		}

		casesA.set( B, resolver );
	},

	/**
	 * Gets a special case callback which was previously {@link module:engine/model/delta/transform~transform.addTransformationCase added}.
	 *
	 * @param {module:engine/model/delta/delta~Delta} a Delta to transform.
	 * @param {module:engine/model/delta/delta~Delta} b Delta to be transformed by.
	 */
	getTransformationCase( a, b ) {
		let casesA = specialCases.get( a.constructor );

		// If there are no special cases registered for class which `a` is instance of, we will
		// check if there are special cases registered for any parent class.
		if ( !casesA || !casesA.get( b.constructor ) ) {
			const cases = specialCases.keys();

			for ( const caseClass of cases ) {
				if ( a instanceof caseClass && specialCases.get( caseClass ).get( b.constructor ) ) {
					casesA = specialCases.get( caseClass );

					break;
				}
			}
		}

		if ( casesA ) {
			return casesA.get( b.constructor );
		}

		return undefined;
	},

	/**
	 * Transforms two sets of deltas by themselves. Returns both transformed sets.
	 *
	 * @param {Array.<module:engine/model/delta/delta~Delta>} deltasA Array with the first set of deltas to transform. These
	 * deltas are considered more important (than `deltasB`) when resolving conflicts.
	 * @param {Array.<module:engine/model/delta/delta~Delta>} deltasB Array with the second set of deltas to transform. These
	 * deltas are considered less important (than `deltasA`) when resolving conflicts.
	 * @param {module:engine/model/document~Document} [document=null] If set, deltas will be transformed in "undo mode"
	 * and given `document` will be used to determine relations between deltas. If not set (default), deltas will be
	 * transforming without additional context information.
	 * @returns {Object}
	 * @returns {Array.<module:engine/model/delta/delta~Delta>} return.deltasA The first set of deltas transformed
	 * by the second set of deltas.
	 * @returns {Array.<module:engine/model/delta/delta~Delta>} return.deltasB The second set of deltas transformed
	 * by the first set of deltas.
	 */
	transformDeltaSets( deltasA, deltasB, document = null ) {
		const transformedDeltasA = Array.from( deltasA );
		const transformedDeltasB = Array.from( deltasB );

		const useAdditionalContext = document !== null;

		const contextAB = {
			isStrong: true
		};

		if ( useAdditionalContext ) {
			contextAB.wasAffected = new Map();
			contextAB.originalDelta = new Map();
			contextAB.document = document;
			contextAB.undoMode = true;

			for ( const delta of transformedDeltasB ) {
				contextAB.originalDelta.set( delta, delta );
			}
		}

		for ( let i = 0; i < transformedDeltasA.length; i++ ) {
			const deltaA = [ transformedDeltasA[ i ] ];

			for ( let j = 0; j < transformedDeltasB.length; j++ ) {
				const deltaB = [ transformedDeltasB[ j ] ];

				for ( let k = 0; k < deltaA.length; k++ ) {
					for ( let l = 0; l < deltaB.length; l++ ) {
						if ( useAdditionalContext ) {
							_setContext( deltaA[ k ], deltaB[ l ], contextAB );
						}

						const resultAB = transform.transform( deltaA[ k ], deltaB[ l ], {
							insertBefore: contextAB.insertBefore,
							forceNotSticky: contextAB.forceNotSticky,
							isStrong: contextAB.isStrong,
							forceWeakRemove: contextAB.forceWeakRemove,
							undoMode: contextAB.undoMode
						} );

						const resultBA = transform.transform( deltaB[ l ], deltaA[ k ], {
							insertBefore: !contextAB.insertBefore,
							forceNotSticky: contextAB.forceNotSticky,
							isStrong: !contextAB.isStrong,
							forceWeakRemove: contextAB.forceWeakRemove,
							undoMode: contextAB.undoMode
						} );

						if ( useAdditionalContext ) {
							_updateContext( deltaA[ k ], resultAB, contextAB );

							const originalDelta = contextAB.originalDelta.get( deltaB[ l ] );

							for ( const deltaBA of resultBA ) {
								contextAB.originalDelta.set( deltaBA, originalDelta );
							}
						}

						deltaA.splice( k, 1, ...resultAB );
						k += resultAB.length - 1;

						deltaB.splice( l, 1, ...resultBA );
						l += resultBA.length - 1;
					}
				}

				transformedDeltasB.splice( j, 1, ...deltaB );
				j += deltaB.length - 1;
			}

			transformedDeltasA.splice( i, 1, ...deltaA );
			i += deltaA.length - 1;
		}

		const opsDiffA = getOpsCount( transformedDeltasA ) - getOpsCount( deltasA );
		const opsDiffB = getOpsCount( transformedDeltasB ) - getOpsCount( deltasB );

		if ( opsDiffB < opsDiffA ) {
			padWithNoOps( transformedDeltasB, opsDiffA - opsDiffB );
		} else if ( opsDiffA < opsDiffB ) {
			padWithNoOps( transformedDeltasA, opsDiffB - opsDiffA );
		}

		return { deltasA: transformedDeltasA, deltasB: transformedDeltasB };
	}
};

/* harmony default export */ __webpack_exports__["a"] = (transform);

// Updates base versions of operations inside deltas (which are the results of delta transformation).
function updateBaseVersion( baseVersion, deltas ) {
	for ( const delta of deltas ) {
		for ( const op of delta.operations ) {
			op.baseVersion = ++baseVersion;
		}
	}

	return deltas;
}

// Returns number of operations in given array of deltas.
function getOpsCount( deltas ) {
	return deltas.reduce( ( current, delta ) => {
		return current + delta.operations.length;
	}, 0 );
}

// Adds a delta containing `howMany` `NoOperation` instances to given array with deltas.
// Used to "synchronize" the number of operations in two delta sets.
function padWithNoOps( deltas, howMany ) {
	const lastDelta = deltas[ deltas.length - 1 ];
	let baseVersion = lastDelta.operations.length + lastDelta.baseVersion;

	const noDelta = new __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */]();

	for ( let i = 0; i < howMany; i++ ) {
		noDelta.addOperation( new __WEBPACK_IMPORTED_MODULE_10__operation_nooperation__["a" /* default */]( baseVersion++ ) );
	}

	deltas.push( noDelta );
}

// Sets context data before delta `a` by delta `b` transformation.
// Using data given in `context` object, sets `context.insertBefore` and `context.forceNotSticky` flags.
// Also updates `context.wasAffected`.
function _setContext( a, b, context ) {
	_setWasAffected( a, b, context );
	_setInsertBeforeContext( a, b, context );
	_setForceWeakRemove( b, context );
	_setForceNotSticky( b, context );
}

// Sets `context.insertBefore` basing on `context.document` history for `a` by `b` transformation.
//
// Simply saying, if `b` is "undoing delta" it means that `a` might already be transformed by the delta
// which was undone by `b` (let's call it `oldB`). If this is true, `a` by `b` transformation has to consider
// how `a` was transformed by `oldB` to get an expected result.
//
// This is used to resolve conflict when two operations want to insert nodes at the same position. If the operations
// are not related, it doesn't matter in what order operations insert those nodes. However if the operations are
// related (for example, in undo) we need to keep the same order.
//
// For example, assume that editor has two letters: 'ab'. Then, both letters are removed, creating two operations:
// (op. 1) REM [ 1 ] - [ 2 ] => (graveyard) [ 0 ]
// (op. 2) REM [ 0 ] - [ 1 ] => (graveyard) [ 1 ]
// Then, we undo operation 2:
// REM [ 0 ] - [ 1 ] => (graveyard) [ 1 ] is reversed to REI (graveyard) [ 1 ] => [ 0 ] - [ 1 ] and is applied.
// History stack is:
// (op. 1) REM [ 1 ] - [ 2 ] => (graveyard) [ 0 ]
// (op. 2) REM [ 0 ] - [ 1 ] => (graveyard) [ 1 ]
// (op. 3) REI (graveyard) [ 1 ] => [ 0 ] - [ 1 ]
// Then, we undo operation 1:
// REM [ 1 ] - [ 2 ] => (graveyard) [ 0 ] is reversed to REI (graveyard) [ 0 ] => [ 1 ] - [ 2 ] then,
// is transformed by (op. 2) REM [ 0 ] - [ 1 ] => (graveyard) [ 1 ] and becomes REI (graveyard) [ 0 ] => [ 0 ] - [ 1 ] then,
// is transformed by (op. 3) REI (graveyard) [ 1 ] => [ 0 ] - [ 1 ] and we have a conflict because both operations
// insert at the same position, but thanks to keeping the context, we know that in this case, the transformed operation should
// insert the node after operation 3.
//
// Keep in mind, that `context.insertBefore` may be either `Boolean` or `undefined`. If it is `Boolean` then the order is
// known (deltas are related and `a` should insert nodes before or after `b`). However, if deltas were not related,
// `context.isBefore` is `undefined` and other factors will be taken into consideration when resolving the order
// (this, however, happens in operational transformation algorithms).
//
// This affects both `MoveOperation` (and its derivatives) and `InsertOperation`.
function _setInsertBeforeContext( a, b, context ) {
	// If `b` is a delta that undoes other delta...
	const originalDelta = context.originalDelta.get( b );

	if ( context.document.history.isUndoingDelta( originalDelta ) ) {
		// Get the undone delta...
		const undoneDelta = context.document.history.getUndoneDelta( originalDelta );
		// Get a map with deltas related to `a` delta...
		const aWasAffectedBy = context.wasAffected.get( a );
		// And check if the undone delta is related with delta `a`.
		const affected = aWasAffectedBy.get( undoneDelta );

		if ( affected !== undefined ) {
			// If deltas are related, set `context.insertBefore` basing on whether `a` was affected by the undone delta.
			context.insertBefore = affected;
		}
	}
}

// Sets `context.forceNotSticky` basing on `context.document` history for transformation by `b` delta.
//
// `MoveOperation` may be "sticky" which means, that anything that was inserted at the boundary of moved range, should
// also be moved. This is particularly helpful for actions like splitting or merging a node. However, this behavior
// sometimes leads to an error, for example in undo.
//
// Simply saying, if delta is going to be transformed by delta `b`, stickiness should not be taken into consideration
// if delta `b` was already undone or if delta `b` is an undoing delta.
//
// This affects `MoveOperation` (and its derivatives).
function _setForceNotSticky( b, context ) {
	const originalDelta = context.originalDelta.get( b );
	const history = context.document.history;

	context.forceNotSticky = history.isUndoneDelta( originalDelta ) || history.isUndoingDelta( originalDelta );
}

// Sets `context.forceWeakRemove` basing on `context.document` history for transformation by `b` delta.
//
// When additional context is not used, default `MoveOperation` x `RemoveOperation` transformation
// always treats `RemoveOperation` as a stronger one, no matter how `context.isStrong` is set. It is like this
// to provide better results when transformations happen.
//
// This, however, works fine only when additional context is not used.
//
// When additional context is used, we need a better way to decide whether `RemoveOperation` is "dominating" (or in other
// words, whether nodes removed by given operation should stay in graveyard if other operation wants to move them).
//
// The answer to this is easy: if `RemoveOperation` has been already undone, we are not forcing given nodes to stay
// in graveyard. In such scenario, we set `context.forceWeakRemove` to `true`. However, if the `RemoveOperation` has
// not been undone, we set `context.forceWeakRemove` to `false` because we want the operation to be "dominating".
function _setForceWeakRemove( b, context ) {
	const history = context.document.history;
	const originalB = context.originalDelta.get( b );

	// If `b` delta has not been undone yet, forceWeakRemove should be `false`.
	// It should be `true`, in any other case, if additional context is used.
	context.forceWeakRemove = history.isUndoneDelta( originalB );
}

// Sets `context.wasAffected` which holds context information about how transformed deltas are related. `context.wasAffected`
// is used by `_setInsertBeforeContext` helper function.
function _setWasAffected( a, b, context ) {
	if ( !context.wasAffected.get( a ) ) {
		// Create a new map with relations for `a` delta.
		context.wasAffected.set( a, new Map() );
	}

	const originalDelta = context.originalDelta.get( b );
	let wasAffected = !!context.wasAffected.get( a ).get( originalDelta );

	// Cross-check all operations from both deltas...
	for ( const opA of a.operations ) {
		for ( const opB of b.operations ) {
			if ( opA instanceof __WEBPACK_IMPORTED_MODULE_11__operation_moveoperation__["a" /* default */] && opB instanceof __WEBPACK_IMPORTED_MODULE_11__operation_moveoperation__["a" /* default */] ) {
				if ( _isOperationAffected( opA, opB ) ) {
					// If any of them are move operations that affect each other, set the relation accordingly.
					wasAffected = true;

					break;
				}
			}
		}

		// Break both loops if affecting pair has been found.
		if ( wasAffected ) {
			break;
		}
	}

	context.wasAffected.get( a ).set( originalDelta, wasAffected );
}

// Checks whether `opA` is affected by `opB`. It is assumed that both operations are `MoveOperation`.
// Operation is affected only if the other operation's source range is before that operation's source range.
function _isOperationAffected( opA, opB ) {
	const target = opA.targetPosition;
	const source = opB.sourcePosition;

	const cmpResult = Object(__WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( source.getParentPath(), target.getParentPath() );

	if ( target.root != source.root ) {
		return false;
	}

	return cmpResult == 'same' && source.offset < target.offset;
}

// Updates `context` object after delta by delta transformation is done.
//
// This means two things:
// 1. Some information are removed from context (those that apply only to the transformation that just happened).
// 2. `context.wasAffected` is updated because `oldDelta` has been transformed to one or many `newDeltas` and we
// need to update entries in `context.wasAffected`. Basically, anything that was in `context.wasAffected` under
// `oldDelta` key should be rewritten to `newDeltas`. This way in next transformation steps, `newDeltas` "remember"
// the context of `oldDelta`.
function _updateContext( oldDelta, newDeltas, context ) {
	delete context.insertBefore;
	delete context.forceNotSticky;
	delete context.forceWeakRemove;

	const wasAffected = context.wasAffected.get( oldDelta );

	context.wasAffected.delete( oldDelta );

	for ( const delta of newDeltas ) {
		context.wasAffected.set( delta, new Map( wasAffected ) );
	}
}

// Takes base delta class (`DeltaClass`) and a set of `operations` that are transformation results and creates
// one or more deltas, acknowledging that the result is a transformation of a delta that is of `DeltaClass`.
//
// The normalization ensures that each delta has it's "normal" state, that is, for example, `MoveDelta` has
// just one `MoveOperation`, `SplitDelta` has just two operations of which first is `InsertOperation` and second
// is `MoveOperation` or `NoOperation`, etc.
function getNormalizedDeltas( DeltaClass, operations ) {
	let deltas = [];
	let delta = null;
	let attributeOperationIndex;

	switch ( DeltaClass ) {
		case __WEBPACK_IMPORTED_MODULE_1__movedelta__["a" /* default */]:
		case __WEBPACK_IMPORTED_MODULE_2__removedelta__["a" /* default */]:
			// Normal MoveDelta has just one MoveOperation.
			// Take all operations and create MoveDelta for each of them.
			for ( const o of operations ) {
				if ( o instanceof __WEBPACK_IMPORTED_MODULE_10__operation_nooperation__["a" /* default */] ) {
					// An operation may be instance of NoOperation and this may be correct.
					// If that's the case, do not create a MoveDelta with singular NoOperation.
					// Create "no delta" instead, that is Delta instance with NoOperation.
					delta = new __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */]();
				} else {
					if ( o instanceof __WEBPACK_IMPORTED_MODULE_12__operation_removeoperation__["a" /* default */] ) {
						delta = new __WEBPACK_IMPORTED_MODULE_2__removedelta__["a" /* default */]();
					} else {
						delta = new __WEBPACK_IMPORTED_MODULE_1__movedelta__["a" /* default */]();
					}
				}

				delta.addOperation( o );
				deltas.push( delta );
			}

			// Return all created MoveDeltas.
			return deltas;
		case __WEBPACK_IMPORTED_MODULE_4__splitdelta__["a" /* default */]:
		case __WEBPACK_IMPORTED_MODULE_5__wrapdelta__["a" /* default */]:
			// Normal SplitDelta and WrapDelta have two operations: first is InsertOperation and second is MoveOperation.
			// The MoveOperation may be split into multiple MoveOperations.
			// If that's the case, convert additional MoveOperations into MoveDeltas.
			// First, create normal SplitDelta or WrapDelta, using first two operations.
			delta = new DeltaClass();
			delta.addOperation( operations[ 0 ] );
			delta.addOperation( operations[ 1 ] );
			// Then, take all but last two operations and use them to create normalized MoveDeltas.
			deltas = getNormalizedDeltas( __WEBPACK_IMPORTED_MODULE_1__movedelta__["a" /* default */], operations.slice( 2 ) );

			// Return all deltas as one array, in proper order.
			return [ delta ].concat( deltas );
		case __WEBPACK_IMPORTED_MODULE_3__mergedelta__["a" /* default */]:
		case __WEBPACK_IMPORTED_MODULE_6__unwrapdelta__["a" /* default */]:
			// Normal MergeDelta and UnwrapDelta have two operations: first is MoveOperation and second is RemoveOperation.
			// The MoveOperation may be split into multiple MoveOperations.
			// If that's the case, convert additional MoveOperations into MoveDeltas.
			// Take all but last two operations and use them to create normalized MoveDeltas.
			deltas = getNormalizedDeltas( __WEBPACK_IMPORTED_MODULE_1__movedelta__["a" /* default */], operations.slice( 0, -2 ) );
			// Then, create normal MergeDelta or UnwrapDelta, using last two operations.
			delta = new DeltaClass();
			delta.addOperation( operations[ operations.length - 2 ] );
			delta.addOperation( operations[ operations.length - 1 ] );

			// Return all deltas as one array, in proper order.
			return deltas.concat( delta );
		case __WEBPACK_IMPORTED_MODULE_7__renamedelta__["a" /* default */]:
			// RenameDelta may become a "no delta" if it's only operation is transformed to NoOperation.
			// This may happen when RenameOperation is transformed by RenameOperation.
			// Keep in mind that RenameDelta always have just one operation.
			if ( operations[ 0 ] instanceof __WEBPACK_IMPORTED_MODULE_10__operation_nooperation__["a" /* default */] ) {
				delta = new __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */]();
			} else {
				delta = new __WEBPACK_IMPORTED_MODULE_7__renamedelta__["a" /* default */]();
			}

			delta.addOperation( operations[ 0 ] );

			return [ delta ];
		case __WEBPACK_IMPORTED_MODULE_8__attributedelta__["a" /* default */]:
			// AttributeDelta is allowed to have multiple AttributeOperations and also NoOperations but
			// the first operation has to be an AttributeOperation as it is used as a reference for deltas properties.
			// Keep in mind that we cannot simply remove NoOperations cause that would mess up base versions.
			// Find an index of first operation that is not a NoOperation.
			for ( attributeOperationIndex = 0; attributeOperationIndex < operations.length; attributeOperationIndex++ ) {
				if ( !( operations[ attributeOperationIndex ] instanceof __WEBPACK_IMPORTED_MODULE_10__operation_nooperation__["a" /* default */] ) ) {
					break;
				}
			}

			// No AttributeOperations has been found. Convert AttributeDelta to "no delta".
			if ( attributeOperationIndex == operations.length ) {
				delta = new __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */]();
			}
			// AttributeOperation found.
			else {
				delta = new __WEBPACK_IMPORTED_MODULE_8__attributedelta__["a" /* default */]();

				// AttributeOperation wasn't the first operation.
				if ( attributeOperationIndex != 0 ) {
					// Move AttributeOperation to the beginning.
					operations.unshift( operations.splice( attributeOperationIndex, 1 )[ 0 ] );
					// No need to update base versions - they are updated at the end of transformation algorithm anyway.
				}
			}

			// Add all operations to the delta (even if it is just a couple of NoOperations we have to keep them all).
			for ( const o of operations ) {
				delta.addOperation( o );
			}

			return [ delta ];
		default:
			// For all other deltas no normalization is needed.
			delta = new DeltaClass();

			for ( const o of operations ) {
				delta.addOperation( o );
			}

			return [ delta ];
	}
}

/**
 * Object containing values and flags describing context of a transformation.
 *
 * @typedef {Object} module:engine/model/delta/transform~transformationContext
 * @property {Boolean} useAdditionalContext Whether additional context should be evaluated and used during transformations.
 * @property {Boolean} isStrong Whether transformed deltas are more (`true`) or less (`false`) important than deltas to transform by.
 * @property {module:engine/model/document~Document} [document] Model document which is a context for transformations.
 * Available only if `useAdditionalContext` is `true`.
 * @property {Boolean|undefined} forceWeakRemove Whether {@link module:engine/model/operation/removeoperation~RemoveOperation}
 * should be always more important than other operations. Available only if `useAdditionalContext` is `true`.
 * @property {Boolean|undefined} insertBefore Used when transforming {@link module:engine/model/operation/moveoperation~MoveOperation}s
 * If two `MoveOperation`s target to the same position, `insertBefore` is used to resolve such conflict. This flag
 * is set and used internally by transformation algorithms. Available only if `useAdditionalContext` is `true`.
 * @property {Boolean|undefined} forceNotSticky Used when transforming
 * {@link module:engine/model/operation/moveoperation~MoveOperation#isSticky sticky MoveOperation}. If set to `true`,
 * `isSticky` flag is discarded during transformations. This flag is set and used internally by transformation algorithms.
 * Available only if `useAdditionalContext` is `true`.
 * @property {Map|undefined} wasAffected Used to evaluate `insertBefore` flag. This map is set and used internally by
 * transformation algorithms. Available only if `useAdditionalContext` is `true`.
 */


/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSlice__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isIterateeCall__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__toInteger__ = __webpack_require__(12);




/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if ((guard ? Object(__WEBPACK_IMPORTED_MODULE_1__isIterateeCall__["a" /* default */])(array, size, guard) : size === undefined)) {
    size = 1;
  } else {
    size = nativeMax(Object(__WEBPACK_IMPORTED_MODULE_2__toInteger__["a" /* default */])(size), 0);
  }
  var length = array ? array.length : 0;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil(length / size));

  while (index < length) {
    result[resIndex++] = Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice__["a" /* default */])(array, index, (index += size));
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (chunk);


/***/ }),
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array ? array.length : 0,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (compact);


/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayPush__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseFlatten__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__copyArray__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArray__ = __webpack_require__(14);





/**
 * Creates a new array concatenating `array` with any additional arrays
 * and/or values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to concatenate.
 * @param {...*} [values] The values to concatenate.
 * @returns {Array} Returns the new concatenated array.
 * @example
 *
 * var array = [1];
 * var other = _.concat(array, 2, [3], [[4]]);
 *
 * console.log(other);
 * // => [1, 2, 3, [4]]
 *
 * console.log(array);
 * // => [1]
 */
function concat() {
  var length = arguments.length,
      args = Array(length ? length - 1 : 0),
      array = arguments[0],
      index = length;

  while (index--) {
    args[index - 1] = arguments[index];
  }
  return length
    ? Object(__WEBPACK_IMPORTED_MODULE_0__arrayPush__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_3__isArray__["a" /* default */])(array) ? Object(__WEBPACK_IMPORTED_MODULE_2__copyArray__["a" /* default */])(array) : [array], Object(__WEBPACK_IMPORTED_MODULE_1__baseFlatten__["a" /* default */])(args, 1))
    : [];
}

/* harmony default export */ __webpack_exports__["a"] = (concat);


/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseDifference__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseFlatten__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__rest__ = __webpack_require__(7);





/**
 * Creates an array of unique `array` values not included in the other given
 * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. The order of result values is determined by the
 * order they occur in the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([3, 2, 1], [4, 2]);
 * // => [3, 1]
 */
var difference = Object(__WEBPACK_IMPORTED_MODULE_3__rest__["a" /* default */])(function(array, values) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */])(array)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseDifference__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_1__baseFlatten__["a" /* default */])(values, 1, __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */], true))
    : [];
});

/* harmony default export */ __webpack_exports__["a"] = (difference);


/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 0 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (indexOfNaN);


/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseDifference__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseFlatten__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__rest__ = __webpack_require__(7);







/**
 * This method is like `_.difference` except that it accepts `iteratee` which
 * is invoked for each element of `array` and `values` to generate the criterion
 * by which they're compared. Result values are chosen from the first array.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);
 * // => [3.1, 1.3]
 *
 * // The `_.property` iteratee shorthand.
 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
 * // => [{ 'x': 2 }]
 */
var differenceBy = Object(__WEBPACK_IMPORTED_MODULE_5__rest__["a" /* default */])(function(array, values) {
  var iteratee = Object(__WEBPACK_IMPORTED_MODULE_4__last__["a" /* default */])(values);
  if (Object(__WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject__["a" /* default */])(iteratee)) {
    iteratee = undefined;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject__["a" /* default */])(array)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseDifference__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_1__baseFlatten__["a" /* default */])(values, 1, __WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject__["a" /* default */], true), Object(__WEBPACK_IMPORTED_MODULE_2__baseIteratee__["a" /* default */])(iteratee))
    : [];
});

/* harmony default export */ __webpack_exports__["a"] = (differenceBy);


/***/ }),
/* 195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isObject__ = __webpack_require__(16);


/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !Object(__WEBPACK_IMPORTED_MODULE_0__isObject__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (isStrictComparable);


/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (matchesStrictComparable);


/***/ }),
/* 197 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGet__ = __webpack_require__(141);


/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is used in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : Object(__WEBPACK_IMPORTED_MODULE_0__baseGet__["a" /* default */])(object, path);
  return result === undefined ? defaultValue : result;
}

/* harmony default export */ __webpack_exports__["a"] = (get);


/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This method returns the first argument given to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

/* harmony default export */ __webpack_exports__["a"] = (identity);


/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseDifference__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseFlatten__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__rest__ = __webpack_require__(7);






/**
 * This method is like `_.difference` except that it accepts `comparator`
 * which is invoked to compare elements of `array` to `values`. Result values
 * are chosen from the first array. The comparator is invoked with two arguments:
 * (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 *
 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }]
 */
var differenceWith = Object(__WEBPACK_IMPORTED_MODULE_4__rest__["a" /* default */])(function(array, values) {
  var comparator = Object(__WEBPACK_IMPORTED_MODULE_3__last__["a" /* default */])(values);
  if (Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */])(comparator)) {
    comparator = undefined;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */])(array)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseDifference__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_1__baseFlatten__["a" /* default */])(values, 1, __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */], true), undefined, comparator)
    : [];
});

/* harmony default export */ __webpack_exports__["a"] = (differenceWith);


/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseWhile__ = __webpack_require__(104);



/**
 * Creates a slice of `array` excluding elements dropped from the end.
 * Elements are dropped until `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.dropRightWhile(users, function(o) { return !o.active; });
 * // => objects for ['barney']
 *
 * // The `_.matches` iteratee shorthand.
 * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
 * // => objects for ['barney', 'fred']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.dropRightWhile(users, ['active', false]);
 * // => objects for ['barney']
 *
 * // The `_.property` iteratee shorthand.
 * _.dropRightWhile(users, 'active');
 * // => objects for ['barney', 'fred', 'pebbles']
 */
function dropRightWhile(array, predicate) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_1__baseWhile__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_0__baseIteratee__["a" /* default */])(predicate, 3), true, true)
    : [];
}

/* harmony default export */ __webpack_exports__["a"] = (dropRightWhile);


/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseWhile__ = __webpack_require__(104);



/**
 * Creates a slice of `array` excluding elements dropped from the beginning.
 * Elements are dropped until `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.dropWhile(users, function(o) { return !o.active; });
 * // => objects for ['pebbles']
 *
 * // The `_.matches` iteratee shorthand.
 * _.dropWhile(users, { 'user': 'barney', 'active': false });
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.dropWhile(users, ['active', false]);
 * // => objects for ['pebbles']
 *
 * // The `_.property` iteratee shorthand.
 * _.dropWhile(users, 'active');
 * // => objects for ['barney', 'fred', 'pebbles']
 */
function dropWhile(array, predicate) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_1__baseWhile__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_0__baseIteratee__["a" /* default */])(predicate, 3), true)
    : [];
}

/* harmony default export */ __webpack_exports__["a"] = (dropWhile);


/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFill__ = __webpack_require__(399);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isIterateeCall__ = __webpack_require__(77);



/**
 * Fills elements of `array` with `value` from `start` up to, but not
 * including, `end`.
 *
 * **Note:** This method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 3.2.0
 * @category Array
 * @param {Array} array The array to fill.
 * @param {*} value The value to fill `array` with.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3];
 *
 * _.fill(array, 'a');
 * console.log(array);
 * // => ['a', 'a', 'a']
 *
 * _.fill(Array(3), 2);
 * // => [2, 2, 2]
 *
 * _.fill([4, 6, 8, 10], '*', 1, 3);
 * // => [4, '*', '*', 10]
 */
function fill(array, value, start, end) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  if (start && typeof start != 'number' && Object(__WEBPACK_IMPORTED_MODULE_1__isIterateeCall__["a" /* default */])(array, value, start)) {
    start = 0;
    end = length;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseFill__["a" /* default */])(array, value, start, end);
}

/* harmony default export */ __webpack_exports__["a"] = (fill);


/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFindIndex__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIteratee__ = __webpack_require__(10);



/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseFindIndex__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_1__baseIteratee__["a" /* default */])(predicate, 3))
    : -1;
}

/* harmony default export */ __webpack_exports__["a"] = (findIndex);


/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {Function} predicate The function invoked per iteration.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromRight) {
  var length = array.length,
      index = fromRight ? length : -1;

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (baseFindIndex);


/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFindIndex__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIteratee__ = __webpack_require__(10);



/**
 * This method is like `_.findIndex` except that it iterates over elements
 * of `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
 * // => 2
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
 * // => 0
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastIndex(users, ['active', false]);
 * // => 2
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastIndex(users, 'active');
 * // => 0
 */
function findLastIndex(array, predicate) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseFindIndex__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_1__baseIteratee__["a" /* default */])(predicate, 3), true)
    : -1;
}

/* harmony default export */ __webpack_exports__["a"] = (findLastIndex);


/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__head__ = __webpack_require__(144);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__head__["a"]; });



/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFlatten__ = __webpack_require__(24);


/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array ? array.length : 0;
  return length ? Object(__WEBPACK_IMPORTED_MODULE_0__baseFlatten__["a" /* default */])(array, 1) : [];
}

/* harmony default export */ __webpack_exports__["a"] = (flatten);


/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFlatten__ = __webpack_require__(24);


/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Recursively flattens `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flattenDeep([1, [2, [3, [4]], 5]]);
 * // => [1, 2, 3, 4, 5]
 */
function flattenDeep(array) {
  var length = array ? array.length : 0;
  return length ? Object(__WEBPACK_IMPORTED_MODULE_0__baseFlatten__["a" /* default */])(array, INFINITY) : [];
}

/* harmony default export */ __webpack_exports__["a"] = (flattenDeep);


/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFlatten__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger__ = __webpack_require__(12);



/**
 * Recursively flatten `array` up to `depth` times.
 *
 * @static
 * @memberOf _
 * @since 4.4.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @param {number} [depth=1] The maximum recursion depth.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * var array = [1, [2, [3, [4]], 5]];
 *
 * _.flattenDepth(array, 1);
 * // => [1, 2, [3, [4]], 5]
 *
 * _.flattenDepth(array, 2);
 * // => [1, 2, 3, [4], 5]
 */
function flattenDepth(array, depth) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  depth = depth === undefined ? 1 : Object(__WEBPACK_IMPORTED_MODULE_1__toInteger__["a" /* default */])(depth);
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseFlatten__["a" /* default */])(array, depth);
}

/* harmony default export */ __webpack_exports__["a"] = (flattenDepth);


/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['fred', 30], ['barney', 40]]);
 * // => { 'fred': 30, 'barney': 40 }
 */
function fromPairs(pairs) {
  var index = -1,
      length = pairs ? pairs.length : 0,
      result = {};

  while (++index < length) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (fromPairs);


/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIndexOf__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger__ = __webpack_require__(12);



/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  fromIndex = Object(__WEBPACK_IMPORTED_MODULE_1__toInteger__["a" /* default */])(fromIndex);
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseIndexOf__["a" /* default */])(array, value, fromIndex);
}

/* harmony default export */ __webpack_exports__["a"] = (indexOf);


/***/ }),
/* 212 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dropRight__ = __webpack_require__(143);


/**
 * Gets all but the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.initial([1, 2, 3]);
 * // => [1, 2]
 */
function initial(array) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__dropRight__["a" /* default */])(array, 1);
}

/* harmony default export */ __webpack_exports__["a"] = (initial);


/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIntersection__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__castArrayLikeObject__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__rest__ = __webpack_require__(7);





/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. The order of result values is determined by the
 * order they occur in the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [4, 2], [1, 2]);
 * // => [2]
 */
var intersection = Object(__WEBPACK_IMPORTED_MODULE_3__rest__["a" /* default */])(function(arrays) {
  var mapped = Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap__["a" /* default */])(arrays, __WEBPACK_IMPORTED_MODULE_2__castArrayLikeObject__["a" /* default */]);
  return (mapped.length && mapped[0] === arrays[0])
    ? Object(__WEBPACK_IMPORTED_MODULE_1__baseIntersection__["a" /* default */])(mapped)
    : [];
});

/* harmony default export */ __webpack_exports__["a"] = (intersection);


/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIntersection__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__castArrayLikeObject__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__rest__ = __webpack_require__(7);







/**
 * This method is like `_.intersection` except that it accepts `iteratee`
 * which is invoked for each element of each `arrays` to generate the criterion
 * by which they're compared. Result values are chosen from the first array.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
 * // => [2.1]
 *
 * // The `_.property` iteratee shorthand.
 * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }]
 */
var intersectionBy = Object(__WEBPACK_IMPORTED_MODULE_5__rest__["a" /* default */])(function(arrays) {
  var iteratee = Object(__WEBPACK_IMPORTED_MODULE_4__last__["a" /* default */])(arrays),
      mapped = Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap__["a" /* default */])(arrays, __WEBPACK_IMPORTED_MODULE_3__castArrayLikeObject__["a" /* default */]);

  if (iteratee === Object(__WEBPACK_IMPORTED_MODULE_4__last__["a" /* default */])(mapped)) {
    iteratee = undefined;
  } else {
    mapped.pop();
  }
  return (mapped.length && mapped[0] === arrays[0])
    ? Object(__WEBPACK_IMPORTED_MODULE_1__baseIntersection__["a" /* default */])(mapped, Object(__WEBPACK_IMPORTED_MODULE_2__baseIteratee__["a" /* default */])(iteratee))
    : [];
});

/* harmony default export */ __webpack_exports__["a"] = (intersectionBy);


/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIntersection__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__castArrayLikeObject__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__rest__ = __webpack_require__(7);






/**
 * This method is like `_.intersection` except that it accepts `comparator`
 * which is invoked to compare elements of `arrays`. Result values are chosen
 * from the first array. The comparator is invoked with two arguments:
 * (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.intersectionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }]
 */
var intersectionWith = Object(__WEBPACK_IMPORTED_MODULE_4__rest__["a" /* default */])(function(arrays) {
  var comparator = Object(__WEBPACK_IMPORTED_MODULE_3__last__["a" /* default */])(arrays),
      mapped = Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap__["a" /* default */])(arrays, __WEBPACK_IMPORTED_MODULE_2__castArrayLikeObject__["a" /* default */]);

  if (comparator === Object(__WEBPACK_IMPORTED_MODULE_3__last__["a" /* default */])(mapped)) {
    comparator = undefined;
  } else {
    mapped.pop();
  }
  return (mapped.length && mapped[0] === arrays[0])
    ? Object(__WEBPACK_IMPORTED_MODULE_1__baseIntersection__["a" /* default */])(mapped, undefined, comparator)
    : [];
});

/* harmony default export */ __webpack_exports__["a"] = (intersectionWith);


/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var arrayProto = Array.prototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeJoin = arrayProto.join;

/**
 * Converts all elements in `array` into a string separated by `separator`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to convert.
 * @param {string} [separator=','] The element separator.
 * @returns {string} Returns the joined string.
 * @example
 *
 * _.join(['a', 'b', 'c'], '~');
 * // => 'a~b~c'
 */
function join(array, separator) {
  return array ? nativeJoin.call(array, separator) : '';
}

/* harmony default export */ __webpack_exports__["a"] = (join);


/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__indexOfNaN__ = __webpack_require__(193);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger__ = __webpack_require__(12);



/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * This method is like `_.indexOf` except that it iterates over elements of
 * `array` from right to left.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.lastIndexOf([1, 2, 1, 2], 2);
 * // => 3
 *
 * // Search from the `fromIndex`.
 * _.lastIndexOf([1, 2, 1, 2], 2, 2);
 * // => 1
 */
function lastIndexOf(array, value, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = length;
  if (fromIndex !== undefined) {
    index = Object(__WEBPACK_IMPORTED_MODULE_1__toInteger__["a" /* default */])(fromIndex);
    index = (
      index < 0
        ? nativeMax(length + index, 0)
        : nativeMin(index, length - 1)
    ) + 1;
  }
  if (value !== value) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__indexOfNaN__["a" /* default */])(array, index, true);
  }
  while (index--) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (lastIndexOf);


/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseNth__ = __webpack_require__(402);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger__ = __webpack_require__(12);



/**
 * Gets the element at `n` index of `array`. If `n` is negative, the nth
 * element from the end is returned.
 *
 * @static
 * @memberOf _
 * @since 4.11.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=0] The index of the element to return.
 * @returns {*} Returns the nth element of `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'd'];
 *
 * _.nth(array, 1);
 * // => 'b'
 *
 * _.nth(array, -2);
 * // => 'c';
 */
function nth(array, n) {
  return (array && array.length) ? Object(__WEBPACK_IMPORTED_MODULE_0__baseNth__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_1__toInteger__["a" /* default */])(n)) : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (nth);


/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pullAll__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rest__ = __webpack_require__(7);



/**
 * Removes all given values from `array` using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
 * to remove elements from an array by predicate.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...*} [values] The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3, 1, 2, 3];
 *
 * _.pull(array, 2, 3);
 * console.log(array);
 * // => [1, 1]
 */
var pull = Object(__WEBPACK_IMPORTED_MODULE_1__rest__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__pullAll__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (pull);


/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__basePullAll__ = __webpack_require__(148);



/**
 * This method is like `_.pullAll` except that it accepts `iteratee` which is
 * invoked for each element of `array` and `values` to generate the criterion
 * by which they're compared. The iteratee is invoked with one argument: (value).
 *
 * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
 *
 * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
 * console.log(array);
 * // => [{ 'x': 2 }]
 */
function pullAllBy(array, values, iteratee) {
  return (array && array.length && values && values.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_1__basePullAll__["a" /* default */])(array, values, Object(__WEBPACK_IMPORTED_MODULE_0__baseIteratee__["a" /* default */])(iteratee))
    : array;
}

/* harmony default export */ __webpack_exports__["a"] = (pullAllBy);


/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basePullAll__ = __webpack_require__(148);


/**
 * This method is like `_.pullAll` except that it accepts `comparator` which
 * is invoked to compare elements of `array` to `values`. The comparator is
 * invoked with two arguments: (arrVal, othVal).
 *
 * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.6.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
 *
 * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
 * console.log(array);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
 */
function pullAllWith(array, values, comparator) {
  return (array && array.length && values && values.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__basePullAll__["a" /* default */])(array, values, undefined, comparator)
    : array;
}

/* harmony default export */ __webpack_exports__["a"] = (pullAllWith);


/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseAt__ = __webpack_require__(404);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseFlatten__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__basePullAt__ = __webpack_require__(223);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__compareAscending__ = __webpack_require__(406);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__isIndex__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__rest__ = __webpack_require__(7);








/**
 * Removes elements from `array` corresponding to `indexes` and returns an
 * array of removed elements.
 *
 * **Note:** Unlike `_.at`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...(number|number[])} [indexes] The indexes of elements to remove.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [5, 10, 15, 20];
 * var evens = _.pullAt(array, 1, 3);
 *
 * console.log(array);
 * // => [5, 15]
 *
 * console.log(evens);
 * // => [10, 20]
 */
var pullAt = Object(__WEBPACK_IMPORTED_MODULE_6__rest__["a" /* default */])(function(array, indexes) {
  indexes = Object(__WEBPACK_IMPORTED_MODULE_2__baseFlatten__["a" /* default */])(indexes, 1);

  var length = array ? array.length : 0,
      result = Object(__WEBPACK_IMPORTED_MODULE_1__baseAt__["a" /* default */])(array, indexes);

  Object(__WEBPACK_IMPORTED_MODULE_3__basePullAt__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap__["a" /* default */])(indexes, function(index) {
    return Object(__WEBPACK_IMPORTED_MODULE_5__isIndex__["a" /* default */])(index, length) ? +index : index;
  }).sort(__WEBPACK_IMPORTED_MODULE_4__compareAscending__["a" /* default */]));

  return result;
});

/* harmony default export */ __webpack_exports__["a"] = (pullAt);


/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__castPath__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isIndex__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isKey__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__parent__ = __webpack_require__(405);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__toKey__ = __webpack_require__(57);







/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * The base implementation of `_.pullAt` without support for individual
 * indexes or capturing the removed elements.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {number[]} indexes The indexes of elements to remove.
 * @returns {Array} Returns `array`.
 */
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0,
      lastIndex = length - 1;

  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (Object(__WEBPACK_IMPORTED_MODULE_1__isIndex__["a" /* default */])(index)) {
        splice.call(array, index, 1);
      }
      else if (!Object(__WEBPACK_IMPORTED_MODULE_2__isKey__["a" /* default */])(index, array)) {
        var path = Object(__WEBPACK_IMPORTED_MODULE_0__castPath__["a" /* default */])(index),
            object = Object(__WEBPACK_IMPORTED_MODULE_4__parent__["a" /* default */])(array, path);

        if (object != null) {
          delete object[Object(__WEBPACK_IMPORTED_MODULE_5__toKey__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_3__last__["a" /* default */])(path))];
        }
      }
      else {
        delete array[Object(__WEBPACK_IMPORTED_MODULE_5__toKey__["a" /* default */])(index)];
      }
    }
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (basePullAt);


/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__basePullAt__ = __webpack_require__(223);



/**
 * Removes all elements from `array` that `predicate` returns truthy for
 * and returns an array of the removed elements. The predicate is invoked
 * with three arguments: (value, index, array).
 *
 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
 * to pull elements from an array by value.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [1, 2, 3, 4];
 * var evens = _.remove(array, function(n) {
 *   return n % 2 == 0;
 * });
 *
 * console.log(array);
 * // => [1, 3]
 *
 * console.log(evens);
 * // => [2, 4]
 */
function remove(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index = -1,
      indexes = [],
      length = array.length;

  predicate = Object(__WEBPACK_IMPORTED_MODULE_0__baseIteratee__["a" /* default */])(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result.push(value);
      indexes.push(index);
    }
  }
  Object(__WEBPACK_IMPORTED_MODULE_1__basePullAt__["a" /* default */])(array, indexes);
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (remove);


/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var arrayProto = Array.prototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeReverse = arrayProto.reverse;

/**
 * Reverses `array` so that the first element becomes the last, the second
 * element becomes the second to last, and so on.
 *
 * **Note:** This method mutates `array` and is based on
 * [`Array#reverse`](https://mdn.io/Array/reverse).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3];
 *
 * _.reverse(array);
 * // => [3, 2, 1]
 *
 * console.log(array);
 * // => [3, 2, 1]
 */
function reverse(array) {
  return array ? nativeReverse.call(array) : array;
}

/* harmony default export */ __webpack_exports__["a"] = (reverse);


/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSlice__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isIterateeCall__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__toInteger__ = __webpack_require__(12);




/**
 * Creates a slice of `array` from `start` up to, but not including, `end`.
 *
 * **Note:** This method is used instead of
 * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
 * returned.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function slice(array, start, end) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  if (end && typeof end != 'number' && Object(__WEBPACK_IMPORTED_MODULE_1__isIterateeCall__["a" /* default */])(array, start, end)) {
    start = 0;
    end = length;
  }
  else {
    start = start == null ? 0 : Object(__WEBPACK_IMPORTED_MODULE_2__toInteger__["a" /* default */])(start);
    end = end === undefined ? length : Object(__WEBPACK_IMPORTED_MODULE_2__toInteger__["a" /* default */])(end);
  }
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice__["a" /* default */])(array, start, end);
}

/* harmony default export */ __webpack_exports__["a"] = (slice);


/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSortedIndex__ = __webpack_require__(105);


/**
 * Uses a binary search to determine the lowest index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedIndex([30, 50], 40);
 * // => 1
 *
 * _.sortedIndex([4, 5], 4);
 * // => 0
 */
function sortedIndex(array, value) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSortedIndex__["a" /* default */])(array, value);
}

/* harmony default export */ __webpack_exports__["a"] = (sortedIndex);


/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseSortedIndexBy__ = __webpack_require__(149);



/**
 * This method is like `_.sortedIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
 *
 * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
 * // => 1
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
 * // => 0
 */
function sortedIndexBy(array, value, iteratee) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__baseSortedIndexBy__["a" /* default */])(array, value, Object(__WEBPACK_IMPORTED_MODULE_0__baseIteratee__["a" /* default */])(iteratee));
}

/* harmony default export */ __webpack_exports__["a"] = (sortedIndexBy);


/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSortedIndex__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__eq__ = __webpack_require__(52);



/**
 * This method is like `_.indexOf` except that it performs a binary
 * search on a sorted `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.sortedIndexOf([1, 1, 2, 2], 2);
 * // => 2
 */
function sortedIndexOf(array, value) {
  var length = array ? array.length : 0;
  if (length) {
    var index = Object(__WEBPACK_IMPORTED_MODULE_0__baseSortedIndex__["a" /* default */])(array, value);
    if (index < length && Object(__WEBPACK_IMPORTED_MODULE_1__eq__["a" /* default */])(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (sortedIndexOf);


/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSortedIndex__ = __webpack_require__(105);


/**
 * This method is like `_.sortedIndex` except that it returns the highest
 * index at which `value` should be inserted into `array` in order to
 * maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedLastIndex([4, 5], 4);
 * // => 1
 */
function sortedLastIndex(array, value) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSortedIndex__["a" /* default */])(array, value, true);
}

/* harmony default export */ __webpack_exports__["a"] = (sortedLastIndex);


/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseSortedIndexBy__ = __webpack_require__(149);



/**
 * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
 * // => 1
 */
function sortedLastIndexBy(array, value, iteratee) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__baseSortedIndexBy__["a" /* default */])(array, value, Object(__WEBPACK_IMPORTED_MODULE_0__baseIteratee__["a" /* default */])(iteratee), true);
}

/* harmony default export */ __webpack_exports__["a"] = (sortedLastIndexBy);


/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSortedIndex__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__eq__ = __webpack_require__(52);



/**
 * This method is like `_.lastIndexOf` except that it performs a binary
 * search on a sorted `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.sortedLastIndexOf([1, 1, 2, 2], 2);
 * // => 3
 */
function sortedLastIndexOf(array, value) {
  var length = array ? array.length : 0;
  if (length) {
    var index = Object(__WEBPACK_IMPORTED_MODULE_0__baseSortedIndex__["a" /* default */])(array, value, true) - 1;
    if (Object(__WEBPACK_IMPORTED_MODULE_1__eq__["a" /* default */])(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (sortedLastIndexOf);


/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSortedUniq__ = __webpack_require__(234);


/**
 * This method is like `_.uniq` except that it's designed and optimized
 * for sorted arrays.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.sortedUniq([1, 1, 2]);
 * // => [1, 2]
 */
function sortedUniq(array) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseSortedUniq__["a" /* default */])(array)
    : [];
}

/* harmony default export */ __webpack_exports__["a"] = (sortedUniq);


/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__eq__ = __webpack_require__(52);


/**
 * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseSortedUniq(array, iteratee) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    if (!index || !Object(__WEBPACK_IMPORTED_MODULE_0__eq__["a" /* default */])(computed, seen)) {
      var seen = computed;
      result[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseSortedUniq);


/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseSortedUniq__ = __webpack_require__(234);



/**
 * This method is like `_.uniqBy` except that it's designed and optimized
 * for sorted arrays.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
 * // => [1.1, 2.3]
 */
function sortedUniqBy(array, iteratee) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_1__baseSortedUniq__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_0__baseIteratee__["a" /* default */])(iteratee))
    : [];
}

/* harmony default export */ __webpack_exports__["a"] = (sortedUniqBy);


/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__drop__ = __webpack_require__(142);


/**
 * Gets all but the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.tail([1, 2, 3]);
 * // => [2, 3]
 */
function tail(array) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__drop__["a" /* default */])(array, 1);
}

/* harmony default export */ __webpack_exports__["a"] = (tail);


/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSlice__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger__ = __webpack_require__(12);



/**
 * Creates a slice of `array` with `n` elements taken from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.take([1, 2, 3]);
 * // => [1]
 *
 * _.take([1, 2, 3], 2);
 * // => [1, 2]
 *
 * _.take([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.take([1, 2, 3], 0);
 * // => []
 */
function take(array, n, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : Object(__WEBPACK_IMPORTED_MODULE_1__toInteger__["a" /* default */])(n);
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice__["a" /* default */])(array, 0, n < 0 ? 0 : n);
}

/* harmony default export */ __webpack_exports__["a"] = (take);


/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSlice__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger__ = __webpack_require__(12);



/**
 * Creates a slice of `array` with `n` elements taken from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.takeRight([1, 2, 3]);
 * // => [3]
 *
 * _.takeRight([1, 2, 3], 2);
 * // => [2, 3]
 *
 * _.takeRight([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.takeRight([1, 2, 3], 0);
 * // => []
 */
function takeRight(array, n, guard) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : Object(__WEBPACK_IMPORTED_MODULE_1__toInteger__["a" /* default */])(n);
  n = length - n;
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice__["a" /* default */])(array, n < 0 ? 0 : n, length);
}

/* harmony default export */ __webpack_exports__["a"] = (takeRight);


/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseWhile__ = __webpack_require__(104);



/**
 * Creates a slice of `array` with elements taken from the end. Elements are
 * taken until `predicate` returns falsey. The predicate is invoked with
 * three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.takeRightWhile(users, function(o) { return !o.active; });
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.matches` iteratee shorthand.
 * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
 * // => objects for ['pebbles']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.takeRightWhile(users, ['active', false]);
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.property` iteratee shorthand.
 * _.takeRightWhile(users, 'active');
 * // => []
 */
function takeRightWhile(array, predicate) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_1__baseWhile__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_0__baseIteratee__["a" /* default */])(predicate, 3), false, true)
    : [];
}

/* harmony default export */ __webpack_exports__["a"] = (takeRightWhile);


/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseWhile__ = __webpack_require__(104);



/**
 * Creates a slice of `array` with elements taken from the beginning. Elements
 * are taken until `predicate` returns falsey. The predicate is invoked with
 * three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false},
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.takeWhile(users, function(o) { return !o.active; });
 * // => objects for ['barney', 'fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.takeWhile(users, { 'user': 'barney', 'active': false });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.takeWhile(users, ['active', false]);
 * // => objects for ['barney', 'fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.takeWhile(users, 'active');
 * // => []
 */
function takeWhile(array, predicate) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_1__baseWhile__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_0__baseIteratee__["a" /* default */])(predicate, 3))
    : [];
}

/* harmony default export */ __webpack_exports__["a"] = (takeWhile);


/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFlatten__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseUniq__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__rest__ = __webpack_require__(7);





/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2, 1], [4, 2], [1, 2]);
 * // => [2, 1, 4]
 */
var union = Object(__WEBPACK_IMPORTED_MODULE_3__rest__["a" /* default */])(function(arrays) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__baseUniq__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__baseFlatten__["a" /* default */])(arrays, 1, __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */], true));
});

/* harmony default export */ __webpack_exports__["a"] = (union);


/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFlatten__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseUniq__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__rest__ = __webpack_require__(7);







/**
 * This method is like `_.union` except that it accepts `iteratee` which is
 * invoked for each element of each `arrays` to generate the criterion by
 * which uniqueness is computed. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
 * // => [2.1, 1.2, 4.3]
 *
 * // The `_.property` iteratee shorthand.
 * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
var unionBy = Object(__WEBPACK_IMPORTED_MODULE_5__rest__["a" /* default */])(function(arrays) {
  var iteratee = Object(__WEBPACK_IMPORTED_MODULE_4__last__["a" /* default */])(arrays);
  if (Object(__WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject__["a" /* default */])(iteratee)) {
    iteratee = undefined;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_2__baseUniq__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__baseFlatten__["a" /* default */])(arrays, 1, __WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject__["a" /* default */], true), Object(__WEBPACK_IMPORTED_MODULE_1__baseIteratee__["a" /* default */])(iteratee));
});

/* harmony default export */ __webpack_exports__["a"] = (unionBy);


/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFlatten__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseUniq__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__rest__ = __webpack_require__(7);






/**
 * This method is like `_.union` except that it accepts `comparator` which
 * is invoked to compare elements of `arrays`. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.unionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
var unionWith = Object(__WEBPACK_IMPORTED_MODULE_4__rest__["a" /* default */])(function(arrays) {
  var comparator = Object(__WEBPACK_IMPORTED_MODULE_3__last__["a" /* default */])(arrays);
  if (Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */])(comparator)) {
    comparator = undefined;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_1__baseUniq__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__baseFlatten__["a" /* default */])(arrays, 1, __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */], true), undefined, comparator);
});

/* harmony default export */ __webpack_exports__["a"] = (unionWith);


/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseUniq__ = __webpack_require__(48);


/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseUniq__["a" /* default */])(array)
    : [];
}

/* harmony default export */ __webpack_exports__["a"] = (uniq);


/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseUniq__ = __webpack_require__(48);



/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniqBy(array, iteratee) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_1__baseUniq__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_0__baseIteratee__["a" /* default */])(iteratee))
    : [];
}

/* harmony default export */ __webpack_exports__["a"] = (uniqBy);


/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseUniq__ = __webpack_require__(48);


/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The comparator is invoked with
 * two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */
function uniqWith(array, comparator) {
  return (array && array.length)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseUniq__["a" /* default */])(array, undefined, comparator)
    : [];
}

/* harmony default export */ __webpack_exports__["a"] = (uniqWith);


/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseDifference__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArrayLikeObject__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__rest__ = __webpack_require__(7);




/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([1, 2, 1, 3], 1, 2);
 * // => [3]
 */
var without = Object(__WEBPACK_IMPORTED_MODULE_2__rest__["a" /* default */])(function(array, values) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__isArrayLikeObject__["a" /* default */])(array)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseDifference__["a" /* default */])(array, values)
    : [];
});

/* harmony default export */ __webpack_exports__["a"] = (without);


/***/ }),
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayFilter__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseXor__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__rest__ = __webpack_require__(7);





/**
 * Creates an array of unique values that is the
 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
 * of the given arrays. The order of result values is determined by the order
 * they occur in the arrays.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.without
 * @example
 *
 * _.xor([2, 1], [4, 2]);
 * // => [1, 4]
 */
var xor = Object(__WEBPACK_IMPORTED_MODULE_3__rest__["a" /* default */])(function(arrays) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__baseXor__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__arrayFilter__["a" /* default */])(arrays, __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */]));
});

/* harmony default export */ __webpack_exports__["a"] = (xor);


/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayFilter__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIteratee__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseXor__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__rest__ = __webpack_require__(7);







/**
 * This method is like `_.xor` except that it accepts `iteratee` which is
 * invoked for each element of each `arrays` to generate the criterion by
 * which by which they're compared. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);
 * // => [1.2, 4.3]
 *
 * // The `_.property` iteratee shorthand.
 * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 2 }]
 */
var xorBy = Object(__WEBPACK_IMPORTED_MODULE_5__rest__["a" /* default */])(function(arrays) {
  var iteratee = Object(__WEBPACK_IMPORTED_MODULE_4__last__["a" /* default */])(arrays);
  if (Object(__WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject__["a" /* default */])(iteratee)) {
    iteratee = undefined;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_2__baseXor__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__arrayFilter__["a" /* default */])(arrays, __WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject__["a" /* default */]), Object(__WEBPACK_IMPORTED_MODULE_1__baseIteratee__["a" /* default */])(iteratee));
});

/* harmony default export */ __webpack_exports__["a"] = (xorBy);


/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayFilter__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseXor__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__rest__ = __webpack_require__(7);






/**
 * This method is like `_.xor` except that it accepts `comparator` which is
 * invoked to compare elements of `arrays`. The comparator is invoked with
 * two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.xorWith(objects, others, _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
var xorWith = Object(__WEBPACK_IMPORTED_MODULE_4__rest__["a" /* default */])(function(arrays) {
  var comparator = Object(__WEBPACK_IMPORTED_MODULE_3__last__["a" /* default */])(arrays);
  if (Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */])(comparator)) {
    comparator = undefined;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_1__baseXor__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__arrayFilter__["a" /* default */])(arrays, __WEBPACK_IMPORTED_MODULE_2__isArrayLikeObject__["a" /* default */]), undefined, comparator);
});

/* harmony default export */ __webpack_exports__["a"] = (xorWith);


/***/ }),
/* 251 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rest__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__unzip__ = __webpack_require__(106);



/**
 * Creates an array of grouped elements, the first of which contains the
 * first elements of the given arrays, the second of which contains the
 * second elements of the given arrays, and so on.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zip(['fred', 'barney'], [30, 40], [true, false]);
 * // => [['fred', 30, true], ['barney', 40, false]]
 */
var zip = Object(__WEBPACK_IMPORTED_MODULE_0__rest__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__unzip__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (zip);


/***/ }),
/* 252 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assignValue__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseZipObject__ = __webpack_require__(253);



/**
 * This method is like `_.fromPairs` except that it accepts two arrays,
 * one of property identifiers and one of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 0.4.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObject(['a', 'b'], [1, 2]);
 * // => { 'a': 1, 'b': 2 }
 */
function zipObject(props, values) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__baseZipObject__["a" /* default */])(props || [], values || [], __WEBPACK_IMPORTED_MODULE_0__assignValue__["a" /* default */]);
}

/* harmony default export */ __webpack_exports__["a"] = (zipObject);


/***/ }),
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */
function baseZipObject(props, values, assignFunc) {
  var index = -1,
      length = props.length,
      valsLength = values.length,
      result = {};

  while (++index < length) {
    var value = index < valsLength ? values[index] : undefined;
    assignFunc(result, props[index], value);
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseZipObject);


/***/ }),
/* 254 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSet__ = __webpack_require__(409);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseZipObject__ = __webpack_require__(253);



/**
 * This method is like `_.zipObject` except that it supports property paths.
 *
 * @static
 * @memberOf _
 * @since 4.1.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
 * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
 */
function zipObjectDeep(props, values) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__baseZipObject__["a" /* default */])(props || [], values || [], __WEBPACK_IMPORTED_MODULE_0__baseSet__["a" /* default */]);
}

/* harmony default export */ __webpack_exports__["a"] = (zipObjectDeep);


/***/ }),
/* 255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rest__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__unzipWith__ = __webpack_require__(150);



/**
 * This method is like `_.zip` except that it accepts `iteratee` to specify
 * how grouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @param {Function} [iteratee=_.identity] The function to combine grouped values.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
 *   return a + b + c;
 * });
 * // => [111, 222]
 */
var zipWith = Object(__WEBPACK_IMPORTED_MODULE_0__rest__["a" /* default */])(function(arrays) {
  var length = arrays.length,
      iteratee = length > 1 ? arrays[length - 1] : undefined;

  iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
  return Object(__WEBPACK_IMPORTED_MODULE_1__unzipWith__["a" /* default */])(arrays, iteratee);
});

/* harmony default export */ __webpack_exports__["a"] = (zipWith);


/***/ }),
/* 256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__liverange__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__text__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__textproxy__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_tomap__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_log__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__selection__ = __webpack_require__(108);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/documentselection
 */












const storePrefix = 'selection:';

const attrOpTypes = new Set(
	[ 'addAttribute', 'removeAttribute', 'changeAttribute', 'addRootAttribute', 'removeRootAttribute', 'changeRootAttribute' ]
);

/**
 * `DocumentSelection` is a special selection which is used as the
 * {@link module:engine/model/document~Document#selection document's selection}.
 * There can be only one instance of `DocumentSelection` per document.
 *
 * `DocumentSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}
 * to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.
 *
 * Differences between {@link module:engine/model/selection~Selection} and `DocumentSelection` are:
 * * there is always a range in `DocumentSelection` - even if no ranges were added there is a "default range"
 * present in the selection,
 * * ranges added to this selection updates automatically when the document changes,
 * * attributes of `DocumentSelection` are updated automatically according to selection ranges.
 *
 * Since `DocumentSelection` uses {@link module:engine/model/liverange~LiveRange live ranges}
 * and is updated when {@link module:engine/model/document~Document document}
 * changes, it cannot be set on {@link module:engine/model/node~Node nodes}
 * that are inside {@link module:engine/model/documentfragment~DocumentFragment document fragment}.
 * If you need to represent a selection in document fragment,
 * use {@link module:engine/model/selection~Selection Selection class} instead.
 *
 * @extends module:engine/model/selection~Selection
 */
class DocumentSelection extends __WEBPACK_IMPORTED_MODULE_8__selection__["a" /* default */] {
	/**
	 * Creates an empty live selection for given {@link module:engine/model/document~Document}.
	 *
	 * @param {module:engine/model/document~Document} document Document which owns this selection.
	 */
	constructor( document ) {
		super();

		/**
		 * Document which owns this selection.
		 *
		 * @protected
		 * @member {module:engine/model/document~Document} module:engine/model/documentselection~DocumentSelection#_document
		 */
		this._document = document;

		/**
		 * Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)
		 * last time. Possible values of priority are: `'low'` and `'normal'`.
		 *
		 * Priorities are used by internal `DocumentSelection` mechanisms. All attributes set using `DocumentSelection`
		 * attributes API are set with `'normal'` priority.
		 *
		 * @private
		 * @member {Map} module:engine/model/documentselection~DocumentSelection#_attributePriority
		 */
		this._attributePriority = new Map();

		this.listenTo( this._document, 'change', ( evt, type, changes, batch ) => {
			// Whenever attribute operation is performed on document, update selection attributes.
			// This is not the most efficient way to update selection attributes, but should be okay for now.
			if ( attrOpTypes.has( type ) ) {
				this._updateAttributes( false );
			}

			// Whenever element which had selection's attributes stored in it stops being empty,
			// the attributes need to be removed.
			clearAttributesStoredInElement( changes, batch, this._document );
		} );
	}

	/**
	 * @inheritDoc
	 */
	get isCollapsed() {
		const length = this._ranges.length;

		return length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
	}

	/**
	 * @inheritDoc
	 */
	get anchor() {
		return super.anchor || this._document._getDefaultRange().start;
	}

	/**
	 * @inheritDoc
	 */
	get focus() {
		return super.focus || this._document._getDefaultRange().end;
	}

	/**
	 * @inheritDoc
	 */
	get rangeCount() {
		return this._ranges.length ? this._ranges.length : 1;
	}

	/**
	 * Describes whether `DocumentSelection` has own range(s) set, or if it is defaulted to
	 * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get hasOwnRange() {
		return this._ranges.length > 0;
	}

	/**
	 * Unbinds all events previously bound by document selection.
	 */
	destroy() {
		for ( let i = 0; i < this._ranges.length; i++ ) {
			this._ranges[ i ].detach();
		}

		this.stopListening();
	}

	/**
	 * @inheritDoc
	 */
	* getRanges() {
		if ( this._ranges.length ) {
			yield* super.getRanges();
		} else {
			yield this._document._getDefaultRange();
		}
	}

	/**
	 * @inheritDoc
	 */
	getFirstRange() {
		return super.getFirstRange() || this._document._getDefaultRange();
	}

	/**
	 * @inheritDoc
	 */
	getLastRange() {
		return super.getLastRange() || this._document._getDefaultRange();
	}

	/**
	 * @inheritDoc
	 */
	addRange( range, isBackward = false ) {
		super.addRange( range, isBackward );
		this.refreshAttributes();
	}

	/**
	 * @inheritDoc
	 */
	removeAllRanges() {
		super.removeAllRanges();
		this.refreshAttributes();
	}

	/**
	 * @inheritDoc
	 */
	setRanges( newRanges, isLastBackward = false ) {
		super.setRanges( newRanges, isLastBackward );
		this.refreshAttributes();
	}

	/**
	 * @inheritDoc
	 */
	setAttribute( key, value ) {
		// Store attribute in parent element if the selection is collapsed in an empty node.
		if ( this.isCollapsed && this.anchor.parent.isEmpty ) {
			this._storeAttribute( key, value );
		}

		if ( this._setAttribute( key, value ) ) {
			// Fire event with exact data.
			const attributeKeys = [ key ];
			this.fire( 'change:attribute', { attributeKeys, directChange: true } );
		}
	}

	/**
	 * @inheritDoc
	 */
	removeAttribute( key ) {
		// Remove stored attribute from parent element if the selection is collapsed in an empty node.
		if ( this.isCollapsed && this.anchor.parent.isEmpty ) {
			this._removeStoredAttribute( key );
		}

		if ( this._removeAttribute( key ) ) {
			// Fire event with exact data.
			const attributeKeys = [ key ];
			this.fire( 'change:attribute', { attributeKeys, directChange: true } );
		}
	}

	/**
	 * @inheritDoc
	 */
	setAttributesTo( attrs ) {
		attrs = Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_tomap__["a" /* default */])( attrs );

		if ( this.isCollapsed && this.anchor.parent.isEmpty ) {
			this._setStoredAttributesTo( attrs );
		}

		const changed = this._setAttributesTo( attrs );

		if ( changed.size > 0 ) {
			// Fire event with exact data (fire only if anything changed).
			const attributeKeys = Array.from( changed );
			this.fire( 'change:attribute', { attributeKeys, directChange: true } );
		}
	}

	/**
	 * @inheritDoc
	 */
	clearAttributes() {
		this.setAttributesTo( [] );
	}

	/**
	 * Removes all attributes from the selection and sets attributes according to the surrounding nodes.
	 */
	refreshAttributes() {
		this._updateAttributes( true );
	}

	/**
	 * This method is not available in `DocumentSelection`. There can be only one
	 * `DocumentSelection` per document instance, so creating new `DocumentSelection`s this way
	 * would be unsafe.
	 */
	static createFromSelection() {
		/**
		 * Cannot create a new `DocumentSelection` instance.
		 *
		 * `DocumentSelection#createFromSelection()` is not available. There can be only one
		 * `DocumentSelection` per document instance, so creating new `DocumentSelection`s this way
		 * would be unsafe.
		 *
		 * @error documentselection-cannot-create
		 */
		throw new __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'documentselection-cannot-create: Cannot create a new DocumentSelection instance.' );
	}

	/**
	 * @inheritDoc
	 */
	_popRange() {
		this._ranges.pop().detach();
	}

	/**
	 * @inheritDoc
	 */
	_pushRange( range ) {
		const liveRange = this._prepareRange( range );

		// `undefined` is returned when given `range` is in graveyard root.
		if ( liveRange ) {
			this._ranges.push( liveRange );
		}
	}

	/**
	 * Prepares given range to be added to selection. Checks if it is correct,
	 * converts it to {@link module:engine/model/liverange~LiveRange LiveRange}
	 * and sets listeners listening to the range's change event.
	 *
	 * @private
	 * @param {module:engine/model/range~Range} range
	 */
	_prepareRange( range ) {
		if ( !( range instanceof __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */] ) ) {
			/**
			 * Trying to add an object that is not an instance of Range.
			 *
			 * @error model-selection-added-not-range
			 */
			throw new __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-selection-added-not-range: Trying to add an object that is not an instance of Range.' );
		}

		if ( range.root == this._document.graveyard ) {
			/**
			 * Trying to add a Range that is in the graveyard root. Range rejected.
			 *
			 * @warning model-selection-range-in-graveyard
			 */
			__WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_log__["a" /* default */].warn( 'model-selection-range-in-graveyard: Trying to add a Range that is in the graveyard root. Range rejected.' );

			return;
		}

		this._checkRange( range );

		const liveRange = __WEBPACK_IMPORTED_MODULE_2__liverange__["a" /* default */].createFromRange( range );

		this.listenTo( liveRange, 'change:range', ( evt, oldRange, data ) => {
			// If `LiveRange` is in whole moved to the graveyard, fix that range.
			if ( liveRange.root == this._document.graveyard ) {
				this._fixGraveyardSelection( liveRange, data.sourcePosition );
			}

			// Whenever a live range from selection changes, fire an event informing about that change.
			this.fire( 'change:range', { directChange: false } );
		} );

		return liveRange;
	}

	/**
	 * Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.
	 *
	 * @protected
	 * @param {Boolean} clearAll
	 * @fires change:attribute
	 */
	_updateAttributes( clearAll ) {
		const newAttributes = Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_tomap__["a" /* default */])( this._getSurroundingAttributes() );
		const oldAttributes = Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_tomap__["a" /* default */])( this.getAttributes() );

		if ( clearAll ) {
			// If `clearAll` remove all attributes and reset priorities.
			this._attributePriority = new Map();
			this._attrs = new Map();
		} else {
			// If not, remove only attributes added with `low` priority.
			for ( const [ key, priority ] of this._attributePriority ) {
				if ( priority == 'low' ) {
					this._attrs.delete( key );
					this._attributePriority.delete( key );
				}
			}
		}

		this._setAttributesTo( newAttributes, false );

		// Let's evaluate which attributes really changed.
		const changed = [];

		// First, loop through all attributes that are set on selection right now.
		// Check which of them are different than old attributes.
		for ( const [ newKey, newValue ] of this.getAttributes() ) {
			if ( !oldAttributes.has( newKey ) || oldAttributes.get( newKey ) !== newValue ) {
				changed.push( newKey );
			}
		}

		// Then, check which of old attributes got removed.
		for ( const [ oldKey ] of oldAttributes ) {
			if ( !this.hasAttribute( oldKey ) ) {
				changed.push( oldKey );
			}
		}

		// Fire event with exact data (fire only if anything changed).
		if ( changed.length > 0 ) {
			this.fire( 'change:attribute', { attributeKeys: changed, directChange: false } );
		}
	}

	/**
	 * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
	 *
	 * @protected
	 * @param {String} key Attribute key to convert.
	 * @returns {String} Converted attribute key, applicable for selection store.
	 */
	static _getStoreAttributeKey( key ) {
		return storePrefix + key;
	}

	/**
	 * Checks whether the given attribute key is an attribute stored on an element.
	 *
	 * @protected
	 * @param {String} key
	 * @returns {Boolean}
	 */
	static _isStoreAttributeKey( key ) {
		return key.startsWith( storePrefix );
	}

	/**
	 * Internal method for setting `DocumentSelection` attribute. Supports attribute priorities (through `directChange`
	 * parameter).
	 *
	 * @private
	 * @param {String} key Attribute key.
	 * @param {*} value Attribute value.
	 * @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change
	 * is caused by `Batch` API.
	 * @returns {Boolean} Whether value has changed.
	 */
	_setAttribute( key, value, directChange = true ) {
		const priority = directChange ? 'normal' : 'low';

		if ( priority == 'low' && this._attributePriority.get( key ) == 'normal' ) {
			// Priority too low.
			return false;
		}

		const oldValue = super.getAttribute( key );

		// Don't do anything if value has not changed.
		if ( oldValue === value ) {
			return false;
		}

		this._attrs.set( key, value );

		// Update priorities map.
		this._attributePriority.set( key, priority );

		return true;
	}

	/**
	 * Internal method for removing `DocumentSelection` attribute. Supports attribute priorities (through `directChange`
	 * parameter).
	 *
	 * @private
	 * @param {String} key Attribute key.
	 * @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change
	 * is caused by `Batch` API.
	 * @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the
	 * existing attribute had higher priority.
	 */
	_removeAttribute( key, directChange = true ) {
		const priority = directChange ? 'normal' : 'low';

		if ( priority == 'low' && this._attributePriority.get( key ) == 'normal' ) {
			// Priority too low.
			return false;
		}

		// Don't do anything if value has not changed.
		if ( !super.hasAttribute( key ) ) {
			return false;
		}

		this._attrs.delete( key );

		// Update priorities map.
		this._attributePriority.set( key, priority );

		return true;
	}

	/**
	 * Internal method for setting multiple `DocumentSelection` attributes. Supports attribute priorities (through
	 * `directChange` parameter).
	 *
	 * @private
	 * @param {Iterable|Object} attrs Iterable object containing attributes to be set.
	 * @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change
	 * is caused by `Batch` API.
	 * @returns {Set.<String>} Changed attribute keys.
	 */
	_setAttributesTo( attrs, directChange = true ) {
		const changed = new Set();

		for ( const [ oldKey, oldValue ] of this.getAttributes() ) {
			// Do not remove attribute if attribute with same key and value is about to be set.
			if ( attrs.get( oldKey ) === oldValue ) {
				continue;
			}

			// Attribute still might not get removed because of priorities.
			if ( this._removeAttribute( oldKey, directChange ) ) {
				changed.add( oldKey );
			}
		}

		for ( const [ key, value ] of attrs ) {
			// Attribute may not be set because of attributes or because same key/value is already added.
			const gotAdded = this._setAttribute( key, value, directChange );

			if ( gotAdded ) {
				changed.add( key );
			}
		}

		return changed;
	}

	/**
	 * Returns an iterator that iterates through all selection attributes stored in current selection's parent.
	 *
	 * @private
	 * @returns {Iterable.<*>}
	 */
	* _getStoredAttributes() {
		const selectionParent = this.getFirstPosition().parent;

		if ( this.isCollapsed && selectionParent.isEmpty ) {
			for ( const key of selectionParent.getAttributeKeys() ) {
				if ( key.startsWith( storePrefix ) ) {
					const realKey = key.substr( storePrefix.length );

					yield [ realKey, selectionParent.getAttribute( key ) ];
				}
			}
		}
	}

	/**
	 * Removes attribute with given key from attributes stored in current selection's parent node.
	 *
	 * @private
	 * @param {String} key Key of attribute to remove.
	 */
	_removeStoredAttribute( key ) {
		const storeKey = DocumentSelection._getStoreAttributeKey( key );

		this._document.batch().removeAttribute( this.anchor.parent, storeKey );
	}

	/**
	 * Stores given attribute key and value in current selection's parent node.
	 *
	 * @private
	 * @param {String} key Key of attribute to set.
	 * @param {*} value Attribute value.
	 */
	_storeAttribute( key, value ) {
		const storeKey = DocumentSelection._getStoreAttributeKey( key );

		this._document.batch().setAttribute( this.anchor.parent, storeKey, value );
	}

	/**
	 * Sets selection attributes stored in current selection's parent node to given set of attributes.
	 *
	 * @private
	 * @param {Iterable|Object} attrs Iterable object containing attributes to be set.
	 */
	_setStoredAttributesTo( attrs ) {
		const selectionParent = this.anchor.parent;
		const batch = this._document.batch();

		for ( const [ oldKey ] of this._getStoredAttributes() ) {
			const storeKey = DocumentSelection._getStoreAttributeKey( oldKey );

			batch.removeAttribute( selectionParent, storeKey );
		}

		for ( const [ key, value ] of attrs ) {
			const storeKey = DocumentSelection._getStoreAttributeKey( key );

			batch.setAttribute( selectionParent, storeKey, value );
		}
	}

	/**
	 * Checks model text nodes that are closest to the selection's first position and returns attributes of first
	 * found element. If there are no text nodes in selection's first position parent, it returns selection
	 * attributes stored in that parent.
	 *
	 * @private
	 * @returns {Iterable.<*>} Collection of attributes.
	 */
	_getSurroundingAttributes() {
		const position = this.getFirstPosition();
		const schema = this._document.schema;

		let attrs = null;

		if ( !this.isCollapsed ) {
			// 1. If selection is a range...
			const range = this.getFirstRange();

			// ...look for a first character node in that range and take attributes from it.
			for ( const value of range ) {
				// If the item is an object, we don't want to get attributes from its children.
				if ( value.item.is( 'element' ) && schema.objects.has( value.item.name ) ) {
					break;
				}

				// This is not an optimal solution because of https://github.com/ckeditor/ckeditor5-engine/issues/454.
				// It can be done better by using `break;` instead of checking `attrs === null`.
				if ( value.type == 'text' && attrs === null ) {
					attrs = value.item.getAttributes();
				}
			}
		} else {
			// 2. If the selection is a caret or the range does not contain a character node...

			const nodeBefore = position.textNode ? position.textNode : position.nodeBefore;
			const nodeAfter = position.textNode ? position.textNode : position.nodeAfter;

			// ...look at the node before caret and take attributes from it if it is a character node.
			attrs = getAttrsIfCharacter( nodeBefore );

			// 3. If not, look at the node after caret...
			if ( !attrs ) {
				attrs = getAttrsIfCharacter( nodeAfter );
			}

			// 4. If not, try to find the first character on the left, that is in the same node.
			if ( !attrs ) {
				let node = nodeBefore;

				while ( node && !attrs ) {
					node = node.previousSibling;
					attrs = getAttrsIfCharacter( node );
				}
			}

			// 5. If not found, try to find the first character on the right, that is in the same node.
			if ( !attrs ) {
				let node = nodeAfter;

				while ( node && !attrs ) {
					node = node.nextSibling;
					attrs = getAttrsIfCharacter( node );
				}
			}

			// 6. If not found, selection should retrieve attributes from parent.
			if ( !attrs ) {
				attrs = this._getStoredAttributes();
			}
		}

		return attrs;
	}

	/**
	 * Fixes a selection range after it ends up in graveyard root.
	 *
	 * @private
	 * @param {module:engine/model/liverange~LiveRange} liveRange The range from selection, that ended up in the graveyard root.
	 * @param {module:engine/model/position~Position} removedRangeStart Start position of a range which was removed.
	 */
	_fixGraveyardSelection( liveRange, removedRangeStart ) {
		// The start of the removed range is the closest position to the `liveRange` - the original selection range.
		// This is a good candidate for a fixed selection range.
		const positionCandidate = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createFromPosition( removedRangeStart );

		// Find a range that is a correct selection range and is closest to the start of removed range.
		const selectionRange = this._document.getNearestSelectionRange( positionCandidate );

		// Remove the old selection range before preparing and adding new selection range. This order is important,
		// because new range, in some cases, may intersect with old range (it depends on `getNearestSelectionRange()` result).
		const index = this._ranges.indexOf( liveRange );
		this._ranges.splice( index, 1 );
		liveRange.detach();

		// If nearest valid selection range has been found - add it in the place of old range.
		if ( selectionRange ) {
			// Check the range, convert it to live range, bind events, etc.
			const newRange = this._prepareRange( selectionRange );

			// Add new range in the place of old range.
			this._ranges.splice( index, 0, newRange );
		}
		// If nearest valid selection range cannot be found - just removing the old range is fine.

		// Fire an event informing about selection change.
		this.fire( 'change:range', { directChange: false } );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DocumentSelection;


/**
 * @event change:attribute
 */

// Helper function for {@link module:engine/model/documentselection~DocumentSelection#_updateAttributes}.
//
// It takes model item, checks whether it is a text node (or text proxy) and, if so, returns it's attributes. If not, returns `null`.
//
// @param {module:engine/model/item~Item|null}  node
// @returns {Boolean}
function getAttrsIfCharacter( node ) {
	if ( node instanceof __WEBPACK_IMPORTED_MODULE_4__textproxy__["a" /* default */] || node instanceof __WEBPACK_IMPORTED_MODULE_3__text__["a" /* default */] ) {
		return node.getAttributes();
	}

	return null;
}

// Removes selection attributes from element which is not empty anymore.
function clearAttributesStoredInElement( changes, batch, document ) {
	// Batch may not be passed to the document#change event in some tests.
	// See https://github.com/ckeditor/ckeditor5-engine/issues/1001#issuecomment-314202352
	// Ignore also transparent batches because they are... transparent.
	if ( !batch || batch.type == 'transparent' ) {
		return;
	}

	const changeParent = changes.range && changes.range.start.parent;

	// `changes.range` is not set in case of rename, root and marker operations.
	// None of them may lead to the element becoming non-empty.
	if ( !changeParent || changeParent.isEmpty ) {
		return;
	}

	document.enqueueChanges( () => {
		const storedAttributes = Array.from( changeParent.getAttributeKeys() ).filter( key => key.startsWith( storePrefix ) );

		for ( const key of storedAttributes ) {
			batch.removeAttribute( changeParent, key );
		}
	} );
}


/***/ }),
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isDomNode;
/**
 * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/isdomnode
 */

/**
 * Checks if the object is a native DOM Node.
 *
 * @param {*} obj
 * @returns {Boolean}
 */
function isDomNode( obj ) {
	if ( obj ) {
		if ( obj.defaultView ) {
			return obj instanceof obj.defaultView.Document;
		} else if ( obj.ownerDocument && obj.ownerDocument.defaultView ) {
			return obj instanceof obj.ownerDocument.defaultView.Node;
		}
	}

	return false;
}

/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = diff;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/diff
 */

// The following code is based on the "O(NP) Sequence Comparison Algorithm"
// by Sun Wu, Udi Manber, Gene Myers, Webb Miller.

/**
 * Calculates the difference between two arrays or strings producing an array containing a list of changes
 * necessary to transform input into output.
 *
 *		diff( 'aba', 'acca' ); // [ 'equal', 'insert', 'insert', 'delete', 'equal' ]
 *
 * @param {Array|String} a Input array or string.
 * @param {Array|String} b Output array or string.
 * @param {Function} [cmp] Optional function used to compare array values, by default === is used.
 * @returns {Array} Array of changes.
 */
function diff( a, b, cmp ) {
	// Set the comparator function.
	cmp = cmp || function( a, b ) {
		return a === b;
	};

	// Temporary action type statics.
	let _insert, _delete;

	// Swapped the arrays to use the shorter one as the first one.
	if ( b.length < a.length ) {
		const tmp = a;

		a = b;
		b = tmp;

		// We swap the action types as well.
		_insert = 'delete';
		_delete = 'insert';
	} else {
		_insert = 'insert';
		_delete = 'delete';
	}

	const m = a.length;
	const n = b.length;
	const delta = n - m;

	// Edit scripts, for each diagonal.
	const es = {};
	// Furthest points, the furthest y we can get on each diagonal.
	const fp = {};

	function snake( k ) {
		// We use -1 as an alternative below to handle initial values ( instead of filling the fp with -1 first ).
		// Furthest points (y) on the diagonal below k.
		const y1 = ( fp[ k - 1 ] !== undefined ? fp[ k - 1 ] : -1 ) + 1;
		// Furthest points (y) on the diagonal above k.
		const y2 = fp[ k + 1 ] !== undefined ? fp[ k + 1 ] : -1;
		// The way we should go to get further.
		const dir = y1 > y2 ? -1 : 1;

		// Clone previous changes array (if any).
		if ( es[ k + dir ] ) {
			es[ k ] = es[ k + dir ].slice( 0 );
		}

		// Create changes array.
		if ( !es[ k ] ) {
			es[ k ] = [];
		}

		// Push the action.
		es[ k ].push( y1 > y2 ? _insert : _delete );

		// Set the beginning coordinates.
		let y = Math.max( y1, y2 );
		let x = y - k;

		// Traverse the diagonal as long as the values match.
		while ( x < m && y < n && cmp( a[ x ], b[ y ] ) ) {
			x++;
			y++;
			// Push no change action.
			es[ k ].push( 'equal' );
		}

		return y;
	}

	let p = 0;
	let k;

	// Traverse the graph until we reach the end of the longer string.
	do {
		// Updates furthest points and edit scripts for diagonals below delta.
		for ( k = -p; k < delta; k++ ) {
			fp[ k ] = snake( k );
		}

		// Updates furthest points and edit scripts for diagonals above delta.
		for ( k = delta + p; k > delta; k-- ) {
			fp[ k ] = snake( k );
		}

		// Updates furthest point and edit script for the delta diagonal.
		// note that the delta diagonal is the one which goes through the sink (m, n).
		fp[ delta ] = snake( delta );

		p++;
	} while ( fp[ delta ] !== n );

	// Return the final list of edit changes.
	// We remove the first item that represents the action for the injected nulls.
	return es[ delta ].slice( 1 );
}


/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getAncestors;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals Node */

/**
 * @module utils/dom/getancestors
 */

/**
 * Returns all ancestors of given DOM node, starting from the top-most (root). Includes the given node itself. If the
 * node is a part of `DocumentFragment` that `DocumentFragment` will be returned. In contrary, if the node is
 * appended to a `Document`, that `Document` will not be returned (algorithms operating on DOM tree care for `Document#documentElement`
 * at most, which will be returned).
 *
 * @param {Node} node DOM node.
 * @returns {Array.<Node|DocumentFragment>} Array of given `node` parents.
 */
function getAncestors( node ) {
	const nodes = [];

	// We are interested in `Node`s `DocumentFragment`s only.
	while ( node && node.nodeType != Node.DOCUMENT_NODE ) {
		nodes.unshift( node );
		node = node.parentNode;
	}

	return nodes;
}


/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editableelement__ = __webpack_require__(89);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/rooteditableelement
 */



const rootNameSymbol = Symbol( 'rootName' );

/**
 * Class representing a single root in the data view. A root can be either {@link #isReadOnly editable or read-only}, but
 * in both cases it is called "an editable". Roots can contain other {@link module:engine/view/editableelement~EditableElement editable
 * elements}
 * making them "nested editables".
 *
 * @extends module:engine/view/editableelement~EditableElement
 */
class RootEditableElement extends __WEBPACK_IMPORTED_MODULE_0__editableelement__["a" /* default */] {
	/**
	 * Creates root editable element.
	 *
	 * @param {module:engine/view/document~Document} document {@link module:engine/view/document~Document} that is an owner of the root.
	 * @param {String} name Node name.
	 */
	constructor( name ) {
		super( name );

		/**
		 * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no
		 * other name is set, `main` name is used.
		 *
		 * @member {String}
		 */
		this.rootName = 'main';
	}

	/**
	 * @inheritDoc
	 */
	is( type, name = null ) {
		if ( !name ) {
			return type == 'rootElement' || super.is( type );
		} else {
			return ( type == 'rootElement' && name == this.name ) || super.is( type, name );
		}
	}

	get rootName() {
		return this.getCustomProperty( rootNameSymbol );
	}

	set rootName( rootName ) {
		this.setCustomProperty( rootNameSymbol, rootName );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RootEditableElement;



/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__observer__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selection__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__filler__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_isEqualWith__ = __webpack_require__(425);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/mutationobserver
 */

/* globals window */






/**
 * Mutation observer class observes changes in the DOM, fires {@link module:engine/view/document~Document#event:mutations} event, mark view
 * elements as changed and call {@link module:engine/view/renderer~Renderer#render}.
 * Because all mutated nodes are marked as "to be rendered" and the
 * {@link module:engine/view/renderer~Renderer#render} is called, all changes will be reverted, unless the mutation will be handled by the
 * {@link module:engine/view/document~Document#event:mutations} event listener. It means user will see only handled changes, and the editor
 * will block all changes which are not handled.
 *
 * Mutation Observer also take care of reducing number of mutations which are fired. It removes duplicates and
 * mutations on elements which do not have corresponding view elements. Also
 * {@link module:engine/view/observer/mutationobserver~MutatedText text mutation} is fired only if parent element do not change child list.
 *
 * Note that this observer is attached by the {@link module:engine/view/document~Document} and is available by default.
 *
 * @extends module:engine/view/observer/observer~Observer
 */
class MutationObserver extends __WEBPACK_IMPORTED_MODULE_0__observer__["a" /* default */] {
	constructor( document ) {
		super( document );

		/**
		 * Native mutation observer config.
		 *
		 * @private
		 * @member {Object}
		 */
		this._config = {
			childList: true,
			characterData: true,
			characterDataOldValue: true,
			subtree: true
		};

		/**
		 * Reference to the {@link module:engine/view/document~Document#domConverter}.
		 *
		 * @member {module:engine/view/domconverter~DomConverter}
		 */
		this.domConverter = document.domConverter;

		/**
		 * Reference to the {@link module:engine/view/document~Document#renderer}.
		 *
		 * @member {module:engine/view/renderer~Renderer}
		 */
		this.renderer = document.renderer;

		/**
		 * Observed DOM elements.
		 *
		 * @private
		 * @member {Array.<HTMLElement>}
		 */
		this._domElements = [];

		/**
		 * Native mutation observer.
		 *
		 * @private
		 * @member {MutationObserver}
		 */
		this._mutationObserver = new window.MutationObserver( this._onMutations.bind( this ) );
	}

	/**
	 * Synchronously fires {@link module:engine/view/document~Document#event:mutations} event with all mutations in record queue.
	 * At the same time empties the queue so mutations will not be fired twice.
	 */
	flush() {
		this._onMutations( this._mutationObserver.takeRecords() );
	}

	/**
	 * @inheritDoc
	 */
	observe( domElement ) {
		this._domElements.push( domElement );

		if ( this.isEnabled ) {
			this._mutationObserver.observe( domElement, this._config );
		}
	}

	/**
	 * @inheritDoc
	 */
	enable() {
		super.enable();

		for ( const domElement of this._domElements ) {
			this._mutationObserver.observe( domElement, this._config );
		}
	}

	/**
	 * @inheritDoc
	 */
	disable() {
		super.disable();

		this._mutationObserver.disconnect();
	}

	/**
	 * @inheritDoc
	 */
	destroy() {
		super.destroy();

		this._mutationObserver.disconnect();
	}

	/**
	 * Handles mutations. Deduplicates, mark view elements to sync, fire event and call render.
	 *
	 * @private
	 * @param {Array.<Object>} domMutations Array of native mutations.
	 */
	_onMutations( domMutations ) {
		// As a result of this.flush() we can have an empty collection.
		if ( domMutations.length === 0 ) {
			return;
		}

		const domConverter = this.domConverter;

		// Use map and set for deduplication.
		const mutatedTexts = new Map();
		const mutatedElements = new Set();

		// Handle `childList` mutations first, so we will be able to check if the `characterData` mutation is in the
		// element with changed structure anyway.
		for ( const mutation of domMutations ) {
			if ( mutation.type === 'childList' ) {
				const element = domConverter.mapDomToView( mutation.target );

				// Do not collect mutations from UIElements.
				if ( element && element.is( 'uiElement' ) ) {
					continue;
				}

				if ( element && !this._isBogusBrMutation( mutation ) ) {
					mutatedElements.add( element );
				}
			}
		}

		// Handle `characterData` mutations later, when we have the full list of nodes which changed structure.
		for ( const mutation of domMutations ) {
			const element = domConverter.mapDomToView( mutation.target );

			// Do not collect mutations from UIElements.
			if ( element && element.is( 'uiElement' ) ) {
				continue;
			}

			if ( mutation.type === 'characterData' ) {
				const text = domConverter.findCorrespondingViewText( mutation.target );

				if ( text && !mutatedElements.has( text.parent ) ) {
					// Use text as a key, for deduplication. If there will be another mutation on the same text element
					// we will have only one in the map.
					mutatedTexts.set( text, {
						type: 'text',
						oldText: text.data,
						newText: Object(__WEBPACK_IMPORTED_MODULE_2__filler__["e" /* getDataWithoutFiller */])( mutation.target ),
						node: text
					} );
				}
				// When we added first letter to the text node which had only inline filler, for the DOM it is mutation
				// on text, but for the view, where filler text node did not existed, new text node was created, so we
				// need to fire 'children' mutation instead of 'text'.
				else if ( !text && Object(__WEBPACK_IMPORTED_MODULE_2__filler__["i" /* startsWithFiller */])( mutation.target ) ) {
					mutatedElements.add( domConverter.mapDomToView( mutation.target.parentNode ) );
				}
			}
		}

		// Now we build the list of mutations to fire and mark elements. We did not do it earlier to avoid marking the
		// same node multiple times in case of duplication.

		// List of mutations we will fire.
		const viewMutations = [];

		for ( const mutatedText of mutatedTexts.values() ) {
			this.renderer.markToSync( 'text', mutatedText.node );
			viewMutations.push( mutatedText );
		}

		for ( const viewElement of mutatedElements ) {
			const domElement = domConverter.mapViewToDom( viewElement );
			const viewChildren = Array.from( viewElement.getChildren() );
			const newViewChildren = Array.from( domConverter.domChildrenToView( domElement ) );

			// It may happen that as a result of many changes (sth was inserted and then removed),
			// both elements haven't really changed. #1031
			if ( !Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_isEqualWith__["a" /* default */])( viewChildren, newViewChildren, sameNodes ) ) {
				this.renderer.markToSync( 'children', viewElement );

				viewMutations.push( {
					type: 'children',
					oldChildren: viewChildren,
					newChildren: newViewChildren,
					node: viewElement
				} );
			}
		}

		// Retrieve `domSelection` using `ownerDocument` of one of mutated nodes.
		// There should not be simultaneous mutation in multiple documents, so it's fine.
		const domSelection = domMutations[ 0 ].target.ownerDocument.getSelection();

		let viewSelection = null;

		if ( domSelection && domSelection.anchorNode ) {
			// If `domSelection` is inside a dom node that is already bound to a view node from view tree, get
			// corresponding selection in the view and pass it together with `viewMutations`. The `viewSelection` may
			// be used by features handling mutations.
			// Only one range is supported.

			const viewSelectionAnchor = domConverter.domPositionToView( domSelection.anchorNode, domSelection.anchorOffset );
			const viewSelectionFocus = domConverter.domPositionToView( domSelection.focusNode, domSelection.focusOffset );

			// Anchor and focus has to be properly mapped to view.
			if ( viewSelectionAnchor && viewSelectionFocus ) {
				viewSelection = new __WEBPACK_IMPORTED_MODULE_1__selection__["a" /* default */]();
				viewSelection.setCollapsedAt( viewSelectionAnchor );
				viewSelection.moveFocusTo( viewSelectionFocus );
			}
		}

		this.document.fire( 'mutations', viewMutations, viewSelection );

		// If nothing changes on `mutations` event, at this point we have "dirty DOM" (changed) and de-synched
		// view (which has not been changed). In order to "reset DOM" we render the view again.
		this.document.render();

		function sameNodes( child1, child2 ) {
			// First level of comparison (array of children vs array of children)  use the Lodash's default behavior.
			if ( Array.isArray( child1 ) ) {
				return;
			}

			// Elements.
			if ( child1 === child2 ) {
				return true;
			}
			// Texts.
			else if ( child1.is( 'text' ) && child2.is( 'text' ) ) {
				return child1.data === child2.data;
			}

			// Not matching types.
			return false;
		}
	}

	/**
	 * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.
	 * Such mutations are generated while pressing space or performing native spellchecker correction
	 * on the end of the block element in Firefox browser.
	 *
	 * @private
	 * @param {Object} mutation Native mutation object.
	 * @returns {Boolean}
	 */
	_isBogusBrMutation( mutation ) {
		let addedNode = null;

		// Check if mutation added only one node on the end of its parent.
		if ( mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1 ) {
			addedNode = this.domConverter.domToView( mutation.addedNodes[ 0 ], {
				withChildren: false
			} );
		}

		return addedNode && addedNode.is( 'element', 'br' );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MutationObserver;


/**
 * Fired when mutation occurred. If tree view is not changed on this event, DOM will be reverter to the state before
 * mutation, so all changes which should be applied, should be handled on this event.
 *
 * Introduced by {@link module:engine/view/observer/mutationobserver~MutationObserver}.
 *
 * Note that because {@link module:engine/view/observer/mutationobserver~MutationObserver} is attached by the
 * {@link module:engine/view/document~Document}
 * this event is available by default.
 *
 * @see module:engine/view/observer/mutationobserver~MutationObserver
 * @event module:engine/view/document~Document#event:mutations
 * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|module:engine/view/observer/mutationobserver~MutatedChildren>}
 * viewMutations Array of mutations.
 * For mutated texts it will be {@link module:engine/view/observer/mutationobserver~MutatedText} and for mutated elements it will be
 * {@link module:engine/view/observer/mutationobserver~MutatedChildren}. You can recognize the type based on the `type` property.
 * @param {module:engine/view/selection~Selection|null} viewSelection View selection that is a result of converting DOM selection to view.
 * Keep in
 * mind that the DOM selection is already "updated", meaning that it already acknowledges changes done in mutation.
 */

/**
 * Mutation item for text.
 *
 * @see module:engine/view/document~Document#event:mutations
 * @see module:engine/view/observer/mutationobserver~MutatedChildren
 *
 * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedText
 *
 * @property {String} type For text mutations it is always 'text'.
 * @property {module:engine/view/text~Text} node Mutated text node.
 * @property {String} oldText Old text.
 * @property {String} newText New text.
 */

/**
 * Mutation item for child nodes.
 *
 * @see module:engine/view/document~Document#event:mutations
 * @see module:engine/view/observer/mutationobserver~MutatedText
 *
 * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedChildren
 *
 * @property {String} type For child nodes mutations it is always 'children'.
 * @property {module:engine/view/element~Element} node Parent of the mutated children.
 * @property {Array.<module:engine/view/node~Node>} oldChildren Old child nodes.
 * @property {Array.<module:engine/view/node~Node>} newChildren New child nodes.
 */


/***/ }),
/* 262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isObjectLike__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isPlainObject__ = __webpack_require__(75);



/**
 * Checks if `value` is likely a DOM element.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a DOM element,
 *  else `false`.
 * @example
 *
 * _.isElement(document.body);
 * // => true
 *
 * _.isElement('<body>');
 * // => false
 */
function isElement(value) {
  return !!value && value.nodeType === 1 && Object(__WEBPACK_IMPORTED_MODULE_0__isObjectLike__["a" /* default */])(value) && !Object(__WEBPACK_IMPORTED_MODULE_1__isPlainObject__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (isElement);


/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getBorderWidths;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/getborderwidths
 */

/**
 * Returns an object containing CSS border widths of a specified HTML element.
 *
 * @param {HTMLElement} element An element which has CSS borders.
 * @param {Object} An object containing `top`, `left`, `right` and `bottom` properties
 * with numerical values of the `border-[top,left,right,bottom]-width` CSS styles.
 */
function getBorderWidths( element ) {
	// Call getComputedStyle on the window the element document belongs to.
	const style = element.ownerDocument.defaultView.getComputedStyle( element );

	return {
		top: parseInt( style.borderTopWidth, 10 ),
		right: parseInt( style.borderRightWidth, 10 ),
		bottom: parseInt( style.borderBottomWidth, 10 ),
		left: parseInt( style.borderLeftWidth, 10 )
	};
}


/***/ }),
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = convertRangeSelection;
/* harmony export (immutable) */ __webpack_exports__["c"] = convertCollapsedSelection;
/* harmony export (immutable) */ __webpack_exports__["e"] = convertSelectionAttribute;
/* harmony export (immutable) */ __webpack_exports__["f"] = convertSelectionMarker;
/* harmony export (immutable) */ __webpack_exports__["a"] = clearAttributes;
/* harmony export (immutable) */ __webpack_exports__["b"] = clearFakeSelection;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view_element__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__view_range__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__view_writer__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_to_view_converters__ = __webpack_require__(90);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */






/**
 * Contains {@link module:engine/model/selection~Selection model selection} to
 * {@link module:engine/view/selection~Selection view selection} converters for
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}.
 *
 * @module engine/conversion/model-selection-to-view-converters
 */

/**
 * Function factory, creates a converter that converts non-collapsed {@link module:engine/model/selection~Selection model selection} to
 * {@link module:engine/view/selection~Selection view selection}. The converter consumes appropriate value from `consumable` object
 * and maps model positions from selection to view positions.
 *
 *		modelDispatcher.on( 'selection', convertRangeSelection() );
 *
 * @returns {Function} Selection converter.
 */
function convertRangeSelection() {
	return ( evt, data, consumable, conversionApi ) => {
		const selection = data.selection;

		if ( selection.isCollapsed ) {
			return;
		}

		if ( !consumable.consume( selection, 'selection' ) ) {
			return;
		}

		conversionApi.viewSelection.removeAllRanges();

		for ( const range of selection.getRanges() ) {
			const viewRange = conversionApi.mapper.toViewRange( range );
			conversionApi.viewSelection.addRange( viewRange, selection.isBackward );
		}
	};
}

/**
 * Function factory, creates a converter that converts collapsed {@link module:engine/model/selection~Selection model selection} to
 * {@link module:engine/view/selection~Selection view selection}. The converter consumes appropriate value from `consumable` object,
 * maps model selection position to view position and breaks {@link module:engine/view/attributeelement~AttributeElement attribute elements}
 * at the selection position.
 *
 *		modelDispatcher.on( 'selection', convertCollapsedSelection() );
 *
 * Example of view state before and after converting collapsed selection:
 *
 *		   <p><strong>f^oo<strong>bar</p>
 *		-> <p><strong>f</strong>^<strong>oo</strong>bar</p>
 *
 * By breaking attribute elements like `<strong>`, selection is in correct element. See also complementary
 * {@link module:engine/conversion/model-selection-to-view-converters~convertSelectionAttribute attribute converter}
 * for selection attributes,
 * which wraps collapsed selection into view elements. Those converters together ensure, that selection ends up in
 * appropriate attribute elements.
 *
 * See also {@link module:engine/conversion/model-selection-to-view-converters~clearAttributes} which does a clean-up
 * by merging attributes.
 *
 * @returns {Function} Selection converter.
 */
function convertCollapsedSelection() {
	return ( evt, data, consumable, conversionApi ) => {
		const selection = data.selection;

		if ( !selection.isCollapsed ) {
			return;
		}

		if ( !consumable.consume( selection, 'selection' ) ) {
			return;
		}

		const modelPosition = selection.getFirstPosition();
		const viewPosition = conversionApi.mapper.toViewPosition( modelPosition );
		const brokenPosition = __WEBPACK_IMPORTED_MODULE_2__view_writer__["a" /* default */].breakAttributes( viewPosition );

		conversionApi.viewSelection.removeAllRanges();
		conversionApi.viewSelection.addRange( new __WEBPACK_IMPORTED_MODULE_1__view_range__["a" /* default */]( brokenPosition, brokenPosition ) );
	};
}

/**
 * Function factory, creates a converter that converts {@link module:engine/model/selection~Selection model selection} attributes to
 * {@link module:engine/view/attributeelement~AttributeElement view attribute elements}. The converter works only for collapsed selection.
 * The converter consumes appropriate value from `consumable` object, maps model selection position to view position and
 * wraps that position into a view attribute element.
 *
 * The wrapping node depends on passed parameter. If {@link module:engine/view/element~Element} was passed, it will be cloned and
 * the copy will become the wrapping element. If `Function` is provided, it is passed all the parameters of the
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:selectionAttribute selectionAttribute event}.
 * It's expected that the function returns a {@link module:engine/view/attributeelement~AttributeElement}.
 * The result of the function will be the wrapping element.
 *
 *		modelDispatcher.on( 'selectionAttribute:italic', convertSelectionAttribute( new ViewAttributeElement( 'em' ) ) );
 *
 *		function styleElementCreator( styleValue ) {
 *			if ( styleValue == 'important' ) {
 *				return new ViewAttributeElement( 'strong', { style: 'text-transform:uppercase;' } );
 *			} else if ( styleValue == 'gold' ) {
 *				return new ViewAttributeElement( 'span', { style: 'color:yellow;' } );
 *			}
 *		}
 *		modelDispatcher.on( 'selectionAttribute:style', convertSelectionAttribute( styleCreator ) );
 *		modelDispatcher.on( 'selection', convertCollapsedSelection() );
 *		modelDispatcher.on( 'selectionAttribute:italic', convertSelectionAttribute( new ViewAttributeElement( 'em' ) ) );
 *		modelDispatcher.on( 'selectionAttribute:bold', convertSelectionAttribute( new ViewAttributeElement( 'strong' ) ) );
 *
 * Example of view states before and after converting collapsed selection:
 *
 *		   <p><em>f^oo</em>bar</p>
 *		-> <p><em>f</em>^<em>oo</em>bar</p>
 *		-> <p><em>f^oo</em>bar</p>
 *
 * Example of view state after converting collapsed selection. The scenario is: selection is inside bold text (`<strong>` element)
 * but it does not have bold attribute itself and has italic attribute instead (let's assume that user turned off bold and turned
 * on italic with selection collapsed):
 *
 *		   <p><strong>f^oo<strong>bar</p>
 *		-> <p><strong>f</strong>^<strong>oo<strong>bar</p>
 *		-> <p><strong>f</strong><em>^</em><strong>oo</strong>bar</p>
 *
 * In first example, nothing has changed, because first `<em>` element got broken by `convertCollapsedSelection()` converter,
 * but then it got wrapped-back by `convertSelectionAttribute()` converter. In second example, notice how `<strong>` element
 * is broken to prevent putting selection in it, since selection has no `bold` attribute.
 *
 * @param {module:engine/view/attributeelement~AttributeElement|Function} elementCreator View element,
 * or function returning a view element, which will be used for wrapping.
 * @returns {Function} Selection converter.
 */
function convertSelectionAttribute( elementCreator ) {
	return ( evt, data, consumable, conversionApi ) => {
		const viewElement = elementCreator instanceof __WEBPACK_IMPORTED_MODULE_0__view_element__["a" /* default */] ?
			elementCreator.clone( true ) :
			elementCreator( data.value, data, data.selection, consumable, conversionApi );

		if ( !viewElement ) {
			return;
		}

		const consumableName = 'selectionAttribute:' + data.key;

		wrapCollapsedSelectionPosition( data.selection, conversionApi.viewSelection, viewElement, consumable, consumableName );
	};
}

/**
 * Performs similar conversion as {@link ~convertSelectionAttribute}, but depends on a marker name of a marker in which
 * collapsed selection is placed.
 *
 *		modelDispatcher.on( 'selectionMarker:searchResult', convertSelectionMarker( { class: 'search' } ) );
 *
 * @see module:engine/conversion/model-selection-to-view-converters~convertSelectionAttribute
 * @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor|Function} highlightDescriptor Highlight
 * descriptor object or function returning a descriptor object.
 * @returns {Function} Selection converter.
 */
function convertSelectionMarker( highlightDescriptor ) {
	return ( evt, data, consumable, conversionApi ) => {
		const descriptor = typeof highlightDescriptor == 'function' ?
			highlightDescriptor( data, consumable, conversionApi ) :
			highlightDescriptor;

		if ( !descriptor ) {
			return;
		}

		if ( !descriptor.id ) {
			descriptor.id = data.markerName;
		}

		const viewElement = Object(__WEBPACK_IMPORTED_MODULE_3__model_to_view_converters__["a" /* createViewElementFromHighlightDescriptor */])( descriptor );
		const consumableName = 'selectionMarker:' + data.markerName;

		wrapCollapsedSelectionPosition( data.selection, conversionApi.viewSelection, viewElement, consumable, consumableName );
	};
}

// Helper function for `convertSelectionAttribute` and `convertSelectionMarker`, which perform similar task.
function wrapCollapsedSelectionPosition( modelSelection, viewSelection, viewElement, consumable, consumableName ) {
	if ( !modelSelection.isCollapsed ) {
		return;
	}

	if ( !consumable.consume( modelSelection, consumableName ) ) {
		return;
	}

	let viewPosition = viewSelection.getFirstPosition();

	// This hack is supposed to place attribute element *after* all ui elements if the attribute element would be
	// the only non-ui child and thus receive a block filler.
	// This is needed to properly render ui elements. Block filler is a <br /> element. If it is placed before
	// UI element, the ui element will most probably be incorrectly rendered (in next line). #1072.
	if ( shouldPushAttributeElement( viewPosition.parent ) ) {
		viewPosition = viewPosition.getLastMatchingPosition( value => value.item.is( 'uiElement' ) );
	}
	// End of hack.

	viewPosition = __WEBPACK_IMPORTED_MODULE_2__view_writer__["a" /* default */].wrapPosition( viewPosition, viewElement );

	viewSelection.removeAllRanges();
	viewSelection.addRange( new __WEBPACK_IMPORTED_MODULE_1__view_range__["a" /* default */]( viewPosition, viewPosition ) );
}

function shouldPushAttributeElement( parent ) {
	if ( !parent.is( 'element' ) ) {
		return false;
	}

	for ( const child of parent.getChildren() ) {
		if ( !child.is( 'uiElement' ) ) {
			return false;
		}
	}

	return true;
}

/**
 * Function factory, creates a converter that clears artifacts after the previous
 * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty
 * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merge sibling attributes at all start and end
 * positions of all ranges.
 *
 *		   <p><strong>^</strong></p>
 *		-> <p>^</p>
 *
 *		   <p><strong>foo</strong>^<strong>bar</strong>bar</p>
 *		-> <p><strong>foo^bar<strong>bar</p>
 *
 *		   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>
 *		-> <p><strong>foo^bar<strong>bar</p>
 *
 * This listener should be assigned before any converter for the new selection:
 *
 *		modelDispatcher.on( 'selection', clearAttributes() );
 *
 * See {@link module:engine/conversion/model-selection-to-view-converters~convertCollapsedSelection}
 * which do the opposite by breaking attributes in the selection position.
 *
 * @returns {Function} Selection converter.
 */
function clearAttributes() {
	return ( evt, data, consumable, conversionApi ) => {
		for ( const range of conversionApi.viewSelection.getRanges() ) {
			// Not collapsed selection should not have artifacts.
			if ( range.isCollapsed ) {
				// Position might be in the node removed by the view writer.
				if ( range.end.parent.document ) {
					__WEBPACK_IMPORTED_MODULE_2__view_writer__["a" /* default */].mergeAttributes( range.start );
				}
			}
		}
		conversionApi.viewSelection.removeAllRanges();
	};
}

/**
 * Function factory, creates a converter that clears fake selection marking after the previous
 * {@link module:engine/model/selection~Selection model selection} conversion.
 */
function clearFakeSelection() {
	return ( evt, data, consumable, conversionApi ) => conversionApi.viewSelection.setFake( false );
}


/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = setDataInElement;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/setdatainelement
 */

/* globals HTMLTextAreaElement */

/**
 * Sets data in a given element.
 *
 * @param {HTMLElement} el The element in which the data will be set.
 * @param {String} data The data string.
 */
function setDataInElement( el, data ) {
	if ( el instanceof HTMLTextAreaElement ) {
		el.value = data;
	}

	el.innerHTML = data;
}


/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/componentfactory
 */



/**
 * A helper class implementing the UI component ({@link module:ui/view~View view}) factory.
 *
 * It allows functions producing specific UI components to be registered under their unique names
 * in the factory. A registered component can be then instantiated by providing its name.
 * Note that names are case insensitive.
 *
 *		// The editor provides localization tools for the factory.
 *		const factory = new ComponentFactory( editor );
 *
 *		factory.add( 'foo', locale => new FooView( locale ) );
 *		factory.add( 'bar', locale => new BarView( locale ) );
 *
 *		// An instance of FooView.
 *		const fooInstance = factory.create( 'foo' );
 *
 *		// Names are case insensitive so this is also allowed:
 *		const barInstance = factory.create( 'Bar' );
 *
 * The {@link module:core/editor/editor~Editor#locale editor locale} is passed to the factory
 * function when {@link module:ui/componentfactory~ComponentFactory#create} is called.
 */
class ComponentFactory {
	/**
	 * Creates an instance of the factory.
	 *
	 * @constructor
	 * @param {module:core/editor/editor~Editor} editor The editor instance.
	 */
	constructor( editor ) {
		/**
		 * The editor instance that the factory belongs to.
		 *
		 * @readonly
		 * @member {module:core/editor/editor~Editor}
		 */
		this.editor = editor;

		/**
		 * Registered component factories.
		 *
		 * @private
		 * @member {Map}
		 */
		this._components = new Map();
	}

	/**
	 * Returns an iterator of registered component names. Names are returned in lower case.
	 *
	 * @returns {Iterator.<String>}
	 */
	* names() {
		yield* this._components.keys();
	}

	/**
	 * Registers a component factory function that will be used by the
	 * {@link #create create} method and called with the
	 * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
	 * allowing localization of the {@link module:ui/view~View view}.
	 *
	 * @param {String} name The name of the component.
	 * @param {Function} callback The callback that returns the component.
	 */
	add( name, callback ) {
		if ( this.has( name ) ) {
			/**
			 * The item already exists in the component factory.
			 *
			 * @error componentfactory-item-exists
			 * @param {String} name The name of the component.
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'componentfactory-item-exists: The item already exists in the component factory.', { name }
			);
		}

		this._components.set( getNormalized( name ), callback );
	}

	/**
	 * Creates an instance of a component registered in the factory under a specific name.
	 *
	 * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
	 * the previously {@link #add added} factory function, allowing localization of the
	 * {@link module:ui/view~View view}.
	 *
	 * @param {String} name The name of the component.
	 * @returns {module:ui/view~View} The instantiated component view.
	 */
	create( name ) {
		if ( !this.has( name ) ) {
			/**
			 * The required component is not registered in the component factory. Please make sure
			 * the provided name is correct and the component has been correctly
			 * {@link #add added} to the factory.
			 *
			 * @error componentfactory-item-missing
			 * @param {String} name The name of the missing component.
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'componentfactory-item-missing: The required component is not registered in the factory.', { name }
			);
		}

		return this._components.get( getNormalized( name ) )( this.editor.locale );
	}

	/**
	 * Checks if a component of a given name is registered in the factory.
	 *
	 * @param {String} name The name of the component.
	 * @returns {Boolean}
	 */
	has( name ) {
		return this._components.has( getNormalized( name ) );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ComponentFactory;


//
// Ensures that the component name used as the key in the internal map is in lower case.
//
// @private
// @param {String} name
// @returns {String}
function getNormalized( name ) {
	return String( name ).toLowerCase();
}


/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = enableToolbarKeyboardFocus;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/toolbar/enabletoolbarkeyboardfocus
 */

/**
 * Enables focus/blur toolbar navigation using `Alt+F10` and `Esc` keystrokes.
 *
 * @param {Object} options Options of the utility.
 * @param {*} options.origin A view to which the focus will return when `Esc` is pressed and
 * `options.toolbar` is focused.
 * @param {module:utils/keystrokehandler~KeystrokeHandler} options.originKeystrokeHandler A keystroke
 * handler to register `Alt+F10` keystroke.
 * @param {module:utils/focustracker~FocusTracker} options.originFocusTracker A focus tracker
 * for `options.origin`.
 * @param {module:ui/toolbar/toolbarview~ToolbarView} options.toolbar A toolbar which is to gain
 * focus when `Alt+F10` is pressed.
 * @param {Function} [options.beforeFocus] A callback executed before the `options.toolbar` gains focus
 * upon the `Alt+F10` keystroke.
 * @param {Function} [options.afterBlur] A callback executed after `options.toolbar` loses focus upon
 * `Esc` keystroke but before the focus goes back to `options.origin`.
 */
function enableToolbarKeyboardFocus( {
	origin,
	originKeystrokeHandler,
	originFocusTracker,
	toolbar,
	beforeFocus,
	afterBlur
} ) {
	// Because toolbar items can get focus, the overall state of the toolbar must
	// also be tracked.
	originFocusTracker.add( toolbar.element );

	// Focus the toolbar on the keystroke, if not already focused.
	originKeystrokeHandler.set( 'Alt+F10', ( data, cancel ) => {
		if ( originFocusTracker.isFocused && !toolbar.focusTracker.isFocused ) {
			if ( beforeFocus ) {
				beforeFocus();
			}

			toolbar.focus();

			cancel();
		}
	} );

	// Blur the toolbar and bring the focus back to origin.
	toolbar.keystrokes.set( 'Esc', ( data, cancel ) => {
		if ( toolbar.focusTracker.isFocused ) {
			origin.focus();

			if ( afterBlur ) {
				afterBlur();
			}

			cancel();
		}
	} );
}


/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = normalizeToolbarConfig;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/toolbar/normalizetoolbarconfig
 */

/**
 * Normalizes the toolbar configuration (`config.toolbar`), which:
 *
 * * may be defined as an `Array`:
 *
 * 		toolbar: [ 'headings', 'bold', 'italic', 'link', ... ]
 *
 * * or an `Object`:
 *
 *		toolbar: {
 *			items: [ 'headings', 'bold', 'italic', 'link', ... ],
 *			...
 *		}
 *
 * * or may not be defined at all (`undefined`)
 *
 * and returns it in the object form.
 *
 * @param {Array|Object|undefined} config The value of `config.toolbar`.
 * @returns {Object} A normalized toolbar config object.
 */
function normalizeToolbarConfig( config ) {
	if ( Array.isArray( config ) ) {
		return {
			items: config
		};
	}

	if ( !config ) {
		return {
			items: []
		};
	}

	return Object.assign( {
		items: []
	}, config );
}


/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__template__ = __webpack_require__(159);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/editorui/editoruiview
 */

/* globals document */




/**
 * The editor UI view class. Base class for the editor main views.
 *
 * @extends module:ui/view~View
 */
class EditorUIView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * Creates an instance of the editor UI view class.
	 *
	 * @param {module:utils/locale~Locale} [locale] The locale instance.
	 */
	constructor( locale ) {
		super( locale );

		/**
		 * Collection of the child views, detached from the DOM
		 * structure of the editor, like panels, icons etc.
		 *
		 * @readonly
		 * @member {module:ui/viewcollection~ViewCollection} #body
		 */
		this.body = this.createCollection();

		/**
		 * The element holding elements of the 'body' region.
		 *
		 * @private
		 * @member {HTMLElement} #_bodyCollectionContainer
		 */
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		this._renderBodyCollection();
	}

	/**
	 * @inheritDoc
	 */
	destroy() {
		this._bodyCollectionContainer.remove();

		return super.destroy();
	}

	/**
	 * Creates and appends to `<body>` the {@link #body} collection container.
	 *
	 * @private
	 */
	_renderBodyCollection() {
		const bodyElement = this._bodyCollectionContainer = new __WEBPACK_IMPORTED_MODULE_1__template__["a" /* default */]( {
			tag: 'div',
			attributes: {
				class: [
					'ck-body',
					'ck-rounded-corners',
					'ck-reset_all'
				]
			},
			children: this.body
		} ).render();

		document.body.appendChild( bodyElement );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EditorUIView;



/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editableui_editableuiview__ = __webpack_require__(440);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/editableui/inline/inlineeditableuiview
 */



/**
 * The inline editable UI class implementing an inline {@link module:ui/editableui/editableuiview~EditableUIView}.
 *
 * @extends module:ui/editableui/editableuiview~EditableUIView
 */
class InlineEditableUIView extends __WEBPACK_IMPORTED_MODULE_0__editableui_editableuiview__["a" /* default */] {
	/**
	 * Creates an instance of the InlineEditableUIView class.
	 *
	 * @param {module:utils/locale~Locale} [locale] The locale instance.
	 * @param {HTMLElement} [editableElement] The editable element. If not specified, the
	 * {@link module:ui/editableui/editableuiview~EditableUIView}
	 * should create it. Otherwise, the existing element should be used.
	 */
	constructor( locale, editableElement ) {
		super( locale, editableElement );

		const bind = this.bindTemplate;
		const t = this.t;

		/**
		 * The name of the editable UI view.
		 *
		 * @observable
		 * @member {String} #name
		 */
		this.set( 'name', null );

		const getLabel = value => {
			return t( 'Rich Text Editor, %0', [ value ] );
		};

		this.extendTemplate( {
			attributes: {
				role: 'textbox',
				'aria-label': bind.to( 'name', getLabel ),
				class: 'ck-editor__editable_inline'
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = InlineEditableUIView;



/***/ }),
/* 271 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = toUnit;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/tounit
 */

/**
 * Returns a helper function, which adds a desired trailing
 * `unit` to the passed value.
 *
 * @param {String} unit An unit like "px" or "em".
 * @returns {module:utils/dom/tounit~helper}
 */
function toUnit( unit ) {
	/**
	 * A function, which adds a predefined trailing `unit`
	 * to the passed `value`.
	 *
	 * @function helper
 	 * @param {*} value A value to be given the unit.
 	 * @returns {String} A value with the trailing unit.
	 */
	return value => value + unit;
}


/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_count__ = __webpack_require__(153);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module typing/changebuffer
 */



/**
 * Change buffer allows to group atomic changes (like characters that have been typed) into
 * {@link module:engine/model/batch~Batch batches}.
 *
 * Batches represent single undo steps, hence changes added to one single batch are undone together.
 *
 * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was
 * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.
 *
 * To use the change buffer you need to let it know about the number of changes that were added to the batch:
 *
 *		const buffer = new ChangeBuffer( document, LIMIT );
 *
 *		// Later on in your feature:
 *		buffer.batch.insert( pos, insertedCharacters );
 *		buffer.input( insertedCharacters.length );
 *
 */
class ChangeBuffer {
	/**
	 * Creates a new instance of the change buffer.
	 *
	 * @param {module:engine/model/document~Document} document
	 * @param {Number} [limit=20] The maximum number of atomic changes which can be contained in one batch.
	 */
	constructor( doc, limit = 20 ) {
		/**
		 * The document instance.
		 *
		 * @readonly
		 * @member {module:engine/model/document~Document} #document
		 */
		this.document = doc;

		/**
		 * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
		 * the {@link #batch batch} is set to a new one.
		 *
		 * @readonly
		 * @member {Number} #size
		 */
		this.size = 0;

		/**
		 * The maximum number of atomic changes which can be contained in one batch.
		 *
		 * @readonly
		 * @member {Number} #limit
		 */
		this.limit = limit;

		/**
		 * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
		 *
		 * @readonly
		 * @member {Boolean} #isLocked
		 */
		this.isLocked = false;

		this._changeCallback = ( evt, type, changes, batch ) => {
			this._onBatch( batch );
		};

		this._selectionChangeCallback = () => {
			this._reset();
		};

		doc.on( 'change', this._changeCallback );

		doc.selection.on( 'change:range', this._selectionChangeCallback );

		doc.selection.on( 'change:attribute', this._selectionChangeCallback );

		/**
		 * The current batch instance.
		 *
		 * @private
		 * @member #_batch
		 */

		/**
		 * The callback to document the change event which later needs to be removed.
		 *
		 * @private
		 * @member #_changeCallback
		 */

		/**
		 * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.
		 *
		 * @private
		 * @member #_selectionChangeCallback
		 */
	}

	/**
	 * The current batch to which a feature should add its deltas. Once the {@link #size}
	 * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
	 *
	 * @type {module:engine/model/batch~Batch}
	 */
	get batch() {
		if ( !this._batch ) {
			this._batch = this.document.batch();
		}

		return this._batch;
	}

	/**
	 * The input number of changes into the buffer. Once the {@link #size} is
	 * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
	 *
	 * @param {Number} changeCount The number of atomic changes to input.
	 */
	input( changeCount ) {
		this.size += changeCount;

		if ( this.size >= this.limit ) {
			this._reset( true );
		}
	}

	/**
	 * Locks the buffer.
	 */
	lock() {
		this.isLocked = true;
	}

	/**
	 * Unlocks the buffer.
	 */
	unlock() {
		this.isLocked = false;
	}

	/**
	 * Destroys the buffer.
	 */
	destroy() {
		this.document.off( 'change', this._changeCallback );
		this.document.selection.off( 'change:range', this._selectionChangeCallback );
		this.document.selection.off( 'change:attribute', this._selectionChangeCallback );
	}

	/**
	 * The method to be called in order to notify the buffer about batches which appeared in the document.
	 * The method will check whether it is a new batch and in that case the buffer will be flushed.
	 *
	 * The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards
	 * should be added to a new batch. For instance, when the  user types, then inserts an image, and then types again,
	 * the characters typed after inserting the image should be added to a different batch than the characters typed before.
	 *
	 * @private
	 * @param {module:engine/model/batch~Batch} batch The batch which appears in the document.
	 */
	_onBatch( batch ) {
		// One operation means a newly created batch.
		if ( batch.type != 'transparent' && batch !== this._batch && Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_count__["a" /* default */])( batch.getOperations() ) <= 1 ) {
			this._reset( true );
		}
	}

	/**
	 * Resets the change buffer.
	 *
	 * @private
	 * @param {Boolean} [ignoreLock] Whether internal lock {@link #isLocked} should be ignored.
	 */
	_reset( ignoreLock ) {
		if ( !this.isLocked || ignoreLock ) {
			this._batch = null;
			this.size = 0;
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ChangeBuffer;



/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export transformRangesByDeltas */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module undo/basecommand
 */



/**
 * Base class for undo feature commands: {@link module:undo/undocommand~UndoCommand} and {@link module:undo/redocommand~RedoCommand}.
 *
 * @protected
 * @extends module:core/command~Command
 */
class BaseCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	constructor( editor ) {
		super( editor );

		/**
		 * Stack of items stored by the command. These are pairs of:
		 *
		 * * {@link module:engine/model/batch~Batch batch} saved by the command,
		 * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.
		 *
		 * @protected
		 * @member {Array} #_stack
		 */
		this._stack = [];

		/**
		 * Stores all batches that were created by this command.
		 *
		 * @protected
		 * @member {WeakSet.<module:engine/model/batch~Batch>} #_createdBatches
		 */
		this._createdBatches = new WeakSet();

		// Refresh state, so the command is inactive right after initialization.
		this.refresh();
	}

	/**
	 * @inheritDoc
	 */
	refresh() {
		this.isEnabled = this._stack.length > 0;
	}

	/**
	 * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}
	 * created by the editor which this command is registered to.
	 *
	 * @param {module:engine/model/batch~Batch} batch The batch to add.
	 */
	addBatch( batch ) {
		const docSelection = this.editor.document.selection;

		const selection = {
			ranges: docSelection.hasOwnRange ? Array.from( docSelection.getRanges() ) : [],
			isBackward: docSelection.isBackward
		};

		this._stack.push( { batch, selection } );
		this.refresh();
	}

	/**
	 * Removes all items from the stack.
	 */
	clearStack() {
		this._stack = [];
		this.refresh();
	}

	/**
	 * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.
	 *
	 * @protected
	 * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be restored.
	 * @param {Boolean} isBackward A flag describing whether the restored range was selected forward or backward.
	 * @param {Array.<module:engine/model/delta/delta~Delta>} deltas Deltas which has been applied since selection has been stored.
	 */
	_restoreSelection( ranges, isBackward, deltas ) {
		const document = this.editor.document;

		// This will keep the transformed selection ranges.
		const selectionRanges = [];

		// Transform all ranges from the restored selection.
		for ( const range of ranges ) {
			const transformedRanges = transformSelectionRange( range, deltas );

			// For each `range` from `ranges`, we take only one transformed range.
			// This is because we want to prevent situation where single-range selection
			// got transformed to multi-range selection. We will take the first range that
			// is not in the graveyard.
			const transformedRange = transformedRanges.find(
				range => range.start.root != document.graveyard
			);

			// `transformedRange` might be `undefined` if transformed range ended up in graveyard.
			if ( transformedRange ) {
				selectionRanges.push( transformedRange );
			}
		}

		// `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.
		if ( selectionRanges.length ) {
			document.selection.setRanges( selectionRanges, isBackward );
		}
	}

	/**
	 * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
	 * This is a helper method for {@link #execute}.
	 *
	 * @protected
	 * @param {module:engine/model/batch~Batch} batchToUndo The batch to be undone.
	 */
	_undo( batchToUndo ) {
		const document = this.editor.document;

		// All changes done by the command execution will be saved as one batch.
		const undoingBatch = document.batch();
		this._createdBatches.add( undoingBatch );

		const deltasToUndo = batchToUndo.deltas.slice();
		deltasToUndo.reverse();

		// We will process each delta from `batchToUndo`, in reverse order. If there were deltas A, B and C in undone batch,
		// we need to revert them in reverse order, so first C' (reversed C), then B', then A'.
		for ( const deltaToUndo of deltasToUndo ) {
			// Keep in mind that transformation algorithms return arrays. That's because the transformation might result in multiple
			// deltas, so we need arrays to handle them. To simplify algorithms, it is better to always operate on arrays.
			const nextBaseVersion = deltaToUndo.baseVersion + deltaToUndo.operations.length;

			// Reverse delta from the history.
			const historyDeltas = Array.from( document.history.getDeltas( nextBaseVersion ) );
			const transformedSets = document.transformDeltas( [ deltaToUndo.getReversed() ], historyDeltas, true );
			const reversedDeltas = transformedSets.deltasA;

			// After reversed delta has been transformed by all history deltas, apply it.
			for ( const delta of reversedDeltas ) {
				// Fix base version.
				delta.baseVersion = document.version;

				// Before applying, add the delta to the `undoingBatch`.
				undoingBatch.addDelta( delta );

				// Now, apply all operations of the delta.
				for ( const operation of delta.operations ) {
					document.applyOperation( operation );
				}

				document.history.setDeltaAsUndone( deltaToUndo, delta );
			}
		}

		return undoingBatch;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BaseCommand;


// Transforms given range `range` by given `deltas`.
// Returns an array containing one or more ranges, which are result of the transformation.
function transformSelectionRange( range, deltas ) {
	const transformed = transformRangesByDeltas( [ range ], deltas );

	// After `range` got transformed, we have an array of ranges. Some of those
	// ranges may be "touching" -- they can be next to each other and could be merged.
	// First, we have to sort those ranges to assure that they are in order.
	transformed.sort( ( a, b ) => a.start.isBefore( b.start ) ? -1 : 1 );

	// Then, we check if two consecutive ranges are touching.
	for ( let i = 1; i < transformed.length; i++ ) {
		const a = transformed[ i - 1 ];
		const b = transformed[ i ];

		if ( a.end.isTouching( b.start ) ) {
			// And join them together if they are.
			a.end = b.end;
			transformed.splice( i, 1 );
			i--;
		}
	}

	return transformed;
}

// Transforms given set of `ranges` by given set of `deltas`. Returns transformed `ranges`.
function transformRangesByDeltas( ranges, deltas ) {
	for ( const delta of deltas ) {
		for ( const operation of delta.operations ) {
			// We look through all operations from all deltas.

			for ( let i = 0; i < ranges.length; i++ ) {
				// We transform every range by every operation.
				let result;

				switch ( operation.type ) {
					case 'insert':
						result = ranges[ i ]._getTransformedByInsertion(
							operation.position,
							operation.nodes.maxOffset,
							true
						);
						break;

					case 'move':
					case 'remove':
					case 'reinsert':
						result = ranges[ i ]._getTransformedByMove(
							operation.sourcePosition,
							operation.targetPosition,
							operation.howMany,
							true
						);
						break;
				}

				// If we have a transformation result, we substitute transformed range with it in `transformed` array.
				// Keep in mind that the result is an array and may contain multiple ranges.
				if ( result ) {
					ranges.splice( i, 1, ...result );

					// Fix iterator.
					i = i + result.length - 1;
				}
			}
		}
	}

	return ranges;
}


/***/ }),
/* 274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module basic-styles/attributecommand
 */



/**
 * An extension of the base {@link module:core/command~Command} class, which provides utilities for a command
 * that toggles a single attribute on a text or an element.
 *
 * `AttributeCommand` uses {@link module:engine/model/document~Document#selection}
 * to decide which nodes (if any) should be changed, and applies or removes the attribute from them.
 *
 * The command checks the {@link module:engine/model/document~Document#schema} to decide if it can be enabled
 * for the current selection and to which nodes the attribute can be applied.
 *
 * @extends module:core/command~Command
 */
class AttributeCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * @param {module:core/editor/editor~Editor} editor
	 * @param {String} attributeKey Attribute that will be set by the command.
	 */
	constructor( editor, attributeKey ) {
		super( editor );

		/**
		 * The attribute that will be set by the command.
		 *
		 * @readonly
		 * @member {String}
		 */
		this.attributeKey = attributeKey;

		/**
		 * Flag indicating whether the command is active. The command is active when the
		 * {@link module:engine/model/selection~Selection#hasAttribute selection has the attribute} which means that:
		 *
		 * * If the selection is not empty &ndash; That it starts in a text (or another node) which has the attribute set.
		 * * If the selection is empty &ndash; That the selection has the attribute itself (which means that newly typed
		 * text will have this attribute, too).
		 *
		 * @observable
		 * @readonly
		 * @member {Boolean} #value
		 */
	}

	/**
	 * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.
	 */
	refresh() {
		const doc = this.editor.document;

		this.value = doc.selection.hasAttribute( this.attributeKey );
		this.isEnabled = doc.schema.checkAttributeInSelection( doc.selection, this.attributeKey );
	}

	/**
	 * Executes the command &mdash; applies the attribute to the selection or removes it from the selection.
	 *
	 * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
	 *
	 * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
	 *
	 * * If the selection is on a range, the command applies the attribute to all nodes in that range
	 * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
	 * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
	 * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
	 * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
	 * that the selection inherits all attributes from a node if it is in an empty node).
	 *
	 * @fires execute
	 * @param {Object} [options] Command options.
	 * @param {Boolean} [options.forceValue] If set, it will force the command behavior. If `true`, the command will apply the attribute,
	 * otherwise the command will remove the attribute.
	 * If not set, the command will look for its current value to decide what it should do.
	 * @param {module:engine/model/batch~Batch} [options.batch] A batch to group undo steps.
	 */
	execute( options = {} ) {
		const doc = this.editor.document;
		const selection = doc.selection;
		const value = ( options.forceValue === undefined ) ? !this.value : options.forceValue;

		doc.enqueueChanges( () => {
			if ( selection.isCollapsed ) {
				if ( value ) {
					selection.setAttribute( this.attributeKey, true );
				} else {
					selection.removeAttribute( this.attributeKey );
				}
			} else {
				const ranges = doc.schema.getValidRanges( selection.getRanges(), this.attributeKey );
				const batch = options.batch || doc.batch();

				for ( const range of ranges ) {
					if ( value ) {
						batch.setAttribute( range, this.attributeKey, value );
					} else {
						batch.removeAttribute( range, this.attributeKey );
					}
				}
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AttributeCommand;



/***/ }),
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export createImageViewElement */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__converters__ = __webpack_require__(510);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_containerelement__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_emptyelement__ = __webpack_require__(183);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/image/imageengine
 */










/**
 * The image engine plugin.
 * Registers `<image>` as a block element in the document schema, and allows `alt`, `src` and `srcset` attributes.
 * Registers converters for editing and data pipelines.
 *
 * @extends module:core/plugin~Plugin
 */
class ImageEngine extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const doc = editor.document;
		const schema = doc.schema;
		const data = editor.data;
		const editing = editor.editing;
		const t = editor.t;

		// Configure schema.
		schema.registerItem( 'image' );
		schema.requireAttributes( 'image', [ 'src' ] );
		schema.allow( { name: 'image', attributes: [ 'alt', 'src', 'srcset' ], inside: '$root' } );
		schema.objects.add( 'image' );

		// Build converter from model to view for data pipeline.
		Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__["a" /* default */])().for( data.modelToView )
			.fromElement( 'image' )
			.toElement( () => createImageViewElement() );

		// Build converter from model to view for editing pipeline.
		Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__["a" /* default */])().for( editing.modelToView )
			.fromElement( 'image' )
			.toElement( () => Object(__WEBPACK_IMPORTED_MODULE_4__utils__["c" /* toImageWidget */])( createImageViewElement(), t( 'image widget' ) ) );

		Object(__WEBPACK_IMPORTED_MODULE_3__converters__["b" /* createImageAttributeConverter */])( [ editing.modelToView, data.modelToView ], 'src' );
		Object(__WEBPACK_IMPORTED_MODULE_3__converters__["b" /* createImageAttributeConverter */])( [ editing.modelToView, data.modelToView ], 'alt' );

		// Convert `srcset` attribute changes and add or remove `sizes` attribute when necessary.
		Object(__WEBPACK_IMPORTED_MODULE_3__converters__["b" /* createImageAttributeConverter */])( [ editing.modelToView, data.modelToView ], 'srcset', __WEBPACK_IMPORTED_MODULE_3__converters__["d" /* srcsetAttributeConverter */] );

		// Build converter for view img element to model image element.
		Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__["a" /* default */])().for( data.viewToModel )
			.from( { name: 'img', attribute: { src: /./ } } )
			.toElement( viewImage => new __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */]( 'image', { src: viewImage.getAttribute( 'src' ) } ) );

		data.viewToModel.on( 'element:img', __WEBPACK_IMPORTED_MODULE_3__converters__["a" /* convertHoistableImage */], { priority: 'low' } );
		data.viewToModel.on( 'element', __WEBPACK_IMPORTED_MODULE_3__converters__["c" /* hoistImageThroughElement */], { priority: 'low' } );

		// Build converter for alt attribute.
		// Note that by default attribute converters are added with `low` priority.
		// This converter will be thus fired after `convertHoistableImage` converter.
		Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__["a" /* default */])().for( data.viewToModel )
			.from( { name: 'img', attribute: { alt: /./ } } )
			.consuming( { attribute: [ 'alt' ] } )
			.toAttribute( viewImage => ( { key: 'alt', value: viewImage.getAttribute( 'alt' ) } ) );

		// Build converter for srcset attribute.
		Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__["a" /* default */])().for( data.viewToModel )
			.from( { name: 'img', attribute: { srcset: /./ } } )
			.consuming( { attribute: [ 'srcset' ] } )
			.toAttribute( viewImage => {
				const value = {
					data: viewImage.getAttribute( 'srcset' )
				};

				if ( viewImage.hasAttribute( 'width' ) ) {
					value.width = viewImage.getAttribute( 'width' );
				}

				return {
					key: 'srcset',
					value
				};
			} );

		// Converter for figure element from view to model.
		data.viewToModel.on( 'element:figure', Object(__WEBPACK_IMPORTED_MODULE_3__converters__["e" /* viewFigureToModel */])() );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageEngine;


// Creates a view element representing the image.
//
//		<figure class="image"><img></img></figure>
//
// Note that `alt` and `src` attributes are converted separately, so they are not included.
//
// @private
// @return {module:engine/view/containerelement~ContainerElement}
function createImageViewElement() {
	return new __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_containerelement__["a" /* default */]( 'figure', { class: 'image' }, new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_emptyelement__["a" /* default */]( 'img' ) );
}


/***/ }),
/* 276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = clickOutsideHandler;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/bindings/clickoutsidehandler
 */

/* global document */

/**
 * Handles clicking **outside** of a specified set of elements, then fires an action.
 *
 * **Note**: Actually, the action is executed upon `mousedown`, not `click`. It prevents
 * certain issues when the user keeps holding the mouse button and the UI cannot react
 * properly.
 *
 * @param {Object} options Configuration options.
 * @param {module:utils/dom/emittermixin~Emitter} options.emitter The emitter to which this behavior
 * should be added.
 * @param {Function} options.activator Function returning a `Boolean`, to determine whether the handler is active.
 * @param {Array.<HTMLElement>} options.contextElements HTML elements that determine the scope of the
 * handler. Clicking any of them or their descendants will **not** fire the callback.
 * @param {Function} options.callback An action executed by the handler.
 */
function clickOutsideHandler( { emitter, activator, callback, contextElements } ) {
	emitter.listenTo( document, 'mousedown', ( evt, { target } ) => {
		if ( !activator() ) {
			return;
		}

		for ( const contextElement of contextElements ) {
			if ( contextElement.contains( target ) ) {
				return;
			}
		}

		callback();
	} );
}


/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_uid__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__label_labelview__ = __webpack_require__(520);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/labeledinput/labeledinputview
 */






/**
 * The labeled input view class.
 *
 * @extends module:ui/view~View
 */
class LabeledInputView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * Creates an instance of the labeled input view class.
	 *
	 * @param {module:utils/locale~Locale} locale The locale instance.
	 * @param {Function} InputView Constructor of the input view.
	 */
	constructor( locale, InputView ) {
		super( locale );

		const id = `ck-input-${ Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_uid__["a" /* default */])() }`;

		/**
		 * The text of the label.
		 *
		 * @observable
		 * @member {String} #label
		 */
		this.set( 'label' );

		/**
		 * The value of the input.
		 *
		 * @observable
		 * @member {String} #value
		 */
		this.set( 'value' );

		/**
		 * Controls whether the component is in read-only mode.
		 *
		 * @observable
		 * @member {Boolean} #isReadOnly
		 */
		this.set( 'isReadOnly', false );

		/**
		 * The label view.
		 *
		 * @member {module:ui/label/labelview~LabelView} #labelView
		 */
		this.labelView = this._createLabelView( id );

		/**
		 * The input view.
		 *
		 * @member {module:ui/view~View} #inputView
		 */
		this.inputView = this._createInputView( InputView, id );

		const bind = this.bindTemplate;

		this.setTemplate( {
			tag: 'div',
			attributes: {
				class: [
					bind.if( 'isReadOnly', 'ck-disabled' )
				]
			},
			children: [
				this.labelView,
				this.inputView
			]
		} );
	}

	/**
	 * Creates label view class instance and bind with view.
	 *
	 * @private
	 * @param {String} id Unique id to set as labelView#for attribute.
	 * @returns {module:ui/label/labelview~LabelView}
	 */
	_createLabelView( id ) {
		const labelView = new __WEBPACK_IMPORTED_MODULE_2__label_labelview__["a" /* default */]( this.locale );

		labelView.for = id;
		labelView.bind( 'text' ).to( this, 'label' );

		return labelView;
	}

	/**
	 * Creates input view class instance and bind with view.
	 *
	 * @private
	 * @param {Function} InputView Input view constructor.
	 * @param {String} id Unique id to set as inputView#id attribute.
	 * @returns {module:ui/inputtext/inputtextview~InputTextView}
	 */
	_createInputView( InputView, id ) {
		const inputView = new InputView( this.locale );

		inputView.id = id;
		inputView.bind( 'value' ).to( this );
		inputView.bind( 'isReadOnly' ).to( this );

		return inputView;
	}

	/**
	 * Moves the focus to the input and selects the value.
	 */
	select() {
		this.inputView.select();
	}

	/**
	 * Focuses the input.
	 */
	focus() {
		this.inputView.focus();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LabeledInputView;



/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/inputtext/inputtextview
 */



/**
 * The text input view class.
 *
 * @extends module:ui/view~View
 */
class InputTextView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		/**
		 * The value of the input.
		 *
		 * @observable
		 * @member {String} #value
		 */
		this.set( 'value' );

		/**
		 * The `id` attribute of the input (i.e. to pair with a `<label>` element).
		 *
		 * @observable
		 * @member {String} #id
		 */
		this.set( 'id' );

		/**
		 * The `placeholder` attribute of the input.
		 *
		 * @observable
		 * @member {String} #placeholder
		 */
		this.set( 'placeholder' );

		/**
		 * Controls whether the input view is in read-only mode.
		 *
		 * @observable
		 * @member {Boolean} #isReadOnly
		 */
		this.set( 'isReadOnly', false );

		const bind = this.bindTemplate;

		this.setTemplate( {
			tag: 'input',
			attributes: {
				type: 'text',
				class: [
					'ck-input',
					'ck-input-text'
				],
				id: bind.to( 'id' ),
				placeholder: bind.to( 'placeholder' ),
				readonly: bind.to( 'isReadOnly' ),
				value: bind.to( 'value' )
			}
		} );
	}

	/**
	 * Moves the focus to the input and selects the value.
	 */
	select() {
		this.element.select();
	}

	/**
	 * Focuses the input.
	 */
	focus() {
		this.element.focus();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = InputTextView;



/***/ }),
/* 279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = submitHandler;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/bindings/submithandler
 */

/**
 * A handler useful for {@link module:ui/view~View views} working as HTML forms. It intercepts a native DOM
 * `submit` event, prevents the default web browser behavior (navigation and page reload) and
 * fires the `submit` event on a view instead. Such a custom event can be then used by any
 * {@link module:utils/dom/emittermixin~Emitter emitter}, e.g. to serialize the form data.
 *
 *		import submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';
 *
 *		// ...
 *
 *		class AnyFormView extends View {
 *			constructor() {
 *				super();
 *
 *				// ...
 *
 *				submitHandler( {
 *					view: this
 *				} );
 *			}
 *		}
 *
 *		// ...
 *
 *		const view = new AnyFormView();
 *
 *		// A sample listener attached by an emitter working with the view.
 *		this.listenTo( view, 'submit', () => {
 *			saveTheFormData();
 *			hideTheForm();
 *		} );
 *
 * @param {Object} [options] Configuration options.
 * @param {module:ui/view~View} options.view The view which DOM `submit` events should be handled.
 */
function submitHandler( { view } ) {
	view.listenTo( view.element, 'submit', ( evt, domEvt ) => {
		domEvt.preventDefault();
		view.fire( 'submit' );
	}, { useCapture: true } );
}


/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = repositionContextualBalloon;
/* harmony export (immutable) */ __webpack_exports__["a"] = getBalloonPositionData;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_panel_balloon_balloonpanelview__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(35);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/image/ui/utils
 */




/**
 * A helper utility which positions the
 * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon} instance
 * with respect to the image in the editor content, if one is selected.
 *
 * @param {module:core/editor/editor~Editor} editor The editor instance.
 */
function repositionContextualBalloon( editor ) {
	const balloon = editor.plugins.get( 'ContextualBalloon' );

	if ( Object(__WEBPACK_IMPORTED_MODULE_1__utils__["b" /* isImageWidgetSelected */])( editor.editing.view.selection ) ) {
		const position = getBalloonPositionData( editor );

		balloon.updatePosition( position );
	}
}

/**
 * Returns the positioning options that control the geometry of the
 * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon}, with respect
 * to the selected element in the editor content.
 *
 * @param {module:core/editor/editor~Editor} editor The editor instance.
 * @returns {module:utils/dom/position~Options}
 */
function getBalloonPositionData( editor ) {
	const editingView = editor.editing.view;
	const defaultPositions = __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_panel_balloon_balloonpanelview__["a" /* default */].defaultPositions;

	return {
		target: editingView.domConverter.viewToDom( editingView.selection.getSelectedElement() ),
		positions: [
			defaultPositions.northArrowSouth,
			defaultPositions.southArrowNorth
		]
	};
}


/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_attributeelement__ = __webpack_require__(91);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module link/linkelement
 */



/**
 * This class is to mark a specific {@link module:engine/view/node~Node} as a {@link module:link/linkelement~LinkElement}.
 * For example, there could be a situation when different features will create nodes with the same names,
 * and hence they must be identified somehow.
 *
 * @extends module:engine/view/attributelement~AttributeElement
 */
class LinkElement extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_attributeelement__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LinkElement;



/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = findLinkRange;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module link/findlinkrange
 */




/**
 * Walks backward and forward from the start position, node by node, as long as they have the same `linkHref` attribute value and return
 * a {@link module:engine/model/range~Range Range} with the found link.
 *
 * @param {module:engine/model/position~Position} position The start position.
 * @param {String} value The `linkHref` attribute value.
 * @returns {module:engine/model/range~Range} The link range.
 */
function findLinkRange( position, value ) {
	return new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_range__["a" /* default */]( _findBound( position, value, true ), _findBound( position, value, false ) );
}

// Walks forward or backward (depends on the `lookBack` flag), node by node, as long as they have the same `linkHref` attribute value
// and returns a position just before or after (depends on the `lookBack` flag) the last matched node.
//
// @param {module:engine/model/position~Position} position The start position.
// @param {String} value The `linkHref` attribute value.
// @param {Boolean} lookBack Whether the walk direction is forward (`false`) or backward (`true`).
// @returns {module:engine/model/position~Position} The position just before the last matched node.
function _findBound( position, value, lookBack ) {
	// Get node before or after position (depends on `lookBack` flag).
	// When position is inside text node then start searching from text node.
	let node = position.textNode || ( lookBack ? position.nodeBefore : position.nodeAfter );

	let lastNode = null;

	while ( node && node.getAttribute( 'linkHref' ) == value ) {
		lastNode = node;
		node = lookBack ? node.previousSibling : node.nextSibling;
	}

	return lastNode ? __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAt( lastNode, lookBack ? 'before' : 'after' ) : position;
}


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

var encode = __webpack_require__(565),
    decode = __webpack_require__(566);

exports.decode = function(data, level){
	return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
};

exports.decodeStrict = function(data, level){
	return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
};

exports.encode = function(data, level){
	return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
};

exports.encodeXML = encode.XML;

exports.encodeHTML4 =
exports.encodeHTML5 =
exports.encodeHTML  = encode.HTML;

exports.decodeXML =
exports.decodeXMLStrict = decode.XML;

exports.decodeHTML4 =
exports.decodeHTML5 =
exports.decodeHTML = decode.HTML;

exports.decodeHTML4Strict =
exports.decodeHTML5Strict =
exports.decodeHTMLStrict = decode.HTMLStrict;

exports.escape = encode.escape;


/***/ }),
/* 284 */
/***/ (function(module, exports) {

module.exports = {"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

/***/ }),
/* 285 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"","aacute":"","Abreve":"","abreve":"","ac":"","acd":"","acE":"","Acirc":"","acirc":"","acute":"","Acy":"","acy":"","AElig":"","aelig":"","af":"","Afr":"","afr":"","Agrave":"","agrave":"","alefsym":"","aleph":"","Alpha":"","alpha":"","Amacr":"","amacr":"","amalg":"","amp":"&","AMP":"&","andand":"","And":"","and":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angmsd":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","Aogon":"","aogon":"","Aopf":"","aopf":"","apacir":"","ap":"","apE":"","ape":"","apid":"","apos":"'","ApplyFunction":"","approx":"","approxeq":"","Aring":"","aring":"","Ascr":"","ascr":"","Assign":"","ast":"*","asymp":"","asympeq":"","Atilde":"","atilde":"","Auml":"","auml":"","awconint":"","awint":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","Backslash":"","Barv":"","barvee":"","barwed":"","Barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","Bcy":"","bcy":"","bdquo":"","becaus":"","because":"","Because":"","bemptyv":"","bepsi":"","bernou":"","Bernoullis":"","Beta":"","beta":"","beth":"","between":"","Bfr":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bNot":"","bnot":"","Bopf":"","bopf":"","bot":"","bottom":"","bowtie":"","boxbox":"","boxdl":"","boxdL":"","boxDl":"","boxDL":"","boxdr":"","boxdR":"","boxDr":"","boxDR":"","boxh":"","boxH":"","boxhd":"","boxHd":"","boxhD":"","boxHD":"","boxhu":"","boxHu":"","boxhU":"","boxHU":"","boxminus":"","boxplus":"","boxtimes":"","boxul":"","boxuL":"","boxUl":"","boxUL":"","boxur":"","boxuR":"","boxUr":"","boxUR":"","boxv":"","boxV":"","boxvh":"","boxvH":"","boxVh":"","boxVH":"","boxvl":"","boxvL":"","boxVl":"","boxVL":"","boxvr":"","boxvR":"","boxVr":"","boxVR":"","bprime":"","breve":"","Breve":"","brvbar":"","bscr":"","Bscr":"","bsemi":"","bsim":"","bsime":"","bsolb":"","bsol":"\\","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","Bumpeq":"","bumpeq":"","Cacute":"","cacute":"","capand":"","capbrcup":"","capcap":"","cap":"","Cap":"","capcup":"","capdot":"","CapitalDifferentialD":"","caps":"","caret":"","caron":"","Cayleys":"","ccaps":"","Ccaron":"","ccaron":"","Ccedil":"","ccedil":"","Ccirc":"","ccirc":"","Cconint":"","ccups":"","ccupssm":"","Cdot":"","cdot":"","cedil":"","Cedilla":"","cemptyv":"","cent":"","centerdot":"","CenterDot":"","cfr":"","Cfr":"","CHcy":"","chcy":"","check":"","checkmark":"","Chi":"","chi":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledast":"","circledcirc":"","circleddash":"","CircleDot":"","circledR":"","circledS":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","cir":"","cirE":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","clubs":"","clubsuit":"","colon":":","Colon":"","Colone":"","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","Congruent":"","conint":"","Conint":"","ContourIntegral":"","copf":"","Copf":"","coprod":"","Coproduct":"","copy":"","COPY":"","copysr":"","CounterClockwiseContourIntegral":"","crarr":"","cross":"","Cross":"","Cscr":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cupbrcap":"","cupcap":"","CupCap":"","cup":"","Cup":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dagger":"","Dagger":"","daleth":"","darr":"","Darr":"","dArr":"","dash":"","Dashv":"","dashv":"","dbkarow":"","dblac":"","Dcaron":"","dcaron":"","Dcy":"","dcy":"","ddagger":"","ddarr":"","DD":"","dd":"","DDotrahd":"","ddotseq":"","deg":"","Del":"","Delta":"","delta":"","demptyv":"","dfisht":"","Dfr":"","dfr":"","dHar":"","dharl":"","dharr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","diam":"","diamond":"","Diamond":"","diamondsuit":"","diams":"","die":"","DifferentialD":"","digamma":"","disin":"","div":"","divide":"","divideontimes":"","divonx":"","DJcy":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","Dopf":"","dopf":"","Dot":"","dot":"","DotDot":"","doteq":"","doteqdot":"","DotEqual":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrowBar":"","downarrow":"","DownArrow":"","Downarrow":"","DownArrowUpArrow":"","DownBreve":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVectorBar":"","DownLeftVector":"","DownRightTeeVector":"","DownRightVectorBar":"","DownRightVector":"","DownTeeArrow":"","DownTee":"","drbkarow":"","drcorn":"","drcrop":"","Dscr":"","dscr":"","DScy":"","dscy":"","dsol":"","Dstrok":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","DZcy":"","dzcy":"","dzigrarr":"","Eacute":"","eacute":"","easter":"","Ecaron":"","ecaron":"","Ecirc":"","ecirc":"","ecir":"","ecolon":"","Ecy":"","ecy":"","eDDot":"","Edot":"","edot":"","eDot":"","ee":"","efDot":"","Efr":"","efr":"","eg":"","Egrave":"","egrave":"","egs":"","egsdot":"","el":"","Element":"","elinters":"","ell":"","els":"","elsdot":"","Emacr":"","emacr":"","empty":"","emptyset":"","EmptySmallSquare":"","emptyv":"","EmptyVerySmallSquare":"","emsp13":"","emsp14":"","emsp":"","ENG":"","eng":"","ensp":"","Eogon":"","eogon":"","Eopf":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","Epsilon":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","Equal":"","equals":"=","EqualTilde":"","equest":"","Equilibrium":"","equiv":"","equivDD":"","eqvparsl":"","erarr":"","erDot":"","escr":"","Escr":"","esdot":"","Esim":"","esim":"","Eta":"","eta":"","ETH":"","eth":"","Euml":"","euml":"","euro":"","excl":"!","exist":"","Exists":"","expectation":"","exponentiale":"","ExponentialE":"","fallingdotseq":"","Fcy":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","Ffr":"","ffr":"","filig":"","FilledSmallSquare":"","FilledVerySmallSquare":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","Fopf":"","fopf":"","forall":"","ForAll":"","fork":"","forkv":"","Fouriertrf":"","fpartint":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","Fscr":"","gacute":"","Gamma":"","gamma":"","Gammad":"","gammad":"","gap":"","Gbreve":"","gbreve":"","Gcedil":"","Gcirc":"","gcirc":"","Gcy":"","gcy":"","Gdot":"","gdot":"","ge":"","gE":"","gEl":"","gel":"","geq":"","geqq":"","geqslant":"","gescc":"","ges":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","Gfr":"","gfr":"","gg":"","Gg":"","ggg":"","gimel":"","GJcy":"","gjcy":"","gla":"","gl":"","glE":"","glj":"","gnap":"","gnapprox":"","gne":"","gnE":"","gneq":"","gneqq":"","gnsim":"","Gopf":"","gopf":"","grave":"`","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","gscr":"","gsim":"","gsime":"","gsiml":"","gtcc":"","gtcir":"","gt":">","GT":">","Gt":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","Hacek":"","hairsp":"","half":"","hamilt":"","HARDcy":"","hardcy":"","harrcir":"","harr":"","hArr":"","harrw":"","Hat":"^","hbar":"","Hcirc":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","Hfr":"","HilbertSpace":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","Hopf":"","horbar":"","HorizontalLine":"","hscr":"","Hscr":"","hslash":"","Hstrok":"","hstrok":"","HumpDownHump":"","HumpEqual":"","hybull":"","hyphen":"","Iacute":"","iacute":"","ic":"","Icirc":"","icirc":"","Icy":"","icy":"","Idot":"","IEcy":"","iecy":"","iexcl":"","iff":"","ifr":"","Ifr":"","Igrave":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","IJlig":"","ijlig":"","Imacr":"","imacr":"","image":"","ImaginaryI":"","imagline":"","imagpart":"","imath":"","Im":"","imof":"","imped":"","Implies":"","incare":"","in":"","infin":"","infintie":"","inodot":"","intcal":"","int":"","Int":"","integers":"","Integral":"","intercal":"","Intersection":"","intlarhk":"","intprod":"","InvisibleComma":"","InvisibleTimes":"","IOcy":"","iocy":"","Iogon":"","iogon":"","Iopf":"","iopf":"","Iota":"","iota":"","iprod":"","iquest":"","iscr":"","Iscr":"","isin":"","isindot":"","isinE":"","isins":"","isinsv":"","isinv":"","it":"","Itilde":"","itilde":"","Iukcy":"","iukcy":"","Iuml":"","iuml":"","Jcirc":"","jcirc":"","Jcy":"","jcy":"","Jfr":"","jfr":"","jmath":"","Jopf":"","jopf":"","Jscr":"","jscr":"","Jsercy":"","jsercy":"","Jukcy":"","jukcy":"","Kappa":"","kappa":"","kappav":"","Kcedil":"","kcedil":"","Kcy":"","kcy":"","Kfr":"","kfr":"","kgreen":"","KHcy":"","khcy":"","KJcy":"","kjcy":"","Kopf":"","kopf":"","Kscr":"","kscr":"","lAarr":"","Lacute":"","lacute":"","laemptyv":"","lagran":"","Lambda":"","lambda":"","lang":"","Lang":"","langd":"","langle":"","lap":"","Laplacetrf":"","laquo":"","larrb":"","larrbfs":"","larr":"","Larr":"","lArr":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","latail":"","lAtail":"","lat":"","late":"","lates":"","lbarr":"","lBarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","Lcaron":"","lcaron":"","Lcedil":"","lcedil":"","lceil":"","lcub":"{","Lcy":"","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","lE":"","LeftAngleBracket":"","LeftArrowBar":"","leftarrow":"","LeftArrow":"","Leftarrow":"","LeftArrowRightArrow":"","leftarrowtail":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVectorBar":"","LeftDownVector":"","LeftFloor":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","LeftRightArrow":"","Leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","LeftRightVector":"","LeftTeeArrow":"","LeftTee":"","LeftTeeVector":"","leftthreetimes":"","LeftTriangleBar":"","LeftTriangle":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVectorBar":"","LeftUpVector":"","LeftVectorBar":"","LeftVector":"","lEg":"","leg":"","leq":"","leqq":"","leqslant":"","lescc":"","les":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","lessgtr":"","LessLess":"","lesssim":"","LessSlantEqual":"","LessTilde":"","lfisht":"","lfloor":"","Lfr":"","lfr":"","lg":"","lgE":"","lHar":"","lhard":"","lharu":"","lharul":"","lhblk":"","LJcy":"","ljcy":"","llarr":"","ll":"","Ll":"","llcorner":"","Lleftarrow":"","llhard":"","lltri":"","Lmidot":"","lmidot":"","lmoustache":"","lmoust":"","lnap":"","lnapprox":"","lne":"","lnE":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","LongLeftArrow":"","Longleftarrow":"","longleftrightarrow":"","LongLeftRightArrow":"","Longleftrightarrow":"","longmapsto":"","longrightarrow":"","LongRightArrow":"","Longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","Lopf":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","LowerLeftArrow":"","LowerRightArrow":"","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","Lscr":"","lsh":"","Lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","Lstrok":"","lstrok":"","ltcc":"","ltcir":"","lt":"<","LT":"<","Lt":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltri":"","ltrie":"","ltrif":"","ltrPar":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","macr":"","male":"","malt":"","maltese":"","Map":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","Mcy":"","mcy":"","mdash":"","mDDot":"","measuredangle":"","MediumSpace":"","Mellintrf":"","Mfr":"","mfr":"","mho":"","micro":"","midast":"*","midcir":"","mid":"","middot":"","minusb":"","minus":"","minusd":"","minusdu":"","MinusPlus":"","mlcp":"","mldr":"","mnplus":"","models":"","Mopf":"","mopf":"","mp":"","mscr":"","Mscr":"","mstpos":"","Mu":"","mu":"","multimap":"","mumap":"","nabla":"","Nacute":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natural":"","naturals":"","natur":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","Ncaron":"","ncaron":"","Ncedil":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","Ncy":"","ncy":"","ndash":"","nearhk":"","nearr":"","neArr":"","nearrow":"","ne":"","nedot":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","nequiv":"","nesear":"","nesim":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\n","nexist":"","nexists":"","Nfr":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","nGg":"","ngsim":"","nGt":"","ngt":"","ngtr":"","nGtv":"","nharr":"","nhArr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","NJcy":"","njcy":"","nlarr":"","nlArr":"","nldr":"","nlE":"","nle":"","nleftarrow":"","nLeftarrow":"","nleftrightarrow":"","nLeftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nLl":"","nlsim":"","nLt":"","nlt":"","nltri":"","nltrie":"","nLtv":"","nmid":"","NoBreak":"","NonBreakingSpace":"","nopf":"","Nopf":"","Not":"","not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","notin":"","notindot":"","notinE":"","notinva":"","notinvb":"","notinvc":"","NotLeftTriangleBar":"","NotLeftTriangle":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","notni":"","notniva":"","notnivb":"","notnivc":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangleBar":"","NotRightTriangle":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","nparallel":"","npar":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","nprec":"","npreceq":"","npre":"","nrarrc":"","nrarr":"","nrArr":"","nrarrw":"","nrightarrow":"","nRightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","Nscr":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","Ntilde":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","Nu":"","nu":"","num":"#","numero":"","numsp":"","nvap":"","nvdash":"","nvDash":"","nVdash":"","nVDash":"","nvge":"","nvgt":">","nvHarr":"","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwarhk":"","nwarr":"","nwArr":"","nwarrow":"","nwnear":"","Oacute":"","oacute":"","oast":"","Ocirc":"","ocirc":"","ocir":"","Ocy":"","ocy":"","odash":"","Odblac":"","odblac":"","odiv":"","odot":"","odsold":"","OElig":"","oelig":"","ofcir":"","Ofr":"","ofr":"","ogon":"","Ograve":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","Omacr":"","omacr":"","Omega":"","omega":"","Omicron":"","omicron":"","omid":"","ominus":"","Oopf":"","oopf":"","opar":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","operp":"","oplus":"","orarr":"","Or":"","or":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oS":"","Oscr":"","oscr":"","Oslash":"","oslash":"","osol":"","Otilde":"","otilde":"","otimesas":"","Otimes":"","otimes":"","Ouml":"","ouml":"","ovbar":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","para":"","parallel":"","par":"","parsim":"","parsl":"","part":"","PartialD":"","Pcy":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","Pfr":"","pfr":"","Phi":"","phi":"","phiv":"","phmmat":"","phone":"","Pi":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plusacir":"","plusb":"","pluscir":"","plus":"+","plusdo":"","plusdu":"","pluse":"","PlusMinus":"","plusmn":"","plussim":"","plustwo":"","pm":"","Poincareplane":"","pointint":"","popf":"","Popf":"","pound":"","prap":"","Pr":"","pr":"","prcue":"","precapprox":"","prec":"","preccurlyeq":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","pre":"","prE":"","precsim":"","prime":"","Prime":"","primes":"","prnap":"","prnE":"","prnsim":"","prod":"","Product":"","profalar":"","profline":"","profsurf":"","prop":"","Proportional":"","Proportion":"","propto":"","prsim":"","prurel":"","Pscr":"","pscr":"","Psi":"","psi":"","puncsp":"","Qfr":"","qfr":"","qint":"","qopf":"","Qopf":"","qprime":"","Qscr":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quot":"\"","QUOT":"\"","rAarr":"","race":"","Racute":"","racute":"","radic":"","raemptyv":"","rang":"","Rang":"","rangd":"","range":"","rangle":"","raquo":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarr":"","Rarr":"","rArr":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","Rarrtl":"","rarrtl":"","rarrw":"","ratail":"","rAtail":"","ratio":"","rationals":"","rbarr":"","rBarr":"","RBarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","Rcaron":"","rcaron":"","Rcedil":"","rcedil":"","rceil":"","rcub":"}","Rcy":"","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","Re":"","rect":"","reg":"","REG":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","rfisht":"","rfloor":"","rfr":"","Rfr":"","rHar":"","rhard":"","rharu":"","rharul":"","Rho":"","rho":"","rhov":"","RightAngleBracket":"","RightArrowBar":"","rightarrow":"","RightArrow":"","Rightarrow":"","RightArrowLeftArrow":"","rightarrowtail":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVectorBar":"","RightDownVector":"","RightFloor":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","RightTeeArrow":"","RightTee":"","RightTeeVector":"","rightthreetimes":"","RightTriangleBar":"","RightTriangle":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVectorBar":"","RightUpVector":"","RightVectorBar":"","RightVector":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoustache":"","rmoust":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","Ropf":"","roplus":"","rotimes":"","RoundImplies":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","Rrightarrow":"","rsaquo":"","rscr":"","Rscr":"","rsh":"","Rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","RuleDelayed":"","ruluhar":"","rx":"","Sacute":"","sacute":"","sbquo":"","scap":"","Scaron":"","scaron":"","Sc":"","sc":"","sccue":"","sce":"","scE":"","Scedil":"","scedil":"","Scirc":"","scirc":"","scnap":"","scnE":"","scnsim":"","scpolint":"","scsim":"","Scy":"","scy":"","sdotb":"","sdot":"","sdote":"","searhk":"","searr":"","seArr":"","searrow":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","Sfr":"","sfr":"","sfrown":"","sharp":"","SHCHcy":"","shchcy":"","SHcy":"","shcy":"","ShortDownArrow":"","ShortLeftArrow":"","shortmid":"","shortparallel":"","ShortRightArrow":"","ShortUpArrow":"","shy":"","Sigma":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","SmallCircle":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","SOFTcy":"","softcy":"","solbar":"","solb":"","sol":"/","Sopf":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","Sqrt":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","square":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","squarf":"","squ":"","squf":"","srarr":"","Sscr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","Star":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","Sub":"","subdot":"","subE":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","Subset":"","subseteq":"","subseteqq":"","SubsetEqual":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succapprox":"","succ":"","succcurlyeq":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","SuchThat":"","sum":"","Sum":"","sung":"","sup1":"","sup2":"","sup3":"","sup":"","Sup":"","supdot":"","supdsub":"","supE":"","supe":"","supedot":"","Superset":"","SupersetEqual":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","Supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swarhk":"","swarr":"","swArr":"","swarrow":"","swnwar":"","szlig":"","Tab":"\t","target":"","Tau":"","tau":"","tbrk":"","Tcaron":"","tcaron":"","Tcedil":"","tcedil":"","Tcy":"","tcy":"","tdot":"","telrec":"","Tfr":"","tfr":"","there4":"","therefore":"","Therefore":"","Theta":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","ThickSpace":"","ThinSpace":"","thinsp":"","thkap":"","thksim":"","THORN":"","thorn":"","tilde":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","timesbar":"","timesb":"","times":"","timesd":"","tint":"","toea":"","topbot":"","topcir":"","top":"","Topf":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","TRADE":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","TripleDot":"","triplus":"","trisb":"","tritime":"","trpezium":"","Tscr":"","tscr":"","TScy":"","tscy":"","TSHcy":"","tshcy":"","Tstrok":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","Uacute":"","uacute":"","uarr":"","Uarr":"","uArr":"","Uarrocir":"","Ubrcy":"","ubrcy":"","Ubreve":"","ubreve":"","Ucirc":"","ucirc":"","Ucy":"","ucy":"","udarr":"","Udblac":"","udblac":"","udhar":"","ufisht":"","Ufr":"","ufr":"","Ugrave":"","ugrave":"","uHar":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","Umacr":"","umacr":"","uml":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","uogon":"","Uopf":"","uopf":"","UpArrowBar":"","uparrow":"","UpArrow":"","Uparrow":"","UpArrowDownArrow":"","updownarrow":"","UpDownArrow":"","Updownarrow":"","UpEquilibrium":"","upharpoonleft":"","upharpoonright":"","uplus":"","UpperLeftArrow":"","UpperRightArrow":"","upsi":"","Upsi":"","upsih":"","Upsilon":"","upsilon":"","UpTeeArrow":"","UpTee":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","Uring":"","uring":"","urtri":"","Uscr":"","uscr":"","utdot":"","Utilde":"","utilde":"","utri":"","utrif":"","uuarr":"","Uuml":"","uuml":"","uwangle":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","vArr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vBar":"","Vbar":"","vBarv":"","Vcy":"","vcy":"","vdash":"","vDash":"","Vdash":"","VDash":"","Vdashl":"","veebar":"","vee":"","Vee":"","veeeq":"","vellip":"","verbar":"|","Verbar":"","vert":"|","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","vfr":"","vltri":"","vnsub":"","vnsup":"","Vopf":"","vopf":"","vprop":"","vrtri":"","Vscr":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","Vvdash":"","vzigzag":"","Wcirc":"","wcirc":"","wedbar":"","wedge":"","Wedge":"","wedgeq":"","weierp":"","Wfr":"","wfr":"","Wopf":"","wopf":"","wp":"","wr":"","wreath":"","Wscr":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","Xfr":"","xfr":"","xharr":"","xhArr":"","Xi":"","xi":"","xlarr":"","xlArr":"","xmap":"","xnis":"","xodot":"","Xopf":"","xopf":"","xoplus":"","xotime":"","xrarr":"","xrArr":"","Xscr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","Yacute":"","yacute":"","YAcy":"","yacy":"","Ycirc":"","ycirc":"","Ycy":"","ycy":"","yen":"","Yfr":"","yfr":"","YIcy":"","yicy":"","Yopf":"","yopf":"","Yscr":"","yscr":"","YUcy":"","yucy":"","yuml":"","Yuml":"","Zacute":"","zacute":"","Zcaron":"","zcaron":"","Zcy":"","zcy":"","Zdot":"","zdot":"","zeetrf":"","ZeroWidthSpace":"","Zeta":"","zeta":"","zfr":"","Zfr":"","ZHcy":"","zhcy":"","zigrarr":"","zopf":"","Zopf":"","Zscr":"","zscr":"","zwj":"","zwnj":""}

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function Renderer() {}

/**
 *  Walks the AST and calls member methods for each Node type.
 *
 *  @param ast {Node} The root of the abstract syntax tree.
 */
function render(ast) {
  var walker = ast.walker()
    , event
    , type;

  this.buffer = '';
  this.lastOut = '\n';

  while((event = walker.next())) {
    type = event.node.type;
    if (this[type]) {
      this[type](event.node, event.entering);
    }
  }
  return this.buffer;
}

/**
 *  Concatenate a literal string to the buffer.
 *
 *  @param str {String} The string to concatenate.
 */
function lit(str) {
  this.buffer += str;
  this.lastOut = str;
}

/**
 *  Output a newline to the buffer.
 */
function cr() {
  if (this.lastOut !== '\n') {
    this.lit('\n');
  }
}

/**
 *  Concatenate a string to the buffer possibly escaping the content.
 *
 *  Concrete renderer implementations should override this method.
 *
 *  @param str {String} The string to concatenate.
 */
function out(str) {
  this.lit(str);
}

/**
 *  Escape a string for the target renderer.
 *
 *  Abstract function that should be implemented by concrete 
 *  renderer implementations.
 *
 *  @param str {String} The string to escape.
 */
function esc(str) {
  return str;
}

Renderer.prototype.render = render;
Renderer.prototype.out = out;
Renderer.prototype.lit = lit;
Renderer.prototype.cr  = cr;
Renderer.prototype.esc  = esc;

module.exports = Renderer;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(288);


/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_editor_classic_src_classiceditor__ = __webpack_require__(289);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_editor_balloon_src_ballooneditor__ = __webpack_require__(448);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_essentials_src_essentials__ = __webpack_require__(456);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_autoformat_src_autoformat__ = __webpack_require__(481);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_basic_styles_src_bold__ = __webpack_require__(484);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_basic_styles_src_italic__ = __webpack_require__(487);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_block_quote_src_blockquote__ = __webpack_require__(490);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_heading_src_heading__ = __webpack_require__(496);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_image_src_image__ = __webpack_require__(509);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_image_src_imagecaption__ = __webpack_require__(526);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ckeditor_ckeditor5_image_src_imagestyle__ = __webpack_require__(534);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ckeditor_ckeditor5_image_src_imagetoolbar__ = __webpack_require__(542);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ckeditor_ckeditor5_link_src_link__ = __webpack_require__(543);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ckeditor_ckeditor5_list_src_list__ = __webpack_require__(552);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_paragraph_src_paragraph__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__ckeditor_ckeditor5_markdown_gfm_src_commonmarkdataprocessor__ = __webpack_require__(560);
















function Markdown(editor) {
    editor.data.processor = new __WEBPACK_IMPORTED_MODULE_15__ckeditor_ckeditor5_markdown_gfm_src_commonmarkdataprocessor__["a" /* default */]();
}
class OPClassicEditor extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_editor_classic_src_classiceditor__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["OPClassicEditor"] = OPClassicEditor;

class OPBalloonEditor extends __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_editor_balloon_src_ballooneditor__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["OPBalloonEditor"] = OPBalloonEditor;

window.BalloonEditor = OPBalloonEditor;
window.ClassicEditor = OPClassicEditor;
const config = {
    plugins: [
        Markdown,
        __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_essentials_src_essentials__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_autoformat_src_autoformat__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_basic_styles_src_bold__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_basic_styles_src_italic__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_block_quote_src_blockquote__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_heading_src_heading__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_image_src_image__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_image_src_imagecaption__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_10__ckeditor_ckeditor5_image_src_imagestyle__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_11__ckeditor_ckeditor5_image_src_imagetoolbar__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_12__ckeditor_ckeditor5_link_src_link__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_13__ckeditor_ckeditor5_list_src_list__["a" /* default */],
        __WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_paragraph_src_paragraph__["a" /* default */],
    ],
    config: {
        toolbar: [
            'headings',
            'bold',
            'italic',
            'link',
            'bulletedList',
            'numberedList',
            'blockQuote',
            'undo',
            'redo'
        ],
        image: {
            toolbar: [
                'imageStyleFull',
                'imageStyleSide',
                '|',
                'imageTextAlternative'
            ]
        }
    }
};
OPClassicEditor.build = config;
OPBalloonEditor.build = config;


/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_editor_standardeditor__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_dataprocessor_htmldataprocessor__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classiceditorui__ = __webpack_require__(436);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__classiceditoruiview__ = __webpack_require__(437);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_elementreplacer__ = __webpack_require__(444);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__theme_theme_scss__ = __webpack_require__(445);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__theme_theme_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__theme_theme_scss__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module editor-classic/classiceditor
 */









/**
 * The {@glink builds/guides/overview#Classic-editor classic editor} implementation.
 * It uses an inline editable and a sticky toolbar, all enclosed in a boxed UI.
 * See the {@glink examples/builds/classic-editor demo}.
 *
 * In order to create a classic editor instance, use the static
 * {@link module:editor-classic/classiceditor~ClassicEditor#create `ClassicEditor.create()`} method.
 *
 * # Classic editor and classic build
 *
 * The classic editor can be used directly from source (if you installed the
 * [`@ckeditor/ckeditor5-editor-classic`](https://www.npmjs.com/package/@ckeditor/ckeditor5-editor-classic) package)
 * but it is also available in the {@glink builds/guides/overview#Classic-editor classic build}.
 *
 * {@glink builds/guides/overview Builds} are ready-to-use editors with plugins bundled in. When using the editor from
 * source you need to take care of loading all plugins by yourself
 * (through the {@link module:core/editor/editorconfig~EditorConfig#plugins `config.plugins`} option).
 * Using the editor from source gives much better flexibility and allows easier customization.
 *
 * Read more about initializing the editor from source or as a build in
 * {@link module:editor-classic/classiceditor~ClassicEditor#create `ClassicEditor.create()`}.
 *
 * @extends module:core/editor/standardeditor~StandardEditor
 */
class ClassicEditor extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_editor_standardeditor__["a" /* default */] {
	/**
	 * Creates an instance of the classic editor.
	 *
	 * **Note:** do not use the constructor to create editor instances. Use the static
	 * {@link module:editor-classic/classiceditor~ClassicEditor#create `ClassicEditor.create()`} method instead.
	 *
	 * @protected
	 * @param {HTMLElement} element The DOM element that will be the source for the created editor.
	 * The data will be loaded from it and loaded back to it once the editor is destroyed.
	 * @param {module:core/editor/editorconfig~EditorConfig} config The editor configuration.
	 */
	constructor( element, config ) {
		super( element, config );

		this.document.createRoot();
		this.data.processor = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_dataprocessor_htmldataprocessor__["a" /* default */]();
		this.ui = new __WEBPACK_IMPORTED_MODULE_2__classiceditorui__["a" /* default */]( this, new __WEBPACK_IMPORTED_MODULE_3__classiceditoruiview__["a" /* default */]( this.locale ) );

		/**
		 * The element replacer instance used to hide the editor element.
		 *
		 * @protected
		 * @member {module:utils/elementreplacer~ElementReplacer}
		 */
		this._elementReplacer = new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_elementreplacer__["a" /* default */]();
	}

	/**
	 * Destroys the editor instance, releasing all resources used by it.
	 *
	 * Updates the original editor element with the data.
	 *
	 * @returns {Promise}
	 */
	destroy() {
		this.updateEditorElement();
		this._elementReplacer.restore();
		this.ui.destroy();

		return super.destroy();
	}

	/**
	 * Creates a classic editor instance.
	 *
	 * Creating instance when using {@glink builds/index CKEditor build}:
	 *
	 *		ClassicEditor
	 *			.create( document.querySelector( '#editor' ) )
	 *			.then( editor => {
	 *				console.log( 'Editor was initialized', editor );
	 *			} )
	 *			.catch( err => {
	 *				console.error( err.stack );
	 *			} );
	 *
	 * Creating instance when using CKEditor from source (make sure to specify the list of plugins to load and the toolbar):
	 *
	 *		import ClassicEditor from '@ckeditor/ckeditor5-editor-classic/src/classiceditor';
	 *		import Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';
	 *		import Bold from '@ckeditor/ckeditor5-basic-styles/src/bold';
	 *		import Italic from '@ckeditor/ckeditor5-basic-styles/src/italic';
	 *		import ...
	 *
	 *		ClassicEditor
	 *			.create( document.querySelector( '#editor' ), {
	 *				plugins: [ Essentials, Bold, Italic, ... ],
	 *				toolbar: [ 'bold', 'italic', ... ]
	 *			} )
	 *			.then( editor => {
	 *				console.log( 'Editor was initialized', editor );
	 *			} )
	 *			.catch( err => {
	 *				console.error( err.stack );
	 *			} );
	 *
	 * @param {HTMLElement} element The DOM element that will be the source for the created editor.
	 * The data will be loaded from it and loaded back to it once the editor is destroyed.
	 * @param {module:core/editor/editorconfig~EditorConfig} config The editor configuration.
	 * @returns {Promise} A promise resolved once the editor is ready.
	 * The promise returns the created {@link module:editor-classic/classiceditor~ClassicEditor} instance.
	 */
	static create( element, config ) {
		return new Promise( resolve => {
			const editor = new this( element, config );

			resolve(
				editor.initPlugins()
					.then( () => editor.ui.init() )
					.then( () => {
						editor._elementReplacer.replace( element, editor.ui.view.element );
						editor.fire( 'uiReady' );
					} )
					.then( () => editor.editing.view.attachDomRoot( editor.ui.view.editableElement ) )
					.then( () => editor.loadDataFromEditorElement() )
					.then( () => {
						editor.fire( 'dataReady' );
						editor.fire( 'ready' );
					} )
					.then( () => editor )
			);
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ClassicEditor;



/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_config__ = __webpack_require__(291);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__plugincollection__ = __webpack_require__(292);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__commandcollection__ = __webpack_require__(293);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_locale__ = __webpack_require__(294);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_controller_datacontroller__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_model_document__ = __webpack_require__(367);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module core/editor/editor
 */











/**
 * Class representing a basic editor. It contains a base architecture, without much additional logic.
 *
 * See also {@link module:core/editor/standardeditor~StandardEditor}.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */
class Editor {
	/**
	 * Creates a new instance of the Editor class.
	 *
	 * @param {Object} config The editor config.
	 */
	constructor( config ) {
		const availablePlugins = this.constructor.build && this.constructor.build.plugins;

		/**
		 * Holds all configurations specific to this editor instance.
		 *
		 * @readonly
		 * @member {module:utils/config~Config}
		 */
		this.config = new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_config__["a" /* default */]( config, this.constructor.build && this.constructor.build.config );

		this.config.define( 'plugins', availablePlugins );

		/**
		 * The plugins loaded and in use by this editor instance.
		 *
		 * @readonly
		 * @member {module:core/plugincollection~PluginCollection}
		 */
		this.plugins = new __WEBPACK_IMPORTED_MODULE_1__plugincollection__["a" /* default */]( this, availablePlugins );

		/**
		 * Commands registered to the editor.
		 *
		 * @readonly
		 * @member {module:core/commandcollection~CommandCollection}
		 */
		this.commands = new __WEBPACK_IMPORTED_MODULE_2__commandcollection__["a" /* default */]();

		/**
		 * @readonly
		 * @member {module:utils/locale~Locale}
		 */
		this.locale = new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_locale__["a" /* default */]( this.config.get( 'lang' ) );

		/**
		 * Shorthand for {@link module:utils/locale~Locale#t}.
		 *
		 * @see module:utils/locale~Locale#t
		 * @method #t
		 */
		this.t = this.locale.t;

		/**
		 * The editor's model document.
		 *
		 * The center of the editor's abstract data model. The document contains
		 * {@link module:engine/model/document~Document#getRoot all editing roots},
		 * {@link module:engine/model/document~Document#selection} and allows
		 * applying changes to through the {@link module:engine/model/document~Document#batch batch interface}.
		 *
		 * Besides the model document, the editor usually contains two controllers 
		 * {@link #data data controller} and {@link #editing editing controller}.
		 * The former is used e.g. when setting or retrieving editor data and contains a useful
		 * set of methods for operating on the content. The latter controls user input and rendering
		 * the content for editing.
		 *
		 * @readonly
		 * @member {module:engine/model/document~Document}
		 */
		this.document = new __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_model_document__["a" /* default */]();

		/**
		 * The {@link module:engine/controller/datacontroller~DataController data controller}.
		 *
		 * @readonly
		 * @member {module:engine/controller/datacontroller~DataController}
		 */
		this.data = new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_controller_datacontroller__["a" /* default */]( this.document );

		/**
		 * Defines whether this editor is in read-only mode.
		 *
		 * In read-only mode the editor {@link #commands commands} are disabled so it is not possible
		 * to modify document using them.
		 *
		 * @observable
		 * @member {Boolean} #isReadOnly
		 */
		this.set( 'isReadOnly', false );

		/**
		 * The {@link module:engine/controller/editingcontroller~EditingController editing controller}.
		 *
		 * This property is set by more specialized editor classes (such as {@link module:core/editor/standardeditor~StandardEditor}),
		 * however, it's required for features to work as their engine-related parts will try to connect converters.
		 *
		 * When defining a virtual editor class, like one working in Node.js, it's possible to plug a virtual
		 * editing controller which only instantiates necessary properties, but without any observers and listeners.
		 *
		 * @readonly
		 * @member {module:engine/controller/editingcontroller~EditingController} #editing
		 */
	}

	/**
	 * Loads and initializes plugins specified in the config.
	 *
	 * @returns {Promise} A promise which resolves once the initialization is completed.
	 */
	initPlugins() {
		const that = this;
		const config = this.config;

		return loadPlugins()
			.then( loadedPlugins => {
				return initPlugins( loadedPlugins, 'init' )
					.then( () => initPlugins( loadedPlugins, 'afterInit' ) );
			} )
			.then( () => this.fire( 'pluginsReady' ) );

		function loadPlugins() {
			const plugins = config.get( 'plugins' ) || [];
			const removePlugins = config.get( 'removePlugins' ) || [];

			return that.plugins.load( plugins, removePlugins );
		}

		function initPlugins( loadedPlugins, method ) {
			return loadedPlugins.reduce( ( promise, plugin ) => {
				if ( !plugin[ method ] ) {
					return promise;
				}

				return promise.then( plugin[ method ].bind( plugin ) );
			}, Promise.resolve() );
		}
	}

	/**
	 * Destroys the editor instance, releasing all resources used by it.
	 *
	 * @fires destroy
	 * @returns {Promise} A promise that resolves once the editor instance is fully destroyed.
	 */
	destroy() {
		this.fire( 'destroy' );

		this.stopListening();

		this.commands.destroy();

		return this.plugins.destroy()
			.then( () => {
				this.document.destroy();
				this.data.destroy();
			} );
	}

	/**
	 * Executes specified command with given parameters.
	 *
	 * Shorthand for:
	 *
	 *		editor.commands.get( commandName ).execute( ... );
	 *
	 * @param {String} commandName Name of command to execute.
	 * @param {*} [...commandParams] Command parameters.
	 */
	execute( ...args ) {
		this.commands.execute( ...args );
	}

	/**
	 * Creates a basic editor instance.
	 *
	 * @param {Object} config The editor config. You can find the list of config options in
	 * {@link module:core/editor/editorconfig~EditorConfig}.
	 * @returns {Promise} Promise resolved once editor is ready.
	 * @returns {module:core/editor/editor~Editor} return.editor The editor instance.
	 */
	static create( config ) {
		return new Promise( resolve => {
			const editor = new this( config );

			resolve(
				editor.initPlugins()
					.then( () => {
						editor.fire( 'dataReady' );
						editor.fire( 'ready' );
					} )
					.then( () => editor )
			);
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Editor;


Object(__WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Editor, __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );

/**
 * Fired after {@link #initPlugins plugins are initialized}.
 *
 * @event pluginsReady
 */

/**
 * Fired when the editor UI is ready. This event won't be fired if the editor has no UI.
 *
 * @event uiReady
 */

/**
 * Fired when the data loaded to the editor is ready. If a specific editor doesn't load
 * any data initially, this event will be fired right before {@link #event:ready}.
 *
 * @event dataReady
 */

/**
 * Fired when {@link #event:pluginsReady plugins}, {@link #event:uiReady UI} and {@link #event:dataReady data} and all additional
 * editor components are ready.
 *
 * @event ready
 */

/**
 * Fired when this editor instance is destroyed. The editor at this point is not usable and this event should be used to
 * perform the clean-up in any plugin.
 *
 * @event destroy
 */

/**
 * Additional data built into the editor class. It's used while bundling the editor in order to provide
 * the default set of plugins and config options which are later used during editor initialization.
 *
 * Two properties are supported:
 *
 * * `plugins`  an array of plugin constructors. They will be automatically initialized by the editor, unless listed
 * in `config.removePlugins` or unless `config.plugins` is passed.
 * * `config`  the defalt config options.
 *
 * @static
 * @member {Object} module:core/editor/editor~Editor.build
 */


/***/ }),
/* 291 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_lodash_isPlainObject__ = __webpack_require__(75);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/config
 */



/**
 * Handles a configuration dictionary.
 */
class Config {
	/**
	 * Creates an instance of the {@link ~Config} class.
	 *
	 * @param {Object} [configurations] The initial configurations to be set. Usually, provided by the user.
	 * @param {Object} [defaultConfigurations] The default configurations. Usually, provided by the system.
	 */
	constructor( configurations, defaultConfigurations ) {
		/**
		 * Store for the whole configuration.
		 *
		 * @private
		 * @member {Object}
		 */
		this._config = {};

		// Set default configuration.
		if ( defaultConfigurations ) {
			this.define( defaultConfigurations );
		}

		// Set initial configuration.
		if ( configurations ) {
			this._setObjectToTarget( this._config, configurations );
		}
	}

	/**
	 * Set configuration values.
	 *
	 * It accepts both a name/value pair or an object, which properties and values will be used to set
	 * configurations.
	 *
	 * It also accepts setting a "deep configuration" by using dots in the name. For example, `'resize.width'` sets
	 * the value for the `width` configuration in the `resize` subset.
	 *
	 *		config.set( 'width', 500 );
	 *		config.set( 'toolbar.collapsed', true );
	 *
	 *		// Equivalent to:
	 *		config.set( {
	 *			width: 500
	 *			toolbar: {
	 *				collapsed: true
	 *			}
	 *		} );
	 *
	 * Passing an object as the value will amend the configuration, not replace it.
	 *
	 *		config.set( 'toolbar', {
	 *			collapsed: true,
	 *		} );
	 *
	 *		config.set( 'toolbar', {
	 *			color: 'red',
	 *		} );
	 *
	 *		config.get( 'toolbar.collapsed' ); // true
	 *		config.get( 'toolbar.color' ); // 'red'
	 *
	 * @param {String|Object} name The configuration name or an object from which take properties as
	 * configuration entries. Configuration names are case-sensitive.
	 * @param {*} value The configuration value. Used if a name is passed.
	 */
	set( name, value ) {
		this._setToTarget( this._config, name, value );
	}

	/**
	 * Does exactly the same as {@link #set} with one exception  passed configuration extends
	 * existing one, but does not overwrite already defined values.
	 *
	 * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be
	 * rarely used for other needs.
	 *
	 * @param {String|Object} name The configuration name or an object from which take properties as
	 * configuration entries. Configuration names are case-sensitive.
	 * @param {*} value The configuration value. Used if a name is passed.
	 */
	define( name, value ) {
		const isDefine = true;

		this._setToTarget( this._config, name, value, isDefine );
	}

	/**
	 * Gets the value for a configuration entry.
	 *
	 *		config.get( 'name' );
	 *
	 * Deep configurations can be retrieved by separating each part with a dot.
	 *
	 *		config.get( 'toolbar.collapsed' );
	 *
	 * @param {String} name The configuration name. Configuration names are case-sensitive.
	 * @returns {*} The configuration value or `undefined` if the configuration entry was not found.
	 */
	get( name ) {
		return this._getFromSource( this._config, name );
	}

	/**
	 * Saves passed configuration to the specified target (nested object).
	 *
	 * @private
	 * @param {Object} target Nested config object.
	 * @param {String|Object} name The configuration name or an object from which take properties as
	 * configuration entries. Configuration names are case-sensitive.
	 * @param {*} value The configuration value. Used if a name is passed.
	 * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.
	 */
	_setToTarget( target, name, value, isDefine = false ) {
		// In case of an object, iterate through it and call `_setToTarget` again for each property.
		if ( Object(__WEBPACK_IMPORTED_MODULE_0__lib_lodash_isPlainObject__["a" /* default */])( name ) ) {
			this._setObjectToTarget( target, name, isDefine );

			return;
		}

		// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].
		const parts = name.split( '.' );

		// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.
		name = parts.pop();

		// Iterate over parts to check if currently stored configuration has proper structure.
		for ( const part of parts ) {
			// If there is no object for specified part then create one.
			if ( !Object(__WEBPACK_IMPORTED_MODULE_0__lib_lodash_isPlainObject__["a" /* default */])( target[ part ] ) ) {
				target[ part ] = {};
			}

			// Nested object becomes a target.
			target = target[ part ];
		}

		// In case of value is an object.
		if ( Object(__WEBPACK_IMPORTED_MODULE_0__lib_lodash_isPlainObject__["a" /* default */])( value ) ) {
			// We take care of proper config structure.
			if ( !Object(__WEBPACK_IMPORTED_MODULE_0__lib_lodash_isPlainObject__["a" /* default */])( target[ name ] ) ) {
				target[ name ] = {};
			}

			target = target[ name ];

			// And iterate through this object calling `_setToTarget` again for each property.
			this._setObjectToTarget( target, value, isDefine );

			return;
		}

		// Do nothing if we are defining configuration for non empty name.
		if ( isDefine && typeof target[ name ] != 'undefined' ) {
			return;
		}

		target[ name ] = value;
	}

	/**
	 * Get specified configuration from specified source (nested object).
	 *
	 * @private
	 * @param {Object} source level of nested object.
	 * @param {String} name The configuration name. Configuration names are case-sensitive.
	 * @returns {*} The configuration value or `undefined` if the configuration entry was not found.
	 */
	_getFromSource( source, name ) {
		// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].
		const parts = name.split( '.' );

		// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.
		name = parts.pop();

		// Iterate over parts to check if currently stored configuration has proper structure.
		for ( const part of parts ) {
			if ( !Object(__WEBPACK_IMPORTED_MODULE_0__lib_lodash_isPlainObject__["a" /* default */])( source[ part ] ) ) {
				source = null;
				break;
			}

			// Nested object becomes a source.
			source = source[ part ];
		}

		// Always returns undefined for non existing configuration
		return source ? source[ name ] : undefined;
	}

	/**
	 * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.
	 *
	 * @private
	 * @param {Object} target Nested config object.
	 * @param {Object} configuration Configuration data set
	 * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.
	 */
	_setObjectToTarget( target, configuration, isDefine ) {
		Object.keys( configuration ).forEach( key => {
			this._setToTarget( target, key, configuration[ key ], isDefine );
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Config;



/***/ }),
/* 292 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_log__ = __webpack_require__(26);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module core/plugincollection
 */




/**
 * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.
 */
class PluginCollection {
	/**
	 * Creates an instance of the PluginCollection class.
	 * Allows loading and initializing plugins and their dependencies.
	 *
	 * @param {module:core/editor/editor~Editor} editor
	 * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use
	 * when {@link module:core/plugincollection~PluginCollection#load} is used with plugin names (strings, instead of constructors).
	 * Usually, the editor will pass its built-in plugins to the collection so they can later be
	 * used in `config.plugins` or `config.removePlugins` by names.
	 */
	constructor( editor, availablePlugins = [] ) {
		/**
		 * @protected
		 * @member {module:core/editor/editor~Editor} module:core/plugin~PluginCollection#_editor
		 */
		this._editor = editor;

		/**
		 * Map of plugin constructors which can be retrieved by their names.
		 *
		 * @protected
		 * @member {Map.<String|Function,Function>} module:core/plugin~PluginCollection#_availablePlugins
		 */
		this._availablePlugins = new Map();

		/**
		 * @protected
		 * @member {Map} module:core/plugin~PluginCollection#_plugins
		 */
		this._plugins = new Map();

		for ( const PluginConstructor of availablePlugins ) {
			this._availablePlugins.set( PluginConstructor, PluginConstructor );

			if ( PluginConstructor.pluginName ) {
				this._availablePlugins.set( PluginConstructor.pluginName, PluginConstructor );
			}
		}
	}

	/**
	 * Collection iterator. Returns `[ PluginConstructor, pluginInstance ]` pairs.
	 */
	* [ Symbol.iterator ]() {
		for ( const entry of this._plugins ) {
			if ( typeof entry[ 0 ] == 'function' ) {
				yield entry;
			}
		}
	}

	/**
	 * Gets the plugin instance by its constructor or name.
	 *
	 * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.
	 * @returns {module:core/plugin~PluginInterface}
	 */
	get( key ) {
		return this._plugins.get( key );
	}

	/**
	 * Loads a set of plugins and adds them to the collection.
	 *
	 * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}
	 * or {@link module:core/plugin~PluginInterface.pluginName plugin names}. The second option (names) work only if
	 * `availablePlugins` were passed to the {@link #constructor}.
	 * @param {Array.<String|Function>} [removePlugins] Names of plugins or plugin constructors
	 * which should not be loaded (despite being specified in the `plugins` array).
	 * @returns {Promise} A promise which gets resolved once all plugins are loaded and available into the
	 * collection.
	 * @returns {Promise.<Array.<module:core/plugin~PluginInterface>>} returns.loadedPlugins The array of loaded plugins.
	 */
	load( plugins, removePlugins = [] ) {
		const that = this;
		const editor = this._editor;
		const loading = new Set();
		const loaded = [];

		const pluginConstructors = mapToAvailableConstructors( plugins );
		const removePluginConstructors = mapToAvailableConstructors( removePlugins );
		const missingPlugins = getMissingPluginNames( plugins );

		if ( missingPlugins ) {
			// TODO update this error docs with links to docs because it will be a frequent problem.

			/**
			 * Some plugins are not available and could not be loaded.
			 *
			 * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.
			 * This is usually done by the builder by setting the {@link module:core/editor/editor~Editor.build}
			 * property.
			 *
			 * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}** it means
			 * that you try to enable a plugin which was not included into that build. This may a be due to a typo
			 * in the plugin name or simply because that plugin is not part of this build. In the latter scenario,
			 * read more about {@glink builds/guides/development/custom-builds custom builds}.
			 *
			 * **If you see this warning when using one of the editor creators directly** (not a build), then it means
			 * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a "plugin loader".
			 * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to
			 * provide each plugin through reference (as a constructor function). Check out the examples in
			 * {@glink builds/guides/integration/advanced-setup#Scenario-2-Building-from-source "Building from source"}.
			 *
			 * @error plugincollection-plugin-not-found
			 * @param {Array.<String>} plugins The name of the plugins which could not be loaded.
			 */
			const errorMsg = 'plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.';

			// Log the error so it's more visible on the console. Hopefully, for better DX.
			__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_log__["a" /* default */].error( errorMsg, { plugins: missingPlugins } );

			return Promise.reject( new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( errorMsg, { plugins: missingPlugins } ) );
		}

		return Promise.all( pluginConstructors.map( loadPlugin ) )
			.then( () => loaded );

		function loadPlugin( PluginConstructor ) {
			if ( removePluginConstructors.includes( PluginConstructor ) ) {
				return;
			}

			// The plugin is already loaded or being loaded - do nothing.
			if ( that.get( PluginConstructor ) || loading.has( PluginConstructor ) ) {
				return;
			}

			return instantiatePlugin( PluginConstructor )
				.catch( err => {
					/**
					 * It was not possible to load the plugin.
					 *
					 * This is a generic error logged to the console when a JavaSript error is thrown during one of
					 * the plugins initialization.
					 *
					 * If you correctly handled a promise returned by the editor's `create()` method (like shown below)
					 * you will find the original error logged on the console too:
					 *
					 *		ClassicEditor.create( document.getElementById( 'editor' ) )
					 *			.then( editor => {
					 *				// ...
					 * 			} )
					 *			.catch( error => {
					 *				console.error( error );
					 *			} );
					 *
					 * @error plugincollection-load
					 * @param {String} plugin The name of the plugin that could not be loaded.
					 */
					__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_log__["a" /* default */].error( 'plugincollection-load: It was not possible to load the plugin.', { plugin: PluginConstructor } );

					throw err;
				} );
		}

		function instantiatePlugin( PluginConstructor ) {
			return new Promise( resolve => {
				loading.add( PluginConstructor );

				if ( PluginConstructor.requires ) {
					PluginConstructor.requires.forEach( RequiredPluginConstructorOrName => {
						const RequiredPluginConstructor = getPluginConstructor( RequiredPluginConstructorOrName );

						if ( removePlugins.includes( RequiredPluginConstructor ) ) {
							/**
							 * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.
							 *
							 * @error plugincollection-required
							 * @param {Function} plugin The required plugin.
							 * @param {Function} requiredBy The parent plugin.
							 */
							throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
								'plugincollection-required: Cannot load a plugin because one of its dependencies is listed in' +
								'the `removePlugins` option.',
								{ plugin: RequiredPluginConstructor, requiredBy: PluginConstructor }
							);
						}

						loadPlugin( RequiredPluginConstructor );
					} );
				}

				const plugin = new PluginConstructor( editor );
				that._add( PluginConstructor, plugin );
				loaded.push( plugin );

				resolve();
			} );
		}

		function getPluginConstructor( PluginConstructorOrName ) {
			if ( typeof PluginConstructorOrName == 'function' ) {
				return PluginConstructorOrName;
			}

			return that._availablePlugins.get( PluginConstructorOrName );
		}

		function getMissingPluginNames( plugins ) {
			const missingPlugins = [];

			for ( const pluginNameOrConstructor of plugins ) {
				if ( !getPluginConstructor( pluginNameOrConstructor ) ) {
					missingPlugins.push( pluginNameOrConstructor );
				}
			}

			return missingPlugins.length ? missingPlugins : null;
		}

		function mapToAvailableConstructors( plugins ) {
			return plugins
				.map( pluginNameOrConstructor => getPluginConstructor( pluginNameOrConstructor ) )
				.filter( PluginConstructor => !!PluginConstructor );
		}
	}

	/**
	 * Destroys all loaded plugins.
	 *
	 * @returns {Promise}
	 */
	destroy() {
		const promises = Array.from( this )
			.map( ( [ , pluginInstance ] ) => pluginInstance )
			.filter( pluginInstance => typeof pluginInstance.destroy == 'function' )
			.map( pluginInstance => pluginInstance.destroy() );

		return Promise.all( promises );
	}

	/**
	 * Adds the plugin to the collection. Exposed mainly for testing purposes.
	 *
	 * @protected
	 * @param {Function} PluginConstructor The plugin constructor.
	 * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.
	 */
	_add( PluginConstructor, plugin ) {
		this._plugins.set( PluginConstructor, plugin );

		const pluginName = PluginConstructor.pluginName;

		if ( !pluginName ) {
			return;
		}

		if ( this._plugins.has( pluginName ) ) {
			/**
			 * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.
			 * This may lead to runtime conflicts between these plugins. This usually means that incorrect
			 * params were passed to {@link module:core/editor/editor~Editor.create}.
			 *
			 * @error plugincollection-plugin-name-conflict
			 * @param {String} pluginName The duplicated plugin name.
			 * @param {Function} plugin1 The first plugin constructor.
			 * @param {Function} plugin2 The second plugin constructor.
			 */
			__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_log__["a" /* default */].warn(
				'plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.',
				{ pluginName, plugin1: this._plugins.get( pluginName ).constructor, plugin2: PluginConstructor }
			);
		} else {
			this._plugins.set( pluginName, plugin );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PluginCollection;



/***/ }),
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module core/commandcollection
 */



/**
 * Collection of commands. Its instance is available in {@link module:core/editor/editor~Editor#commands `editor.commands`}.
 */
class CommandCollection {
	/**
	 * Creates collection instance.
	 */
	constructor() {
		/**
		 * Command map.
		 *
		 * @private
		 * @member {Map}
		 */
		this._commands = new Map();
	}

	/**
	 * Registers a new command.
	 *
	 * @param {String} commandName The name of the command.
	 * @param {module:core/command~Command} command
	 */
	add( commandName, command ) {
		this._commands.set( commandName, command );
	}

	/**
	 * Retrieves a command from the collection.
	 *
	 * @param {String} commandName The name of the command.
	 * @returns {module:core/command~Command}
	 */
	get( commandName ) {
		return this._commands.get( commandName );
	}

	/**
	 * Executes a command.
	 *
	 * @param {String} commandName The name of the command.
	 */
	execute( commandName, ...args ) {
		const command = this.get( commandName );

		if ( !command ) {
			/**
			 * Command does not exist.
			 *
			 * @error commandcollection-command-not-found
			 * @param {String} commandName Name of the command.
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'commandcollection-command-not-found: Command does not exist.', { commandName } );
		}

		command.execute( ...args );
	}

	/**
	 * Returns iterator of command names.
	 *
	 * @returns {Iterator.<String>}
	 */
	* names() {
		yield* this._commands.keys();
	}

	/**
	 * Returns iterator of command instances.
	 *
	 * @returns {Iterator.<module:core/command~Command>}
	 */
	* commands() {
		yield* this._commands.values();
	}

	/**
	 * Collection iterator.
	 */
	[ Symbol.iterator ]() {
		return this._commands[ Symbol.iterator ]();
	}

	/**
	 * Destroys all collection commands.
	 */
	destroy() {
		for ( const command of this.commands() ) {
			command.destroy();
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CommandCollection;



/***/ }),
/* 294 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__translation_service__ = __webpack_require__(295);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/locale
 */



/**
 * Represents the localization services.
 */
class Locale {
	/**
	 * Creates a new instance of the Locale class.
	 *
	 * @param {String} [lang='en'] The language code in [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
	 */
	constructor( lang ) {
		/**
		 * The language code in [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
		 *
		 * @readonly
		 * @member {String}
		 */
		this.lang = lang || 'en';

		/**
		 * Translates the given string to the {@link #lang}. This method is also availble in {@link module:core/editor/editor~Editor#t} and
		 * {@link module:ui/view~View#t}.
		 *
		 * The strings may contain placeholders (`%<index>`) for values which are passed as the second argument.
		 * `<index>` is the index in the `values` array.
		 *
		 *		editor.t( 'Created file "%0" in %1ms.', [ fileName, timeTaken ] );
		 *
		 * This method's context is statically bound to Locale instance,
		 * so it can be called as a function:
		 *
		 *		const t = this.t;
		 *		t( 'Label' );
		 *
		 * @method #t
		 * @param {String} str The string to translate.
		 * @param {String[]} values Values that should be used to interpolate the string.
		 */
		this.t = ( ...args ) => this._t( ...args );
	}

	/**
	 * Base for the {@link #t} method.
	 *
	 * @private
	 */
	_t( str, values ) {
		let translatedString = Object(__WEBPACK_IMPORTED_MODULE_0__translation_service__["a" /* translate */])( this.lang, str );

		if ( values ) {
			translatedString = translatedString.replace( /%(\d+)/g, ( match, index ) => {
				return ( index < values.length ) ? values[ index ] : match;
			} );
		}

		return translatedString;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Locale;



/***/ }),
/* 295 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export add */
/* harmony export (immutable) */ __webpack_exports__["a"] = translate;
/* unused harmony export _clear */
/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/translation-service
 */

let dictionaries = {};

/**
 * Adds package translations to existing ones.
 * These translations will later be available for {@link module:utils/translation-service~translate translate}.
 *
 *		add( 'pl', {
 *			'OK': 'OK',
 *			'Cancel [context: reject]': 'Anuluj'
 *		} );
 *
 * @param {String} lang Target language.
 * @param {Object.<String, String>} translations Translations which will be added to the dictionary.
 */
function add( lang, translations ) {
	dictionaries[ lang ] = dictionaries[ lang ] || {};

	Object.assign( dictionaries[ lang ], translations );
}

/**
 * Translates string if the translation of the string was previously {@link module:utils/translation-service~add added}
 * to the dictionary. This happens in a multi-language mode were translation modules are created by the bundler.
 *
 * When no translation is defined in the dictionary or the dictionary doesn't exist this function returns
 * the original string without the `'[context: ]'` (happens in development and single-language modes).
 *
 * In a single-language mode (when values passed to `t()` were replaced with target languange strings) the dictionary
 * is left empty, so this function will return the original strings always.
 *
 *		translate( 'pl', 'Cancel [context: reject]' );
 *
 * @param {String} lang Target language.
 * @param {String} translationKey String which is going to be translated.
 * @returns {String} Translated sentence.
 */
function translate( lang, translationKey ) {
	if ( !hasTranslation( lang, translationKey ) ) {
		return translationKey.replace( / \[context: [^\]]+\]$/, '' );
	}

	return dictionaries[ lang ][ translationKey ];
}

// Checks whether the dictionary exists and translaiton in that dictionary exists.
function hasTranslation( lang, translationKey ) {
	return (
		( lang in dictionaries ) &&
		( translationKey in dictionaries[ lang ] )
	);
}

/**
 * Clears dictionaries for test purposes.
 *
 * @protected
 */
function _clear() {
	dictionaries = {};
}


/***/ }),
/* 296 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__conversion_mapper__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__conversion_modelconversiondispatcher__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__conversion_model_to_view_converters__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__conversion_viewconversiondispatcher__ = __webpack_require__(360);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__conversion_view_to_model_converters__ = __webpack_require__(362);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__view_documentfragment__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__insertcontent__ = __webpack_require__(363);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__deletecontent__ = __webpack_require__(364);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__modifyselection__ = __webpack_require__(365);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__getselectedcontent__ = __webpack_require__(366);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/controller/datacontroller
 */























/**
 * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document
 * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}
 * and {@link ~DataController#set set} data of the {@link ~DataController#model model}
 * using given:
 *
 * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},
 * * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher model to view} and
 * * {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher view to model} converters.
 *
 * @mixes module:utils/emittermixin~ObservableMixin
 */
class DataController {
	/**
	 * Creates data controller instance.
	 *
	 * @param {module:engine/model/document~Document} model Document model.
	 * @param {module:engine/dataprocessor/dataprocessor~DataProcessor} [dataProcessor] Data processor which should used by the controller.
	 */
	constructor( model, dataProcessor ) {
		/**
		 * Document model.
		 *
		 * @readonly
		 * @member {module:engine/model/document~Document}
		 */
		this.model = model;

		/**
		 * Data processor used during the conversion.
		 *
		 * @readonly
		 * @member {module:engine/dataProcessor~DataProcessor}
		 */
		this.processor = dataProcessor;

		/**
		 * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and
		 * cleared directly after data are converted. However, the mapper is defined as class property, because
		 * it needs to be passed to the `ModelConversionDispatcher` as a conversion API.
		 *
		 * @member {module:engine/conversion/mapper~Mapper}
		 */
		this.mapper = new __WEBPACK_IMPORTED_MODULE_2__conversion_mapper__["a" /* default */]();

		/**
		 * Model to view conversion dispatcher used by the {@link #get get method}.
		 * To attach model to view converter to the data pipeline you need to add lister to this property:
		 *
		 *		data.modelToView( 'insert:$element', customInsertConverter );
		 *
		 * Or use {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder}:
		 *
		 *		buildModelConverter().for( data.modelToView ).fromAttribute( 'bold' ).toElement( 'b' );
		 *
		 * @readonly
		 * @member {module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}
		 */
		this.modelToView = new __WEBPACK_IMPORTED_MODULE_3__conversion_modelconversiondispatcher__["a" /* default */]( this.model, {
			mapper: this.mapper
		} );
		this.modelToView.on( 'insert:$text', Object(__WEBPACK_IMPORTED_MODULE_4__conversion_model_to_view_converters__["e" /* insertText */])(), { priority: 'lowest' } );

		/**
		 * View to model conversion dispatcher used by the {@link #set set method}.
		 * To attach view to model converter to the data pipeline you need to add lister to this property:
		 *
		 *		data.viewToModel( 'element', customElementConverter );
		 *
		 * Or use {@link module:engine/conversion/buildviewconverter~ViewConverterBuilder}:
		 *
		 *		buildViewConverter().for( data.viewToModel ).fromElement( 'b' ).toAttribute( 'bold', 'true' );
		 *
		 * @readonly
		 * @member {module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher}
		 */
		this.viewToModel = new __WEBPACK_IMPORTED_MODULE_5__conversion_viewconversiondispatcher__["a" /* default */]( {
			schema: model.schema
		} );

		// Define default converters for text and elements.
		//
		// Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be
		// converted to nothing. We add `convertToModelFragment` as a last converter so it converts children of that
		// element to the document fragment so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.
		this.viewToModel.on( 'text', Object(__WEBPACK_IMPORTED_MODULE_6__conversion_view_to_model_converters__["a" /* convertText */])(), { priority: 'lowest' } );
		this.viewToModel.on( 'element', Object(__WEBPACK_IMPORTED_MODULE_6__conversion_view_to_model_converters__["b" /* convertToModelFragment */])(), { priority: 'lowest' } );
		this.viewToModel.on( 'documentFragment', Object(__WEBPACK_IMPORTED_MODULE_6__conversion_view_to_model_converters__["b" /* convertToModelFragment */])(), { priority: 'lowest' } );

		[ 'insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent' ]
			.forEach( methodName => this.decorate( methodName ) );
	}

	/**
	 * Returns model's data converted by the {@link #modelToView model to view converters} and
	 * formatted by the {@link #processor data processor}.
	 *
	 * @param {String} [rootName='main'] Root name.
	 * @returns {String} Output data.
	 */
	get( rootName = 'main' ) {
		// Get model range.
		return this.stringify( this.model.getRoot( rootName ) );
	}

	/**
	 * Returns the content of the given {@link module:engine/model/element~Element model's element} or
	 * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the
	 * {@link #modelToView model to view converters} and formatted by the
	 * {@link #processor data processor}.
	 *
	 * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment
	 * Element which content will be stringified.
	 * @returns {String} Output data.
	 */
	stringify( modelElementOrFragment ) {
		// model -> view
		const viewDocumentFragment = this.toView( modelElementOrFragment );

		// view -> data
		return this.processor.toData( viewDocumentFragment );
	}

	/**
	 * Returns the content of the given {@link module:engine/model/element~Element model element} or
	 * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the
	 * {@link #modelToView model to view converters} to a
	 * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.
	 *
	 * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment
	 * Element or document fragment which content will be converted.
	 * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.
	 */
	toView( modelElementOrFragment ) {
		const modelRange = __WEBPACK_IMPORTED_MODULE_8__model_range__["a" /* default */].createIn( modelElementOrFragment );

		const viewDocumentFragment = new __WEBPACK_IMPORTED_MODULE_7__view_documentfragment__["a" /* default */]();
		this.mapper.bindElements( modelElementOrFragment, viewDocumentFragment );

		this.modelToView.convertInsertion( modelRange );

		this.mapper.clearBindings();

		return viewDocumentFragment;
	}

	/**
	 * Sets input data parsed by the {@link #processor data processor} and
	 * converted by the {@link #viewToModel view to model converters}.
	 *
	 * This method also creates a batch with all the changes applied. If all you need is to parse data use
	 * the {@link #parse} method.
	 *
	 * @param {String} data Input data.
	 * @param {String} [rootName='main'] Root name.
	 */
	set( data, rootName = 'main' ) {
		// Save to model.
		const modelRoot = this.model.getRoot( rootName );

		this.model.enqueueChanges( () => {
			// Clearing selection is a workaround for ticket #569 (LiveRange loses position after removing data from document).
			// After fixing it this code should be removed.
			this.model.selection.removeAllRanges();
			this.model.selection.clearAttributes();

			// Initial batch should be ignored by features like undo, etc.
			this.model.batch( 'transparent' )
				.remove( __WEBPACK_IMPORTED_MODULE_8__model_range__["a" /* default */].createIn( modelRoot ) )
				.insert( __WEBPACK_IMPORTED_MODULE_9__model_position__["a" /* default */].createAt( modelRoot, 0 ), this.parse( data ) );
		} );
	}

	/**
	 * Returns data parsed by the {@link #processor data processor} and then
	 * converted by the {@link #viewToModel view to model converters}.
	 *
	 * @see #set
	 * @param {String} data Data to parse.
	 * @param {String} [context='$root'] Base context in which the view will be converted to the model. See:
	 * {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#convert}.
	 * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.
	 */
	parse( data, context = '$root' ) {
		// data -> view
		const viewDocumentFragment = this.processor.toView( data );

		// view -> model
		return this.toModel( viewDocumentFragment, context );
	}

	/**
	 * Returns wrapped by {module:engine/model/documentfragment~DocumentFragment} result of the given
	 * {@link module:engine/view/element~Element view element} or
	 * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the
	 * {@link #viewToModel view to model converters}.
	 *
	 * When marker elements were converted during conversion process then will be set as DocumentFragment's
	 * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
	 *
	 * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment
	 * Element or document fragment which content will be converted.
	 * @param {String} [context='$root'] Base context in which the view will be converted to the model. See:
	 * {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#convert}.
	 * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.
	 */
	toModel( viewElementOrFragment, context = '$root' ) {
		return this.viewToModel.convert( viewElementOrFragment, { context: [ context ] } );
	}

	/**
	 * Removes all event listeners set by the DataController.
	 */
	destroy() {}

	/**
	 * See {@link module:engine/controller/insertcontent.insertContent}.
	 *
	 * @fires insertContent
	 * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.
	 * @param {module:engine/model/selection~Selection} selection Selection into which the content should be inserted.
	 * @param {module:engine/model/batch~Batch} [batch] Batch to which deltas will be added. If not specified, then
	 * changes will be added to a new batch.
	 */
	insertContent( content, selection, batch ) {
		Object(__WEBPACK_IMPORTED_MODULE_11__insertcontent__["a" /* default */])( this, content, selection, batch );
	}

	/**
	 * See {@link module:engine/controller/deletecontent.deleteContent}.
	 *
	 * Note: For the sake of predictability, the resulting selection should always be collapsed.
	 * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
	 * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
	 * then that behavior should be implemented in the view's listener. At the same time, the table feature
	 * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
	 * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
	 * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.
	 *
	 * @fires deleteContent
	 * @param {module:engine/model/selection~Selection} selection Selection of which the content should be deleted.
	 * @param {module:engine/model/batch~Batch} batch Batch to which deltas will be added.
	 * @param {Object} options See {@link module:engine/controller/deletecontent~deleteContent}'s options.
	 */
	deleteContent( selection, batch, options ) {
		Object(__WEBPACK_IMPORTED_MODULE_12__deletecontent__["a" /* default */])( selection, batch, options );
	}

	/**
	 * See {@link module:engine/controller/modifyselection.modifySelection}.
	 *
	 * @fires modifySelection
	 * @param {module:engine/model/selection~Selection} selection The selection to modify.
	 * @param {Object} options See {@link module:engine/controller/modifyselection~modifySelection}'s options.
	 */
	modifySelection( selection, options ) {
		Object(__WEBPACK_IMPORTED_MODULE_13__modifyselection__["a" /* default */])( this, selection, options );
	}

	/**
	 * See {@link module:engine/controller/getselectedcontent.getSelectedContent}.
	 *
	 * @fires module:engine/controller/datacontroller~DataController#getSelectedContent
	 * @param {module:engine/model/selection~Selection} selection The selection of which content will be retrieved.
	 * @returns {module:engine/model/documentfragment~DocumentFragment} Document fragment holding the clone of the selected content.
	 */
	getSelectedContent( selection ) {
		return Object(__WEBPACK_IMPORTED_MODULE_14__getselectedcontent__["a" /* default */])( selection );
	}

	/**
	 * Checks whether given {@link module:engine/model/range~Range range} or {@link module:engine/model/element~Element element}
	 * has any content.
	 *
	 * Content is any text node or element which is registered in {@link module:engine/model/schema~Schema schema}.
	 *
	 * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.
	 * @returns {Boolean}
	 */
	hasContent( rangeOrElement ) {
		if ( rangeOrElement instanceof __WEBPACK_IMPORTED_MODULE_10__model_element__["a" /* default */] ) {
			rangeOrElement = __WEBPACK_IMPORTED_MODULE_8__model_range__["a" /* default */].createIn( rangeOrElement );
		}

		if ( rangeOrElement.isCollapsed ) {
			return false;
		}

		for ( const item of rangeOrElement.getItems() ) {
			// Remember, `TreeWalker` returns always `textProxy` nodes.
			if ( item.is( 'textProxy' ) || this.model.schema.objects.has( item.name ) ) {
				return true;
			}
		}

		return false;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DataController;


Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( DataController, __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );

/**
 * Event fired when {@link #insertContent} method is called.
 *
 * The {@link #insertContent default action of that method} is implemented as a
 * listener to this event so it can be fully customized by the features.
 *
 * @event insertContent
 * @param {Array} args The arguments passed to the original method.
 */

/**
 * Event fired when {@link #deleteContent} method is called.
 *
 * The {@link #deleteContent default action of that method} is implemented as a
 * listener to this event so it can be fully customized by the features.
 *
 * @event deleteContent
 * @param {Array} args The arguments passed to the original method.
 */

/**
 * Event fired when {@link #modifySelection} method is called.
 *
 * The {@link #modifySelection default action of that method} is implemented as a
 * listener to this event so it can be fully customized by the features.
 *
 * @event modifySelection
 * @param {Array} args The arguments passed to the original method.
 */

/**
 * Event fired when {@link #getSelectedContent} method is called.
 *
 * The {@link #getSelectedContent default action of that method} is implemented as a
 * listener to this event so it can be fully customized by the features.
 *
 * @event getSelectedContent
 * @param {Array} args The arguments passed to the original method.
 */


/***/ }),
/* 297 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__spy__ = __webpack_require__(298);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/eventinfo
 */



/**
 * The event object passed to event callbacks. It is used to provide information about the event as well as a tool to
 * manipulate it.
 */
class EventInfo {
	/**
	 * @param {Object} source The emitter.
	 * @param {String} name The event name.
	 */
	constructor( source, name ) {
		/**
		 * The object that fired the event.
		 *
		 * @readonly
		 * @member {Object}
		 */
		this.source = source;

		/**
		 * The event name.
		 *
		 * @readonly
		 * @member {String}
		 */
		this.name = name;

		/**
		 * Path this event has followed. See {@link module:utils/emittermixin~EmitterMixin#delegate}.
		 *
		 * @readonly
		 * @member {Array.<Object>}
		 */
		this.path = [];

		// The following methods are defined in the constructor because they must be re-created per instance.

		/**
		 * Stops the event emitter to call further callbacks for this event interaction.
		 *
		 * @method #stop
		 */
		this.stop = Object(__WEBPACK_IMPORTED_MODULE_0__spy__["a" /* default */])();

		/**
		 * Removes the current callback from future interactions of this event.
		 *
		 * @method #off
		 */
		this.off = Object(__WEBPACK_IMPORTED_MODULE_0__spy__["a" /* default */])();

		/**
		 * The value which will be returned by {@link module:utils/emittermixin~EmitterMixin#fire}.
		 *
		 * It's `undefined` by default and can be changed by an event listener:
		 *
		 *		dataController.fire( 'getSelectedContent', ( evt ) => {
		 *			// This listener will make `dataController.fire( 'getSelectedContent' )`
		 *			// always return an empty DocumentFragment.
		 *			evt.return = new DocumentFragment();
		 *
		 *			// Make sure no other listeners are executed.
		 *			evt.stop();
		 *		} );
		 *
		 * @member #return
		 */
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EventInfo;



/***/ }),
/* 298 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/spy
 */

/**
 * Creates a spy function (ala Sinon.js) that can be used to inspect call to it.
 *
 * The following are the present features:
 *
 * * spy.called: property set to `true` if the function has been called at least once.
 *
 * @returns {Function} The spy function.
 */
function spy() {
	return function spy() {
		spy.called = true;
	};
}

/* harmony default export */ __webpack_exports__["a"] = (spy);


/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/priorities
 */

/**
 * String representing a priority value.
 *
 * @typedef {'highest'|'high'|'normal'|'low'|'lowest'} module:utils/priorities~PriorityString
 */

/**
 * Provides group of constants to use instead of hardcoding numeric priority values.
 *
 * @namespace
 */
const priorities = {
	/**
	 * Converts a string with priority name to it's numeric value. If `Number` is given, it just returns it.
	 *
	 * @static
	 * @param {module:utils/priorities~PriorityString|Number} priority Priority to convert.
	 * @returns {Number} Converted priority.
	 */
	get( priority ) {
		if ( typeof priority != 'number' ) {
			return this[ priority ] || this.normal;
		} else {
			return priority;
		}
	},

	highest: 100000,
	high: 1000,
	normal: 0,
	low: -1000,
	lowest: -100000
};

/* harmony default export */ __webpack_exports__["a"] = (priorities);


/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assignValue__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__copyObject__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__createAssigner__ = __webpack_require__(301);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArrayLike__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isPrototype__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__keysIn__ = __webpack_require__(304);







/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * function Bar() {
 *   this.d = 4;
 * }
 *
 * Foo.prototype.c = 3;
 * Bar.prototype.e = 5;
 *
 * _.assignIn({ 'a': 1 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
 */
var assignIn = Object(__WEBPACK_IMPORTED_MODULE_2__createAssigner__["a" /* default */])(function(object, source) {
  if (nonEnumShadows || Object(__WEBPACK_IMPORTED_MODULE_4__isPrototype__["a" /* default */])(source) || Object(__WEBPACK_IMPORTED_MODULE_3__isArrayLike__["a" /* default */])(source)) {
    Object(__WEBPACK_IMPORTED_MODULE_1__copyObject__["a" /* default */])(source, Object(__WEBPACK_IMPORTED_MODULE_5__keysIn__["a" /* default */])(source), object);
    return;
  }
  for (var key in source) {
    Object(__WEBPACK_IMPORTED_MODULE_0__assignValue__["a" /* default */])(object, key, source[key]);
  }
});

/* harmony default export */ __webpack_exports__["a"] = (assignIn);


/***/ }),
/* 301 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isIterateeCall__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rest__ = __webpack_require__(7);



/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__rest__["a" /* default */])(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && Object(__WEBPACK_IMPORTED_MODULE_0__isIterateeCall__["a" /* default */])(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/* harmony default export */ __webpack_exports__["a"] = (createAssigner);


/***/ }),
/* 302 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseProperty__ = __webpack_require__(119);


/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a
 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
 * Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = Object(__WEBPACK_IMPORTED_MODULE_0__baseProperty__["a" /* default */])('length');

/* harmony default export */ __webpack_exports__["a"] = (getLength);


/***/ }),
/* 303 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__toNumber__ = __webpack_require__(166);


/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = Object(__WEBPACK_IMPORTED_MODULE_0__toNumber__["a" /* default */])(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/* harmony default export */ __webpack_exports__["a"] = (toFinite);


/***/ }),
/* 304 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseKeysIn__ = __webpack_require__(305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__indexKeys__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isIndex__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isPrototype__ = __webpack_require__(80);





/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  var index = -1,
      isProto = Object(__WEBPACK_IMPORTED_MODULE_3__isPrototype__["a" /* default */])(object),
      props = Object(__WEBPACK_IMPORTED_MODULE_0__baseKeysIn__["a" /* default */])(object),
      propsLength = props.length,
      indexes = Object(__WEBPACK_IMPORTED_MODULE_1__indexKeys__["a" /* default */])(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  while (++index < propsLength) {
    var key = props[index];
    if (!(skipIndexes && (key == 'length' || Object(__WEBPACK_IMPORTED_MODULE_2__isIndex__["a" /* default */])(key, length))) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (keysIn);


/***/ }),
/* 305 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Reflect__ = __webpack_require__(306);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iteratorToArray__ = __webpack_require__(309);



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var enumerate = __WEBPACK_IMPORTED_MODULE_0__Reflect__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Reflect__["a" /* default */].enumerate : undefined,
    propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * The base implementation of `_.keysIn` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  object = object == null ? object : Object(object);

  var result = [];
  for (var key in object) {
    result.push(key);
  }
  return result;
}

// Fallback for IE < 9 with es6-shim.
if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
  baseKeysIn = function(object) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__iteratorToArray__["a" /* default */])(enumerate(object));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (baseKeysIn);


/***/ }),
/* 306 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root__ = __webpack_require__(33);


/** Built-in value references. */
var Reflect = __WEBPACK_IMPORTED_MODULE_0__root__["a" /* default */].Reflect;

/* harmony default export */ __webpack_exports__["a"] = (Reflect);


/***/ }),
/* 307 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

/* harmony default export */ __webpack_exports__["a"] = (checkGlobal);


/***/ }),
/* 309 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (iteratorToArray);


/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/* harmony default export */ __webpack_exports__["a"] = (listCacheClear);


/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assocIndexOf__ = __webpack_require__(84);


/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = Object(__WEBPACK_IMPORTED_MODULE_0__assocIndexOf__["a" /* default */])(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/* harmony default export */ __webpack_exports__["a"] = (listCacheDelete);


/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assocIndexOf__ = __webpack_require__(84);


/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = Object(__WEBPACK_IMPORTED_MODULE_0__assocIndexOf__["a" /* default */])(data, key);

  return index < 0 ? undefined : data[index][1];
}

/* harmony default export */ __webpack_exports__["a"] = (listCacheGet);


/***/ }),
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assocIndexOf__ = __webpack_require__(84);


/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__assocIndexOf__["a" /* default */])(this.__data__, key) > -1;
}

/* harmony default export */ __webpack_exports__["a"] = (listCacheHas);


/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assocIndexOf__ = __webpack_require__(84);


/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = Object(__WEBPACK_IMPORTED_MODULE_0__assocIndexOf__["a" /* default */])(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/* harmony default export */ __webpack_exports__["a"] = (listCacheSet);


/***/ }),
/* 315 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ListCache__ = __webpack_require__(83);


/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new __WEBPACK_IMPORTED_MODULE_0__ListCache__["a" /* default */];
}

/* harmony default export */ __webpack_exports__["a"] = (stackClear);


/***/ }),
/* 316 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/* harmony default export */ __webpack_exports__["a"] = (stackDelete);


/***/ }),
/* 317 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/* harmony default export */ __webpack_exports__["a"] = (stackGet);


/***/ }),
/* 318 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* harmony default export */ __webpack_exports__["a"] = (stackHas);


/***/ }),
/* 319 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ListCache__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__MapCache__ = __webpack_require__(124);



/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof __WEBPACK_IMPORTED_MODULE_0__ListCache__["a" /* default */] && cache.__data__.length == LARGE_ARRAY_SIZE) {
    cache = this.__data__ = new __WEBPACK_IMPORTED_MODULE_1__MapCache__["a" /* default */](cache.__data__);
  }
  cache.set(key, value);
  return this;
}

/* harmony default export */ __webpack_exports__["a"] = (stackSet);


/***/ }),
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Hash__ = __webpack_require__(321);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ListCache__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Map__ = __webpack_require__(174);




/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new __WEBPACK_IMPORTED_MODULE_0__Hash__["a" /* default */],
    'map': new (__WEBPACK_IMPORTED_MODULE_2__Map__["a" /* default */] || __WEBPACK_IMPORTED_MODULE_1__ListCache__["a" /* default */]),
    'string': new __WEBPACK_IMPORTED_MODULE_0__Hash__["a" /* default */]
  };
}

/* harmony default export */ __webpack_exports__["a"] = (mapCacheClear);


/***/ }),
/* 321 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hashClear__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hashDelete__ = __webpack_require__(324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hashGet__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__hashHas__ = __webpack_require__(326);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__hashSet__ = __webpack_require__(327);






/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = __WEBPACK_IMPORTED_MODULE_0__hashClear__["a" /* default */];
Hash.prototype['delete'] = __WEBPACK_IMPORTED_MODULE_1__hashDelete__["a" /* default */];
Hash.prototype.get = __WEBPACK_IMPORTED_MODULE_2__hashGet__["a" /* default */];
Hash.prototype.has = __WEBPACK_IMPORTED_MODULE_3__hashHas__["a" /* default */];
Hash.prototype.set = __WEBPACK_IMPORTED_MODULE_4__hashSet__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (Hash);


/***/ }),
/* 322 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nativeCreate__ = __webpack_require__(85);


/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = __WEBPACK_IMPORTED_MODULE_0__nativeCreate__["a" /* default */] ? Object(__WEBPACK_IMPORTED_MODULE_0__nativeCreate__["a" /* default */])(null) : {};
}

/* harmony default export */ __webpack_exports__["a"] = (hashClear);


/***/ }),
/* 323 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isFunction__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isHostObject__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObject__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__toSource__ = __webpack_require__(173);





/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObject__["a" /* default */])(value)) {
    return false;
  }
  var pattern = (Object(__WEBPACK_IMPORTED_MODULE_0__isFunction__["a" /* default */])(value) || Object(__WEBPACK_IMPORTED_MODULE_1__isHostObject__["a" /* default */])(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(Object(__WEBPACK_IMPORTED_MODULE_3__toSource__["a" /* default */])(value));
}

/* harmony default export */ __webpack_exports__["a"] = (isNative);


/***/ }),
/* 324 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/* harmony default export */ __webpack_exports__["a"] = (hashDelete);


/***/ }),
/* 325 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nativeCreate__ = __webpack_require__(85);


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (__WEBPACK_IMPORTED_MODULE_0__nativeCreate__["a" /* default */]) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (hashGet);


/***/ }),
/* 326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nativeCreate__ = __webpack_require__(85);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return __WEBPACK_IMPORTED_MODULE_0__nativeCreate__["a" /* default */] ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/* harmony default export */ __webpack_exports__["a"] = (hashHas);


/***/ }),
/* 327 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nativeCreate__ = __webpack_require__(85);


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (__WEBPACK_IMPORTED_MODULE_0__nativeCreate__["a" /* default */] && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

/* harmony default export */ __webpack_exports__["a"] = (hashSet);


/***/ }),
/* 328 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getMapData__ = __webpack_require__(86);


/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__getMapData__["a" /* default */])(this, key)['delete'](key);
}

/* harmony default export */ __webpack_exports__["a"] = (mapCacheDelete);


/***/ }),
/* 329 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/* harmony default export */ __webpack_exports__["a"] = (isKeyable);


/***/ }),
/* 330 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getMapData__ = __webpack_require__(86);


/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__getMapData__["a" /* default */])(this, key).get(key);
}

/* harmony default export */ __webpack_exports__["a"] = (mapCacheGet);


/***/ }),
/* 331 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getMapData__ = __webpack_require__(86);


/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__getMapData__["a" /* default */])(this, key).has(key);
}

/* harmony default export */ __webpack_exports__["a"] = (mapCacheHas);


/***/ }),
/* 332 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getMapData__ = __webpack_require__(86);


/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  Object(__WEBPACK_IMPORTED_MODULE_0__getMapData__["a" /* default */])(this, key).set(key, value);
  return this;
}

/* harmony default export */ __webpack_exports__["a"] = (mapCacheSet);


/***/ }),
/* 333 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayEach);


/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__copyObject__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keys__ = __webpack_require__(69);



/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && Object(__WEBPACK_IMPORTED_MODULE_0__copyObject__["a" /* default */])(source, Object(__WEBPACK_IMPORTED_MODULE_1__keys__["a" /* default */])(source), object);
}

/* harmony default export */ __webpack_exports__["a"] = (baseAssign);


/***/ }),
/* 335 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = Object.keys;

/**
 * The base implementation of `_.keys` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  return nativeKeys(Object(object));
}

/* harmony default export */ __webpack_exports__["a"] = (baseKeys);


/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (cloneBuffer);


/***/ }),
/* 337 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__copyObject__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getSymbols__ = __webpack_require__(177);



/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__copyObject__["a" /* default */])(source, Object(__WEBPACK_IMPORTED_MODULE_1__getSymbols__["a" /* default */])(source), object);
}

/* harmony default export */ __webpack_exports__["a"] = (copySymbols);


/***/ }),
/* 338 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetAllKeys__ = __webpack_require__(339);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getSymbols__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__keys__ = __webpack_require__(69);




/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseGetAllKeys__["a" /* default */])(object, __WEBPACK_IMPORTED_MODULE_2__keys__["a" /* default */], __WEBPACK_IMPORTED_MODULE_1__getSymbols__["a" /* default */]);
}

/* harmony default export */ __webpack_exports__["a"] = (getAllKeys);


/***/ }),
/* 339 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayPush__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArray__ = __webpack_require__(14);



/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return Object(__WEBPACK_IMPORTED_MODULE_1__isArray__["a" /* default */])(object) ? result : Object(__WEBPACK_IMPORTED_MODULE_0__arrayPush__["a" /* default */])(result, symbolsFunc(object));
}

/* harmony default export */ __webpack_exports__["a"] = (baseGetAllKeys);


/***/ }),
/* 340 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root__ = __webpack_require__(33);



/* Built-in method references that are verified to be native. */
var DataView = Object(__WEBPACK_IMPORTED_MODULE_0__getNative__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__root__["a" /* default */], 'DataView');

/* harmony default export */ __webpack_exports__["a"] = (DataView);


/***/ }),
/* 341 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root__ = __webpack_require__(33);



/* Built-in method references that are verified to be native. */
var Promise = Object(__WEBPACK_IMPORTED_MODULE_0__getNative__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__root__["a" /* default */], 'Promise');

/* harmony default export */ __webpack_exports__["a"] = (Promise);


/***/ }),
/* 342 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root__ = __webpack_require__(33);



/* Built-in method references that are verified to be native. */
var WeakMap = Object(__WEBPACK_IMPORTED_MODULE_0__getNative__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__root__["a" /* default */], 'WeakMap');

/* harmony default export */ __webpack_exports__["a"] = (WeakMap);


/***/ }),
/* 343 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (initCloneArray);


/***/ }),
/* 344 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cloneDataView__ = __webpack_require__(345);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cloneMap__ = __webpack_require__(346);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__cloneRegExp__ = __webpack_require__(348);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__cloneSet__ = __webpack_require__(349);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__cloneSymbol__ = __webpack_require__(351);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__cloneTypedArray__ = __webpack_require__(352);








/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return Object(__WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer__["a" /* default */])(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return Object(__WEBPACK_IMPORTED_MODULE_1__cloneDataView__["a" /* default */])(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return Object(__WEBPACK_IMPORTED_MODULE_6__cloneTypedArray__["a" /* default */])(object, isDeep);

    case mapTag:
      return Object(__WEBPACK_IMPORTED_MODULE_2__cloneMap__["a" /* default */])(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return Object(__WEBPACK_IMPORTED_MODULE_3__cloneRegExp__["a" /* default */])(object);

    case setTag:
      return Object(__WEBPACK_IMPORTED_MODULE_4__cloneSet__["a" /* default */])(object, isDeep, cloneFunc);

    case symbolTag:
      return Object(__WEBPACK_IMPORTED_MODULE_5__cloneSymbol__["a" /* default */])(object);
  }
}

/* harmony default export */ __webpack_exports__["a"] = (initCloneByTag);


/***/ }),
/* 345 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer__ = __webpack_require__(126);


/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? Object(__WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer__["a" /* default */])(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/* harmony default export */ __webpack_exports__["a"] = (cloneDataView);


/***/ }),
/* 346 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__addMapEntry__ = __webpack_require__(347);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayReduce__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mapToArray__ = __webpack_require__(127);




/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(Object(__WEBPACK_IMPORTED_MODULE_2__mapToArray__["a" /* default */])(map), true) : Object(__WEBPACK_IMPORTED_MODULE_2__mapToArray__["a" /* default */])(map);
  return Object(__WEBPACK_IMPORTED_MODULE_1__arrayReduce__["a" /* default */])(array, __WEBPACK_IMPORTED_MODULE_0__addMapEntry__["a" /* default */], new map.constructor);
}

/* harmony default export */ __webpack_exports__["a"] = (cloneMap);


/***/ }),
/* 347 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `Map#set` because it doesn't return the map instance in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/* harmony default export */ __webpack_exports__["a"] = (addMapEntry);


/***/ }),
/* 348 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (cloneRegExp);


/***/ }),
/* 349 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__addSetEntry__ = __webpack_require__(350);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayReduce__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__setToArray__ = __webpack_require__(88);




/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(Object(__WEBPACK_IMPORTED_MODULE_2__setToArray__["a" /* default */])(set), true) : Object(__WEBPACK_IMPORTED_MODULE_2__setToArray__["a" /* default */])(set);
  return Object(__WEBPACK_IMPORTED_MODULE_1__arrayReduce__["a" /* default */])(array, __WEBPACK_IMPORTED_MODULE_0__addSetEntry__["a" /* default */], new set.constructor);
}

/* harmony default export */ __webpack_exports__["a"] = (cloneSet);


/***/ }),
/* 350 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  set.add(value);
  return set;
}

/* harmony default export */ __webpack_exports__["a"] = (addSetEntry);


/***/ }),
/* 351 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol__ = __webpack_require__(128);


/** Used to convert symbols to primitives and strings. */
var symbolProto = __WEBPACK_IMPORTED_MODULE_0__Symbol__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol__["a" /* default */].prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/* harmony default export */ __webpack_exports__["a"] = (cloneSymbol);


/***/ }),
/* 352 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer__ = __webpack_require__(126);


/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? Object(__WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer__["a" /* default */])(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/* harmony default export */ __webpack_exports__["a"] = (cloneTypedArray);


/***/ }),
/* 353 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseCreate__ = __webpack_require__(354);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getPrototype__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isPrototype__ = __webpack_require__(80);




/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !Object(__WEBPACK_IMPORTED_MODULE_2__isPrototype__["a" /* default */])(object))
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseCreate__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_1__getPrototype__["a" /* default */])(object))
    : {};
}

/* harmony default export */ __webpack_exports__["a"] = (initCloneObject);


/***/ }),
/* 354 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isObject__ = __webpack_require__(16);


/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__isObject__["a" /* default */])(proto) ? objectCreate(proto) : {};
}

/* harmony default export */ __webpack_exports__["a"] = (baseCreate);


/***/ }),
/* 355 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(356);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root__ = __webpack_require__(33);



/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
  ? exports
  : undefined;

/** Detect free variable `module`. */
var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
  ? module
  : undefined;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = (freeModule && freeModule.exports === freeExports)
  ? freeExports
  : undefined;

/** Built-in value references. */
var Buffer = moduleExports ? __WEBPACK_IMPORTED_MODULE_1__root__["a" /* default */].Buffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = !Buffer ? Object(__WEBPACK_IMPORTED_MODULE_0__constant__["a" /* default */])(false) : function(value) {
  return value instanceof Buffer;
};

/* harmony default export */ __webpack_exports__["a"] = (isBuffer);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(167)(module)))

/***/ }),
/* 356 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var getter = _.constant(object);
 *
 * getter() === object;
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (constant);


/***/ }),
/* 357 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/textproxy
 */



/**
 * TextProxy is a wrapper for substring of {@link module:engine/view/text~Text}. Instance of this class is created by
 * {@link module:engine/view/treewalker~TreeWalker} when only a part of {@link module:engine/view/text~Text} needs to be returned.
 *
 * `TextProxy` has an API similar to {@link module:engine/view/text~Text Text} and allows to do most of the common tasks performed
 * on view nodes.
 *
 * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.
 * See {@link module:engine/view/textproxy~TextProxy#isPartial}.
 *
 * **Note:** `TextProxy` is a readonly interface.
 *
 * **Note:** `TextProxy` instances are created on the fly basing on the current state of parent {@link module:engine/view/text~Text}.
 * Because of this it is highly unrecommended to store references to `TextProxy instances because they might get
 * invalidated due to operations on Document. Also TextProxy is not a {@link module:engine/view/node~Node} so it can not be
 * inserted as a child of {@link module:engine/view/element~Element}.
 *
 * `TextProxy` instances are created by {@link module:engine/view/treewalker~TreeWalker view tree walker}. You should not need to create
 * an instance of this class by your own.
 */
class TextProxy {
	/**
	 * Creates a text proxy.
	 *
	 * @protected
	 * @param {module:engine/view/text~Text} textNode Text node which part is represented by this text proxy.
	 * @param {Number} offsetInText Offset in {@link module:engine/view/textproxy~TextProxy#textNode text node}
	 * from which the text proxy starts.
	 * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
	 * @constructor
	 */
	constructor( textNode, offsetInText, length ) {
		/**
		 * Reference to the {@link module:engine/view/text~Text} element which TextProxy is a substring.
		 *
		 * @readonly
		 * @member {module:engine/view/text~Text} module:engine/view/textproxy~TextProxy#textNode
		 */
		this.textNode = textNode;

		if ( offsetInText < 0 || offsetInText > textNode.data.length ) {
			/**
			 * Given offsetInText value is incorrect.
			 *
			 * @error view-textproxy-wrong-offsetintext
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.' );
		}

		if ( length < 0 || offsetInText + length > textNode.data.length ) {
			/**
			 * Given length value is incorrect.
			 *
			 * @error view-textproxy-wrong-length
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-textproxy-wrong-length: Given length value is incorrect.' );
		}

		/**
		 * Text data represented by this text proxy.
		 *
		 * @readonly
		 * @member {String} module:engine/view/textproxy~TextProxy#data
		 */
		this.data = textNode.data.substring( offsetInText, offsetInText + length );

		/**
		 * Offset in the `textNode` where this `TextProxy` instance starts.
		 *
		 * @readonly
		 * @member {Number} module:engine/view/textproxy~TextProxy#offsetInText
		 */
		this.offsetInText = offsetInText;
	}

	/**
	 * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/view/text~Text text node}
	 * (`true`) or the whole text node (`false`).
	 *
	 * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~TextProxy#textNode textNode}
	 * ({@link module:engine/view/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
	 * text node size.
	 *
	 * @readonly
	 * @type {Boolean}
	 */
	get isPartial() {
		return this.data.length !== this.textNode.data.length;
	}

	/**
	 * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
	 *
	 * @readonly
	 * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}
	 */
	get parent() {
		return this.textNode.parent;
	}

	/**
	 * Root of this text proxy, which is same as root of text node represented by this text proxy.
	 *
	 * @readonly
	 * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}
	 */
	get root() {
		return this.textNode.root;
	}

	/**
	 * {@link module:engine/view/document~Document View document} that owns this text proxy, or `null` if the text proxy is inside
	 * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
	 *
	 * @readonly
	 * @type {module:engine/view/document~Document|null}
	 */
	get document() {
		return this.textNode.document;
	}

	/**
	 * Checks whether given view tree object is of given type.
	 *
	 * Read more in {@link module:engine/view/node~Node#is}.
	 *
	 * @param {String} type
	 * @returns {Boolean}
	 */
	is( type ) {
		return type == 'textProxy';
	}

	/**
	 * Returns ancestors array of this text proxy.
	 *
	 * @param {Object} options Options object.
	 * @param {Boolean} [options.includeSelf=false] When set to `true` {#textNode} will be also included in parent's array.
	 * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to
	 * root element, otherwise root element will be the first item in the array.
	 * @returns {Array} Array with ancestors.
	 */
	getAncestors( options = { includeSelf: false, parentFirst: false } ) {
		const ancestors = [];
		let parent = options.includeSelf ? this.textNode : this.parent;

		while ( parent !== null ) {
			ancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );
			parent = parent.parent;
		}

		return ancestors;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TextProxy;



/***/ }),
/* 358 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model_textproxy__ = __webpack_require__(66);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/conversion/modelconsumable
 */



/**
 * Manages a list of consumable values for {@link module:engine/model/item~Item model items}.
 *
 * Consumables are various aspects of the model. A model item can be broken down into singular properties that might be
 * taken into consideration when converting that item.
 *
 * `ModelConsumable` is used by {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher} while analyzing changed
 * parts of {@link module:engine/model/document~Document the document}. The added / changed / removed model items are broken down
 * into singular properties (the item itself and it's attributes). All those parts are saved in `ModelConsumable`. Then,
 * during conversion, when given part of model item is converted (i.e. the view element has been inserted into the view,
 * but without attributes), consumable value is removed from `ModelConsumable`.
 *
 * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addAttribute:<attributeKey>`,
 * `changeAttribute:<attributeKey>`, `removeAttribute:<attributeKey>`.
 *
 * In most cases, it is enough to let {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}
 * gather consumable values, so there is no need to use
 * @link module:engine/conversion/modelconsumable~ModelConsumable#add add method} directly.
 * However, it is important to understand how consumable values can be
 * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.
 * See {@link module:engine/conversion/model-selection-to-view-converters default model to view converters} for more information.
 *
 * Keep in mind, that one conversion event may have multiple callbacks (converters) attached to it. Each of those is
 * able to convert one or more parts of the model. However, when one of those callbacks actually converts
 * something, other should not, because they would duplicate the results. Using `ModelConsumable` helps avoiding
 * this situation, because callbacks should only convert those values, which were not yet consumed from `ModelConsumable`.
 *
 * Consuming multiple values in a single callback:
 *
 *		// Converter for custom `image` element that might have a `caption` element inside which changes
 *		// how the image is displayed in the view:
 *		//
 *		// Model:
 *		//
 *		// [image]
 *		//    [caption]
 *		//        foo
 *		//
 *		// View:
 *		//
 *		// <figure>
 *		//    <img />
 *		//    <caption>
 *		//        foo
 *		modelConversionDispatcher.on( 'insert:image', ( evt, data, consumable, conversionApi ) => {
 *			// First, consume the `image` element.
 *			consumable.consume( data.item, 'insert' );
 *
 *			// Just create normal image element for the view.
 *			// Maybe it will be "decorated" later.
 *			const viewImage = new ViewElement( 'img' );
 *			const insertPosition = conversionApi.mapper.toViewPosition( data.range.start );
 *
 *			// Check if the `image` element has children.
 *			if ( data.item.childCount > 0 ) {
 *				const modelCaption = data.item.getChild( 0 );
 *
 *				// `modelCaption` insertion change is consumed from consumable values.
 *				// It will not be converted by other converters, but it's children (probably some text) will be.
 *				// Through mapping, converters for text will know where to insert contents of `modelCaption`.
 *				if ( consumable.consume( modelCaption, 'insert' ) ) {
 *					const viewCaption = new ViewElement( 'figcaption' );
 *
 *					const viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );
 *
 *					conversionApi.mapper.bindElements( modelCaption, viewCaption );
 *					conversionApi.mapper.bindElements( data.item, viewImageHolder );
 *					viewWriter.insert( insertPosition, viewImageHolder );
 *				}
 *			} else {
 *				conversionApi.mapper.bindElements( data.item, viewImage );
 *				viewWriter.insert( insertPosition, viewImage );
 *			}
 *
 *			evt.stop();
 *		} );
 */
class ModelConsumable {
	/**
	 * Creates an empty consumables list.
	 */
	constructor() {
		/**
		 * Contains list of consumable values.
		 *
		 * @private
		 * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_consumable
		 */
		this._consumable = new Map();

		/**
		 * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds parent
		 * of that `TextProxy` and start and end indices of that `TextProxy`. This allows identification of `TextProxy`
		 * instances that points to the same part of the model but are different instances. Each distinct `TextProxy`
		 * is given unique `Symbol` which is then registered as consumable. This process is transparent for `ModelConsumable`
		 * API user because whenever `TextProxy` is added, tested, consumed or reverted, internal mechanisms of
		 * `ModelConsumable` translates `TextProxy` to that unique `Symbol`.
		 *
		 * @private
		 * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_textProxyRegistry
		 */
		this._textProxyRegistry = new Map();
	}

	/**
	 * Adds a consumable value to the consumables list and links it with given model item.
	 *
	 *		modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
	 *		modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
	 *		modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
	 *		modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
	 *		modelConsumable.add( modelSelection, 'selectionAttribute:bold' ); // Add `bold` attribute on `modelSelection` to consumables.
	 *		modelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.
	 *
	 * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item
	 * Model item, range or selection that has the consumable.
	 * @param {String} type Consumable type.
	 */
	add( item, type ) {
		if ( item instanceof __WEBPACK_IMPORTED_MODULE_0__model_textproxy__["a" /* default */] ) {
			item = this._getSymbolForTextProxy( item );
		}

		if ( !this._consumable.has( item ) ) {
			this._consumable.set( item, new Map() );
		}

		this._consumable.get( item ).set( type, true );
	}

	/**
	 * Removes given consumable value from given model item.
	 *
	 *		modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
	 *		modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
	 *		modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
	 *		modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
	 *		modelConsumable.consume( modelSelection, 'selectionAttribute:bold' ); // Remove `bold` on `modelSelection` from consumables.
	 *		modelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.
	 *
	 * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item
	 * Model item, range or selection from which consumable will be consumed.
	 * @param {String} type Consumable type.
	 * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.
	 */
	consume( item, type ) {
		if ( item instanceof __WEBPACK_IMPORTED_MODULE_0__model_textproxy__["a" /* default */] ) {
			item = this._getSymbolForTextProxy( item );
		}

		if ( this.test( item, type ) ) {
			this._consumable.get( item ).set( type, false );

			return true;
		} else {
			return false;
		}
	}

	/**
	 * Tests whether there is a consumable value of given type connected with given model item.
	 *
	 *		modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
	 *		modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
	 *		modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
	 *		modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
	 *		modelConsumable.test( modelSelection, 'selectionAttribute:bold' ); // Check if `bold` on `modelSelection` is consumable.
	 *		modelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.
	 *
	 * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item
	 * Model item, range or selection to be tested.
	 * @param {String} type Consumable type.
	 * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was
	 * already consumed or `true` if it was added and not consumed yet.
	 */
	test( item, type ) {
		if ( item instanceof __WEBPACK_IMPORTED_MODULE_0__model_textproxy__["a" /* default */] ) {
			item = this._getSymbolForTextProxy( item );
		}

		const itemConsumables = this._consumable.get( item );

		if ( itemConsumables === undefined ) {
			return null;
		}

		const value = itemConsumables.get( type );

		if ( value === undefined ) {
			return null;
		}

		return value;
	}

	/**
	 * Reverts consuming of consumable value.
	 *
	 *		modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
	 *		modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
	 *		modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
	 *		modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
	 *		modelConsumable.revert( modelSelection, 'selectionAttribute:bold' ); // Revert consuming `bold` from `modelSelection`.
	 *		modelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.
	 *
	 * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item
	 * Model item, range or selection to be reverted.
	 * @param {String} type Consumable type.
	 * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
	 * never been added.
	 */
	revert( item, type ) {
		if ( item instanceof __WEBPACK_IMPORTED_MODULE_0__model_textproxy__["a" /* default */] ) {
			item = this._getSymbolForTextProxy( item );
		}

		const test = this.test( item, type );

		if ( test === false ) {
			this._consumable.get( item ).set( type, true );

			return true;
		} else if ( test === true ) {
			return false;
		}

		return null;
	}

	/**
	 * Gets a unique symbol for passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that
	 * have same parent, same start index and same end index will get the same symbol.
	 *
	 * Used internally to correctly consume `TextProxy` instances.
	 *
	 * @private
	 * @param {module:engine/model/textproxy~TextProxy} textProxy `TextProxy` instance to get a symbol for.
	 * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.
	 */
	_getSymbolForTextProxy( textProxy ) {
		let symbol = null;

		const startMap = this._textProxyRegistry.get( textProxy.startOffset );

		if ( startMap ) {
			const endMap = startMap.get( textProxy.endOffset );

			if ( endMap ) {
				symbol = endMap.get( textProxy.parent );
			}
		}

		if ( !symbol ) {
			symbol = this._addSymbolForTextProxy( textProxy.startOffset, textProxy.endOffset, textProxy.parent );
		}

		return symbol;
	}

	/**
	 * Adds a symbol for given properties that characterizes a {@link module:engine/model/textproxy~TextProxy} instance.
	 *
	 * Used internally to correctly consume `TextProxy` instances.
	 *
	 * @private
	 * @param {Number} startIndex Text proxy start index in it's parent.
	 * @param {Number} endIndex Text proxy end index in it's parent.
	 * @param {module:engine/model/element~Element} parent Text proxy parent.
	 * @returns {Symbol} Symbol generated for given properties.
	 */
	_addSymbolForTextProxy( start, end, parent ) {
		const symbol = Symbol( 'textProxySymbol' );
		let startMap, endMap;

		startMap = this._textProxyRegistry.get( start );

		if ( !startMap ) {
			startMap = new Map();
			this._textProxyRegistry.set( start, startMap );
		}

		endMap = startMap.get( end );

		if ( !endMap ) {
			endMap = new Map();
			startMap.set( end, endMap );
		}

		endMap.set( parent, symbol );

		return symbol;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ModelConsumable;



/***/ }),
/* 359 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export isMac */
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals navigator:false */

/**
 * @module utils/env
 */

const userAgent = navigator.userAgent.toLowerCase();

/**
 * A namespace containing environment and browser information.
 *
 * @namespace
 */
const env = {
	/**
	 * Indicates that application is running on Macintosh.
	 *
	 * @static
	 * @member {Boolean} module:utils/env~env#mac
	 */
	mac: isMac( userAgent )
};

/* harmony default export */ __webpack_exports__["a"] = (env);

/**
 * Checks if User Agent represented by the string is running on Macintosh.
 *
 * @param {String} userAgent **Lowercase** `navigator.userAgent` string.
 * @returns {Boolean} Whether User Agent is running on Macintosh or not.
 */
function isMac( userAgent ) {
	return userAgent.indexOf( 'macintosh' ) > -1;
}


/***/ }),
/* 360 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewconsumable__ = __webpack_require__(361);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_treewalker__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__model_node__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__model_documentfragment__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__model_writer__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_lib_lodash_extend__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ckeditor_ckeditor5_utils_src_log__ = __webpack_require__(26);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/conversion/viewconversiondispatcher
 */














/**
 * `ViewConversionDispatcher` is a central point of {@link module:engine/view/view view} conversion, which is a process of
 * converting given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or
 * {@link module:engine/view/element~Element}
 * into another structure. In default application, {@link module:engine/view/view view} is converted to {@link module:engine/model/model}.
 *
 * During conversion process, for all {@link module:engine/view/node~Node view nodes} from the converted view document fragment,
 * `ViewConversionDispatcher` fires corresponding events. Special callbacks called "converters" should listen to
 * `ViewConversionDispatcher` for those events.
 *
 * Each callback, as a first argument, is passed a special object `data` that has `input` and `output` properties.
 * `input` property contains {@link module:engine/view/node~Node view node} or
 * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}
 * that is converted at the moment and might be handled by the callback. `output` property should be used to save the result
 * of conversion. Keep in mind that the `data` parameter is customizable and may contain other values - see
 * {@link ~ViewConversionDispatcher#convert}. It is also shared by reference by all callbacks
 * listening to given event. **Note**: in view to model conversion - `data` contains `context` property that is an array
 * of {@link module:engine/model/element~Element model elements}. These are model elements that will be the parent of currently
 * converted view item. `context` property is used in examples below.
 *
 * The second parameter passed to a callback is an instance of {@link module:engine/conversion/viewconsumable~ViewConsumable}. It stores
 * information about what parts of processed view item are still waiting to be handled. After a piece of view item
 * was converted, appropriate consumable value should be {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.
 *
 * The third parameter passed to a callback is an instance of {@link ~ViewConversionDispatcher}
 * which provides additional tools for converters.
 *
 * Examples of providing callbacks for `ViewConversionDispatcher`:
 *
 *		// Converter for paragraphs (<p>).
 *		viewDispatcher.on( 'element:p', ( evt, data, consumable, conversionApi ) => {
 *			const paragraph = new ModelElement( 'paragraph' );
 *			const schemaQuery = {
 *				name: 'paragraph',
 *				inside: data.context
 *			};
 *
 *			if ( conversionApi.schema.check( schemaQuery ) ) {
 *				if ( !consumable.consume( data.input, { name: true } ) ) {
 *					// Before converting this paragraph's children we have to update their context by this paragraph.
 *					data.context.push( paragraph );
 *					const children = conversionApi.convertChildren( data.input, consumable, data );
 *					data.context.pop();
 *					paragraph.appendChildren( children );
 *					data.output = paragraph;
 *				}
 *			}
 *		} );
 *
 *		// Converter for links (<a>).
 *		viewDispatcher.on( 'element:a', ( evt, data, consumable, conversionApi ) => {
 *			if ( consumable.consume( data.input, { name: true, attributes: [ 'href' ] } ) ) {
 *				// <a> element is inline and is represented by an attribute in the model.
 *				// This is why we are not updating `context` property.
 *				data.output = conversionApi.convertChildren( data.input, consumable, data );
 *
 *				for ( let item of Range.createFrom( data.output ) ) {
 *					const schemaQuery = {
 *						name: item.name || '$text',
 *						attribute: 'link',
 *						inside: data.context
 *					};
 *
 *					if ( conversionApi.schema.check( schemaQuery ) ) {
 *						item.setAttribute( 'link', data.input.getAttribute( 'href' ) );
 *					}
 *				}
 *			}
 *		} );
 *
 *		// Fire conversion.
 *		// Always take care where the converted model structure will be appended to. If this `viewDocumentFragment`
 *		// is going to be appended directly to a '$root' element, use that in `context`.
 *		viewDispatcher.convert( viewDocumentFragment, { context: [ '$root' ] } );
 *
 * Before each conversion process, `ViewConversionDispatcher` fires {@link ~ViewConversionDispatcher#event:viewCleanup}
 * event which can be used to prepare tree view for conversion.
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 * @fires viewCleanup
 * @fires element
 * @fires text
 * @fires documentFragment
 */
class ViewConversionDispatcher {
	/**
	 * Creates a `ViewConversionDispatcher` that operates using passed API.
	 *
	 * @see module:engine/conversion/viewconversiondispatcher~ViewConversionApi
	 * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired
	 * by `ViewConversionDispatcher`.
	 */
	constructor( conversionApi = {} ) {
		/**
		 * Interface passed by dispatcher to the events callbacks.
		 *
		 * @member {module:engine/conversion/viewconversiondispatcher~ViewConversionApi}
		 */
		this.conversionApi = Object(__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_lib_lodash_extend__["a" /* default */])( {}, conversionApi );

		// `convertItem` and `convertChildren` are bound to this `ViewConversionDispatcher` instance and
		// set on `conversionApi`. This way only a part of `ViewConversionDispatcher` API is exposed.
		this.conversionApi.convertItem = this._convertItem.bind( this );
		this.conversionApi.convertChildren = this._convertChildren.bind( this );
	}

	/**
	 * Starts the conversion process. The entry point for the conversion.
	 *
	 * @fires element
	 * @fires text
	 * @fires documentFragment
	 * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem
	 * Part of the view to be converted.
	 * @param {Object} [additionalData] Additional data to be passed in `data` argument when firing `ViewConversionDispatcher`
	 * events. See also {@link ~ViewConversionDispatcher#event:element element event}.
	 * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is a result of the conversion process
	 * wrapped in `DocumentFragment`. Converted marker elements will be set as that document fragment's
	 * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
	 */
	convert( viewItem, additionalData = {} ) {
		this.fire( 'viewCleanup', viewItem );

		const consumable = __WEBPACK_IMPORTED_MODULE_0__viewconsumable__["a" /* default */].createFrom( viewItem );
		let conversionResult = this._convertItem( viewItem, consumable, additionalData );

		// We can get a null here if conversion failed (see _convertItem())
		// or simply if an item could not be converted (e.g. due to the schema).
		if ( !conversionResult ) {
			return new __WEBPACK_IMPORTED_MODULE_5__model_documentfragment__["a" /* default */]();
		}

		// When conversion result is not a document fragment we need to wrap it in document fragment.
		if ( !conversionResult.is( 'documentFragment' ) ) {
			conversionResult = new __WEBPACK_IMPORTED_MODULE_5__model_documentfragment__["a" /* default */]( [ conversionResult ] );
		}

		// Extract temporary markers elements from model and set as static markers collection.
		conversionResult.markers = extractMarkersFromModelFragment( conversionResult );

		return conversionResult;
	}

	/**
	 * @private
	 * @see module:engine/conversion/viewconversiondispatcher~ViewConversionApi#convertItem
	 */
	_convertItem( input, consumable, additionalData = {} ) {
		const data = Object(__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_utils_src_lib_lodash_extend__["a" /* default */])( {}, additionalData, {
			input,
			output: null
		} );

		if ( input.is( 'element' ) ) {
			this.fire( 'element:' + input.name, data, consumable, this.conversionApi );
		} else if ( input.is( 'text' ) ) {
			this.fire( 'text', data, consumable, this.conversionApi );
		} else {
			this.fire( 'documentFragment', data, consumable, this.conversionApi );
		}

		// Handle incorrect `data.output`.
		if ( data.output && !( data.output instanceof __WEBPACK_IMPORTED_MODULE_4__model_node__["a" /* default */] || data.output instanceof __WEBPACK_IMPORTED_MODULE_5__model_documentfragment__["a" /* default */] ) ) {
			/**
			 * Incorrect conversion result was dropped.
			 *
			 * Item may be converted to either {@link module:engine/model/node~Node model node} or
			 * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.
			 *
			 * @error view-conversion-dispatcher-incorrect-result
			 */
			__WEBPACK_IMPORTED_MODULE_10__ckeditor_ckeditor5_utils_src_log__["a" /* default */].warn( 'view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.', [ input, data.output ] );

			return null;
		}

		return data.output;
	}

	/**
	 * @private
	 * @see module:engine/conversion/viewconversiondispatcher~ViewConversionApi#convertChildren
	 */
	_convertChildren( input, consumable, additionalData = {} ) {
		// Get all children of view input item.
		const viewChildren = Array.from( input.getChildren() );

		// 1. Map those children to model.
		// 2. Filter out items that has not been converted or for which conversion returned wrong result (for those warning is logged).
		// 3. Extract children from document fragments to flatten results.
		const convertedChildren = viewChildren
			.map( viewChild => this._convertItem( viewChild, consumable, additionalData ) )
			.filter( converted => converted instanceof __WEBPACK_IMPORTED_MODULE_4__model_node__["a" /* default */] || converted instanceof __WEBPACK_IMPORTED_MODULE_5__model_documentfragment__["a" /* default */] )
			.reduce( ( result, filtered ) => {
				return result.concat(
					filtered.is( 'documentFragment' ) ? Array.from( filtered.getChildren() ) : filtered
				);
			}, [] );

		// Normalize array to model document fragment.
		return new __WEBPACK_IMPORTED_MODULE_5__model_documentfragment__["a" /* default */]( convertedChildren );
	}

	/**
	 * Fired before the first conversion event, at the beginning of view to model conversion process.
	 *
	 * @event viewCleanup
	 * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}
	 * viewItem Part of the view to be converted.
	 */

	/**
	 * Fired when {@link module:engine/view/element~Element} is converted.
	 *
	 * `element` is a namespace event for a class of events. Names of actually called events follow this pattern:
	 * `element:<elementName>` where `elementName` is the name of converted element. This way listeners may listen to
	 * all elements conversion or to conversion of specific elements.
	 *
	 * @event element
	 * @param {Object} data Object containing conversion input and a placeholder for conversion output and possibly other
	 * values (see {@link #convert}).
	 * Keep in mind that this object is shared by reference between all callbacks that will be called.
	 * This means that callbacks can add their own values if needed,
	 * and those values will be available in other callbacks.
	 * @param {module:engine/view/element~Element} data.input Converted element.
	 * @param {*} data.output The current state of conversion result. Every change to converted element should
	 * be reflected by setting or modifying this property.
	 * @param {module:engine/model/schema~SchemaPath} data.context The conversion context.
	 * @param {module:engine/conversion/viewconsumable~ViewConsumable} consumable Values to consume.
	 * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ViewConversionDispatcher` constructor.
	 * Besides of properties passed in constructor, it also has `convertItem` and `convertChildren` methods which are references
	 * to {@link #_convertItem} and
	 * {@link ~ViewConversionDispatcher#_convertChildren}. Those methods are needed to convert
	 * the whole view-tree they were exposed in `conversionApi` for callbacks.
	 */

	/**
	 * Fired when {@link module:engine/view/text~Text} is converted.
	 *
	 * @event text
	 * @see #event:element
	 */

	/**
	 * Fired when {@link module:engine/view/documentfragment~DocumentFragment} is converted.
	 *
	 * @event documentFragment
	 * @see #event:element
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ViewConversionDispatcher;


Object(__WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( ViewConversionDispatcher, __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

// Traverses given model item and searches elements which marks marker range. Found element is removed from
// DocumentFragment but path of this element is stored in a Map which is then returned.
//
// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.
// @returns {Map<String, module:engine/model/range~Range>} List of static markers.
function extractMarkersFromModelFragment( modelItem ) {
	const markerElements = new Set();
	const markers = new Map();

	// Create ModelTreeWalker.
	const walker = new __WEBPACK_IMPORTED_MODULE_3__model_treewalker__["a" /* default */]( {
		startPosition: __WEBPACK_IMPORTED_MODULE_2__model_position__["a" /* default */].createAt( modelItem, 0 ),
		ignoreElementEnd: true
	} );

	// Walk through DocumentFragment and collect marker elements.
	for ( const value of walker ) {
		// Check if current element is a marker.
		if ( value.item.name == '$marker' ) {
			markerElements.add( value.item );
		}
	}

	// Walk through collected marker elements store its path and remove its from the DocumentFragment.
	for ( const markerElement of markerElements ) {
		const markerName = markerElement.getAttribute( 'data-name' );
		const currentPosition = __WEBPACK_IMPORTED_MODULE_2__model_position__["a" /* default */].createBefore( markerElement );

		// When marker of given name is not stored it means that we have found the beginning of the range.
		if ( !markers.has( markerName ) ) {
			markers.set( markerName, new __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */]( __WEBPACK_IMPORTED_MODULE_2__model_position__["a" /* default */].createFromPosition( currentPosition ) ) );
		// Otherwise is means that we have found end of the marker range.
		} else {
			markers.get( markerName ).end = __WEBPACK_IMPORTED_MODULE_2__model_position__["a" /* default */].createFromPosition( currentPosition );
		}

		// Remove marker element from DocumentFragment.
		Object(__WEBPACK_IMPORTED_MODULE_6__model_writer__["d" /* remove */])( __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */].createOn( markerElement ) );
	}

	return markers;
}

/**
 * Conversion interface that is registered for given {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher}
 * and is passed as one of parameters when {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher dispatcher}
 * fires it's events.
 *
 * `ViewConversionApi` object is built by {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher} constructor.
 * The exact list of properties of this object is determined by the object passed to the constructor.
 *
 * @interface ViewConversionApi
 */

/**
 * Starts conversion of given item by firing an appropriate event.
 *
 * Every fired event is passed (as first parameter) an object with `output` property. Every event may set and/or
 * modify that property. When all callbacks are done, the final value of `output` property is returned by this method.
 * The `output` must be either {@link module:engine/model/node~Node model node} or
 * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} or `null` (as set by default).
 *
 * @method #convertItem
 * @fires module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:element
 * @fires module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:text
 * @fires module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:documentFragment
 * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element|module:engine/view/text~Text}
 * input Item to convert.
 * @param {module:engine/conversion/viewconsumable~ViewConsumable} consumable Values to consume.
 * @param {Object} [additionalData] Additional data to be passed in `data` argument when firing `ViewConversionDispatcher`
 * events. See also {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:element element event}.
 * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment|null} The result of item conversion,
 * created and modified by callbacks attached to fired event, or `null` if the conversion result was incorrect.
 */

/**
 * Starts conversion of all children of given item by firing appropriate events for all those children.
 *
 * @method #convertChildren
 * @fires module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:element
 * @fires module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:text
 * @fires module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:documentFragment
 * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}
 * input Item which children will be converted.
 * @param {module:engine/conversion/viewconsumable~ViewConsumable} consumable Values to consume.
 * @param {Object} [additionalData] Additional data to be passed in `data` argument when firing `ViewConversionDispatcher`
 * events. See also {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:element element event}.
 * @returns {module:engine/model/documentfragment~DocumentFragment} Model document fragment containing results of conversion
 * of all children of given item.
 */


/***/ }),
/* 361 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_isArray__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/conversion/viewconsumable
 */




/**
 * Class used for handling consumption of view {@link module:engine/view/element~Element elements},
 * {@link module:engine/view/text~Text text nodes} and {@link module:engine/view/documentfragment~DocumentFragment document fragments}.
 * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name
 * does not consume its attributes, classes and styles.
 * To add items for consumption use {@link module:engine/conversion/viewconsumable~ViewConsumable#add add method}.
 * To test items use {@link module:engine/conversion/viewconsumable~ViewConsumable#test test method}.
 * To consume items use {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume method}.
 * To revert already consumed items use {@link module:engine/conversion/viewconsumable~ViewConsumable#revert revert method}.
 *
 *		viewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.
 *		viewConsumable.add( textNode ); // Adds text node for consumption.
 *		viewConsumable.add( docFragment ); // Adds document fragment for consumption.
 *		viewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.
 *		viewConsumable.test( textNode ); // Tests if text node can be consumed.
 *		viewConsumable.test( docFragment ); // Tests if document fragment can be consumed.
 *		viewConsumable.consume( element, { name: true }  ); // Consume element's name.
 *		viewConsumable.consume( textNode ); // Consume text node.
 *		viewConsumable.consume( docFragment ); // Consume document fragment.
 *		viewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.
 *		viewConsumable.revert( textNode ); // Revert already consumed text node.
 *		viewConsumable.revert( docFragment ); // Revert already consumed document fragment.
 */
class ViewConsumable {
	/**
	 * Creates new ViewConsumable.
	 */
	constructor() {
		/**
		 * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,
		 * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.
		 * For {@link module:engine/view/text~Text text nodes} and
		 * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.
		 *
		 * @protected
		 * @member {Map.<module:engine/conversion/viewconsumable~ViewElementConsumables|Boolean>}
		*/
		this._consumables = new Map();
	}

	/**
	 * Adds {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
	 * {@link module:engine/view/documentfragment~DocumentFragment document fragment} as ready to be consumed.
	 *
	 *		viewConsumable.add( p, { name: true } ); // Adds element's name to consume.
	 *		viewConsumable.add( p, { attribute: 'name' } ); // Adds element's attribute.
	 *		viewConsumable.add( p, { class: 'foobar' } ); // Adds element's class.
	 *		viewConsumable.add( p, { style: 'color' } ); // Adds element's style
	 *		viewConsumable.add( p, { attribute: 'name', style: 'color' } ); // Adds attribute and style.
	 *		viewConsumable.add( p, { class: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.
	 *		viewConsumable.add( textNode ); // Adds text node to consume.
	 *		viewConsumable.add( docFragment ); // Adds document fragment to consume.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
	 * attribute is provided - it should be handled separately by providing actual style/class.
	 *
	 *		viewConsumable.add( p, { attribute: 'style' } ); // This call will throw an exception.
	 *		viewConsumable.add( p, { style: 'color' } ); // This is properly handled style.
	 *
	 * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element
	 * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
	 * @param {Boolean} consumables.name If set to true element's name will be included.
	 * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
	 * @param {String|Array.<String>} consumables.class Class name or array of class names.
	 * @param {String|Array.<String>} consumables.style Style name or array of style names.
	 */
	add( element, consumables ) {
		let elementConsumables;

		// For text nodes and document fragments just mark them as consumable.
		if ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {
			this._consumables.set( element, true );

			return;
		}

		// For elements create new ViewElementConsumables or update already existing one.
		if ( !this._consumables.has( element ) ) {
			elementConsumables = new ViewElementConsumables();
			this._consumables.set( element, elementConsumables );
		} else {
			elementConsumables = this._consumables.get( element );
		}

		elementConsumables.add( consumables );
	}

	/**
	 * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
	 * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.
	 * It returns `true` when all items included in method's call can be consumed. Returns `false` when
	 * first already consumed item is found and `null` when first non-consumable item is found.
	 *
	 *		viewConsumable.test( p, { name: true } ); // Tests element's name.
	 *		viewConsumable.test( p, { attribute: 'name' } ); // Tests attribute.
	 *		viewConsumable.test( p, { class: 'foobar' } ); // Tests class.
	 *		viewConsumable.test( p, { style: 'color' } ); // Tests style.
	 *		viewConsumable.test( p, { attribute: 'name', style: 'color' } ); // Tests attribute and style.
	 *		viewConsumable.test( p, { class: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
	 *		viewConsumable.test( textNode ); // Tests text node.
	 *		viewConsumable.test( docFragment ); // Tests document fragment.
	 *
	 * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
	 *
	 *		viewConsumable.test( p, { attribute: 'class' } ); // Tests if all added classes can be consumed.
	 *		viewConsumable.test( p, { attribute: 'style' } ); // Tests if all added styles can be consumed.
	 *
	 * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element
	 * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
	 * @param {Boolean} consumables.name If set to true element's name will be included.
	 * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
	 * @param {String|Array.<String>} consumables.class Class name or array of class names.
	 * @param {String|Array.<String>} consumables.style Style name or array of style names.
	 * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`
	 * when first already consumed item is found and `null` when first non-consumable item is found.
	 */
	test( element, consumables ) {
		const elementConsumables = this._consumables.get( element );

		if ( elementConsumables === undefined ) {
			return null;
		}

		// For text nodes and document fragments return stored boolean value.
		if ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {
			return elementConsumables;
		}

		// For elements test consumables object.
		return elementConsumables.test( consumables );
	}

	/**
	 * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
	 * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
	 * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
	 *
	 *		viewConsumable.consume( p, { name: true } ); // Consumes element's name.
	 *		viewConsumable.consume( p, { attribute: 'name' } ); // Consumes element's attribute.
	 *		viewConsumable.consume( p, { class: 'foobar' } ); // Consumes element's class.
	 *		viewConsumable.consume( p, { style: 'color' } ); // Consumes element's style.
	 *		viewConsumable.consume( p, { attribute: 'name', style: 'color' } ); // Consumes attribute and style.
	 *		viewConsumable.consume( p, { class: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
	 *		viewConsumable.consume( textNode ); // Consumes text node.
	 *		viewConsumable.consume( docFragment ); // Consumes document fragment.
	 *
	 * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
	 *
	 *		viewConsumable.consume( p, { attribute: 'class' } ); // Consume only if all added classes can be consumed.
	 *		viewConsumable.consume( p, { attribute: 'style' } ); // Consume only if all added styles can be consumed.
	 *
	 * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element
	 * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
	 * @param {Boolean} consumables.name If set to true element's name will be included.
	 * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
	 * @param {String|Array.<String>} consumables.class Class name or array of class names.
	 * @param {String|Array.<String>} consumables.style Style name or array of style names.
	 * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,
	 * otherwise returns `false`.
	 */
	consume( element, consumables ) {
		if ( this.test( element, consumables ) ) {
			if ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {
				// For text nodes and document fragments set value to false.
				this._consumables.set( element, false );
			} else {
				// For elements - consume consumables object.
				this._consumables.get( element ).consume( consumables );
			}

			return true;
		}

		return false;
	}

	/**
	 * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
	 * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.
	 * Method does not revert items that were never previously added for consumption, even if they are included in
	 * method's call.
	 *
	 *		viewConsumable.revert( p, { name: true } ); // Reverts element's name.
	 *		viewConsumable.revert( p, { attribute: 'name' } ); // Reverts element's attribute.
	 *		viewConsumable.revert( p, { class: 'foobar' } ); // Reverts element's class.
	 *		viewConsumable.revert( p, { style: 'color' } ); // Reverts element's style.
	 *		viewConsumable.revert( p, { attribute: 'name', style: 'color' } ); // Reverts attribute and style.
	 *		viewConsumable.revert( p, { class: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
	 *		viewConsumable.revert( textNode ); // Reverts text node.
	 *		viewConsumable.revert( docFragment ); // Reverts document fragment.
	 *
	 * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
	 * consumption.
	 *
	 *		viewConsumable.revert( p, { attribute: 'class' } ); // Reverts all classes added for consumption.
	 *		viewConsumable.revert( p, { attribute: 'style' } ); // Reverts all styles added for consumption.
	 *
	 * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element
	 * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
	 * @param {Boolean} consumables.name If set to true element's name will be included.
	 * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
	 * @param {String|Array.<String>} consumables.class Class name or array of class names.
	 * @param {String|Array.<String>} consumables.style Style name or array of style names.
	 */
	revert( element, consumables ) {
		const elementConsumables = this._consumables.get( element );

		if ( elementConsumables !== undefined ) {
			if ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {
				// For text nodes and document fragments - set consumable to true.
				this._consumables.set( element, true );
			} else {
				// For elements - revert items from consumables object.
				elementConsumables.revert( consumables );
			}
		}
	}

	/**
	 * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include
	 * element's name and all its attributes, classes and styles.
	 *
	 * @static
	 * @param {module:engine/view/element~Element} element
	 * @returns {Object} consumables
	 */
	static consumablesFromElement( element ) {
		const consumables = {
			name: true,
			attribute: [],
			class: [],
			style: []
		};

		const attributes = element.getAttributeKeys();

		for ( const attribute of attributes ) {
			// Skip classes and styles - will be added separately.
			if ( attribute == 'style' || attribute == 'class' ) {
				continue;
			}

			consumables.attribute.push( attribute );
		}

		const classes = element.getClassNames();

		for ( const className of classes ) {
			consumables.class.push( className );
		}

		const styles = element.getStyleNames();

		for ( const style of styles ) {
			consumables.style.push( style );
		}

		return consumables;
	}

	/**
	 * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from
	 * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
	 * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
	 *
	 * @static
	 * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment
	 * from which `ViewConsumable` will be created.
	 * @param {module:engine/conversion/viewconsumable~ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used
	 * to add all consumables. It will be returned instead of a new instance.
	 */
	static createFrom( from, instance ) {
		if ( !instance ) {
			instance = new ViewConsumable();
		}

		if ( from.is( 'text' ) ) {
			instance.add( from );

			return instance;
		}

		// Add `from` itself, if it is an element.
		if ( from.is( 'element' ) ) {
			instance.add( from, ViewConsumable.consumablesFromElement( from ) );
		}

		if ( from.is( 'documentFragment' ) ) {
			instance.add( from );
		}

		for ( const child of from.getChildren() ) {
			instance = ViewConsumable.createFrom( child, instance );
		}

		return instance;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ViewConsumable;


/**
 * This is a private helper-class for {@link module:engine/conversion/viewconsumable~ViewConsumable}.
 * It represents and manipulates consumable parts of a single {@link module:engine/view/element~Element}.
 *
 * @private
 */
class ViewElementConsumables {
	/**
	 * Creates ViewElementConsumables instance.
	 */
	constructor() {
		/**
		 * Flag indicating if name of the element can be consumed.
		 *
		 * @private
		 * @member {Boolean}
		 */
		this._canConsumeName = null;

		/**
		 * Contains maps of element's consumables: attributes, classes and styles.
		 *
		 * @private
		 * @member {Object}
		 */
		this._consumables = {
			attribute: new Map(),
			style: new Map(),
			class: new Map()
		};
	}

	/**
	 * Adds consumable parts of the {@link module:engine/view/element~Element view element}.
	 * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
	 * styles still could be consumed):
	 *
	 *		consumables.add( { name: true } );
	 *
	 * Attributes classes and styles:
	 *
	 *		consumables.add( { attribute: 'title', class: 'foo', style: 'color' } );
	 *		consumables.add( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
	 * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
	 *
	 * @param {Object} consumables Object describing which parts of the element can be consumed.
	 * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.
	 * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to add as consumable.
	 * @param {String|Array.<String>} consumables.class Class name or array of class names to add as consumable.
	 * @param {String|Array.<String>} consumables.style Style name or array of style names to add as consumable.
	 */
	add( consumables ) {
		if ( consumables.name ) {
			this._canConsumeName = true;
		}

		for ( const type in this._consumables ) {
			if ( type in consumables ) {
				this._add( type, consumables[ type ] );
			}
		}
	}

	/**
	 * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.
	 *
	 * Element's name can be tested:
	 *
	 *		consumables.test( { name: true } );
	 *
	 * Attributes classes and styles:
	 *
	 *		consumables.test( { attribute: 'title', class: 'foo', style: 'color' } );
	 *		consumables.test( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
	 *
	 * @param {Object} consumables Object describing which parts of the element should be tested.
	 * @param {Boolean} consumables.name If set to `true` element's name will be tested.
	 * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to test.
	 * @param {String|Array.<String>} consumables.class Class name or array of class names to test.
	 * @param {String|Array.<String>} consumables.style Style name or array of style names to test.
	 * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items
	 * was never marked for consumption and `false` when even one of the items was already consumed.
	 */
	test( consumables ) {
		// Check if name can be consumed.
		if ( consumables.name && !this._canConsumeName ) {
			return this._canConsumeName;
		}

		for ( const type in this._consumables ) {
			if ( type in consumables ) {
				const value = this._test( type, consumables[ type ] );

				if ( value !== true ) {
					return value;
				}
			}
		}

		// Return true only if all can be consumed.
		return true;
	}

	/**
	 * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item
	 * is already consumed - it consumes all consumable items provided.
	 * Element's name can be consumed:
	 *
	 *		consumables.consume( { name: true } );
	 *
	 * Attributes classes and styles:
	 *
	 *		consumables.consume( { attribute: 'title', class: 'foo', style: 'color' } );
	 *		consumables.consume( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
	 *
	 * @param {Object} consumables Object describing which parts of the element should be consumed.
	 * @param {Boolean} consumables.name If set to `true` element's name will be consumed.
	 * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to consume.
	 * @param {String|Array.<String>} consumables.class Class name or array of class names to consume.
	 * @param {String|Array.<String>} consumables.style Style name or array of style names to consume.
	 */
	consume( consumables ) {
		if ( consumables.name ) {
			this._canConsumeName = false;
		}

		for ( const type in this._consumables ) {
			if ( type in consumables ) {
				this._consume( type, consumables[ type ] );
			}
		}
	}

	/**
	 * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.
	 * Element's name can be reverted:
	 *
	 *		consumables.revert( { name: true } );
	 *
	 * Attributes classes and styles:
	 *
	 *		consumables.revert( { attribute: 'title', class: 'foo', style: 'color' } );
	 *		consumables.revert( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
	 *
	 * @param {Object} consumables Object describing which parts of the element should be reverted.
	 * @param {Boolean} consumables.name If set to `true` element's name will be reverted.
	 * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to revert.
	 * @param {String|Array.<String>} consumables.class Class name or array of class names to revert.
	 * @param {String|Array.<String>} consumables.style Style name or array of style names to revert.
	 */
	revert( consumables ) {
		if ( consumables.name ) {
			this._canConsumeName = true;
		}

		for ( const type in this._consumables ) {
			if ( type in consumables ) {
				this._revert( type, consumables[ type ] );
			}
		}
	}

	/**
	 * Helper method that adds consumables of a given type: attribute, class or style.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
	 * type is provided - it should be handled separately by providing actual style/class type.
	 *
	 * @private
	 * @param {String} type Type of the consumable item: `attribute`, `class` or `style`.
	 * @param {String|Array.<String>} item Consumable item or array of items.
	 */
	_add( type, item ) {
		const items = Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_isArray__["a" /* default */])( item ) ? item : [ item ];
		const consumables = this._consumables[ type ];

		for ( const name of items ) {
			if ( type === 'attribute' && ( name === 'class' || name === 'style' ) ) {
				/**
				 * Class and style attributes should be handled separately in
				 * {@link module:engine/conversion/viewconsumable~ViewConsumable#add `ViewConsumable#add()`}.
				 *
				 * What you have done is trying to use:
				 *
				 *		consumables.add( { attribute: [ 'class', 'style' ] } );
				 *
				 * While each class and style should be registered separately:
				 *
				 *		consumables.add( { class: 'some-class', style: 'font-weight' } );
				 *
				 * @error viewconsumable-invalid-attribute
				 */
				throw new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'viewconsumable-invalid-attribute: Classes and styles should be handled separately.' );
			}

			consumables.set( name, true );
		}
	}

	/**
	 * Helper method that tests consumables of a given type: attribute, class or style.
	 *
	 * @private
	 * @param {String} type Type of the consumable item: `attribute`, `class` or `style`.
	 * @param {String|Array.<String>} item Consumable item or array of items.
	 * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be
	 * consumed and `false` when one of the items is already consumed.
	 */
	_test( type, item ) {
		const items = Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_isArray__["a" /* default */])( item ) ? item : [ item ];
		const consumables = this._consumables[ type ];

		for ( const name of items ) {
			if ( type === 'attribute' && ( name === 'class' || name === 'style' ) ) {
				// Check all classes/styles if class/style attribute is tested.
				const value = this._test( name, [ ...this._consumables[ name ].keys() ] );

				if ( value !== true ) {
					return value;
				}
			} else {
				const value = consumables.get( name );
				// Return null if attribute is not found.
				if ( value === undefined ) {
					return null;
				}

				if ( !value ) {
					return false;
				}
			}
		}

		return true;
	}

	/**
	 * Helper method that consumes items of a given type: attribute, class or style.
	 *
	 * @private
	 * @param {String} type Type of the consumable item: `attribute`, `class` or `style`.
	 * @param {String|Array.<String>} item Consumable item or array of items.
	 */
	_consume( type, item ) {
		const items = Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_isArray__["a" /* default */])( item ) ? item : [ item ];
		const consumables = this._consumables[ type ];

		for ( const name of items ) {
			if ( type === 'attribute' && ( name === 'class' || name === 'style' ) ) {
				// If class or style is provided for consumption - consume them all.
				this._consume( name, [ ...this._consumables[ name ].keys() ] );
			} else {
				consumables.set( name, false );
			}
		}
	}

	/**
	 * Helper method that reverts items of a given type: attribute, class or style.
	 *
	 * @private
	 * @param {String} type Type of the consumable item: `attribute`, `class` or , `style`.
	 * @param {String|Array.<String>} item Consumable item or array of items.
	 */
	_revert( type, item ) {
		const items = Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_isArray__["a" /* default */])( item ) ? item : [ item ];
		const consumables = this._consumables[ type ];

		for ( const name of items ) {
			if ( type === 'attribute' && ( name === 'class' || name === 'style' ) ) {
				// If class or style is provided for reverting - revert them all.
				this._revert( name, [ ...this._consumables[ name ].keys() ] );
			} else {
				const value = consumables.get( name );

				if ( value === false ) {
					consumables.set( name, true );
				}
			}
		}
	}
}


/***/ }),
/* 362 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = convertToModelFragment;
/* harmony export (immutable) */ __webpack_exports__["a"] = convertText;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model_documentfragment__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_text__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_writer__ = __webpack_require__(22);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */





/**
 * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for
 * {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher}.
 *
 * @module engine/conversion/view-to-model-converters
 */

/**
 * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}
 * or all children of {@link module:engine/view/element~Element} into
 * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.
 * This is the "entry-point" converter for view to model conversion. This converter starts the conversion of all children
 * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.
 *
 * This also a "default", last resort converter for all view elements that has not been converted by other converters.
 * When a view element is being converted to the model but it does not have converter specified, that view element
 * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.
 *
 * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and
 * {@link module:engine/view/element~Element elements} that returns
 * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.
 */
function convertToModelFragment() {
	return ( evt, data, consumable, conversionApi ) => {
		// Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.
		if ( !data.output && consumable.consume( data.input, { name: true } ) ) {
			const convertedChildren = conversionApi.convertChildren( data.input, consumable, data );

			data.output = new __WEBPACK_IMPORTED_MODULE_0__model_documentfragment__["a" /* default */]( Object(__WEBPACK_IMPORTED_MODULE_2__model_writer__["c" /* normalizeNodes */])( convertedChildren ) );
		}
	};
}

/**
 * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.
 *
 * @returns {Function} {@link module:engine/view/text~Text View text} converter.
 */
function convertText() {
	return ( evt, data, consumable, conversionApi ) => {
		const schemaQuery = {
			name: '$text',
			inside: data.context
		};

		if ( conversionApi.schema.check( schemaQuery ) ) {
			if ( consumable.consume( data.input ) ) {
				data.output = new __WEBPACK_IMPORTED_MODULE_1__model_text__["a" /* default */]( data.input.data );
			}
		}
	};
}


/***/ }),
/* 363 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = insertContent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_liveposition__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_log__ = __webpack_require__(26);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/controller/insertcontent
 */







/**
 * Inserts content into the editor (specified selection) as one would expect the paste
 * functionality to work.
 *
 * **Note:** Use {@link module:engine/controller/datacontroller~DataController#insertContent} instead of this function.
 * This function is only exposed to be reusable in algorithms
 * which change the {@link module:engine/controller/datacontroller~DataController#insertContent}
 * method's behavior.
 *
 * @param {module:engine/controller/datacontroller~DataController} dataController The data controller in context of which the insertion
 * should be performed.
 * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.
 * @param {module:engine/model/selection~Selection} selection Selection into which the content should be inserted.
 * @param {module:engine/model/batch~Batch} [batch] Batch to which deltas will be added. If not specified, then
 * changes will be added to a new batch.
 */
function insertContent( dataController, content, selection, batch ) {
	if ( !batch ) {
		batch = dataController.model.batch();
	}

	if ( !selection.isCollapsed ) {
		dataController.deleteContent( selection, batch );
	}

	const insertion = new Insertion( dataController, batch, selection.anchor );

	let nodesToInsert;

	if ( content.is( 'documentFragment' ) ) {
		nodesToInsert = content.getChildren();
	} else {
		nodesToInsert = [ content ];
	}

	insertion.handleNodes( nodesToInsert, {
		// The set of children being inserted is the only set in this context
		// so it's the first and last (it's a hack ;)).
		isFirst: true,
		isLast: true
	} );

	const newRange = insertion.getSelectionRange();

	/* istanbul ignore else */
	if ( newRange ) {
		selection.setRanges( [ newRange ] );
	} else {
		// We are not testing else because it's a safe check for unpredictable edge cases:
		// an insertion without proper range to select.

		/**
		 * Cannot determine a proper selection range after insertion.
		 *
		 * @warning insertcontent-no-range
		 */
		__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_log__["a" /* default */].warn( 'insertcontent-no-range: Cannot determine a proper selection range after insertion.' );
	}
}

/**
 * Utility class for performing content insertion.
 *
 * @private
 */
class Insertion {
	constructor( dataController, batch, position ) {
		/**
		 * The data controller in context of which the insertion should be performed.
		 *
		 * @member {module:engine/controller/datacontroller~DataController} #dataController
		 */
		this.dataController = dataController;

		/**
		 * Batch to which deltas will be added.
		 *
		 * @member {module:engine/controller/batch~Batch} #batch
		 */
		this.batch = batch;

		/**
		 * The position at which (or near which) the next node will be inserted.
		 *
		 * @member {module:engine/model/position~Position} #position
		 */
		this.position = position;

		/**
		 * Elements with which the inserted elements can be merged.
		 *
		 *		<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)
		 *		<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)
		 *		<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,
		 *								so both its pieces will be added to this set)
		 *
		 *
		 * @member {Set} #canMergeWith
		 */
		this.canMergeWith = new Set( [ this.position.parent ] );

		/**
		 * Schema of the model.
		 *
		 * @member {module:engine/model/schema~Schema} #schema
		 */
		this.schema = dataController.model.schema;
	}

	/**
	 * Handles insertion of a set of nodes.
	 *
	 * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.
	 * @param {Object} parentContext Context in which parent of these nodes was supposed to be inserted.
	 * If the parent context is passed it means that the parent element was stripped (was not allowed).
	 */
	handleNodes( nodes, parentContext ) {
		nodes = Array.from( nodes );

		for ( let i = 0; i < nodes.length; i++ ) {
			const node = nodes[ i ];

			this._handleNode( node, {
				isFirst: i === 0 && parentContext.isFirst,
				isLast: ( i === ( nodes.length - 1 ) ) && parentContext.isLast
			} );
		}
	}

	/**
	 * Returns range to be selected after insertion.
	 * Returns null if there is no valid range to select after insertion.
	 *
	 * @returns {module:engine/model/range~Range|null}
	 */
	getSelectionRange() {
		if ( this.nodeToSelect ) {
			return __WEBPACK_IMPORTED_MODULE_3__model_range__["a" /* default */].createOn( this.nodeToSelect );
		}

		return this.dataController.model.getNearestSelectionRange( this.position );
	}

	/**
	 * Handles insertion of a single node.
	 *
	 * @param {module:engine/model/node~Node} node
	 * @param {Object} context
	 * @param {Boolean} context.isFirst Whether the given node is the first one in the content to be inserted.
	 * @param {Boolean} context.isLast Whether the given node is the last one in the content to be inserted.
	 */
	_handleNode( node, context ) {
		// Let's handle object in a special way.
		// * They should never be merged with other elements.
		// * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.
		if ( this._checkIsObject( node ) ) {
			this._handleObject( node, context );

			return;
		}

		// Try to find a place for the given node.
		// Split the position.parent's branch up to a point where the node can be inserted.
		// If it isn't allowed in the whole branch, then of course don't split anything.
		const isAllowed = this._checkAndSplitToAllowedPosition( node, context );

		if ( !isAllowed ) {
			this._handleDisallowedNode( node, context );

			return;
		}

		this._insert( node );

		// After the node was inserted we may try to merge it with its siblings.
		// This should happen only if it was the first and/or last of the nodes (so only with boundary nodes)
		// and only if the selection was in those elements initially.
		//
		// E.g.:
		// <p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>
		// and:
		// <p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>y</p><p>z</p> => <p>xy[]z</p>
		// but:
		// <p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging)
		// <p>x</p>[<img>]<p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging, note: after running deletetContents
		//																	 it's exactly the same case as above)
		this._mergeSiblingsOf( node, context );
	}

	/**
	 * @param {module:engine/model/element~Element} node The object element.
	 * @param {Object} context
	 */
	_handleObject( node, context ) {
		// Try finding it a place in the tree.
		if ( this._checkAndSplitToAllowedPosition( node ) ) {
			this._insert( node );
		}
		// Try autoparagraphing.
		else {
			this._tryAutoparagraphing( node, context );
		}
	}

	/**
	 * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.
	 * @param {Object} context
	 */
	_handleDisallowedNode( node, context ) {
		// If the node is an element, try inserting its children (strip the parent).
		if ( node.is( 'element' ) ) {
			this.handleNodes( node.getChildren(), context );
		}
		// If the node is a text and bare text is allowed in current position it means that the node
		// contains disallowed attributes and we have to remove them.
		else if ( this.schema.check( { name: '$text', inside: this.position } ) ) {
			this.schema.removeDisallowedAttributes( [ node ], this.position );
			this._handleNode( node, context );
		}
		// If text is not allowed, try autoparagraphing.
		else {
			this._tryAutoparagraphing( node, context );
		}
	}

	/**
	 * @param {module:engine/model/node~Node} node The node to insert.
	 */
	_insert( node ) {
		/* istanbul ignore if */
		if ( !this._checkIsAllowed( node, this.position ) ) {
			// Algorithm's correctness check. We should never end up here but it's good to know that we did.
			// Note that it would often be a silent issue if we insert node in a place where it's not allowed.
			__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_log__["a" /* default */].error(
				'insertcontent-wrong-position: The node cannot be inserted on the given position.',
				{ node, position: this.position }
			);

			return;
		}

		const livePos = __WEBPACK_IMPORTED_MODULE_1__model_liveposition__["a" /* default */].createFromPosition( this.position );

		this.batch.insert( this.position, node );

		this.position = __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createFromPosition( livePos );
		livePos.detach();

		// The last inserted object should be selected because we can't put a collapsed selection after it.
		if ( this._checkIsObject( node ) && !this.schema.check( { name: '$text', inside: this.position } ) ) {
			this.nodeToSelect = node;
		} else {
			this.nodeToSelect = null;
		}
	}

	/**
	 * @param {module:engine/model/node~Node} node The node which could potentially be merged.
	 * @param {Object} context
	 */
	_mergeSiblingsOf( node, context ) {
		if ( !( node instanceof __WEBPACK_IMPORTED_MODULE_2__model_element__["a" /* default */] ) ) {
			return;
		}

		const mergeLeft = context.isFirst && ( node.previousSibling instanceof __WEBPACK_IMPORTED_MODULE_2__model_element__["a" /* default */] ) && this.canMergeWith.has( node.previousSibling );
		const mergeRight = context.isLast && ( node.nextSibling instanceof __WEBPACK_IMPORTED_MODULE_2__model_element__["a" /* default */] ) && this.canMergeWith.has( node.nextSibling );
		const mergePosLeft = __WEBPACK_IMPORTED_MODULE_1__model_liveposition__["a" /* default */].createBefore( node );
		const mergePosRight = __WEBPACK_IMPORTED_MODULE_1__model_liveposition__["a" /* default */].createAfter( node );

		if ( mergeLeft ) {
			const position = __WEBPACK_IMPORTED_MODULE_1__model_liveposition__["a" /* default */].createFromPosition( this.position );

			this.batch.merge( mergePosLeft );

			// We need to check and strip disallowed attributes in all nested nodes because after merge
			// some attributes could end up in a path where are disallowed.
			const parent = position.nodeBefore;
			this.schema.removeDisallowedAttributes( parent.getChildren(), __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createAt( parent ), this.batch );

			this.position = __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createFromPosition( position );
			position.detach();
		}

		if ( mergeRight ) {
			/* istanbul ignore if */
			if ( !this.position.isEqual( mergePosRight ) ) {
				// Algorithm's correctness check. We should never end up here but it's good to know that we did.
				// At this point the insertion position should be after the node we'll merge. If it isn't,
				// it should need to be secured as in the left merge case.
				__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_log__["a" /* default */].error( 'insertcontent-wrong-position-on-merge: The insertion position should equal the merge position' );
			}

			// Move the position to the previous node, so it isn't moved to the graveyard on merge.
			// <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>
			this.position = __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createAt( mergePosRight.nodeBefore, 'end' );

			// OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)
			// NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)
			const position = new __WEBPACK_IMPORTED_MODULE_1__model_liveposition__["a" /* default */]( this.position.root, this.position.path, 'sticksToPrevious' );

			this.batch.merge( mergePosRight );

			// We need to check and strip disallowed attributes in all nested nodes because after merge
			// some attributes could end up in a place where are disallowed.
			this.schema.removeDisallowedAttributes( position.parent.getChildren(), position, this.batch );

			this.position = __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createFromPosition( position );
			position.detach();
		}

		mergePosLeft.detach();
		mergePosRight.detach();

		// When there was no merge we need to check and strip disallowed attributes in all nested nodes of
		// just inserted node because some attributes could end up in a place where are disallowed.
		if ( !mergeLeft && !mergeRight ) {
			this.schema.removeDisallowedAttributes( node.getChildren(), __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createAt( node ), this.batch );
		}
	}

	/**
	 * Tries wrapping the node in a new paragraph and inserting it this way.
	 *
	 * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.
	 * @param {Object} context
	 */
	_tryAutoparagraphing( node, context ) {
		const paragraph = new __WEBPACK_IMPORTED_MODULE_2__model_element__["a" /* default */]( 'paragraph' );

		// Do not autoparagraph if the paragraph won't be allowed there,
		// cause that would lead to an infinite loop. The paragraph would be rejected in
		// the next _handleNode() call and we'd be here again.
		if ( this._getAllowedIn( paragraph, this.position.parent ) ) {
			// When node is a text and is disallowed by schema it means that contains disallowed attributes
			// and we need to remove them.
			if ( node.is( 'text' ) && !this._checkIsAllowed( node, [ paragraph ] ) ) {
				this.schema.removeDisallowedAttributes( [ node ], [ paragraph ] );
			}

			if ( this._checkIsAllowed( node, [ paragraph ] ) ) {
				paragraph.appendChildren( node );
				this._handleNode( paragraph, context );
			}
		}
	}

	/**
	 * @param {module:engine/model/node~Node} node
	 * @returns {Boolean} Whether an allowed position was found.
	 * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.
	 */
	_checkAndSplitToAllowedPosition( node ) {
		const allowedIn = this._getAllowedIn( node, this.position.parent );

		if ( !allowedIn ) {
			return false;
		}

		while ( allowedIn != this.position.parent ) {
			// If a parent which we'd need to leave is a limit element, break.
			if ( this.schema.limits.has( this.position.parent.name ) ) {
				return false;
			}

			if ( this.position.isAtStart ) {
				const parent = this.position.parent;
				this.position = __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createBefore( parent );

				// Special case  parent is empty (<p>^</p>) so isAtStart == isAtEnd == true.
				// We can remove the element after moving selection out of it.
				if ( parent.isEmpty ) {
					this.batch.remove( parent );
				}
			} else if ( this.position.isAtEnd ) {
				this.position = __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createAfter( this.position.parent );
			} else {
				const tempPos = __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createAfter( this.position.parent );

				this.batch.split( this.position );

				this.position = tempPos;

				this.canMergeWith.add( this.position.nodeAfter );
			}
		}

		return true;
	}

	/**
	 * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.
	 *
	 * @param {module:engine/model/node~Node} node The node to check.
	 * @param {module:engine/model/element~Element} element The element in which the node's correctness should be checked.
	 * @returns {module:engine/model/element~Element|null}
	 */
	_getAllowedIn( node, element ) {
		if ( this._checkIsAllowed( node, [ element ] ) ) {
			return element;
		}

		if ( element.parent ) {
			return this._getAllowedIn( node, element.parent );
		}

		return null;
	}

	/**
	 * Check whether the given node is allowed in the specified schema path.
	 *
	 * @param {module:engine/model/node~Node} node
	 * @param {module:engine/model/schema~SchemaPath} path
	 */
	_checkIsAllowed( node, path ) {
		return this.schema.check( {
			name: getNodeSchemaName( node ),
			attributes: Array.from( node.getAttributeKeys() ),
			inside: path
		} );
	}

	/**
	 * Checks whether according to the schema this is an object type element.
	 *
	 * @param {module:engine/model/node~Node} node The node to check.
	 */
	_checkIsObject( node ) {
		return this.schema.objects.has( getNodeSchemaName( node ) );
	}
}

// Gets a name under which we should check this node in the schema.
//
// @param {module:engine/model/node~Node} node The node.
// @returns {String} Node name.
function getNodeSchemaName( node ) {
	return node.is( 'text' ) ? '$text' : node.name;
}


/***/ }),
/* 364 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = deleteContent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model_liveposition__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_element__ = __webpack_require__(5);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/controller/deletecontent
 */






/**
 * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.
 *
 * @param {module:engine/model/selection~Selection} selection Selection of which the content should be deleted.
 * @param {module:engine/model/batch~Batch} batch Batch to which the deltas will be added.
 * @param {Object} [options]
 * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.
 *
 * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:
 *
 * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)
 * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).
 *
 * Note: {@link module:engine/model/schema~Schema#objects object} and {@link module:engine/model/schema~Schema#limits limit}
 * elements will not be merged.
 *
 * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a
 * paragraph when the entire content was selected.
 *
 * For example `<heading>[x</heading><paragraph>y]</paragraph> will become:
 *
 * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)
 * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).
 */
function deleteContent( selection, batch, options = {} ) {
	if ( selection.isCollapsed ) {
		return;
	}

	const schema = batch.document.schema;

	// 1. Replace the entire content with paragraph.
	// See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.
	if ( !options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph( schema, selection ) ) {
		replaceEntireContentWithParagraph( batch, selection );

		return;
	}

	const selRange = selection.getFirstRange();
	const startPos = selRange.start;
	const endPos = __WEBPACK_IMPORTED_MODULE_0__model_liveposition__["a" /* default */].createFromPosition( selRange.end );

	// 2. Remove the content if there is any.
	if ( !selRange.start.isTouching( selRange.end ) ) {
		batch.remove( selRange );
	}

	// 3. Merge elements in the right branch to the elements in the left branch.
	// The only reasonable (in terms of data and selection correctness) case in which we need to do that is:
	//
	// <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>
	//
	// However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),
	// as it's hard to imagine what should actually be the default behavior. Usually, specific features will
	// want to override that behavior anyway.
	if ( !options.leaveUnmerged ) {
		mergeBranches( batch, startPos, endPos );

		// We need to check and strip disallowed attributes in all nested nodes because after merge
		// some attributes could end up in a path where are disallowed.
		//
		// e.g. bold is disallowed for <H1>
		// <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.
		schema.removeDisallowedAttributes( startPos.parent.getChildren(), startPos, batch );
	}

	selection.setCollapsedAt( startPos );

	// 4. Autoparagraphing.
	// Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).
	if ( shouldAutoparagraph( schema, startPos ) ) {
		insertParagraph( batch, startPos, selection );
	}

	endPos.detach();
}

// This function is a result of reaching the Ballmer's peak for just the right amount of time.
// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.
function mergeBranches( batch, startPos, endPos ) {
	const startParent = startPos.parent;
	const endParent = endPos.parent;

	// If both positions ended up in the same parent, then there's nothing more to merge:
	// <$root><p>x[]</p><p>{}y</p></$root> => <$root><p>xy</p>[]{}</$root>
	if ( startParent == endParent ) {
		return;
	}

	// If one of the positions is a root, then there's nothing more to merge (at least in the current state of implementation).
	// Theoretically in this case we could unwrap the <p>: <$root>x[]<p>{}y</p></$root>, but we don't need to support it yet
	// so let's just abort.
	if ( !startParent.parent || !endParent.parent ) {
		return;
	}

	// Check if operations we'll need to do won't need to cross object or limit boundaries.
	// E.g., we can't merge endParent into startParent in this case:
	// <limit><startParent>x[]</startParent></limit><endParent>{}</endParent>
	if ( !checkCanBeMerged( startPos, endPos ) ) {
		return;
	}

	// Remember next positions to merge. For example:
	// <a><b>x[]</b></a><c><d>{}y</d></c>
	// will become:
	// <a><b>xy</b>[]</a><c>{}</c>
	startPos = __WEBPACK_IMPORTED_MODULE_1__model_position__["a" /* default */].createAfter( startParent );
	endPos = __WEBPACK_IMPORTED_MODULE_1__model_position__["a" /* default */].createBefore( endParent );

	if ( !endPos.isEqual( startPos ) ) {
		// In this case, before we merge, we need to move `endParent` to the `startPos`:
		// <a><b>x[]</b></a><c><d>{}y</d></c>
		// becomes:
		// <a><b>x</b>[]<d>y</d></a><c>{}</c>
		batch.move( endParent, startPos );
	}

	// Merge two siblings:
	// <a>x</a>[]<b>y</b> -> <a>xy</a> (the usual case)
	// <a><b>x</b>[]<d>y</d></a><c></c> -> <a><b>xy</b>[]</a><c></c> (this is the "move parent" case shown above)
	batch.merge( startPos );

	// Remove empty end ancestors:
	// <a>fo[o</a><b><a><c>bar]</c></a></b>
	// becomes:
	// <a>fo[]</a><b><a>{}</a></b>
	// So we can remove <a> and <b>.
	while ( endPos.parent.isEmpty ) {
		const parentToRemove = endPos.parent;

		endPos = __WEBPACK_IMPORTED_MODULE_1__model_position__["a" /* default */].createBefore( parentToRemove );

		batch.remove( parentToRemove );
	}

	// Continue merging next level.
	mergeBranches( batch, startPos, endPos );
}

function shouldAutoparagraph( schema, position ) {
	const isTextAllowed = schema.check( { name: '$text', inside: position } );
	const isParagraphAllowed = schema.check( { name: 'paragraph', inside: position } );

	return !isTextAllowed && isParagraphAllowed;
}

// Check if parents of two positions can be merged by checking if there are no limit/object
// boundaries between those two positions.
//
// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>
// we'll check <p>, <bQ>, <widget> and <caption>.
// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.
function checkCanBeMerged( leftPos, rightPos ) {
	const schema = leftPos.root.document.schema;
	const rangeToCheck = new __WEBPACK_IMPORTED_MODULE_2__model_range__["a" /* default */]( leftPos, rightPos );

	for ( const value of rangeToCheck.getWalker() ) {
		if ( schema.objects.has( value.item.name ) || schema.limits.has( value.item.name ) ) {
			return false;
		}
	}

	return true;
}

function insertParagraph( batch, position, selection ) {
	const paragraph = new __WEBPACK_IMPORTED_MODULE_3__model_element__["a" /* default */]( 'paragraph' );
	batch.insert( position, paragraph );

	selection.setCollapsedAt( paragraph );
}

function replaceEntireContentWithParagraph( batch, selection ) {
	const limitElement = batch.document.schema.getLimitElement( selection );

	batch.remove( __WEBPACK_IMPORTED_MODULE_2__model_range__["a" /* default */].createIn( limitElement ) );
	insertParagraph( batch, __WEBPACK_IMPORTED_MODULE_1__model_position__["a" /* default */].createAt( limitElement ), selection );
}

// We want to replace the entire content with a paragraph when:
// * the entire content is selected,
// * selection contains at least two elements,
// * whether the paragraph is allowed in schema in the common ancestor.
function shouldEntireContentBeReplacedWithParagraph( schema, selection ) {
	const limitElement = schema.getLimitElement( selection );

	if ( !selection.containsEntireContent( limitElement ) ) {
		return false;
	}

	const range = selection.getFirstRange();

	if ( range.start.parent == range.end.parent ) {
		return false;
	}

	return schema.check( { name: 'paragraph', inside: limitElement.name } );
}


/***/ }),
/* 365 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = modifySelection;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_treewalker__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_unicode__ = __webpack_require__(185);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/controller/modifyselection
 */






/**
 * Modifies the selection. Currently, the supported modifications are:
 *
 * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
 * Possible values for `unit` are:
 *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
 *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
 *  with a symbol before it ("base character") to create one user-perceived character. For example, `q` is a normal
 *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
 *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
 *  why `'character'` value is most natural and common method of modifying selection.
 *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
 *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
 *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
 *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
 *  For example `` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
 *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
 *  extension will include whole "surrogate pair".
 *
 * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
 *
 * @param {module:engine/controller/datacontroller~DataController} dataController The data controller in context of which
 * the selection modification should be performed.
 * @param {module:engine/model/selection~Selection} selection The selection to modify.
 * @param {Object} [options]
 * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.
 * @param {'character'|'codePoint'} [options.unit='character'] The unit by which selection should be modified.
 */
function modifySelection( dataController, selection, options = {} ) {
	const schema = dataController.model.schema;
	const isForward = options.direction != 'backward';
	const unit = options.unit ? options.unit : 'character';

	const focus = selection.focus;
	const walker = new __WEBPACK_IMPORTED_MODULE_1__model_treewalker__["a" /* default */]( {
		boundaries: getSearchRange( focus, isForward ),
		singleCharacters: true,
		direction: isForward ? 'forward' : 'backward'
	} );

	const data = { walker, schema, isForward, unit };

	let next;

	while ( ( next = walker.next() ) ) {
		if ( next.done ) {
			return;
		}

		const position = tryExtendingTo( data, next.value );

		if ( position ) {
			selection.moveFocusTo( position );

			return;
		}
	}
}

// Checks whether the selection can be extended to the the walker's next value (next position).
function tryExtendingTo( data, value ) {
	// If found text, we can certainly put the focus in it. Let's just find a correct position
	// based on the unit.
	if ( value.type == 'text' ) {
		return getCorrectPosition( data.walker, data.unit );
	}

	// Entering an element.
	if ( value.type == ( data.isForward ? 'elementStart' : 'elementEnd' ) ) {
		// If it's an object, we can select it now.
		if ( data.schema.objects.has( value.item.name ) ) {
			return __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createAt( value.item, data.isForward ? 'after' : 'before' );
		}

		// If text allowed on this position, extend to this place.
		if ( data.schema.check( { name: '$text', inside: value.nextPosition } ) ) {
			return value.nextPosition;
		}
	}
	// Leaving an element.
	else {
		// If leaving a limit element, stop.
		if ( data.schema.limits.has( value.item.name ) ) {
			// NOTE: Fast-forward the walker until the end.
			data.walker.skip( () => true );

			return;
		}

		// If text allowed on this position, extend to this place.
		if ( data.schema.check( { name: '$text', inside: value.nextPosition } ) ) {
			return value.nextPosition;
		}
	}
}

// Finds a correct position by walking in a text node and checking whether selection can be extended to given position
// or should be extended further.
function getCorrectPosition( walker, unit ) {
	const textNode = walker.position.textNode;

	if ( textNode ) {
		const data = textNode.data;
		let offset = walker.position.offset - textNode.startOffset;

		while ( Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_unicode__["b" /* isInsideSurrogatePair */])( data, offset ) || ( unit == 'character' && Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_unicode__["a" /* isInsideCombinedSymbol */])( data, offset ) ) ) {
			walker.next();

			offset = walker.position.offset - textNode.startOffset;
		}
	}

	return walker.position;
}

function getSearchRange( start, isForward ) {
	const root = start.root;
	const searchEnd = __WEBPACK_IMPORTED_MODULE_0__model_position__["a" /* default */].createAt( root, isForward ? 'end' : 0 );

	if ( isForward ) {
		return new __WEBPACK_IMPORTED_MODULE_2__model_range__["a" /* default */]( start, searchEnd );
	} else {
		return new __WEBPACK_IMPORTED_MODULE_2__model_range__["a" /* default */]( searchEnd, start );
	}
}


/***/ }),
/* 366 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getSelectedContent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model_documentfragment__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_text__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__model_writer__ = __webpack_require__(22);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/controller/getselectedcontent
 */







/**
 * Gets a clone of the selected content.
 *
 * For example, for the following selection:
 *
 *		<p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>
 *
 * It will return a document fragment with such a content:
 *
 *		<quote><h>st</h></quote><p>se</p>
 *
 * @param {module:engine/model/selection~Selection} selection The selection of which content will be returned.
 * @returns {module:engine/model/documentfragment~DocumentFragment}
 */
function getSelectedContent( selection ) {
	const frag = new __WEBPACK_IMPORTED_MODULE_0__model_documentfragment__["a" /* default */]();
	const range = selection.getFirstRange();

	if ( !range || range.isCollapsed ) {
		return frag;
	}

	const root = range.start.root;
	const commonPath = range.start.getCommonPath( range.end );
	const commonParent = root.getNodeByPath( commonPath );

	// ## 1st step
	//
	// First, we'll clone a fragment represented by a minimal flat range
	// containing the original range to be cloned.
	// E.g. let's consider such a range:
	//
	// <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>
	//
	// A minimal flat range containing this one is:
	//
	// <p>x</p>[<quote><p>y</p><h>first</h></quote><p>second</p>]<p>z</p>
	//
	// We can easily clone this structure, preserving e.g. the <quote> element.
	let flatSubtreeRange;

	if ( range.start.parent == range.end.parent ) {
		// The original range is flat, so take it.
		flatSubtreeRange = range;
	} else {
		flatSubtreeRange = __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */].createFromParentsAndOffsets(
			commonParent, range.start.path[ commonPath.length ],
			commonParent, range.end.path[ commonPath.length ] + 1
		);
	}

	const howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset;

	// Clone the whole contents.
	for ( const item of flatSubtreeRange.getItems( { shallow: true } ) ) {
		if ( item.is( 'textProxy' ) ) {
			frag.appendChildren( new __WEBPACK_IMPORTED_MODULE_3__model_text__["a" /* default */]( item.data, item.getAttributes() ) );
		} else {
			frag.appendChildren( item.clone( true ) );
		}
	}

	// ## 2nd step
	//
	// If the original range wasn't flat, then we need to remove the excess nodes from the both ends of the cloned fragment.
	//
	// For example, for the range shown in the 1st step comment, we need to remove these pieces:
	//
	// <quote>[<p>y</p>]<h>[fir]st</h></quote><p>se[cond]</p>
	//
	// So this will be the final copied content:
	//
	// <quote><h>st</h></quote><p>se</p>
	//
	// In order to do that, we remove content from these two ranges:
	//
	// [<quote><p>y</p><h>fir]st</h></quote><p>se[cond</p>]
	if ( flatSubtreeRange != range ) {
		// Find the position of the original range in the cloned fragment.
		const newRange = range._getTransformedByMove( flatSubtreeRange.start, __WEBPACK_IMPORTED_MODULE_2__model_position__["a" /* default */].createAt( frag, 0 ), howMany )[ 0 ];

		const leftExcessRange = new __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */]( __WEBPACK_IMPORTED_MODULE_2__model_position__["a" /* default */].createAt( frag ), newRange.start );
		const rightExcessRange = new __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */]( newRange.end, __WEBPACK_IMPORTED_MODULE_2__model_position__["a" /* default */].createAt( frag, 'end' ) );

		removeRangeContent( rightExcessRange );
		removeRangeContent( leftExcessRange );
	}

	return frag;
}

// After https://github.com/ckeditor/ckeditor5-engine/issues/690 is fixed,
// this function will, most likely, be able to rewritten using getMinimalFlatRanges().
function removeRangeContent( range ) {
	const parentsToCheck = [];

	Array.from( range.getItems( { direction: 'backward' } ) )
		// We should better store ranges because text proxies will lose integrity
		// with the text nodes when we'll start removing content.
		.map( item => __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */].createOn( item ) )
		// Filter only these items which are fully contained in the passed range.
		//
		// E.g. for the following range: [<quote><p>y</p><h>fir]st</h>
		// the walker will return the entire <h> element, when only the "fir" item inside it is fully contained.
		.filter( itemRange => {
			// We should be able to use Range.containsRange, but https://github.com/ckeditor/ckeditor5-engine/issues/691.
			const contained =
				( itemRange.start.isAfter( range.start ) || itemRange.start.isEqual( range.start ) ) &&
				( itemRange.end.isBefore( range.end ) || itemRange.end.isEqual( range.end ) );

			return contained;
		} )
		.forEach( itemRange => {
			parentsToCheck.push( itemRange.start.parent );

			Object(__WEBPACK_IMPORTED_MODULE_4__model_writer__["d" /* remove */])( itemRange );
		} );

	// Remove ancestors of the removed items if they turned to be empty now
	// (their whole content was contained in the range).
	parentsToCheck.forEach( parentToCheck => {
		let parent = parentToCheck;

		while ( parent.parent && parent.isEmpty ) {
			const removeRange = __WEBPACK_IMPORTED_MODULE_1__model_range__["a" /* default */].createOn( parent );

			parent = parent.parent;

			Object(__WEBPACK_IMPORTED_MODULE_4__model_writer__["d" /* remove */])( removeRange );
		}
	} );
}


/***/ }),
/* 367 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta_basic_deltas__ = __webpack_require__(368);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__delta_basic_transformations__ = __webpack_require__(378);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__rootelement__ = __webpack_require__(412);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__history__ = __webpack_require__(413);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__documentselection__ = __webpack_require__(256);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__schema__ = __webpack_require__(415);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__treewalker__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__markercollection__ = __webpack_require__(416);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__delta_transform__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ckeditor_ckeditor5_utils_src_lib_lodash_clone__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__ckeditor_ckeditor5_utils_src_unicode__ = __webpack_require__(185);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/document
 */

// Load all basic deltas and transformations, they register themselves.



















const graveyardName = '$graveyard';

/**
 * Document tree model describes all editable data in the editor. It may contain multiple
 * {@link module:engine/model/document~Document#roots root elements}, for example if the editor have multiple editable areas,
 * each area will be represented by the separate root.
 *
 * All changes in the document are done by {@link module:engine/model/operation/operation~Operation operations}. To create operations in
 * a simple way, use the {@link module:engine/model/batch~Batch} API, for example:
 *
 *		doc.batch().insert( position, nodes ).split( otherPosition );
 *
 * @see module:engine/model/document~Document#batch
 * @mixes module:utils/emittermixin~EmitterMixin
 */
class Document {
	/**
	 * Creates an empty document instance with no {@link #roots} (other than
	 * the {@link #graveyard graveyard root}).
	 */
	constructor() {
		/**
		 * Document version. It starts from `0` and every operation increases the version number. It is used to ensure that
		 * operations are applied on the proper document version.
		 * If the {@link module:engine/model/operation/operation~Operation#baseVersion} will not match document version the
		 * {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.
		 *
		 * @readonly
		 * @member {Number}
		 */
		this.version = 0;

		/**
		 * Schema for this document.
		 *
		 * @member {module:engine/model/schema~Schema}
		 */
		this.schema = new __WEBPACK_IMPORTED_MODULE_8__schema__["a" /* default */]();

		/**
		 * Document's history.
		 *
		 * **Note:** Be aware that deltas applied to the document might get removed or changed.
		 *
		 * @readonly
		 * @member {module:engine/model/history~History}
		 */
		this.history = new __WEBPACK_IMPORTED_MODULE_6__history__["a" /* default */]( this );

		/**
		 * Document's markers' collection.
		 *
		 * @readonly
		 * @member {module:engine/model/markercollection~MarkerCollection}
		 */
		this.markers = new __WEBPACK_IMPORTED_MODULE_10__markercollection__["a" /* default */]();

		/**
		 * Selection done on this document.
		 *
		 * @readonly
		 * @member {module:engine/model/documentselection~DocumentSelection}
		 */
		this.selection = new __WEBPACK_IMPORTED_MODULE_7__documentselection__["a" /* default */]( this );

		/**
		 * Array of pending changes. See: {@link #enqueueChanges}.
		 *
		 * @private
		 * @member {Array.<Function>}
		 */
		this._pendingChanges = [];

		/**
		 * List of roots that are owned and managed by this document. Use {@link #createRoot} and
		 * {@link #getRoot} to manipulate it.
		 *
		 * @readonly
		 * @member {Map}
		 */
		this.roots = new Map();

		// Add events that will ensure selection correctness.
		this.selection.on( 'change:range', () => {
			for ( const range of this.selection.getRanges() ) {
				if ( !this._validateSelectionRange( range ) ) {
					/**
					 * Range from {@link module:engine/model/documentselection~DocumentSelection document selection}
					 * starts or ends at incorrect position.
					 *
					 * @error document-selection-wrong-position
					 * @param {module:engine/model/range~Range} range
					 */
					throw new __WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'document-selection-wrong-position: ' +
						'Range from document selection starts or ends at incorrect position.', { range } );
				}
			}
		} );

		// Graveyard tree root. Document always have a graveyard root, which stores removed nodes.
		this.createRoot( '$root', graveyardName );
	}

	/**
	 * Graveyard tree root. Document always have a graveyard root, which stores removed nodes.
	 *
	 * @readonly
	 * @member {module:engine/model/rootelement~RootElement}
	 */
	get graveyard() {
		return this.getRoot( graveyardName );
	}

	/**
	 * This is the entry point for all document changes. All changes on the document are done using
	 * {@link module:engine/model/operation/operation~Operation operations}. To create operations in the simple way use the
	 * {@link module:engine/model/batch~Batch} API available via {@link #batch} method.
	 *
	 * @fires event:change
	 * @param {module:engine/model/operation/operation~Operation} operation Operation to be applied.
	 */
	applyOperation( operation ) {
		if ( operation.baseVersion !== this.version ) {
			/**
			 * Only operations with matching versions can be applied.
			 *
			 * @error document-applyOperation-wrong-version
			 * @param {module:engine/model/operation/operation~Operation} operation
			 */
			throw new __WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.',
				{ operation } );
		}

		const changes = operation._execute();

		this.version++;

		this.history.addDelta( operation.delta );

		this.fire( 'change', operation.type, changes, operation.delta.batch, operation.delta.type );
	}

	/**
	 * Creates a {@link module:engine/model/batch~Batch} instance which allows to change the document.
	 *
	 * @param {String} [type] Batch type. See {@link module:engine/model/batch~Batch#type}.
	 * @returns {module:engine/model/batch~Batch} Batch instance.
	 */
	batch( type ) {
		return new __WEBPACK_IMPORTED_MODULE_5__batch__["a" /* default */]( this, type );
	}

	/**
	 * Creates a new top-level root.
	 *
	 * @param {String} [elementName='$root'] Element name. Defaults to `'$root'` which also have
	 * some basic schema defined (`$block`s are allowed inside the `$root`). Make sure to define a proper
	 * schema if you use a different name.
	 * @param {String} [rootName='main'] Unique root name.
	 * @returns {module:engine/model/rootelement~RootElement} Created root.
	 */
	createRoot( elementName = '$root', rootName = 'main' ) {
		if ( this.roots.has( rootName ) ) {
			/**
			 * Root with specified name already exists.
			 *
			 * @error model-document-createRoot-name-exists
			 * @param {module:engine/model/document~Document} doc
			 * @param {String} name
			 */
			throw new __WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'model-document-createRoot-name-exists: Root with specified name already exists.',
				{ name: rootName }
			);
		}

		const root = new __WEBPACK_IMPORTED_MODULE_4__rootelement__["a" /* default */]( this, elementName, rootName );
		this.roots.set( rootName, root );

		return root;
	}

	/**
	 * Removes all events listeners set by document instance.
	 */
	destroy() {
		this.selection.destroy();
		this.stopListening();
	}

	/**
	 * Enqueues document changes. Any changes to be done on document (mostly using {@link #batch}
	 * should be placed in the queued callback. If no other plugin is changing document at the moment, the callback will be
	 * called immediately. Otherwise it will wait for all previously queued changes to finish happening. This way
	 * queued callback will not interrupt other callbacks.
	 *
	 * When all queued changes are done {@link #event:changesDone} event is fired.
	 *
	 * @fires changesDone
	 * @param {Function} callback Callback to enqueue.
	 */
	enqueueChanges( callback ) {
		this._pendingChanges.push( callback );

		if ( this._pendingChanges.length == 1 ) {
			while ( this._pendingChanges.length ) {
				this._pendingChanges[ 0 ]();
				this._pendingChanges.shift();
			}

			this.fire( 'changesDone' );
		}
	}

	/**
	 * Returns top-level root by its name.
	 *
	 * @param {String} [name='main'] Unique root name.
	 * @returns {module:engine/model/rootelement~RootElement} Root registered under given name.
	 */
	getRoot( name = 'main' ) {
		if ( !this.roots.has( name ) ) {
			/**
			 * Root with specified name does not exist.
			 *
			 * @error model-document-getRoot-root-not-exist
			 * @param {String} name
			 */
			throw new __WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */](
				'model-document-getRoot-root-not-exist: Root with specified name does not exist.',
				{ name }
			);
		}

		return this.roots.get( name );
	}

	/**
	 * Checks if root with given name is defined.
	 *
	 * @param {String} name Name of root to check.
	 * @returns {Boolean}
	 */
	hasRoot( name ) {
		return this.roots.has( name );
	}

	/**
	 * Returns array with names of all roots (without the {@link #graveyard}) added to the document.
	 *
	 * @returns {Array.<String>} Roots names.
	 */
	getRootNames() {
		return Array.from( this.roots.keys() ).filter( name => name != graveyardName );
	}

	/**
	 * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range Range} instance that is
	 * nearest to that `position` and is a correct range for selection.
	 *
	 * Correct selection range might be collapsed - when it's located in position where text node can be placed.
	 * Non-collapsed range is returned when selection can be placed around element marked as "object" in
	 * {@link module:engine/model/schema~Schema schema}.
	 *
	 * Direction of searching for nearest correct selection range can be specified as:
	 * * `both` - searching will be performed in both ways,
	 * * `forward` - searching will be performed only forward,
	 * * `backward` - searching will be performed only backward.
	 *
	 * When valid selection range cannot be found, `null` is returned.
	 *
	 * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.
	 * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.
	 * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.
	 */
	getNearestSelectionRange( position, direction = 'both' ) {
		// Return collapsed range if provided position is valid.
		if ( this.schema.check( { name: '$text', inside: position } ) ) {
			return new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( position );
		}

		let backwardWalker, forwardWalker;

		if ( direction == 'both' || direction == 'backward' ) {
			backwardWalker = new __WEBPACK_IMPORTED_MODULE_9__treewalker__["a" /* default */]( { startPosition: position, direction: 'backward' } );
		}

		if ( direction == 'both' || direction == 'forward' ) {
			forwardWalker = new __WEBPACK_IMPORTED_MODULE_9__treewalker__["a" /* default */]( { startPosition: position } );
		}

		for ( const data of combineWalkers( backwardWalker, forwardWalker ) ) {
			const type = ( data.walker == backwardWalker ? 'elementEnd' : 'elementStart' );
			const value = data.value;

			if ( value.type == type && this.schema.objects.has( value.item.name ) ) {
				return __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */].createOn( value.item );
			}

			if ( this.schema.check( { name: '$text', inside: value.nextPosition } ) ) {
				return new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( value.nextPosition );
			}
		}

		return null;
	}

	/**
	 * Transforms two sets of deltas by themselves. Returns both transformed sets.
	 *
	 * @param {Array.<module:engine/model/delta/delta~Delta>} deltasA Array with the first set of deltas to transform. These
	 * deltas are considered more important (than `deltasB`) when resolving conflicts.
	 * @param {Array.<module:engine/model/delta/delta~Delta>} deltasB Array with the second set of deltas to transform. These
	 * deltas are considered less important (than `deltasA`) when resolving conflicts.
	 * @param {Boolean} [useContext=false] When set to `true`, transformation will store and use additional context
	 * information to guarantee more expected results. Should be used whenever deltas related to already applied
	 * deltas are transformed (for example when undoing changes).
	 * @returns {Object}
	 * @returns {Array.<module:engine/model/delta/delta~Delta>} return.deltasA The first set of deltas transformed
	 * by the second set of deltas.
	 * @returns {Array.<module:engine/model/delta/delta~Delta>} return.deltasB The second set of deltas transformed
	 * by the first set of deltas.
	 */
	transformDeltas( deltasA, deltasB, useContext = false ) {
		return __WEBPACK_IMPORTED_MODULE_11__delta_transform__["a" /* default */].transformDeltaSets( deltasA, deltasB, useContext ? this : null );
	}

	/**
	 * Custom toJSON method to solve child-parent circular dependencies.
	 *
	 * @returns {Object} Clone of this object with the document property changed to string.
	 */
	toJSON() {
		const json = Object(__WEBPACK_IMPORTED_MODULE_12__ckeditor_ckeditor5_utils_src_lib_lodash_clone__["a" /* default */])( this );

		// Due to circular references we need to remove parent reference.
		json.selection = '[engine.model.DocumentSelection]';

		return json;
	}

	/**
	 * Returns default root for this document which is either the first root that was added to the the document using
	 * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.
	 *
	 * @protected
	 * @returns {module:engine/model/rootelement~RootElement} The default root for this document.
	 */
	_getDefaultRoot() {
		for ( const root of this.roots.values() ) {
			if ( root !== this.graveyard ) {
				return root;
			}
		}

		return this.graveyard;
	}

	/**
	 * Returns a default range for this selection. The default range is a collapsed range that starts and ends
	 * at the beginning of this selection's document's {@link #_getDefaultRoot default root}.
	 *
	 * @protected
	 * @returns {module:engine/model/range~Range}
	 */
	_getDefaultRange() {
		const defaultRoot = this._getDefaultRoot();

		// Find the first position where the selection can be put.
		const position = new __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */]( defaultRoot, [ 0 ] );
		const nearestRange = this.getNearestSelectionRange( position );

		// If valid selection range is not found - return range collapsed at the beginning of the root.
		return nearestRange || new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( position );
	}

	/**
	 * Checks whether given {@link module:engine/model/range~Range range} is a valid range for
	 * {@link #selection document's selection}.
	 *
	 * @private
	 * @param {module:engine/model/range~Range} range Range to check.
	 * @returns {Boolean} `true` if `range` is valid, `false` otherwise.
	 */
	_validateSelectionRange( range ) {
		return validateTextNodePosition( range.start ) && validateTextNodePosition( range.end );
	}

	/**
	 * Fired when document changes by applying an operation.
	 *
	 * There are 5 types of change:
	 *
	 * * 'insert' when nodes are inserted,
	 * * 'remove' when nodes are removed,
	 * * 'reinsert' when remove is undone,
	 * * 'move' when nodes are moved,
	 * * 'rename' when element is renamed,
	 * * 'marker' when a marker changes (added, removed or its range is changed),
	 * * 'addAttribute' when attributes are added,
	 * * 'removeAttribute' when attributes are removed,
	 * * 'changeAttribute' when attributes change,
	 * * 'addRootAttribute' when attribute for root is added,
	 * * 'removeRootAttribute' when attribute for root is removed,
	 * * 'changeRootAttribute' when attribute for root changes.
	 *
	 * @event change
	 * @param {String} type Change type, possible option: 'insert', 'remove', 'reinsert', 'move', 'attribute'.
	 * @param {Object} data Additional information about the change.
	 * @param {module:engine/model/range~Range} [data.range] Range in model containing changed nodes. Note that the range state is
	 * after changes has been done, i.e. for 'remove' the range will be in the {@link #graveyard graveyard root}.
	 * The range is not defined for root, rename and marker types.
	 * @param {module:engine/model/position~Position} [data.sourcePosition] Change source position.
	 * Exists for 'remove', 'reinsert' and 'move'.
	 * Note that this position state is before changes has been done, i.e. for 'reinsert' the source position will be in the
	 * {@link #graveyard graveyard root}.
	 * @param {String} [data.key] Only for attribute types. Key of changed / inserted / removed attribute.
	 * @param {*} [data.oldValue] Only for 'removeAttribute', 'removeRootAttribute', 'changeAttribute' or
	 * 'changeRootAttribute' type.
	 * @param {*} [data.newValue] Only for 'addAttribute', 'addRootAttribute', 'changeAttribute' or
	 * 'changeRootAttribute' type.
	 * @param {module:engine/model/rootelement~RootElement} [data.root] Root element which attributes got changed. This is defined
	 * only for root types.
	 * @param {module:engine/model/batch~Batch} batch A {@link module:engine/model/batch~Batch batch}
	 * of changes which this change is a part of.
	 */

	/**
	 * Fired when all queued document changes are done. See {@link #enqueueChanges}.
	 *
	 * @event changesDone
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Document;


Object(__WEBPACK_IMPORTED_MODULE_15__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Document, __WEBPACK_IMPORTED_MODULE_13__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

// Checks whether given range boundary position is valid for document selection, meaning that is not between
// unicode surrogate pairs or base character and combining marks.
function validateTextNodePosition( rangeBoundary ) {
	const textNode = rangeBoundary.textNode;

	if ( textNode ) {
		const data = textNode.data;
		const offset = rangeBoundary.offset - textNode.startOffset;

		return !Object(__WEBPACK_IMPORTED_MODULE_16__ckeditor_ckeditor5_utils_src_unicode__["b" /* isInsideSurrogatePair */])( data, offset ) && !Object(__WEBPACK_IMPORTED_MODULE_16__ckeditor_ckeditor5_utils_src_unicode__["a" /* isInsideCombinedSymbol */])( data, offset );
	}

	return true;
}

// Generator function returning values from provided walkers, switching between them at each iteration. If only one walker
// is provided it will return data only from that walker.
//
// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.
// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.
// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned
// given value) fields.
function* combineWalkers( backward, forward ) {
	let done = false;

	while ( !done ) {
		done = true;

		if ( backward ) {
			const step = backward.next();

			if ( !step.done ) {
				done = false;
				yield{
					walker: backward,
					value: step.value
				};
			}
		}

		if ( forward ) {
			const step = forward.next();

			if ( !step.done ) {
				done = false;
				yield{
					walker: forward,
					value: step.value
				};
			}
		}
	}
}


/***/ }),
/* 368 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__attributedelta__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__insertdelta__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mergedelta__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__movedelta__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__removedelta__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__renamedelta__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__splitdelta__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__unwrapdelta__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__weakinsertdelta__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__wrapdelta__ = __webpack_require__(102);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/basic-deltas
 */

// Deltas require `register` method that require `Batch` class and is defined in batch-base.js.
// We would like to group all deltas files in one place, so we would only have to include batch.js
// which would already have all default deltas registered.

// Import default suite of deltas so a feature have to include only Batch class file.












/***/ }),
/* 369 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__operation_attributeoperation__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__operation_insertoperation__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__operation_markeroperation__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_moveoperation__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__operation_nooperation__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__operation_operation__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__operation_reinsertoperation__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__operation_removeoperation__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__operation_renameoperation__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__operation_rootattributeoperation__ = __webpack_require__(133);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/operationfactory
 */












const operations = {};
operations[ __WEBPACK_IMPORTED_MODULE_0__operation_attributeoperation__["a" /* default */].className ] = __WEBPACK_IMPORTED_MODULE_0__operation_attributeoperation__["a" /* default */];
operations[ __WEBPACK_IMPORTED_MODULE_1__operation_insertoperation__["a" /* default */].className ] = __WEBPACK_IMPORTED_MODULE_1__operation_insertoperation__["a" /* default */];
operations[ __WEBPACK_IMPORTED_MODULE_2__operation_markeroperation__["a" /* default */].className ] = __WEBPACK_IMPORTED_MODULE_2__operation_markeroperation__["a" /* default */];
operations[ __WEBPACK_IMPORTED_MODULE_3__operation_moveoperation__["a" /* default */].className ] = __WEBPACK_IMPORTED_MODULE_3__operation_moveoperation__["a" /* default */];
operations[ __WEBPACK_IMPORTED_MODULE_4__operation_nooperation__["a" /* default */].className ] = __WEBPACK_IMPORTED_MODULE_4__operation_nooperation__["a" /* default */];
operations[ __WEBPACK_IMPORTED_MODULE_5__operation_operation__["a" /* default */].className ] = __WEBPACK_IMPORTED_MODULE_5__operation_operation__["a" /* default */];
operations[ __WEBPACK_IMPORTED_MODULE_6__operation_reinsertoperation__["a" /* default */].className ] = __WEBPACK_IMPORTED_MODULE_6__operation_reinsertoperation__["a" /* default */];
operations[ __WEBPACK_IMPORTED_MODULE_7__operation_removeoperation__["a" /* default */].className ] = __WEBPACK_IMPORTED_MODULE_7__operation_removeoperation__["a" /* default */];
operations[ __WEBPACK_IMPORTED_MODULE_8__operation_renameoperation__["a" /* default */].className ] = __WEBPACK_IMPORTED_MODULE_8__operation_renameoperation__["a" /* default */];
operations[ __WEBPACK_IMPORTED_MODULE_9__operation_rootattributeoperation__["a" /* default */].className ] = __WEBPACK_IMPORTED_MODULE_9__operation_rootattributeoperation__["a" /* default */];

/**
 * A factory class for creating operations.
 *
 * @abstract
 */
class OperationFactory {
	/**
	 * Creates concrete `Operation` object from deserilized object, i.e. from parsed JSON string.
	 *
	 * @param {Object} json Deserialized JSON object.
	 * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
	 * @returns {module:engine/model/operation/operation~Operation}
	 */
	static fromJSON( json, document ) {
		return operations[ json.__className ].fromJSON( json, document );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = OperationFactory;



/***/ }),
/* 370 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsEqual__ = __webpack_require__(94);


/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent,
 *  else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseIsEqual__["a" /* default */])(value, other);
}

/* harmony default export */ __webpack_exports__["a"] = (isEqual);


/***/ }),
/* 371 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Stack__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__equalArrays__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__equalByTag__ = __webpack_require__(375);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__equalObjects__ = __webpack_require__(376);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__getTag__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__isArray__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__isHostObject__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__isTypedArray__ = __webpack_require__(377);









/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = Object(__WEBPACK_IMPORTED_MODULE_5__isArray__["a" /* default */])(object),
      othIsArr = Object(__WEBPACK_IMPORTED_MODULE_5__isArray__["a" /* default */])(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = Object(__WEBPACK_IMPORTED_MODULE_4__getTag__["a" /* default */])(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = Object(__WEBPACK_IMPORTED_MODULE_4__getTag__["a" /* default */])(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !Object(__WEBPACK_IMPORTED_MODULE_6__isHostObject__["a" /* default */])(object),
      othIsObj = othTag == objectTag && !Object(__WEBPACK_IMPORTED_MODULE_6__isHostObject__["a" /* default */])(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new __WEBPACK_IMPORTED_MODULE_0__Stack__["a" /* default */]);
    return (objIsArr || Object(__WEBPACK_IMPORTED_MODULE_7__isTypedArray__["a" /* default */])(object))
      ? Object(__WEBPACK_IMPORTED_MODULE_1__equalArrays__["a" /* default */])(object, other, equalFunc, customizer, bitmask, stack)
      : Object(__WEBPACK_IMPORTED_MODULE_2__equalByTag__["a" /* default */])(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new __WEBPACK_IMPORTED_MODULE_0__Stack__["a" /* default */]);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new __WEBPACK_IMPORTED_MODULE_0__Stack__["a" /* default */]);
  return Object(__WEBPACK_IMPORTED_MODULE_3__equalObjects__["a" /* default */])(object, other, equalFunc, customizer, bitmask, stack);
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsEqualDeep);


/***/ }),
/* 372 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/* harmony default export */ __webpack_exports__["a"] = (setCacheAdd);


/***/ }),
/* 373 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/* harmony default export */ __webpack_exports__["a"] = (setCacheHas);


/***/ }),
/* 374 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (arraySome);


/***/ }),
/* 375 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Uint8Array__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__equalArrays__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mapToArray__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__setToArray__ = __webpack_require__(88);






/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = __WEBPACK_IMPORTED_MODULE_0__Symbol__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol__["a" /* default */].prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new __WEBPACK_IMPORTED_MODULE_1__Uint8Array__["a" /* default */](object), new __WEBPACK_IMPORTED_MODULE_1__Uint8Array__["a" /* default */](other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and
      // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
      // not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object) ? other != +other : object == +other;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = __WEBPACK_IMPORTED_MODULE_3__mapToArray__["a" /* default */];

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = __WEBPACK_IMPORTED_MODULE_4__setToArray__["a" /* default */]);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;
      stack.set(object, other);

      // Recursively compare objects (susceptible to call stack limits).
      return Object(__WEBPACK_IMPORTED_MODULE_2__equalArrays__["a" /* default */])(convert(object), convert(other), equalFunc, customizer, bitmask, stack);

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (equalByTag);


/***/ }),
/* 376 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseHas__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keys__ = __webpack_require__(69);



/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = Object(__WEBPACK_IMPORTED_MODULE_1__keys__["a" /* default */])(object),
      objLength = objProps.length,
      othProps = Object(__WEBPACK_IMPORTED_MODULE_1__keys__["a" /* default */])(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : Object(__WEBPACK_IMPORTED_MODULE_0__baseHas__["a" /* default */])(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (equalObjects);


/***/ }),
/* 377 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isLength__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike__ = __webpack_require__(43);



/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike__["a" /* default */])(value) &&
    Object(__WEBPACK_IMPORTED_MODULE_0__isLength__["a" /* default */])(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/* harmony default export */ __webpack_exports__["a"] = (isTypedArray);


/***/ }),
/* 378 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transform__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_nooperation__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__operation_attributeoperation__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__operation_insertoperation__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__operation_reinsertoperation__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__attributedelta__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__insertdelta__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__markerdelta__ = __webpack_require__(411);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__mergedelta__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__movedelta__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__splitdelta__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__weakinsertdelta__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__wrapdelta__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__unwrapdelta__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__renamedelta__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__removedelta__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__ckeditor_ckeditor5_utils_src_comparearrays__ = __webpack_require__(54);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/basic-transformations
 */


const addTransformationCase = __WEBPACK_IMPORTED_MODULE_0__transform__["a" /* default */].addTransformationCase;
const defaultTransform = __WEBPACK_IMPORTED_MODULE_0__transform__["a" /* default */].defaultTransform;
























// Provide transformations for default deltas.

// Add special case for AttributeDelta x WeakInsertDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_8__attributedelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_14__weakinsertdelta__["a" /* default */], ( a, b, context ) => {
	// If nodes are weak-inserted into attribute delta range, we need to apply changes from attribute delta on them.
	// So first we do the normal transformation and if this special cases happens, we will add an extra delta.
	const deltas = defaultTransform( a, b, context );

	if ( a.range.containsPosition( b.position ) ) {
		deltas.push( _getComplementaryAttrDelta( b, a ) );
	}

	return deltas;
} );

// Add special case for AttributeDelta x SplitDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_8__attributedelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], ( a, b, context ) => {
	// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.
	if ( !b.position ) {
		return defaultTransform( a, b, context );
	}

	const undoMode = context.undoMode;
	const splitPosition = new __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */]( b.position.root, b.position.path.slice( 0, -1 ) );

	const deltas = defaultTransform( a, b, context );

	// Special case applies only if undo is not a context and only if `SplitDelta` has `InsertOperation` (not `ReinsertOperation`).
	if ( undoMode || !( b._cloneOperation instanceof __WEBPACK_IMPORTED_MODULE_5__operation_insertoperation__["a" /* default */] ) ) {
		return deltas;
	}

	for ( const operation of a.operations ) {
		// If a node that has been split has it's attribute updated, we should also update attribute of
		// the node created during splitting.
		if ( operation.range.containsPosition( splitPosition ) || operation.range.start.isEqual( splitPosition ) ) {
			const additionalAttributeDelta = new __WEBPACK_IMPORTED_MODULE_8__attributedelta__["a" /* default */]();

			const rangeStart = splitPosition.getShiftedBy( 1 );
			const rangeEnd = __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createFromPosition( rangeStart );
			rangeEnd.path.push( 0 );

			const oldValue = b._cloneOperation.nodes.getNode( 0 ).getAttribute( operation.key );

			additionalAttributeDelta.addOperation( new __WEBPACK_IMPORTED_MODULE_4__operation_attributeoperation__["a" /* default */](
				new __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */]( rangeStart, rangeEnd ),
				operation.key,
				oldValue === undefined ? null : oldValue,
				operation.newValue,
				0
			) );

			deltas.push( additionalAttributeDelta );

			break;
		}
	}

	return deltas;
} );

// Add special case for InsertDelta x MergeDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_9__insertdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_11__mergedelta__["a" /* default */], ( a, b, context ) => {
	// Do not apply special transformation case if `MergeDelta` has `NoOperation` as the second operation.
	if ( !b.position ) {
		return defaultTransform( a, b, context );
	}

	const undoMode = context.undoMode;

	// If insert is applied at the same position where merge happened, we reverse the merge (we treat it like it
	// didn't happen) and then apply the original insert operation. This is "mirrored" in MergeDelta x InsertDelta
	// transformation below, where we simply do not apply MergeDelta.
	if ( !undoMode && a.position.isEqual( b.position ) ) {
		return [
			b.getReversed(),
			a.clone()
		];
	}

	return defaultTransform( a, b, context );
} );

function transformMarkerDelta( a, b ) {
	const transformedDelta = a.clone();
	const transformedOp = transformedDelta.operations[ 0 ];

	if ( transformedOp.oldRange ) {
		transformedOp.oldRange = transformedOp.oldRange.getTransformedByDelta( b )[ 0 ];
	}

	if ( transformedOp.newRange ) {
		transformedOp.newRange = transformedOp.newRange.getTransformedByDelta( b )[ 0 ];
	}

	return [ transformedDelta ];
}

addTransformationCase( __WEBPACK_IMPORTED_MODULE_10__markerdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], transformMarkerDelta );
addTransformationCase( __WEBPACK_IMPORTED_MODULE_10__markerdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_11__mergedelta__["a" /* default */], transformMarkerDelta );
addTransformationCase( __WEBPACK_IMPORTED_MODULE_10__markerdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_15__wrapdelta__["a" /* default */], transformMarkerDelta );
addTransformationCase( __WEBPACK_IMPORTED_MODULE_10__markerdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_16__unwrapdelta__["a" /* default */], transformMarkerDelta );
addTransformationCase( __WEBPACK_IMPORTED_MODULE_10__markerdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_12__movedelta__["a" /* default */], transformMarkerDelta );
addTransformationCase( __WEBPACK_IMPORTED_MODULE_10__markerdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_17__renamedelta__["a" /* default */], transformMarkerDelta );

// Add special case for MoveDelta x MergeDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_12__movedelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_11__mergedelta__["a" /* default */], ( a, b, context ) => {
	const undoMode = context.undoMode;

	// Do not apply special transformation case in undo mode or if `MergeDelta` has `NoOperation` as the second operation.
	if ( undoMode || !b.position ) {
		return defaultTransform( a, b, context );
	}

	// If move delta is supposed to move a node that has been merged, we reverse the merge (we treat it like it
	// didn't happen) and then apply the original move operation. This is "mirrored" in MergeDelta x MoveDelta
	// transformation below, where we simply do not apply MergeDelta.
	const operateInSameParent =
		a.sourcePosition.root == b.position.root &&
		Object(__WEBPACK_IMPORTED_MODULE_19__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( a.sourcePosition.getParentPath(), b.position.getParentPath() ) === 'same';

	const mergeInsideMoveRange = a.sourcePosition.offset <= b.position.offset && a.sourcePosition.offset + a.howMany > b.position.offset;

	if ( operateInSameParent && mergeInsideMoveRange ) {
		return [
			b.getReversed(),
			a.clone()
		];
	}

	return defaultTransform( a, b, context );
} );

// Add special case for MergeDelta x InsertDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_11__mergedelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_9__insertdelta__["a" /* default */], ( a, b, context ) => {
	// Do not apply special transformation case if `MergeDelta` has `NoOperation` as the second operation.
	if ( !a.position ) {
		return defaultTransform( a, b, context );
	}

	const undoMode = context.undoMode;

	// If merge is applied at the same position where we inserted a range of nodes we cancel the merge as it's results
	// may be unexpected and very weird. Even if we do some "magic" we don't know what really are users' expectations.
	if ( !undoMode && a.position.isEqual( b.position ) ) {
		return [ noDelta() ];
	}

	return defaultTransform( a, b, context );
} );

// Add special case for MergeDelta x MoveDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_11__mergedelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_12__movedelta__["a" /* default */], ( a, b, context ) => {
	const undoMode = context.undoMode;

	// Do not apply special transformation case in undo mode or if `MergeDelta` has `NoOperation` as the second operation.
	if ( undoMode || !a.position ) {
		return defaultTransform( a, b, context );
	}

	// If merge is applied at the position between moved nodes we cancel the merge as it's results may be unexpected and
	// very weird. Even if we do some "magic" we don't know what really are users' expectations.
	const operateInSameParent =
		a.position.root == b.sourcePosition.root &&
		Object(__WEBPACK_IMPORTED_MODULE_19__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( a.position.getParentPath(), b.sourcePosition.getParentPath() ) === 'same';

	const mergeInsideMoveRange = b.sourcePosition.offset <= a.position.offset && b.sourcePosition.offset + b.howMany > a.position.offset;

	if ( operateInSameParent && mergeInsideMoveRange ) {
		return [ noDelta() ];
	}

	return defaultTransform( a, b, context );
} );

addTransformationCase( __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], ( a, b, context ) => {
	const undoMode = context.undoMode;

	// Do not apply special transformation case if transformation is in undo mode.
	if ( undoMode ) {
		return defaultTransform( a, b, context );
	}

	// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.
	if ( !a.position || !b.position ) {
		return defaultTransform( a, b, context );
	}

	const pathA = a.position.getParentPath();
	const pathB = b.position.getParentPath();

	// The special case is for splits inside the same parent.
	if ( a.position.root == b.position.root && Object(__WEBPACK_IMPORTED_MODULE_19__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( pathA, pathB ) == 'same' ) {
		a = a.clone();

		if ( a.position.offset < b.position.offset || ( a.position.offset == b.position.offset && context.isStrong ) ) {
			// If both first operations are `ReinsertOperation`s, we might need to transform `a._cloneOperation`,
			// so it will take correct node from graveyard.
			if (
				a._cloneOperation instanceof __WEBPACK_IMPORTED_MODULE_6__operation_reinsertoperation__["a" /* default */] && b._cloneOperation instanceof __WEBPACK_IMPORTED_MODULE_6__operation_reinsertoperation__["a" /* default */] &&
				a._cloneOperation.sourcePosition.offset > b._cloneOperation.sourcePosition.offset
			) {
				a._cloneOperation.sourcePosition.offset--;
			}

			// `a` splits closer or at same offset.
			// Change how many nodes are moved. Do not move nodes that were moved by delta `b`.
			const aRange = __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createFromPositionAndShift( a.position, a._moveOperation.howMany );
			const bRange = __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */].createFromPositionAndShift( b.position, b._moveOperation.howMany );

			const diff = aRange.getDifference( bRange );

			let newHowMany = 0;

			for ( const range of diff ) {
				newHowMany += range.end.offset - range.start.offset;
			}

			if ( newHowMany === 0 ) {
				a.operations.pop(); // Remove last operation (`MoveOperation`).
				a.addOperation( new __WEBPACK_IMPORTED_MODULE_3__operation_nooperation__["a" /* default */]( a.operations[ 0 ].baseVersion + 1 ) ); // Add `NoOperation` instead.
			} else {
				a.operations[ 1 ].howMany = newHowMany;
			}

			return [ a ];
		} else {
			// `a` splits further.
			// This is more complicated case, thankfully we can solve it using default transformation and setting proper context.
			const newContext = Object.assign( {}, context );
			newContext.isStrong = true;
			newContext.insertBefore = true;

			return defaultTransform( a, b, newContext );
		}
	}

	return defaultTransform( a, b, context );
} );

// Add special case for SplitDelta x UnwrapDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_16__unwrapdelta__["a" /* default */], ( a, b, context ) => {
	// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.
	if ( !a.position ) {
		return defaultTransform( a, b, context );
	}

	// If incoming split delta tries to split a node that just got unwrapped, there is actually nothing to split,
	// so we discard that delta.
	if ( a.position.root == b.position.root && Object(__WEBPACK_IMPORTED_MODULE_19__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( b.position.path, a.position.getParentPath() ) === 'same' ) {
		return [ noDelta() ];
	}

	return defaultTransform( a, b, context );
} );

// Add special case for SplitDelta x WrapDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_15__wrapdelta__["a" /* default */], ( a, b, context ) => {
	// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.
	if ( !a.position ) {
		return defaultTransform( a, b, context );
	}

	// If split is applied at the position between wrapped nodes, we cancel the split as it's results may be unexpected and
	// very weird. Even if we do some "magic" we don't know what really are users' expectations.

	const sameRoot = a.position.root == b.range.start.root;
	const operateInSameParent = sameRoot && Object(__WEBPACK_IMPORTED_MODULE_19__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( a.position.getParentPath(), b.range.start.getParentPath() ) === 'same';
	const splitInsideWrapRange = b.range.start.offset < a.position.offset && b.range.end.offset >= a.position.offset;

	if ( operateInSameParent && splitInsideWrapRange ) {
		return [ noDelta() ];
	} else if ( sameRoot && Object(__WEBPACK_IMPORTED_MODULE_19__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( a.position.getParentPath(), b.range.end.getShiftedBy( -1 ).path ) === 'same' ) {
		// Split position is directly inside the last node from wrap range.
		// If that's the case, we manually change split delta so it will "target" inside the wrapping element.
		// By doing so we will be inserting split node right to the original node which feels natural and is a good UX.
		const delta = a.clone();

		// 1. Fix insert operation position.
		// Node to split is the last children of the wrapping element.
		// Wrapping element is the element inserted by WrapDelta (re)insert operation.
		// It is inserted after the wrapped range, but the wrapped range will be moved inside it.
		// Having this in mind, it is correct to use wrapped range start position as the position before wrapping element.
		const splitNodePos = __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createFromPosition( b.range.start );
		// Now, `splitNodePos` points before wrapping element.
		// To get a position before last children of that element, we expand position's `path` member by proper offset.
		splitNodePos.path.push( b.howMany - 1 );

		// SplitDelta insert operation position should be right after the node we split.
		const insertPos = splitNodePos.getShiftedBy( 1 );
		delta._cloneOperation.position = insertPos;

		// 2. Fix move operation source position.
		// Nodes moved by SplitDelta will be moved from new position, modified by WrapDelta.
		// To obtain that new position, `splitNodePos` will be used, as this is the node we are extracting children from.
		const sourcePos = __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createFromPosition( splitNodePos );
		// Nothing changed inside split node so it is correct to use the original split position offset.
		sourcePos.path.push( a.position.offset );
		delta._moveOperation.sourcePosition = sourcePos;

		// 3. Fix move operation target position.
		// SplitDelta move operation target position should be inside the node inserted by operation above.
		// Since the node is empty, we will insert at offset 0.
		const targetPos = __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */].createFromPosition( insertPos );
		targetPos.path.push( 0 );
		delta._moveOperation.targetPosition = targetPos;

		return [ delta ];
	}

	return defaultTransform( a, b, context );
} );

// Add special case for SplitDelta x WrapDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_8__attributedelta__["a" /* default */], ( a, b, context ) => {
	// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.
	if ( !a.position ) {
		return defaultTransform( a, b, context );
	}

	a = a.clone();

	const undoMode = context.undoMode;
	const splitPosition = new __WEBPACK_IMPORTED_MODULE_2__position__["a" /* default */]( a.position.root, a.position.path.slice( 0, -1 ) );

	// Special case applies only if undo is not a context and only if `SplitDelta` has `InsertOperation` (not `ReinsertOperation`).
	if ( undoMode || !( a._cloneOperation instanceof __WEBPACK_IMPORTED_MODULE_5__operation_insertoperation__["a" /* default */] ) ) {
		return [ a ];
	}

	// If element to split had it's attribute changed, we have to reflect this change in an element
	// that is in SplitDelta's InsertOperation.
	for ( const operation of b.operations ) {
		if ( operation.range.containsPosition( splitPosition ) || operation.range.start.isEqual( splitPosition ) ) {
			if ( operation.newValue !== null ) {
				a._cloneOperation.nodes.getNode( 0 ).setAttribute( operation.key, operation.newValue );
			} else {
				a._cloneOperation.nodes.getNode( 0 ).removeAttribute( operation.key );
			}

			break;
		}
	}

	return [ a ];
} );

// Add special case for UnwrapDelta x SplitDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_16__unwrapdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], ( a, b, context ) => {
	// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.
	if ( !b.position ) {
		return defaultTransform( a, b, context );
	}

	// If incoming unwrap delta tries to unwrap node that got split we should unwrap the original node and the split copy.
	// This can be achieved either by reverting split and applying unwrap to singular node, or creating additional unwrap delta.
	if ( a.position.root == b.position.root && Object(__WEBPACK_IMPORTED_MODULE_19__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( a.position.path, b.position.getParentPath() ) === 'same' ) {
		return [
			b.getReversed(),
			a.clone()
		];
	}

	return defaultTransform( a, b, context );
} );

// Add special case for WeakInsertDelta x AttributeDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_14__weakinsertdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_8__attributedelta__["a" /* default */], ( a, b ) => {
	// If nodes are weak-inserted into attribute delta range, we need to apply changes from attribute delta on them.
	const deltas = [ a.clone() ];

	if ( b.range.containsPosition( a.position ) ) {
		deltas.push( _getComplementaryAttrDelta( a, b ) );
	}

	return deltas;
} );

// Add special case for WrapDelta x SplitDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_15__wrapdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], ( a, b, context ) => {
	// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.
	if ( !b.position ) {
		return defaultTransform( a, b, context );
	}

	// If incoming wrap delta tries to wrap range that contains split position, we have to cancel the split and apply
	// the wrap. Since split was already applied, we have to revert it.
	const sameRoot = a.range.start.root == b.position.root;
	const operateInSameParent = sameRoot && Object(__WEBPACK_IMPORTED_MODULE_19__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( a.range.start.getParentPath(), b.position.getParentPath() ) === 'same';
	const splitInsideWrapRange = a.range.start.offset < b.position.offset && a.range.end.offset >= b.position.offset;

	if ( operateInSameParent && splitInsideWrapRange ) {
		return [
			b.getReversed(),
			a.clone()
		];
	} else if ( sameRoot && Object(__WEBPACK_IMPORTED_MODULE_19__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( b.position.getParentPath(), a.range.end.getShiftedBy( -1 ).path ) === 'same' ) {
		const delta = a.clone();

		// Move wrapping element insert position one node further so it is after the split node insertion.
		delta._insertOperation.position.offset++;

		// Include the split node copy.
		delta._moveOperation.howMany++;

		// Change the path to wrapping element in move operation.
		delta._moveOperation.targetPosition.path[ delta._moveOperation.targetPosition.path.length - 2 ]++;

		return [ delta ];
	}

	return defaultTransform( a, b, context );
} );

// Add special case for RenameDelta x SplitDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_17__renamedelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], ( a, b, context ) => {
	const undoMode = context.undoMode;
	const deltas = defaultTransform( a, b, context );

	// Special case applies only if undo is not a context and only if `SplitDelta` has `InsertOperation` (not `ReinsertOperation`).
	if ( undoMode || !( b._cloneOperation instanceof __WEBPACK_IMPORTED_MODULE_5__operation_insertoperation__["a" /* default */] ) ) {
		return deltas;
	}

	const insertPosition = b._cloneOperation.position.getShiftedBy( -1 );

	if ( insertPosition && a.operations[ 0 ].position.isEqual( insertPosition ) ) {
		// If a node that has been split has it's name changed, we should also change name of
		// the node created during splitting.
		const additionalRenameDelta = a.clone();
		additionalRenameDelta.operations[ 0 ].position = insertPosition.getShiftedBy( 1 );

		deltas.push( additionalRenameDelta );
	}

	return deltas;
} );

// Add special case for SplitDelta x RenameDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_17__renamedelta__["a" /* default */], ( a, b, context ) => {
	a = a.clone();

	const undoMode = context.undoMode;

	// Special case applies only if undo is not a context and only if `SplitDelta` has `InsertOperation` (not `ReinsertOperation`).
	if ( undoMode || !( a._cloneOperation instanceof __WEBPACK_IMPORTED_MODULE_5__operation_insertoperation__["a" /* default */] ) ) {
		return [ a ];
	}

	const insertPosition = a._cloneOperation.position.getShiftedBy( -1 );

	// If element to split had it's name changed, we have to reflect this by creating additional rename operation.
	if ( insertPosition && !undoMode && b.operations[ 0 ].position.isEqual( insertPosition ) ) {
		const additionalRenameDelta = b.clone();
		additionalRenameDelta.operations[ 0 ].position = insertPosition.getShiftedBy( 1 );
		additionalRenameDelta.operations[ 0 ].oldName = a._cloneOperation.nodes.getNode( 0 ).name;

		return [ a, additionalRenameDelta ];
	}

	return [ a ];
} );

// Add special case for RemoveDelta x SplitDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_18__removedelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], ( a, b, context ) => {
	const deltas = defaultTransform( a, b, context );
	// The "clone operation" may be InsertOperation, ReinsertOperation, MoveOperation or NoOperation.
	const insertPosition = b._cloneOperation.position || b._cloneOperation.targetPosition;

	// NoOperation.
	if ( !insertPosition ) {
		return defaultTransform( a, b, context );
	}

	const undoMode = context.undoMode;

	// Special case applies only if undo is not a context.
	if ( undoMode ) {
		return deltas;
	}

	// In case if `defaultTransform` returned more than one delta.
	for ( const delta of deltas ) {
		// "No delta" may be returned in some cases.
		if ( delta instanceof __WEBPACK_IMPORTED_MODULE_18__removedelta__["a" /* default */] ) {
			const operation = delta._moveOperation;
			const rangeEnd = operation.sourcePosition.getShiftedBy( operation.howMany );

			if ( rangeEnd.isEqual( insertPosition ) ) {
				operation.howMany += 1;
			}
		}
	}

	return deltas;
} );

// Add special case for SplitDelta x RemoveDelta transformation.
addTransformationCase( __WEBPACK_IMPORTED_MODULE_13__splitdelta__["a" /* default */], __WEBPACK_IMPORTED_MODULE_18__removedelta__["a" /* default */], ( a, b, context ) => {
	const undoMode = context.undoMode;

	// Special case applies only if undo is not a context.
	if ( undoMode ) {
		return defaultTransform( a, b, context );
	}

	// This case is very trickily solved.
	// Instead of fixing `a` delta, we change `b` delta for a while and fire default transformation with fixed `b` delta.
	// Thanks to that fixing `a` delta will be differently (correctly) transformed.
	//
	// The "clone operation" may be InsertOperation, ReinsertOperation, MoveOperation or NoOperation.
	const insertPosition = a._cloneOperation.position || a._cloneOperation.targetPosition;

	// NoOperation.
	if ( !insertPosition ) {
		return defaultTransform( a, b, context );
	}

	b = b.clone();
	const operation = b._moveOperation;
	const rangeEnd = operation.sourcePosition.getShiftedBy( operation.howMany );

	if ( rangeEnd.isEqual( insertPosition ) ) {
		operation.howMany += 1;
	}

	return defaultTransform( a, b, context );
} );

// Helper function for `AttributeDelta` class transformations.
// Creates an attribute delta that sets attribute from given `attributeDelta` on nodes from given `weakInsertDelta`.
function _getComplementaryAttrDelta( weakInsertDelta, attributeDelta ) {
	const complementaryAttrDelta = new __WEBPACK_IMPORTED_MODULE_8__attributedelta__["a" /* default */]();
	const nodes = weakInsertDelta.nodes;

	// At the beginning we store the attribute value from the first node on `weakInsertDelta` node list.
	let val = nodes.getNode( 0 ).getAttribute( attributeDelta.key );

	// This stores the last index of `weakInsertDelta` node list where the attribute value was different
	// than in the previous node. We need it to create separate `AttributeOperation`s for nodes with different attributes.
	let lastOffset = 0;
	// Sum of offsets of already processed nodes.
	let offsetSum = nodes.getNode( 0 ).offsetSize;

	for ( let i = 1; i < nodes.length; i++ ) {
		const node = nodes.getNode( i );
		const nodeAttrVal = node.getAttribute( attributeDelta.key );

		// If previous node has different attribute value, we will create an operation to the point before current node.
		// So all nodes with the same attributes up to this point will be included in one `AttributeOperation`.
		if ( nodeAttrVal != val ) {
			// New operation is created only when it is needed. If given node already has proper value for this
			// attribute we simply skip it without adding a new operation.
			if ( val != attributeDelta.value ) {
				addOperation();
			}

			val = nodeAttrVal;
			lastOffset = offsetSum;
		}

		offsetSum = offsetSum + node.offsetSize;
	}

	// At the end we have to add additional `AttributeOperation` for the last part of node list. If all nodes on the
	// node list had same attributes, this will be the only operation added to the delta.
	addOperation();

	return complementaryAttrDelta;

	function addOperation() {
		const range = new __WEBPACK_IMPORTED_MODULE_1__range__["a" /* default */](
			weakInsertDelta.position.getShiftedBy( lastOffset ),
			weakInsertDelta.position.getShiftedBy( offsetSum )
		);

		const attrOperation = new __WEBPACK_IMPORTED_MODULE_4__operation_attributeoperation__["a" /* default */]( range, attributeDelta.key, val, attributeDelta.value, 0 );
		complementaryAttrDelta.addOperation( attrOperation );
	}
}

// This is "no-op" delta, it has no type and only no-operation, it basically does nothing.
// It is used when we don't want to apply changes but still we need to return a delta.
function noDelta() {
	const noDelta = new __WEBPACK_IMPORTED_MODULE_7__delta__["a" /* default */]();

	// BaseVersion will be fixed later anyway.
	noDelta.addOperation( new __WEBPACK_IMPORTED_MODULE_3__operation_nooperation__["a" /* default */]( 0 ) );

	return noDelta;
}


/***/ }),
/* 379 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__insertoperation__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__attributeoperation__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__rootattributeoperation__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__renameoperation__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__markeroperation__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__moveoperation__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__removeoperation__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__reinsertoperation__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__nooperation__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ckeditor_ckeditor5_utils_src_comparearrays__ = __webpack_require__(54);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/operation/transform
 */













/**
 * Transforms given {@link module:engine/model/operation/operation~Operation operation}
 * by another {@link module:engine/model/operation/operation~Operation operation}
 * and returns the result of that transformation as an array containing
 * one or more {@link module:engine/model/operation/operation~Operation operations}.
 *
 * Operations work on specified positions, passed to them when they are created.
 * Whenever {@link module:engine/model/document~Document document}
 * changes, we have to reflect those modifications by updating or "transforming" operations which are not yet applied.
 * When an operation is transformed, its parameters may change based on the operation by which it is transformed.
 * If the transform-by operation applied any modifications to the Tree Data Model which affect positions or nodes
 * connected with transformed operation, those changes will be reflected in the parameters of the returned operation(s).
 *
 * Whenever the {@link module:engine/model/document~Document document}
 * has different {@link module:engine/model/document~Document#version}
 * than the operation you want to {@link module:engine/model/document~Document#applyOperation apply}, you need to transform that
 * operation by all operations which were already applied to the {@link module:engine/model/document~Document document} and have greater
 * {@link module:engine/model/document~Document#version} than the operation being applied. Transform them in the same order as those
 * operations which were applied. This way all modifications done to the Tree Data Model will be reflected
 * in the operation parameters and the operation will "operate" on "up-to-date" version of the Tree Data Model.
 * This is mostly the case with Operational Transformations but it might be needed in particular features as well.
 *
 * In some cases, when given operation apply changes to the same nodes as this operation, two or more operations need
 * to be created as one would not be able to reflect the combination of these operations.
 * This is why an array is returned instead of a single object. All returned operations have to be applied
 * (or further transformed) to get an effect which was intended in pre-transformed operation.
 *
 * Sometimes two operations are in conflict. This happens when they modify the same node in a different way, i.e.
 * set different value for the same attribute or move the node into different positions. When this happens,
 * we need to decide which operation is more important. We can't assume that operation `a` or operation `b` is always
 * more important. In Operational Transformations algorithms we often need to get a result of transforming
 * `a` by `b` and also `b` by `a`. In both transformations the same operation has to be the important one. If we assume
 * that first or the second passed operation is always more important we won't be able to solve this case.
 *
 * @function module:engine/model/operation/transform~transform
 * @param {module:engine/model/operation/operation~Operation} a Operation that will be transformed.
 * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.
 * @param {module:engine/model/delta/transform~transformationContext} [context] Transformation context.
 * @returns {Array.<module:engine/model/operation/operation~Operation>} Result of the transformation.
 */

/* harmony default export */ __webpack_exports__["a"] = (transform);

const ot = {
	InsertOperation: {
		// Transforms InsertOperation `a` by InsertOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		InsertOperation( a, b, context ) {
			// Transformed operations are always new instances, not references to the original operations.
			const transformed = a.clone();

			// Check whether there is a forced order of nodes or use `context.isStrong` flag for conflict resolving.
			const insertBefore = context.insertBefore === undefined ? !context.isStrong : context.insertBefore;

			// Transform insert position by the other operation position.
			transformed.position = transformed.position._getTransformedByInsertion( b.position, b.nodes.maxOffset, insertBefore );

			return [ transformed ];
		},

		AttributeOperation: doNotUpdate,

		RootAttributeOperation: doNotUpdate,

		RenameOperation: doNotUpdate,

		MarkerOperation: doNotUpdate,

		// Transforms InsertOperation `a` by MoveOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		MoveOperation( a, b, context ) {
			const transformed = a.clone();

			// Check whether there is a forced order of nodes or use `context.isStrong` flag for conflict resolving.
			const insertBefore = context.insertBefore === undefined ? !context.isStrong : context.insertBefore;

			// Transform insert position by the other operation parameters.
			transformed.position = a.position._getTransformedByMove(
				b.sourcePosition,
				b.targetPosition,
				b.howMany,
				insertBefore,
				b.isSticky && !context.forceNotSticky
			);

			return [ transformed ];
		}
	},

	AttributeOperation: {
		// Transforms AttributeOperation `a` by InsertOperation `b`. Returns results as an array of operations.
		InsertOperation( a, b ) {
			// Transform this operation's range.
			const ranges = a.range._getTransformedByInsertion( b.position, b.nodes.maxOffset, true, false );

			// Map transformed range(s) to operations and return them.
			return ranges.reverse().map( range => {
				return new __WEBPACK_IMPORTED_MODULE_1__attributeoperation__["a" /* default */]( range, a.key, a.oldValue, a.newValue, a.baseVersion );
			} );
		},

		// Transforms AttributeOperation `a` by AttributeOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		AttributeOperation( a, b, context ) {
			if ( a.key === b.key ) {
				// If operations attributes are in conflict, check if their ranges intersect and manage them properly.

				// First, we want to apply change to the part of a range that has not been changed by the other operation.
				const operations = a.range.getDifference( b.range ).map( range => {
					return new __WEBPACK_IMPORTED_MODULE_1__attributeoperation__["a" /* default */]( range, a.key, a.oldValue, a.newValue, a.baseVersion );
				} );

				// Then we take care of the common part of ranges.
				const common = a.range.getIntersection( b.range );

				if ( common ) {
					// If this operation is more important, we also want to apply change to the part of the
					// original range that has already been changed by the other operation. Since that range
					// got changed we also have to update `oldValue`.
					if ( context.isStrong ) {
						operations.push( new __WEBPACK_IMPORTED_MODULE_1__attributeoperation__["a" /* default */]( common, b.key, b.newValue, a.newValue, a.baseVersion ) );
					} else if ( operations.length === 0 ) {
						operations.push( new __WEBPACK_IMPORTED_MODULE_8__nooperation__["a" /* default */]( 0 ) );
					}
				}

				return operations;
			} else {
				// If operations don't conflict, simply return an array containing just a clone of this operation.
				return [ a.clone() ];
			}
		},

		RootAttributeOperation: doNotUpdate,

		RenameOperation: doNotUpdate,

		MarkerOperation: doNotUpdate,

		// Transforms AttributeOperation `a` by MoveOperation `b`. Returns results as an array of operations.
		MoveOperation( a, b ) {
			// Convert MoveOperation properties into a range.
			const rangeB = __WEBPACK_IMPORTED_MODULE_9__range__["a" /* default */].createFromPositionAndShift( b.sourcePosition, b.howMany );

			// This will aggregate transformed ranges.
			let ranges = [];

			// Difference is a part of changed range that is modified by AttributeOperation but is not affected
			// by MoveOperation. This can be zero, one or two ranges (if moved range is inside changed range).
			// Right now we will make a simplification and join difference ranges and transform them as one. We will cover rangeB later.
			const difference = joinRanges( a.range.getDifference( rangeB ) );

			// Common is a range of nodes that is affected by MoveOperation. So it got moved to other place.
			const common = a.range.getIntersection( rangeB );

			if ( difference !== null ) {
				// MoveOperation removes nodes from their original position. We acknowledge this by proper transformation.
				// Take the start and the end of the range and transform them by deletion of moved nodes.
				// Note that if rangeB was inside AttributeOperation range, only difference.end will be transformed.
				// This nicely covers the joining simplification we did in the previous step.
				difference.start = difference.start._getTransformedByDeletion( b.sourcePosition, b.howMany );
				difference.end = difference.end._getTransformedByDeletion( b.sourcePosition, b.howMany );

				// MoveOperation pastes nodes into target position. We acknowledge this by proper transformation.
				// Note that since we operate on transformed difference range, we should transform by
				// previously transformed target position.
				// Note that we do not use Position._getTransformedByMove on range boundaries because we need to
				// transform by insertion a range as a whole, since newTargetPosition might be inside that range.
				ranges = difference._getTransformedByInsertion( b.getMovedRangeStart(), b.howMany, true, false ).reverse();
			}

			if ( common !== null ) {
				// Here we do not need to worry that newTargetPosition is inside moved range, because that
				// would mean that the MoveOperation targets into itself, and that is incorrect operation.
				// Instead, we calculate the new position of that part of original range.
				common.start = common.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );
				common.end = common.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );

				ranges.push( common );
			}

			// Map transformed range(s) to operations and return them.
			return ranges.map( range => {
				return new __WEBPACK_IMPORTED_MODULE_1__attributeoperation__["a" /* default */]( range, a.key, a.oldValue, a.newValue, a.baseVersion );
			} );
		}
	},

	RootAttributeOperation: {
		InsertOperation: doNotUpdate,

		AttributeOperation: doNotUpdate,

		// Transforms RootAttributeOperation `a` by RootAttributeOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		RootAttributeOperation( a, b, context ) {
			if ( a.root === b.root && a.key === b.key ) {
				if ( ( a.newValue !== b.newValue && !context.isStrong ) || a.newValue === b.newValue ) {
					return [ new __WEBPACK_IMPORTED_MODULE_8__nooperation__["a" /* default */]( a.baseVersion ) ];
				}
			}

			return [ a.clone() ];
		},

		RenameOperation: doNotUpdate,

		MarkerOperation: doNotUpdate,

		MoveOperation: doNotUpdate
	},

	RenameOperation: {
		// Transforms RenameOperation `a` by InsertOperation `b`. Returns results as an array of operations.
		InsertOperation( a, b ) {
			// Clone the operation, we don't want to alter the original operation.
			const clone = a.clone();

			// Transform this operation's position.
			clone.position = clone.position._getTransformedByInsertion( b.position, b.nodes.maxOffset, true );

			return [ clone ];
		},

		AttributeOperation: doNotUpdate,

		RootAttributeOperation: doNotUpdate,

		// Transforms RenameOperation `a` by RenameOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		RenameOperation( a, b, context ) {
			// Clone the operation, we don't want to alter the original operation.
			const clone = a.clone();

			if ( a.position.isEqual( b.position ) ) {
				if ( context.isStrong ) {
					clone.oldName = b.newName;
				} else {
					return [ new __WEBPACK_IMPORTED_MODULE_8__nooperation__["a" /* default */]( a.baseVersion ) ];
				}
			}

			return [ clone ];
		},

		MarkerOperation: doNotUpdate,

		// Transforms RenameOperation `a` by MoveOperation `b`. Returns results as an array of operations.
		MoveOperation( a, b ) {
			const clone = a.clone();
			const isSticky = clone.position.isEqual( b.sourcePosition );

			clone.position = clone.position._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany, true, isSticky );

			return [ clone ];
		}
	},

	MarkerOperation: {
		// Transforms MarkerOperation `a` by InsertOperation `b`. Returns results as an array of operations.
		InsertOperation( a, b ) {
			// Clone the operation, we don't want to alter the original operation.
			const clone = a.clone();

			if ( clone.oldRange ) {
				clone.oldRange = clone.oldRange._getTransformedByInsertion( b.position, b.nodes.maxOffset, false, false )[ 0 ];
			}

			if ( clone.newRange ) {
				clone.newRange = clone.newRange._getTransformedByInsertion( b.position, b.nodes.maxOffset, false, false )[ 0 ];
			}

			return [ clone ];
		},

		AttributeOperation: doNotUpdate,

		RootAttributeOperation: doNotUpdate,

		RenameOperation: doNotUpdate,

		// Transforms MarkerOperation `a` by MarkerOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		MarkerOperation( a, b, context ) {
			// Clone the operation, we don't want to alter the original operation.
			const clone = a.clone();

			if ( a.name == b.name ) {
				if ( context.isStrong ) {
					clone.oldRange = b.newRange;
				} else {
					return [ new __WEBPACK_IMPORTED_MODULE_8__nooperation__["a" /* default */]( a.baseVersion ) ];
				}
			}

			return [ clone ];
		},

		// Transforms MarkerOperation `a` by MoveOperation `b`. Returns results as an array of operations.
		MoveOperation( a, b ) {
			// Clone the operation, we don't want to alter the original operation.
			const clone = a.clone();

			if ( clone.oldRange ) {
				const oldRanges = clone.oldRange._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );
				clone.oldRange = __WEBPACK_IMPORTED_MODULE_9__range__["a" /* default */].createFromRanges( oldRanges );
			}

			if ( clone.newRange ) {
				const newRanges = clone.newRange._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );
				clone.newRange = __WEBPACK_IMPORTED_MODULE_9__range__["a" /* default */].createFromRanges( newRanges );
			}

			return [ clone ];
		}
	},

	MoveOperation: {
		// Transforms MoveOperation `a` by InsertOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		InsertOperation( a, b, context ) {
			// Create range from MoveOperation properties and transform it by insertion.
			let range = __WEBPACK_IMPORTED_MODULE_9__range__["a" /* default */].createFromPositionAndShift( a.sourcePosition, a.howMany );
			const includeB = a.isSticky && !context.forceNotSticky;

			range = range._getTransformedByInsertion( b.position, b.nodes.maxOffset, false, includeB )[ 0 ];

			// Check whether there is a forced order of nodes or use `context.isStrong` flag for conflict resolving.
			const insertBefore = context.insertBefore === undefined ? !context.isStrong : context.insertBefore;

			const result = new a.constructor(
				range.start,
				range.end.offset - range.start.offset,
				a.targetPosition._getTransformedByInsertion( b.position, b.nodes.maxOffset, insertBefore ),
				a.baseVersion
			);

			result.isSticky = a.isSticky;

			return [ result ];
		},

		AttributeOperation: doNotUpdate,

		RootAttributeOperation: doNotUpdate,

		RenameOperation: doNotUpdate,

		MarkerOperation: doNotUpdate,

		// Transforms MoveOperation `a` by MoveOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		MoveOperation( a, b, context ) {
			//
			// Setting and evaluating some variables that will be used in special cases and default algorithm.
			//
			// Create ranges from `MoveOperations` properties.
			const rangeA = __WEBPACK_IMPORTED_MODULE_9__range__["a" /* default */].createFromPositionAndShift( a.sourcePosition, a.howMany );
			const rangeB = __WEBPACK_IMPORTED_MODULE_9__range__["a" /* default */].createFromPositionAndShift( b.sourcePosition, b.howMany );

			// Assign `context.isStrong` to a different variable, because the value may change during execution of
			// this algorithm and we do not want to override original `context.isStrong` that will be used in later transformations.
			let isStrong = context.isStrong;

			// Whether range moved by operation `b` is includable in operation `a` move range.
			// For this, `a` operation has to be sticky (so `b` sticks to the range) and context has to allow stickiness.
			const includeB = a.isSticky && !context.forceNotSticky;

			// Evaluate new target position for transformed operation.
			// Check whether there is a forced order of nodes or use `isStrong` flag for conflict resolving.
			const insertBefore = context.insertBefore === undefined ? !isStrong : context.insertBefore;

			// `a.targetPosition` could be affected by the `b` operation. We will transform it.
			const newTargetPosition = a.targetPosition._getTransformedByMove(
				b.sourcePosition,
				b.targetPosition,
				b.howMany,
				insertBefore,
				b.isSticky && !context.forceNotSticky
			);

			//
			// Special case #1 + mirror.
			//
			// Special case when both move operations' target positions are inside nodes that are
			// being moved by the other move operation. So in other words, we move ranges into inside of each other.
			// This case can't be solved reasonably (on the other hand, it should not happen often).
			if ( moveTargetIntoMovedRange( a, b ) && moveTargetIntoMovedRange( b, a ) ) {
				// Instead of transforming operation, we return a reverse of the operation that we transform by.
				// So when the results of this "transformation" will be applied, `b` MoveOperation will get reversed.
				return [ b.getReversed() ];
			}
			//
			// End of special case #1.
			//

			//
			// Special case #2.
			//
			// Check if `b` operation targets inside `rangeA`. Use stickiness if possible.
			const bTargetsToA = rangeA.containsPosition( b.targetPosition ) ||
				( rangeA.start.isEqual( b.targetPosition ) && includeB ) ||
				( rangeA.end.isEqual( b.targetPosition ) && includeB );

			// If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.
			// You might say that operation `b` is captured inside operation `a`.
			if ( bTargetsToA && rangeA.containsRange( rangeB, true ) ) {
				// There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why
				// we need to transform `a` operation anyway.
				rangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany, !includeB );
				rangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany, includeB );

				return makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition, a );
			}

			//
			// Special case #2 mirror.
			//
			const aTargetsToB = rangeB.containsPosition( a.targetPosition ) ||
				( rangeB.start.isEqual( a.targetPosition ) && b.isSticky && !context.forceNotSticky ) ||
				( rangeB.end.isEqual( a.targetPosition ) && b.isSticky && !context.forceNotSticky );

			if ( aTargetsToB && rangeB.containsRange( rangeA, true ) ) {
				// `a` operation is "moved together" with `b` operation.
				// Here, just move `rangeA` "inside" `rangeB`.
				rangeA.start = rangeA.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );
				rangeA.end = rangeA.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );

				return makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition, a );
			}
			//
			// End of special case #2.
			//

			//
			// Special case #3 + mirror.
			//
			// `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`
			// but not on the same tree level. In such case ranges have common part but we have to treat it
			// differently, because in such case those ranges are not really conflicting and should be treated like
			// two separate ranges. Also we have to discard two difference parts.
			const aCompB = Object(__WEBPACK_IMPORTED_MODULE_10__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath() );

			if ( aCompB == 'prefix' || aCompB == 'extension' ) {
				// Transform `rangeA` by `b` operation and make operation out of it, and that's all.
				// Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)
				// like a one difference part.
				rangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany, !includeB );
				rangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany, includeB );

				return makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition, a );
			}
			//
			// End of special case #3.
			//

			//
			// Default case - ranges are on the same level or are not connected with each other.
			//
			// Modifier for default case.
			// Modifies `isStrong` flag in certain conditions.
			//
			// If only one of operations is a remove operation, we force remove operation to be the "stronger" one
			// to provide more expected results. This is done only if `context.forceWeakRemove` is set to `false`.
			// `context.forceWeakRemove` is set to `true` in certain conditions when transformation takes place during undo.
			if ( !context.forceWeakRemove ) {
				if ( a instanceof __WEBPACK_IMPORTED_MODULE_6__removeoperation__["a" /* default */] && !( b instanceof __WEBPACK_IMPORTED_MODULE_6__removeoperation__["a" /* default */] ) ) {
					isStrong = true;
				} else if ( !( a instanceof __WEBPACK_IMPORTED_MODULE_6__removeoperation__["a" /* default */] ) && b instanceof __WEBPACK_IMPORTED_MODULE_6__removeoperation__["a" /* default */] ) {
					isStrong = false;
				}
			}

			// Handle operation's source ranges - check how `rangeA` is affected by `b` operation.
			// This will aggregate transformed ranges.
			const ranges = [];

			// Get the "difference part" of `a` operation source range.
			// This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.
			const difference = rangeA.getDifference( rangeB );

			for ( const range of difference ) {
				// Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.
				range.start = range.start._getTransformedByDeletion( b.sourcePosition, b.howMany );
				range.end = range.end._getTransformedByDeletion( b.sourcePosition, b.howMany );

				// If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.
				const shouldSpread = Object(__WEBPACK_IMPORTED_MODULE_10__ckeditor_ckeditor5_utils_src_comparearrays__["a" /* default */])( range.start.getParentPath(), b.getMovedRangeStart().getParentPath() ) == 'same';
				const newRanges = range._getTransformedByInsertion( b.getMovedRangeStart(), b.howMany, shouldSpread, includeB );

				ranges.push( ...newRanges );
			}

			// Then, we have to manage the "common part" of both move ranges.
			const common = rangeA.getIntersection( rangeB );

			if ( common !== null && isStrong && !bTargetsToA ) {
				// Calculate the new position of that part of original range.
				common.start = common.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );
				common.end = common.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );

				// Take care of proper range order.
				//
				// Put `common` at appropriate place. Keep in mind that we are interested in original order.
				// Basically there are only three cases: there is zero, one or two difference ranges.
				//
				// If there is zero difference ranges, just push `common` in the array.
				if ( ranges.length === 0 ) {
					ranges.push( common );
				}
				// If there is one difference range, we need to check whether common part was before it or after it.
				else if ( ranges.length == 1 ) {
					if ( rangeB.start.isBefore( rangeA.start ) || rangeB.start.isEqual( rangeA.start ) ) {
						ranges.unshift( common );
					} else {
						ranges.push( common );
					}
				}
				// If there are more ranges (which means two), put common part between them. This is the only scenario
				// where there could be two difference ranges so we don't have to make any comparisons.
				else {
					ranges.splice( 1, 0, common );
				}
			}

			if ( ranges.length === 0 ) {
				// If there are no "source ranges", nothing should be changed.
				// Note that this can happen only if `isStrong == false` and `rangeA.isEqual( rangeB )`.
				return [ new __WEBPACK_IMPORTED_MODULE_8__nooperation__["a" /* default */]( a.baseVersion ) ];
			}

			return makeMoveOperationsFromRanges( ranges, newTargetPosition, a );
		}
	}
};

function transform( a, b, context = { isStrong: false } ) {
	let group, algorithm;

	if ( a instanceof __WEBPACK_IMPORTED_MODULE_0__insertoperation__["a" /* default */] ) {
		group = ot.InsertOperation;
	} else if ( a instanceof __WEBPACK_IMPORTED_MODULE_1__attributeoperation__["a" /* default */] ) {
		group = ot.AttributeOperation;
	} else if ( a instanceof __WEBPACK_IMPORTED_MODULE_2__rootattributeoperation__["a" /* default */] ) {
		group = ot.RootAttributeOperation;
	} else if ( a instanceof __WEBPACK_IMPORTED_MODULE_3__renameoperation__["a" /* default */] ) {
		group = ot.RenameOperation;
	} else if ( a instanceof __WEBPACK_IMPORTED_MODULE_4__markeroperation__["a" /* default */] ) {
		group = ot.MarkerOperation;
	} else if ( a instanceof __WEBPACK_IMPORTED_MODULE_5__moveoperation__["a" /* default */] ) {
		group = ot.MoveOperation;
	} else {
		algorithm = doNotUpdate;
	}

	if ( group ) {
		if ( b instanceof __WEBPACK_IMPORTED_MODULE_0__insertoperation__["a" /* default */] ) {
			algorithm = group.InsertOperation;
		} else if ( b instanceof __WEBPACK_IMPORTED_MODULE_1__attributeoperation__["a" /* default */] ) {
			algorithm = group.AttributeOperation;
		} else if ( b instanceof __WEBPACK_IMPORTED_MODULE_2__rootattributeoperation__["a" /* default */] ) {
			algorithm = group.RootAttributeOperation;
		} else if ( b instanceof __WEBPACK_IMPORTED_MODULE_3__renameoperation__["a" /* default */] ) {
			algorithm = group.RenameOperation;
		} else if ( b instanceof __WEBPACK_IMPORTED_MODULE_4__markeroperation__["a" /* default */] ) {
			algorithm = group.MarkerOperation;
		} else if ( b instanceof __WEBPACK_IMPORTED_MODULE_5__moveoperation__["a" /* default */] ) {
			algorithm = group.MoveOperation;
		} else {
			algorithm = doNotUpdate;
		}
	}

	const transformed = algorithm( a, b, context );

	return updateBaseVersions( a.baseVersion, transformed );
}

// When we don't want to update an operation, we create and return a clone of it.
// Returns the operation in "unified format" - wrapped in an Array.
function doNotUpdate( operation ) {
	return [ operation.clone() ];
}

// Takes an Array of operations and sets consecutive base versions for them, starting from given base version.
// Returns the passed array.
function updateBaseVersions( baseVersion, operations ) {
	for ( let i = 0; i < operations.length; i++ ) {
		operations[ i ].baseVersion = baseVersion + i + 1;
	}

	return operations;
}

// Checks whether MoveOperation targetPosition is inside a node from the moved range of the other MoveOperation.
function moveTargetIntoMovedRange( a, b ) {
	return a.targetPosition._getTransformedByDeletion( b.sourcePosition, b.howMany ) === null;
}

// Gets an array of Ranges and produces one Range out of it. The root of a new range will be same as
// the root of the first range in the array. If any of given ranges has different root than the first range,
// it will be discarded.
function joinRanges( ranges ) {
	if ( ranges.length === 0 ) {
		return null;
	} else if ( ranges.length == 1 ) {
		return ranges[ 0 ];
	} else {
		ranges[ 0 ].end = ranges[ ranges.length - 1 ].end;

		return ranges[ 0 ];
	}
}

// Helper function for `MoveOperation` x `MoveOperation` transformation.
// Convert given ranges and target position to move operations and return them.
// Ranges and target position will be transformed on-the-fly when generating operations.
// Given `ranges` should be in the order of how they were in the original transformed operation.
// Given `targetPosition` is the target position of the first range from `ranges`.
function makeMoveOperationsFromRanges( ranges, targetPosition, a ) {
	// At this moment we have some ranges and a target position, to which those ranges should be moved.
	// Order in `ranges` array is the go-to order of after transformation.
	//
	// We are almost done. We have `ranges` and `targetPosition` to make operations from.
	// Unfortunately, those operations may affect each other. Precisely, first operation after move
	// may affect source range and target position of second and third operation. Same with second
	// operation affecting third.
	//
	// We need to fix those source ranges and target positions once again, before converting `ranges` to operations.
	const operations = [];

	// Keep in mind that nothing will be transformed if there is just one range in `ranges`.
	for ( let i = 0; i < ranges.length; i++ ) {
		// Create new operation out of a range and target position.
		const op = makeMoveOperation( ranges[ i ], targetPosition, a.isSticky );

		operations.push( op );

		// Transform other ranges by the generated operation.
		for ( let j = i + 1; j < ranges.length; j++ ) {
			// All ranges in `ranges` array should be:
			// * non-intersecting (these are part of original operation source range), and
			// * `targetPosition` does not target into them (opposite would mean that transformed operation targets "inside itself").
			//
			// This means that the transformation will be "clean" and always return one result.
			ranges[ j ] = ranges[ j ]._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany )[ 0 ];
		}

		targetPosition = targetPosition._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany, true, false );
	}

	return operations;
}

function makeMoveOperation( range, targetPosition, isSticky ) {
	// We want to keep correct operation class.
	let OperationClass;

	if ( targetPosition.root.rootName == '$graveyard' ) {
		OperationClass = __WEBPACK_IMPORTED_MODULE_6__removeoperation__["a" /* default */];
	} else if ( range.start.root.rootName == '$graveyard' ) {
		OperationClass = __WEBPACK_IMPORTED_MODULE_7__reinsertoperation__["a" /* default */];
	} else {
		OperationClass = __WEBPACK_IMPORTED_MODULE_5__moveoperation__["a" /* default */];
	}

	const result = new OperationClass(
		range.start,
		range.end.offset - range.start.offset,
		targetPosition,
		0 // Is corrected anyway later.
	);

	result.isSticky = isSticky;

	return result;
}


/***/ }),
/* 380 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__chunk__ = __webpack_require__(189);
/* unused harmony reexport chunk */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__compact__ = __webpack_require__(190);
/* unused harmony reexport compact */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__concat__ = __webpack_require__(191);
/* unused harmony reexport concat */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__difference__ = __webpack_require__(192);
/* unused harmony reexport difference */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__differenceBy__ = __webpack_require__(194);
/* unused harmony reexport differenceBy */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__differenceWith__ = __webpack_require__(199);
/* unused harmony reexport differenceWith */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__drop__ = __webpack_require__(142);
/* unused harmony reexport drop */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__dropRight__ = __webpack_require__(143);
/* unused harmony reexport dropRight */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__dropRightWhile__ = __webpack_require__(200);
/* unused harmony reexport dropRightWhile */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__dropWhile__ = __webpack_require__(201);
/* unused harmony reexport dropWhile */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__fill__ = __webpack_require__(202);
/* unused harmony reexport fill */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__findIndex__ = __webpack_require__(203);
/* unused harmony reexport findIndex */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__findLastIndex__ = __webpack_require__(205);
/* unused harmony reexport findLastIndex */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__first__ = __webpack_require__(206);
/* unused harmony reexport first */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__flatten__ = __webpack_require__(207);
/* unused harmony reexport flatten */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__flattenDeep__ = __webpack_require__(208);
/* unused harmony reexport flattenDeep */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__flattenDepth__ = __webpack_require__(209);
/* unused harmony reexport flattenDepth */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__fromPairs__ = __webpack_require__(210);
/* unused harmony reexport fromPairs */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__head__ = __webpack_require__(144);
/* unused harmony reexport head */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__indexOf__ = __webpack_require__(211);
/* unused harmony reexport indexOf */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__initial__ = __webpack_require__(212);
/* unused harmony reexport initial */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__intersection__ = __webpack_require__(213);
/* unused harmony reexport intersection */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__intersectionBy__ = __webpack_require__(214);
/* unused harmony reexport intersectionBy */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__intersectionWith__ = __webpack_require__(215);
/* unused harmony reexport intersectionWith */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__join__ = __webpack_require__(216);
/* unused harmony reexport join */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__last__ = __webpack_require__(17);
/* unused harmony reexport last */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__lastIndexOf__ = __webpack_require__(217);
/* unused harmony reexport lastIndexOf */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__nth__ = __webpack_require__(218);
/* unused harmony reexport nth */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__pull__ = __webpack_require__(219);
/* unused harmony reexport pull */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__pullAll__ = __webpack_require__(147);
/* unused harmony reexport pullAll */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__pullAllBy__ = __webpack_require__(220);
/* unused harmony reexport pullAllBy */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__pullAllWith__ = __webpack_require__(221);
/* unused harmony reexport pullAllWith */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__pullAt__ = __webpack_require__(222);
/* unused harmony reexport pullAt */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__remove__ = __webpack_require__(224);
/* unused harmony reexport remove */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__reverse__ = __webpack_require__(225);
/* unused harmony reexport reverse */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__slice__ = __webpack_require__(226);
/* unused harmony reexport slice */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__sortedIndex__ = __webpack_require__(227);
/* unused harmony reexport sortedIndex */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__sortedIndexBy__ = __webpack_require__(228);
/* unused harmony reexport sortedIndexBy */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__sortedIndexOf__ = __webpack_require__(229);
/* unused harmony reexport sortedIndexOf */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__sortedLastIndex__ = __webpack_require__(230);
/* unused harmony reexport sortedLastIndex */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__sortedLastIndexBy__ = __webpack_require__(231);
/* unused harmony reexport sortedLastIndexBy */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__sortedLastIndexOf__ = __webpack_require__(232);
/* unused harmony reexport sortedLastIndexOf */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__sortedUniq__ = __webpack_require__(233);
/* unused harmony reexport sortedUniq */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__sortedUniqBy__ = __webpack_require__(235);
/* unused harmony reexport sortedUniqBy */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__tail__ = __webpack_require__(236);
/* unused harmony reexport tail */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__take__ = __webpack_require__(237);
/* unused harmony reexport take */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__takeRight__ = __webpack_require__(238);
/* unused harmony reexport takeRight */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__takeRightWhile__ = __webpack_require__(239);
/* unused harmony reexport takeRightWhile */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__takeWhile__ = __webpack_require__(240);
/* unused harmony reexport takeWhile */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__union__ = __webpack_require__(241);
/* unused harmony reexport union */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__unionBy__ = __webpack_require__(242);
/* unused harmony reexport unionBy */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__unionWith__ = __webpack_require__(243);
/* unused harmony reexport unionWith */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__uniq__ = __webpack_require__(244);
/* unused harmony reexport uniq */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__uniqBy__ = __webpack_require__(245);
/* unused harmony reexport uniqBy */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__uniqWith__ = __webpack_require__(246);
/* unused harmony reexport uniqWith */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__unzip__ = __webpack_require__(106);
/* unused harmony reexport unzip */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__unzipWith__ = __webpack_require__(150);
/* unused harmony reexport unzipWith */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__without__ = __webpack_require__(247);
/* unused harmony reexport without */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__xor__ = __webpack_require__(248);
/* unused harmony reexport xor */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__xorBy__ = __webpack_require__(249);
/* unused harmony reexport xorBy */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__xorWith__ = __webpack_require__(250);
/* unused harmony reexport xorWith */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__zip__ = __webpack_require__(251);
/* unused harmony reexport zip */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__zipObject__ = __webpack_require__(252);
/* unused harmony reexport zipObject */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__zipObjectDeep__ = __webpack_require__(254);
/* unused harmony reexport zipObjectDeep */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__zipWith__ = __webpack_require__(255);
/* unused harmony reexport zipWith */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_65__array_default__ = __webpack_require__(410);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_65__array_default__["a"]; });




































































/***/ }),
/* 381 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArguments__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArray__ = __webpack_require__(14);



/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__isArray__["a" /* default */])(value) || Object(__WEBPACK_IMPORTED_MODULE_0__isArguments__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (isFlattenable);


/***/ }),
/* 382 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsMatch__ = __webpack_require__(383);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getMatchData__ = __webpack_require__(384);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__matchesStrictComparable__ = __webpack_require__(196);




/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = Object(__WEBPACK_IMPORTED_MODULE_1__getMatchData__["a" /* default */])(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return Object(__WEBPACK_IMPORTED_MODULE_2__matchesStrictComparable__["a" /* default */])(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || Object(__WEBPACK_IMPORTED_MODULE_0__baseIsMatch__["a" /* default */])(object, source, matchData);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (baseMatches);


/***/ }),
/* 383 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Stack__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIsEqual__ = __webpack_require__(94);



/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new __WEBPACK_IMPORTED_MODULE_0__Stack__["a" /* default */];
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? Object(__WEBPACK_IMPORTED_MODULE_1__baseIsEqual__["a" /* default */])(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsMatch);


/***/ }),
/* 384 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isStrictComparable__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toPairs__ = __webpack_require__(385);



/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = Object(__WEBPACK_IMPORTED_MODULE_1__toPairs__["a" /* default */])(object),
      length = result.length;

  while (length--) {
    result[length][2] = Object(__WEBPACK_IMPORTED_MODULE_0__isStrictComparable__["a" /* default */])(result[length][1]);
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (getMatchData);


/***/ }),
/* 385 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createToPairs__ = __webpack_require__(386);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keys__ = __webpack_require__(69);



/**
 * Creates an array of own enumerable string keyed-value pairs for `object`
 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
 * entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entries
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairs(new Foo);
 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
 */
var toPairs = Object(__WEBPACK_IMPORTED_MODULE_0__createToPairs__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__keys__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (toPairs);


/***/ }),
/* 386 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseToPairs__ = __webpack_require__(387);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getTag__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mapToArray__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__setToPairs__ = __webpack_require__(388);





/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/**
 * Creates a `_.toPairs` or `_.toPairsIn` function.
 *
 * @private
 * @param {Function} keysFunc The function to get the keys of a given object.
 * @returns {Function} Returns the new pairs function.
 */
function createToPairs(keysFunc) {
  return function(object) {
    var tag = Object(__WEBPACK_IMPORTED_MODULE_1__getTag__["a" /* default */])(object);
    if (tag == mapTag) {
      return Object(__WEBPACK_IMPORTED_MODULE_2__mapToArray__["a" /* default */])(object);
    }
    if (tag == setTag) {
      return Object(__WEBPACK_IMPORTED_MODULE_3__setToPairs__["a" /* default */])(object);
    }
    return Object(__WEBPACK_IMPORTED_MODULE_0__baseToPairs__["a" /* default */])(object, keysFunc(object));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (createToPairs);


/***/ }),
/* 387 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap__ = __webpack_require__(30);


/**
 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
 * of key-value pairs for `object` corresponding to the property names of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the key-value pairs.
 */
function baseToPairs(object, props) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap__["a" /* default */])(props, function(key) {
    return [key, object[key]];
  });
}

/* harmony default export */ __webpack_exports__["a"] = (baseToPairs);


/***/ }),
/* 388 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Converts `set` to its value-value pairs.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the value-value pairs.
 */
function setToPairs(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = [value, value];
  });
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (setToPairs);


/***/ }),
/* 389 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsEqual__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__get__ = __webpack_require__(197);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasIn__ = __webpack_require__(394);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isKey__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isStrictComparable__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__matchesStrictComparable__ = __webpack_require__(196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__toKey__ = __webpack_require__(57);








/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (Object(__WEBPACK_IMPORTED_MODULE_3__isKey__["a" /* default */])(path) && Object(__WEBPACK_IMPORTED_MODULE_4__isStrictComparable__["a" /* default */])(srcValue)) {
    return Object(__WEBPACK_IMPORTED_MODULE_5__matchesStrictComparable__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_6__toKey__["a" /* default */])(path), srcValue);
  }
  return function(object) {
    var objValue = Object(__WEBPACK_IMPORTED_MODULE_1__get__["a" /* default */])(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? Object(__WEBPACK_IMPORTED_MODULE_2__hasIn__["a" /* default */])(object, path)
      : Object(__WEBPACK_IMPORTED_MODULE_0__baseIsEqual__["a" /* default */])(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (baseMatchesProperty);


/***/ }),
/* 390 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__memoize__ = __webpack_require__(391);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toString__ = __webpack_require__(392);



/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = Object(__WEBPACK_IMPORTED_MODULE_0__memoize__["a" /* default */])(function(string) {
  var result = [];
  Object(__WEBPACK_IMPORTED_MODULE_1__toString__["a" /* default */])(string).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/* harmony default export */ __webpack_exports__["a"] = (stringToPath);


/***/ }),
/* 391 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MapCache__ = __webpack_require__(124);


/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || __WEBPACK_IMPORTED_MODULE_0__MapCache__["a" /* default */]);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = __WEBPACK_IMPORTED_MODULE_0__MapCache__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (memoize);


/***/ }),
/* 392 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseToString__ = __webpack_require__(393);


/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : Object(__WEBPACK_IMPORTED_MODULE_0__baseToString__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (toString);


/***/ }),
/* 393 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isSymbol__ = __webpack_require__(45);



/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = __WEBPACK_IMPORTED_MODULE_0__Symbol__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol__["a" /* default */].prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (Object(__WEBPACK_IMPORTED_MODULE_1__isSymbol__["a" /* default */])(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseToString);


/***/ }),
/* 394 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseHasIn__ = __webpack_require__(395);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasPath__ = __webpack_require__(396);



/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && Object(__WEBPACK_IMPORTED_MODULE_1__hasPath__["a" /* default */])(object, path, __WEBPACK_IMPORTED_MODULE_0__baseHasIn__["a" /* default */]);
}

/* harmony default export */ __webpack_exports__["a"] = (hasIn);


/***/ }),
/* 395 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return key in Object(object);
}

/* harmony default export */ __webpack_exports__["a"] = (baseHasIn);


/***/ }),
/* 396 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__castPath__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArguments__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArray__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isIndex__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isKey__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__isLength__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__isString__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__toKey__ = __webpack_require__(57);









/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = Object(__WEBPACK_IMPORTED_MODULE_4__isKey__["a" /* default */])(path, object) ? [path] : Object(__WEBPACK_IMPORTED_MODULE_0__castPath__["a" /* default */])(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = Object(__WEBPACK_IMPORTED_MODULE_7__toKey__["a" /* default */])(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && Object(__WEBPACK_IMPORTED_MODULE_5__isLength__["a" /* default */])(length) && Object(__WEBPACK_IMPORTED_MODULE_3__isIndex__["a" /* default */])(key, length) &&
    (Object(__WEBPACK_IMPORTED_MODULE_2__isArray__["a" /* default */])(object) || Object(__WEBPACK_IMPORTED_MODULE_6__isString__["a" /* default */])(object) || Object(__WEBPACK_IMPORTED_MODULE_1__isArguments__["a" /* default */])(object));
}

/* harmony default export */ __webpack_exports__["a"] = (hasPath);


/***/ }),
/* 397 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseProperty__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__basePropertyDeep__ = __webpack_require__(398);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isKey__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__toKey__ = __webpack_require__(57);





/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__isKey__["a" /* default */])(path) ? Object(__WEBPACK_IMPORTED_MODULE_0__baseProperty__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_3__toKey__["a" /* default */])(path)) : Object(__WEBPACK_IMPORTED_MODULE_1__basePropertyDeep__["a" /* default */])(path);
}

/* harmony default export */ __webpack_exports__["a"] = (property);


/***/ }),
/* 398 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGet__ = __webpack_require__(141);


/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__baseGet__["a" /* default */])(object, path);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (basePropertyDeep);


/***/ }),
/* 399 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__toInteger__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toLength__ = __webpack_require__(400);



/**
 * The base implementation of `_.fill` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to fill.
 * @param {*} value The value to fill `array` with.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns `array`.
 */
function baseFill(array, value, start, end) {
  var length = array.length;

  start = Object(__WEBPACK_IMPORTED_MODULE_0__toInteger__["a" /* default */])(start);
  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = (end === undefined || end > length) ? length : Object(__WEBPACK_IMPORTED_MODULE_0__toInteger__["a" /* default */])(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : Object(__WEBPACK_IMPORTED_MODULE_1__toLength__["a" /* default */])(end);
  while (start < end) {
    array[start++] = value;
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (baseFill);


/***/ }),
/* 400 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseClamp__ = __webpack_require__(401);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger__ = __webpack_require__(12);



/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/**
 * Converts `value` to an integer suitable for use as the length of an
 * array-like object.
 *
 * **Note:** This method is based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toLength(3.2);
 * // => 3
 *
 * _.toLength(Number.MIN_VALUE);
 * // => 0
 *
 * _.toLength(Infinity);
 * // => 4294967295
 *
 * _.toLength('3.2');
 * // => 3
 */
function toLength(value) {
  return value ? Object(__WEBPACK_IMPORTED_MODULE_0__baseClamp__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_1__toInteger__["a" /* default */])(value), 0, MAX_ARRAY_LENGTH) : 0;
}

/* harmony default export */ __webpack_exports__["a"] = (toLength);


/***/ }),
/* 401 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

/* harmony default export */ __webpack_exports__["a"] = (baseClamp);


/***/ }),
/* 402 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isIndex__ = __webpack_require__(36);


/**
 * The base implementation of `_.nth` which doesn't coerce `n` to an integer.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {number} n The index of the element to return.
 * @returns {*} Returns the nth element of `array`.
 */
function baseNth(array, n) {
  var length = array.length;
  if (!length) {
    return;
  }
  n += n < 0 ? length : 0;
  return Object(__WEBPACK_IMPORTED_MODULE_0__isIndex__["a" /* default */])(n, length) ? array[n] : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (baseNth);


/***/ }),
/* 403 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This function is like `baseIndexOf` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (comparator(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (baseIndexOfWith);


/***/ }),
/* 404 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__get__ = __webpack_require__(197);


/**
 * The base implementation of `_.at` without support for individual paths.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {string[]} paths The property paths of elements to pick.
 * @returns {Array} Returns the picked elements.
 */
function baseAt(object, paths) {
  var index = -1,
      isNil = object == null,
      length = paths.length,
      result = Array(length);

  while (++index < length) {
    result[index] = isNil ? undefined : Object(__WEBPACK_IMPORTED_MODULE_0__get__["a" /* default */])(object, paths[index]);
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseAt);


/***/ }),
/* 405 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGet__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseSlice__ = __webpack_require__(41);



/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length == 1 ? object : Object(__WEBPACK_IMPORTED_MODULE_0__baseGet__["a" /* default */])(object, Object(__WEBPACK_IMPORTED_MODULE_1__baseSlice__["a" /* default */])(path, 0, -1));
}

/* harmony default export */ __webpack_exports__["a"] = (parent);


/***/ }),
/* 406 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isSymbol__ = __webpack_require__(45);


/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = Object(__WEBPACK_IMPORTED_MODULE_0__isSymbol__["a" /* default */])(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = Object(__WEBPACK_IMPORTED_MODULE_0__isSymbol__["a" /* default */])(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

/* harmony default export */ __webpack_exports__["a"] = (compareAscending);


/***/ }),
/* 407 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Set__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__noop__ = __webpack_require__(408);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__setToArray__ = __webpack_require__(88);




/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(__WEBPACK_IMPORTED_MODULE_0__Set__["a" /* default */] && (1 / Object(__WEBPACK_IMPORTED_MODULE_2__setToArray__["a" /* default */])(new __WEBPACK_IMPORTED_MODULE_0__Set__["a" /* default */]([,-0]))[1]) == INFINITY) ? __WEBPACK_IMPORTED_MODULE_1__noop__["a" /* default */] : function(values) {
  return new __WEBPACK_IMPORTED_MODULE_0__Set__["a" /* default */](values);
};

/* harmony default export */ __webpack_exports__["a"] = (createSet);


/***/ }),
/* 408 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A no-operation function that returns `undefined` regardless of the
 * arguments it receives.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.noop(object) === undefined;
 * // => true
 */
function noop() {
  // No operation performed.
}

/* harmony default export */ __webpack_exports__["a"] = (noop);


/***/ }),
/* 409 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assignValue__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__castPath__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isIndex__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isKey__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isObject__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__toKey__ = __webpack_require__(57);







/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  path = Object(__WEBPACK_IMPORTED_MODULE_3__isKey__["a" /* default */])(path, object) ? [path] : Object(__WEBPACK_IMPORTED_MODULE_1__castPath__["a" /* default */])(path);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = Object(__WEBPACK_IMPORTED_MODULE_5__toKey__["a" /* default */])(path[index]);
    if (Object(__WEBPACK_IMPORTED_MODULE_4__isObject__["a" /* default */])(nested)) {
      var newValue = value;
      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = objValue == null
            ? (Object(__WEBPACK_IMPORTED_MODULE_2__isIndex__["a" /* default */])(path[index + 1]) ? [] : {})
            : objValue;
        }
      }
      Object(__WEBPACK_IMPORTED_MODULE_0__assignValue__["a" /* default */])(nested, key, newValue);
    }
    nested = nested[key];
  }
  return object;
}

/* harmony default export */ __webpack_exports__["a"] = (baseSet);


/***/ }),
/* 410 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__chunk__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__compact__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__concat__ = __webpack_require__(191);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__difference__ = __webpack_require__(192);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__differenceBy__ = __webpack_require__(194);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__differenceWith__ = __webpack_require__(199);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__drop__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__dropRight__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__dropRightWhile__ = __webpack_require__(200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__dropWhile__ = __webpack_require__(201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__fill__ = __webpack_require__(202);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__findIndex__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__findLastIndex__ = __webpack_require__(205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__first__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__flatten__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__flattenDeep__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__flattenDepth__ = __webpack_require__(209);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__fromPairs__ = __webpack_require__(210);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__head__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__indexOf__ = __webpack_require__(211);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__initial__ = __webpack_require__(212);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__intersection__ = __webpack_require__(213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__intersectionBy__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__intersectionWith__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__join__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__last__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__lastIndexOf__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__nth__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__pull__ = __webpack_require__(219);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__pullAll__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__pullAllBy__ = __webpack_require__(220);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__pullAllWith__ = __webpack_require__(221);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__pullAt__ = __webpack_require__(222);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__remove__ = __webpack_require__(224);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__reverse__ = __webpack_require__(225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__slice__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__sortedIndex__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__sortedIndexBy__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__sortedIndexOf__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__sortedLastIndex__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__sortedLastIndexBy__ = __webpack_require__(231);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__sortedLastIndexOf__ = __webpack_require__(232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__sortedUniq__ = __webpack_require__(233);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__sortedUniqBy__ = __webpack_require__(235);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__tail__ = __webpack_require__(236);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__take__ = __webpack_require__(237);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__takeRight__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__takeRightWhile__ = __webpack_require__(239);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__takeWhile__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__union__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__unionBy__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__unionWith__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__uniq__ = __webpack_require__(244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__uniqBy__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__uniqWith__ = __webpack_require__(246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__unzip__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__unzipWith__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__without__ = __webpack_require__(247);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__xor__ = __webpack_require__(248);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__xorBy__ = __webpack_require__(249);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__xorWith__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__zip__ = __webpack_require__(251);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__zipObject__ = __webpack_require__(252);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__zipObjectDeep__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__zipWith__ = __webpack_require__(255);


































































/* harmony default export */ __webpack_exports__["a"] = ({
  chunk: __WEBPACK_IMPORTED_MODULE_0__chunk__["a" /* default */], compact: __WEBPACK_IMPORTED_MODULE_1__compact__["a" /* default */], concat: __WEBPACK_IMPORTED_MODULE_2__concat__["a" /* default */], difference: __WEBPACK_IMPORTED_MODULE_3__difference__["a" /* default */], differenceBy: __WEBPACK_IMPORTED_MODULE_4__differenceBy__["a" /* default */],
  differenceWith: __WEBPACK_IMPORTED_MODULE_5__differenceWith__["a" /* default */], drop: __WEBPACK_IMPORTED_MODULE_6__drop__["a" /* default */], dropRight: __WEBPACK_IMPORTED_MODULE_7__dropRight__["a" /* default */], dropRightWhile: __WEBPACK_IMPORTED_MODULE_8__dropRightWhile__["a" /* default */], dropWhile: __WEBPACK_IMPORTED_MODULE_9__dropWhile__["a" /* default */],
  fill: __WEBPACK_IMPORTED_MODULE_10__fill__["a" /* default */], findIndex: __WEBPACK_IMPORTED_MODULE_11__findIndex__["a" /* default */], findLastIndex: __WEBPACK_IMPORTED_MODULE_12__findLastIndex__["a" /* default */], first: __WEBPACK_IMPORTED_MODULE_13__first__["a" /* default */], flatten: __WEBPACK_IMPORTED_MODULE_14__flatten__["a" /* default */],
  flattenDeep: __WEBPACK_IMPORTED_MODULE_15__flattenDeep__["a" /* default */], flattenDepth: __WEBPACK_IMPORTED_MODULE_16__flattenDepth__["a" /* default */], fromPairs: __WEBPACK_IMPORTED_MODULE_17__fromPairs__["a" /* default */], head: __WEBPACK_IMPORTED_MODULE_18__head__["a" /* default */], indexOf: __WEBPACK_IMPORTED_MODULE_19__indexOf__["a" /* default */],
  initial: __WEBPACK_IMPORTED_MODULE_20__initial__["a" /* default */], intersection: __WEBPACK_IMPORTED_MODULE_21__intersection__["a" /* default */], intersectionBy: __WEBPACK_IMPORTED_MODULE_22__intersectionBy__["a" /* default */], intersectionWith: __WEBPACK_IMPORTED_MODULE_23__intersectionWith__["a" /* default */], join: __WEBPACK_IMPORTED_MODULE_24__join__["a" /* default */],
  last: __WEBPACK_IMPORTED_MODULE_25__last__["a" /* default */], lastIndexOf: __WEBPACK_IMPORTED_MODULE_26__lastIndexOf__["a" /* default */], nth: __WEBPACK_IMPORTED_MODULE_27__nth__["a" /* default */], pull: __WEBPACK_IMPORTED_MODULE_28__pull__["a" /* default */], pullAll: __WEBPACK_IMPORTED_MODULE_29__pullAll__["a" /* default */],
  pullAllBy: __WEBPACK_IMPORTED_MODULE_30__pullAllBy__["a" /* default */], pullAllWith: __WEBPACK_IMPORTED_MODULE_31__pullAllWith__["a" /* default */], pullAt: __WEBPACK_IMPORTED_MODULE_32__pullAt__["a" /* default */], remove: __WEBPACK_IMPORTED_MODULE_33__remove__["a" /* default */], reverse: __WEBPACK_IMPORTED_MODULE_34__reverse__["a" /* default */],
  slice: __WEBPACK_IMPORTED_MODULE_35__slice__["a" /* default */], sortedIndex: __WEBPACK_IMPORTED_MODULE_36__sortedIndex__["a" /* default */], sortedIndexBy: __WEBPACK_IMPORTED_MODULE_37__sortedIndexBy__["a" /* default */], sortedIndexOf: __WEBPACK_IMPORTED_MODULE_38__sortedIndexOf__["a" /* default */], sortedLastIndex: __WEBPACK_IMPORTED_MODULE_39__sortedLastIndex__["a" /* default */],
  sortedLastIndexBy: __WEBPACK_IMPORTED_MODULE_40__sortedLastIndexBy__["a" /* default */], sortedLastIndexOf: __WEBPACK_IMPORTED_MODULE_41__sortedLastIndexOf__["a" /* default */], sortedUniq: __WEBPACK_IMPORTED_MODULE_42__sortedUniq__["a" /* default */], sortedUniqBy: __WEBPACK_IMPORTED_MODULE_43__sortedUniqBy__["a" /* default */], tail: __WEBPACK_IMPORTED_MODULE_44__tail__["a" /* default */],
  take: __WEBPACK_IMPORTED_MODULE_45__take__["a" /* default */], takeRight: __WEBPACK_IMPORTED_MODULE_46__takeRight__["a" /* default */], takeRightWhile: __WEBPACK_IMPORTED_MODULE_47__takeRightWhile__["a" /* default */], takeWhile: __WEBPACK_IMPORTED_MODULE_48__takeWhile__["a" /* default */], union: __WEBPACK_IMPORTED_MODULE_49__union__["a" /* default */],
  unionBy: __WEBPACK_IMPORTED_MODULE_50__unionBy__["a" /* default */], unionWith: __WEBPACK_IMPORTED_MODULE_51__unionWith__["a" /* default */], uniq: __WEBPACK_IMPORTED_MODULE_52__uniq__["a" /* default */], uniqBy: __WEBPACK_IMPORTED_MODULE_53__uniqBy__["a" /* default */], uniqWith: __WEBPACK_IMPORTED_MODULE_54__uniqWith__["a" /* default */],
  unzip: __WEBPACK_IMPORTED_MODULE_55__unzip__["a" /* default */], unzipWith: __WEBPACK_IMPORTED_MODULE_56__unzipWith__["a" /* default */], without: __WEBPACK_IMPORTED_MODULE_57__without__["a" /* default */], xor: __WEBPACK_IMPORTED_MODULE_58__xor__["a" /* default */], xorBy: __WEBPACK_IMPORTED_MODULE_59__xorBy__["a" /* default */],
  xorWith: __WEBPACK_IMPORTED_MODULE_60__xorWith__["a" /* default */], zip: __WEBPACK_IMPORTED_MODULE_61__zip__["a" /* default */], zipObject: __WEBPACK_IMPORTED_MODULE_62__zipObject__["a" /* default */], zipObjectDeep: __WEBPACK_IMPORTED_MODULE_63__zipObjectDeep__["a" /* default */], zipWith: __WEBPACK_IMPORTED_MODULE_64__zipWith__["a" /* default */]
});


/***/ }),
/* 411 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__delta__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__deltafactory__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__batch__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__operation_markeroperation__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/delta/markerdelta
 */







/**
 * To provide specific OT behavior and better collisions solving, the {@link module:engine/model/batch~Batch#setMarker Batch#setMarker}
 * and {@link module:engine/model/batch~Batch#removeMarker Batch#removeMarker} methods use the `MarkerDelta` class which inherits
 * from the `Delta` class and may overwrite some methods.
 *
 * @extends module:engine/model/delta/delta~Delta
 */
class MarkerDelta extends __WEBPACK_IMPORTED_MODULE_0__delta__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	get type() {
		return 'marker';
	}

	/**
	 * A class that will be used when creating reversed delta.
	 *
	 * @private
	 * @type {Function}
	 */
	get _reverseDeltaClass() {
		return MarkerDelta;
	}

	/**
	 * @inheritDoc
	 */
	static get className() {
		return 'engine.model.delta.MarkerDelta';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MarkerDelta;


/**
 * Adds or updates {@link module:engine/model/markercollection~Marker marker} with given name to given `range`.
 *
 * If passed name is a name of already existing marker (or {@link module:engine/model/markercollection~Marker Marker} instance
 * is passed), `range` parameter may be omitted. In this case marker will not be updated in
 * {@link module:engine/model/document~Document#markers document marker collection}. However the marker will be added to
 * the document history. This may be important for other features, like undo. From document history point of view, it will
 * look like the marker was created and added to the document at the moment when it is set using this method.
 *
 * This is useful if the marker is created before it can be added to document history (e.g. a feature creating the marker
 * is waiting for additional data, etc.). In this case, the marker may be first created directly through
 * {@link module:engine/model/markercollection~MarkerCollection MarkerCollection API} and only later added using `Batch` API.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#setMarker
 * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to add or update.
 * @param {module:engine/model/range~Range} [newRange] Marker range.
 */
Object(__WEBPACK_IMPORTED_MODULE_2__batch__["b" /* register */])( 'setMarker', function( markerOrName, newRange ) {
	const name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;
	const currentMarker = this.document.markers.get( name );

	if ( !newRange && !currentMarker ) {
		/**
		 * Range parameter is required when adding a new marker.
		 *
		 * @error batch-setMarker-no-range
		 */
		throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-setMarker-no-range: Range parameter is required when adding a new marker.' );
	}

	const currentRange = currentMarker ? currentMarker.getRange() : null;

	if ( !newRange ) {
		// If `newRange` is not given, treat this as synchronizing existing marker.
		// Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.
		addOperation( this, name, null, currentRange );
	} else {
		// Just change marker range.
		addOperation( this, name, currentRange, newRange );
	}

	return this;
} );

/**
 * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.
 *
 * @chainable
 * @method module:engine/model/batch~Batch#removeMarker
 * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.
 */
Object(__WEBPACK_IMPORTED_MODULE_2__batch__["b" /* register */])( 'removeMarker', function( markerOrName ) {
	const name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;

	if ( !this.document.markers.has( name ) ) {
		/**
		 * Trying to remove marker which does not exist.
		 *
		 * @error batch-removeMarker-no-marker
		 */
		throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'batch-removeMarker-no-marker: Trying to remove marker which does not exist.' );
	}

	const oldRange = this.document.markers.get( name ).getRange();

	addOperation( this, name, oldRange, null );

	return this;
} );

function addOperation( batch, name, oldRange, newRange ) {
	const doc = batch.document;
	const delta = new MarkerDelta();

	const operation = new __WEBPACK_IMPORTED_MODULE_3__operation_markeroperation__["a" /* default */]( name, oldRange, newRange, doc.markers, doc.version );

	batch.addDelta( delta );
	delta.addOperation( operation );
	doc.applyOperation( operation );
}

__WEBPACK_IMPORTED_MODULE_1__deltafactory__["a" /* default */].register( MarkerDelta );


/***/ }),
/* 412 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__element__ = __webpack_require__(5);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/rootelement
 */



/**
 * Type of {@link module:engine/model/element~Element} that is a root of a model tree.
 * @extends module:engine/model/element~Element
 */
class RootElement extends __WEBPACK_IMPORTED_MODULE_0__element__["a" /* default */] {
	/**
	 * Creates root element.
	 *
	 * @param {module:engine/model/document~Document} doc Document that is an owner of this root.
	 * @param {String} name Node name.
	 * @param {String} [rootName='main'] Unique root name used to identify this root
	 * element by {@link module:engine/model/document~Document}.
	 */
	constructor( doc, name, rootName = 'main' ) {
		super( name );

		/**
		 * Document that is an owner of this root.
		 *
		 * @private
		 * @member {module:engine/model/document~Document}
		 */
		this._doc = doc;

		/**
		 * Unique root name used to identify this root element by {@link module:engine/model/document~Document}.
		 *
		 * @readonly
		 * @member {String}
		 */
		this.rootName = rootName;
	}

	/**
	 * {@link module:engine/model/document~Document Document} that owns this root element.
	 *
	 * In contrary, to {@link module:engine/model/node~Node node}, root element always have a `document`.
	 *
	 * @readonly
	 * @type {module:engine/model/document~Document|null}
	 */
	get document() {
		return this._doc;
	}

	/**
	 * @inheritDoc
	 */
	is( type, name ) {
		if ( !name ) {
			return type == 'rootElement' || super.is( type );
		} else {
			return ( type == 'rootElement' && name == this.name ) || super.is( type, name );
		}
	}

	/**
	 * Converts `RootElement` instance to `String` containing it's name.
	 *
	 * @returns {String} `RootElement` instance converted to `String`.
	 */
	toJSON() {
		return this.rootName;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RootElement;



/***/ }),
/* 413 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/history
 */



/**
 * `History` keeps the track of all the deltas applied to the {@link module:engine/model/document~Document document}.
 */
class History {
	/**
	 * Creates an empty History instance.
	 */
	constructor() {
		/**
		 * Deltas added to the history.
		 *
		 * @protected
		 * @member {Array.<module:engine/model/delta/delta~Delta>} module:engine/model/history~History#_deltas
		 */
		this._deltas = [];

		/**
		 * Helper structure that maps added delta's base version to the index in {@link module:engine/model/history~History#_deltas}
		 * at which the delta was added.
		 *
		 * @protected
		 * @member {Map} module:engine/model/history~History#_historyPoints
		 */
		this._historyPoints = new Map();

		/**
		 * Holds an information which {@link module:engine/model/delta/delta~Delta delta} undoes which
		 * {@link module:engine/model/delta/delta~Delta delta}.
		 *
		 * Keys of the map are "undoing deltas", that is deltas that undone some other deltas. For each key, the
		 * value is a delta that has been undone by the "undoing delta".
		 *
		 * @private
		 * @member {Map} module:engine/model/history~History#_undoPairs
		 */
		this._undoPairs = new Map();

		/**
		 * Holds all undone deltas.
		 *
		 * @private
		 * @member {Set.<module:engine/model/delta/delta~Delta>} module:engine/model/history~History#_undoneDeltas
		 */
		this._undoneDeltas = new Set();
	}

	/**
	 * Adds delta to the history.
	 *
	 * @param {module:engine/model/delta/delta~Delta} delta Delta to add.
	 */
	addDelta( delta ) {
		if ( delta.operations.length > 0 && !this._historyPoints.has( delta.baseVersion ) ) {
			const index = this._deltas.length;

			this._deltas[ index ] = delta;
			this._historyPoints.set( delta.baseVersion, index );
		}
	}

	/**
	 * Returns deltas added to the history.
	 *
	 * @param {Number} [from=0] Base version from which deltas should be returned (inclusive). Defaults to `0`, which means
	 * that deltas from the first one will be returned.
	 * @param {Number} [to=Number.POSITIVE_INFINITY] Base version up to which deltas should be returned (exclusive).
	 * Defaults to `Number.POSITIVE_INFINITY` which means that deltas up to the last one will be returned.
	 * @returns {Iterator.<module:engine/model/delta/delta~Delta>} Deltas added to the history from given base versions range.
	 */
	* getDeltas( from = 0, to = Number.POSITIVE_INFINITY ) {
		// No deltas added, nothing to yield.
		if ( this._deltas.length === 0 ) {
			return;
		}

		// Will throw if base version is incorrect.
		let fromIndex = this._getIndex( from );

		// Base version is too low or too high and is not found in history.
		if ( fromIndex == -1 ) {
			return;
		}

		// We have correct `fromIndex` so let's iterate starting from it.
		while ( fromIndex < this._deltas.length ) {
			const delta = this._deltas[ fromIndex++ ];

			if ( delta.baseVersion >= to ) {
				break;
			}

			yield delta;
		}
	}

	/**
	 * Returns delta from history that bases on given `baseVersion`.
	 *
	 * @param {Number} baseVersion Base version of the delta to get.
	 * @returns {module:engine/model/delta/delta~Delta|null} Delta with given base version or `null` if there is no such delta in history.
	 */
	getDelta( baseVersion ) {
		const index = this._historyPoints.get( baseVersion );

		return index === undefined ? null : this._deltas[ index ];
	}

	/**
	 * Marks in history that one delta is a delta that is undoing the other delta. By marking deltas this way,
	 * history is keeping more context information about deltas which helps in operational transformation.
	 *
	 * @param {module:engine/model/delta/delta~Delta} undoneDelta Delta which is undone by `undoingDelta`.
	 * @param {module:engine/model/delta/delta~Delta} undoingDelta Delta which undoes `undoneDelta`.
	 */
	setDeltaAsUndone( undoneDelta, undoingDelta ) {
		this._undoPairs.set( undoingDelta, undoneDelta );
		this._undoneDeltas.add( undoneDelta );
	}

	/**
	 * Checks whether given `delta` is undoing by any other delta.
	 *
	 * @param {module:engine/model/delta/delta~Delta} delta Delta to check.
	 * @returns {Boolean} `true` if given `delta` is undoing any other delta, `false` otherwise.
	 */
	isUndoingDelta( delta ) {
		return this._undoPairs.has( delta );
	}

	/**
	 * Checks whether given `delta` has been undone by any other delta.
	 *
	 * @param {module:engine/model/delta/delta~Delta} delta Delta to check.
	 * @returns {Boolean} `true` if given `delta` has been undone any other delta, `false` otherwise.
	 */
	isUndoneDelta( delta ) {
		return this._undoneDeltas.has( delta );
	}

	/**
	 * For given `undoingDelta`, returns the delta which has been undone by it.
	 *
	 * @param {module:engine/model/delta/delta~Delta} undoingDelta
	 * @returns {module:engine/model/delta/delta~Delta|undefined} Delta that has been undone by given `undoingDelta` or `undefined`
	 * if given `undoingDelta` is not undoing any other delta.
	 */
	getUndoneDelta( undoingDelta ) {
		return this._undoPairs.get( undoingDelta );
	}

	/**
	 * Gets an index in {@link module:engine/model/history~History#_deltas} where delta with given `baseVersion` is added.
	 *
	 * @private
	 * @param {Number} baseVersion Base version of delta.
	 */
	_getIndex( baseVersion ) {
		const index = this._historyPoints.get( baseVersion );

		// Base version not found - it is either too high or too low, or is in the middle of delta.
		if ( index === undefined ) {
			const lastDelta = this._deltas[ this._deltas.length - 1 ];
			const nextBaseVersion = lastDelta.baseVersion + lastDelta.operations.length;

			if ( baseVersion < 0 || baseVersion >= nextBaseVersion ) {
				// Base version is too high or too low - it's acceptable situation.
				return -1;
			}

			/**
			 * Given base version points to the middle of a delta.
			 *
			 * @error history-wrong-version
			 */
			throw new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-history-wrong-version: Given base version points to the middle of a delta.' );
		}

		return index;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = History;



/***/ }),
/* 414 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = mapsEqual;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/mapsequal
 */

/**
 * Checks whether given {Map}s are equal, that is has same size and same key-value pairs.
 *
 * @returns {Boolean} `true` if given maps are equal, `false` otherwise.
 */
function mapsEqual( mapA, mapB ) {
	if ( mapA.size != mapB.size ) {
		return false;
	}

	for ( const attr of mapA.entries() ) {
		const valA = JSON.stringify( attr[ 1 ] );
		const valB = JSON.stringify( mapB.get( attr[ 0 ] ) );

		if ( valA !== valB ) {
			return false;
		}
	}

	return true;
}


/***/ }),
/* 415 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__documentselection__ = __webpack_require__(256);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_lib_lodash_clone__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_lib_lodash_isArray__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_lib_lodash_isString__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/schema
 */










/**
 * Schema is a definition of the structure of the document. It allows to define which tree model items (element, text, etc.)
 * can be nested within which ones and which attributes can be applied to them. It's created during the run-time of the application,
 * typically by features. Also, the features can query the schema to learn what structure is allowed and act accordingly.
 *
 * For instance, if a feature wants to define that an attribute bold is allowed on the text it needs to register this rule like this:
 *
 *		editor.document.schema.allow( '$text', 'bold' );
 *
 * Note: items prefixed with `$` are special group of items. By default, `Schema` defines three special items:
 *
 * * `$inline` represents all inline elements,
 * * `$text` is a sub-group of `$inline` and represents text nodes,
 * * `$block` represents block elements,
 * * `$root` represents default editing roots (those that allow only `$block`s inside them).
 *
 * When registering an item it's possible to tell that this item should inherit from some other existing item.
 * E.g. `p` can inherit from `$block`, so whenever given attribute is allowed on the `$block` it will automatically be
 * also allowed on the `p` element. By default, `$text` item already inherits from `$inline`.
 */
class Schema {
	/**
	 * Creates Schema instance.
	 */
	constructor() {
		/**
		 * Names of elements which have "object" nature. This means that these
		 * elements should be treated as whole, never merged, can be selected from outside, etc.
		 * Just like images, placeholder widgets, etc.
		 *
		 * @member {Set.<String>} module:engine/model/schema~Schema#objects
		 */
		this.objects = new Set();

		/**
		 * Names of elements to which editing operations should be limited.
		 * For example, the <kbd>Enter</kbd> should not split such elements and
		 * <kbd>Backspace</kbd> should not be able to leave or modify such elements.
		 *
		 * @member {Set.<String>} module:engine/model/schema~Schema#limits
		 */
		this.limits = new Set();

		/**
		 * Schema items registered in the schema.
		 *
		 * @private
		 * @member {Map} module:engine/model/schema~Schema#_items
		 */
		this._items = new Map();

		/**
		 * Description of what entities are a base for given entity.
		 *
		 * @private
		 * @member {Map} module:engine/model/schema~Schema#_extensionChains
		 */
		this._extensionChains = new Map();

		// Register some default abstract entities.
		this.registerItem( '$root' );
		this.registerItem( '$block' );
		this.registerItem( '$inline' );
		this.registerItem( '$text', '$inline' );

		this.allow( { name: '$block', inside: '$root' } );
		this.allow( { name: '$inline', inside: '$block' } );

		this.limits.add( '$root' );

		// TMP!
		// Create an "all allowed" context in the schema for processing the pasted content.
		// Read: https://github.com/ckeditor/ckeditor5-engine/issues/638#issuecomment-255086588

		this.registerItem( '$clipboardHolder', '$root' );
		this.allow( { name: '$inline', inside: '$clipboardHolder' } );
	}

	/**
	 * Allows given query in the schema.
	 *
	 *		// Allow text with bold attribute in all P elements.
	 *		schema.registerItem( 'p', '$block' );
	 *		schema.allow( { name: '$text', attributes: 'bold', inside: 'p' } );
	 *
	 *		// Allow header in Ps that are in DIVs
	 *		schema.registerItem( 'header', '$block' );
	 *		schema.registerItem( 'div', '$block' );
	 *		schema.allow( { name: 'header', inside: 'div p' } ); // inside: [ 'div', 'p' ] would also work.
	 *
	 * @param {module:engine/model/schema~SchemaQuery} query Allowed query.
	 */
	allow( query ) {
		this._getItem( query.name ).allow( Schema._normalizeQueryPath( query.inside ), query.attributes );
	}

	/**
	 * Disallows given query in the schema.
	 *
	 * @see #allow
	 * @param {module:engine/model/schema~SchemaQuery} query Disallowed query.
	 */
	disallow( query ) {
		this._getItem( query.name ).disallow( Schema._normalizeQueryPath( query.inside ), query.attributes );
	}

	/**
	 * Makes a requirement in schema that entity represented by given item has to have given set of attributes. Some
	 * elements in the model might require some attributes to be set. If multiple sets of attributes are required it
	 * is enough that the entity fulfills only one set.
	 *
	 *		// "a" element must either have "href" attribute or "name" attribute
	 *		schema.requireAttributes( 'a', [ 'href' ] );
	 *		schema.requireAttributes( 'a', [ 'name' ] );
	 *		// "img" element must have both "src" and "alt" attributes
	 *		schema.requireAttributes( 'img', [ 'src', 'alt' ] );
	 *
	 * @param {String} name Entity name.
	 * @param {Array.<String>} attributes Attributes that has to be set on the entity to make it valid.
	 */
	requireAttributes( name, attributes ) {
		this._getItem( name ).requireAttributes( attributes );
	}

	/**
	 * Checks whether given query is allowed in schema.
	 *
	 *		// Check whether bold text is allowed in header element.
	 *		let query = {
	 *			name: '$text',
	 *			attributes: 'bold',
	 *			inside: 'header'
	 *		};
	 *		if ( schema.check( query ) ) { ... }
	 *
	 *		// Check whether bold and italic text can be placed at caret position.
	 *		let caretPos = editor.document.selection.getFirstPosition();
	 *		let query = {
	 *			name: '$text',
	 *			attributes: [ 'bold', 'italic' ],
	 *			inside: caretPos
	 *		};
	 *		if ( schema.check( query ) ) { ... }
	 *
	 *		// Check whether image with alt, src and title is allowed in given elements path.
	 *		let quoteElement = new Element( 'quote' );
	 *		let query = {
	 *			name: 'img',
	 *			attributes: [ 'alt', 'src', 'title' ],
	 *			// It is possible to mix strings with elements.
	 *			// Query will check whether "img" can be inside "quoteElement" that is inside a block element.
	 *			inside: [ '$block', quoteElement ]
	 *		};
	 *		if ( schema.check( query ) ) { ... }
	 *
	 * @param {module:engine/model/schema~SchemaQuery} query Query to check.
	 * @returns {Boolean} `true` if given query is allowed in schema, `false` otherwise.
	 */
	check( query ) {
		if ( !this.hasItem( query.name ) ) {
			return false;
		}

		// If attributes property is a string or undefined, wrap it in an array for easier processing.
		if ( !Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_lib_lodash_isArray__["a" /* default */])( query.attributes ) ) {
			query.attributes = [ query.attributes ];
		} else if ( query.attributes.length === 0 ) {
			// To simplify algorithms, when a SchemaItem path is added "without" attribute, it is added with
			// attribute equal to undefined. This means that algorithms can work the same way for specified attributes
			// and no-atrtibutes, but we have to fill empty array with "fake" undefined value for algorithms reasons.
			query.attributes.push( undefined );
		}

		// Normalize the path to an array of strings.
		const path = Schema._normalizeQueryPath( query.inside );

		// Get extension chain of given item and retrieve all schema items that are extended by given item.
		const schemaItems = this._extensionChains.get( query.name ).map( name => {
			return this._getItem( name );
		} );

		// First check if the query meets at required attributes for this item.
		if ( !this._getItem( query.name )._checkRequiredAttributes( query.attributes ) ) {
			return false;
		}

		// If there is matching disallow path, this query is not valid with schema.
		for ( const attribute of query.attributes ) {
			for ( const schemaItem of schemaItems ) {
				if ( schemaItem._hasMatchingPath( 'disallow', path, attribute ) ) {
					return false;
				}
			}
		}

		// At this point, the query is not disallowed.
		// If there are correct allow paths that match the query, this query is valid with schema.
		// Since we are supporting multiple attributes, we have to make sure that if attributes are set,
		// we have allowed paths for all of them.
		// Keep in mind that if the query has no attributes, query.attribute was converted to an array
		// with a single `undefined` value. This fits the algorithm well.
		for ( const attribute of query.attributes ) {
			// Skip all attributes that are stored in elements.
			// This isn't perfect solution but we have to deal with it for now.
			// `attribute` may have `undefined` value.
			if ( attribute && __WEBPACK_IMPORTED_MODULE_3__documentselection__["a" /* default */]._isStoreAttributeKey( attribute ) ) {
				continue;
			}

			let matched = false;

			for ( const schemaItem of schemaItems ) {
				if ( schemaItem._hasMatchingPath( 'allow', path, attribute ) ) {
					matched = true;
					break;
				}
			}

			// The attribute has not been matched, so it is not allowed by any schema item.
			// The query is disallowed.
			if ( !matched ) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Checks whether there is an item registered under given name in schema.
	 *
	 * @param itemName
	 * @returns {Boolean}
	 */
	hasItem( itemName ) {
		return this._items.has( itemName );
	}

	/**
	 * Registers given item name in schema.
	 *
	 *		// Register P element that should be treated like all block elements.
	 *		schema.registerItem( 'p', '$block' );
	 *
	 * @param {String} itemName Name to register.
	 * @param [isExtending] If set, new item will extend item with given name.
	 */
	registerItem( itemName, isExtending ) {
		if ( this.hasItem( itemName ) ) {
			/**
			 * Item with specified name already exists in schema.
			 *
			 * @error model-schema-item-exists
			 */
			throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-schema-item-exists: Item with specified name already exists in schema.' );
		}

		if ( !!isExtending && !this.hasItem( isExtending ) ) {
			throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-schema-no-item: Item with specified name does not exist in schema.' );
		}

		// Create new SchemaItem and add it to the items store.
		this._items.set( itemName, new SchemaItem( this ) );

		// Create an extension chain.
		// Extension chain has all item names that should be checked when that item is on path to check.
		// This simply means, that if item is not extending anything, it should have only itself in it's extension chain.
		// Since extending is not dynamic, we can simply get extension chain of extended item and expand it with registered name,
		// if the registered item is extending something.
		const chain = this.hasItem( isExtending ) ? this._extensionChains.get( isExtending ).concat( itemName ) : [ itemName ];
		this._extensionChains.set( itemName, chain );
	}

	/**
	 * Checks whether item of given name is extending item of another given name.
	 *
	 * @param {String} childItemName Name of the child item.
	 * @param {String} parentItemName Name of the parent item.
	 * @returns {Boolean} `true` if child item extends parent item, `false` otherwise.
	 */
	itemExtends( childItemName, parentItemName ) {
		if ( !this.hasItem( childItemName ) || !this.hasItem( parentItemName ) ) {
			throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-schema-no-item: Item with specified name does not exist in schema.' );
		}

		const chain = this._extensionChains.get( childItemName );

		return chain.some( itemName => itemName == parentItemName );
	}

	/**
	 * Checks whether the attribute is allowed in selection:
	 *
	 * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,
	 * * if the selection is collapsed, then checks if on the selection position there's a text with the
	 * specified attribute allowed.
	 *
	 * @param {module:engine/model/selection~Selection} selection Selection which will be checked.
	 * @param {String} attribute The name of the attribute to check.
	 * @returns {Boolean}
	 */
	checkAttributeInSelection( selection, attribute ) {
		if ( selection.isCollapsed ) {
			// Check whether schema allows for a text with the attribute in the selection.
			return this.check( { name: '$text', inside: selection.getFirstPosition(), attributes: attribute } );
		} else {
			const ranges = selection.getRanges();

			// For all ranges, check nodes in them until you find a node that is allowed to have the attribute.
			for ( const range of ranges ) {
				for ( const value of range ) {
					// If returned item does not have name property, it is a TextFragment.
					const name = value.item.name || '$text';

					// Attribute should be checked together with existing attributes.
					// See https://github.com/ckeditor/ckeditor5-engine/issues/1110.
					const attributes = Array.from( value.item.getAttributeKeys() ).concat( attribute );

					if ( this.check( { name, inside: value.previousPosition, attributes } ) ) {
						// If we found a node that is allowed to have the attribute, return true.
						return true;
					}
				}
			}
		}

		// If we haven't found such node, return false.
		return false;
	}

	/**
	 * Transforms the given set ranges into a set of ranges where the given attribute is allowed (and can be applied).
	 *
	 * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.
	 * @param {String} attribute The name of the attribute to check.
	 * @returns {Array.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.
	 */
	getValidRanges( ranges, attribute ) {
		const validRanges = [];

		for ( const range of ranges ) {
			let last = range.start;
			let from = range.start;
			const to = range.end;

			for ( const value of range.getWalker() ) {
				const name = value.item.name || '$text';
				const itemPosition = __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */].createBefore( value.item );

				if ( !this.check( { name, inside: itemPosition, attributes: attribute } ) ) {
					if ( !from.isEqual( last ) ) {
						validRanges.push( new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( from, last ) );
					}

					from = value.nextPosition;
				}

				last = value.nextPosition;
			}

			if ( from && !from.isEqual( to ) ) {
				validRanges.push( new __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */]( from, to ) );
			}
		}

		return validRanges;
	}

	/**
	 * Returns the lowest {@link module:engine/model/schema~Schema#limits limit element} containing the entire
	 * selection or the root otherwise.
	 *
	 * @param {module:engine/model/selection~Selection} selection Selection which returns the common ancestor.
	 * @returns {module:engine/model/element~Element}
	 */
	getLimitElement( selection ) {
		// Find the common ancestor for all selection's ranges.
		let element = Array.from( selection.getRanges() )
			.reduce( ( node, range ) => {
				if ( !node ) {
					return range.getCommonAncestor();
				}

				return node.getCommonAncestor( range.getCommonAncestor() );
			}, null );

		while ( !this.limits.has( element.name ) ) {
			if ( element.parent ) {
				element = element.parent;
			} else {
				break;
			}
		}

		return element;
	}

	/**
	 * Removes disallowed by {@link module:engine/model/schema~Schema schema} attributes from given nodes.
	 * When {@link module:engine/model/batch~Batch batch} parameter is provided then attributes will be removed
	 * using that batch, by creating {@link module:engine/model/delta/attributedelta~AttributeDelta attribute deltas}.
	 * Otherwise, attributes will be removed directly from provided nodes using {@link module:engine/model/node~Node node} API.
	 *
	 * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.
	 * @param {module:engine/model/schema~SchemaPath} inside Path inside which schema will be checked.
	 * @param {module:engine/model/batch~Batch} [batch] Batch to which the deltas will be added.
	 */
	removeDisallowedAttributes( nodes, inside, batch ) {
		for ( const node of nodes ) {
			const name = node.is( 'text' ) ? '$text' : node.name;
			const attributes = Array.from( node.getAttributeKeys() );
			const queryPath = Schema._normalizeQueryPath( inside );

			// When node with attributes is not allowed in current position.
			if ( !this.check( { name, attributes, inside: queryPath } ) ) {
				// Let's remove attributes one by one.
				// TODO: this should be improved to check all combination of attributes.
				for ( const attribute of node.getAttributeKeys() ) {
					if ( !this.check( { name, attributes: attribute, inside: queryPath } ) ) {
						if ( batch ) {
							batch.removeAttribute( node, attribute );
						} else {
							node.removeAttribute( attribute );
						}
					}
				}
			}

			if ( node.is( 'element' ) ) {
				this.removeDisallowedAttributes( node.getChildren(), queryPath.concat( node.name ), batch );
			}
		}
	}

	/**
	 * Returns {@link module:engine/model/schema~SchemaItem schema item} that was registered in the schema under given name.
	 * If item has not been found, throws error.
	 *
	 * @private
	 * @param {String} itemName Name to look for in schema.
	 * @returns {module:engine/model/schema~SchemaItem} Schema item registered under given name.
	 */
	_getItem( itemName ) {
		if ( !this.hasItem( itemName ) ) {
			throw new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'model-schema-no-item: Item with specified name does not exist in schema.' );
		}

		return this._items.get( itemName );
	}

	/**
	 * Normalizes a path to an entity by converting it from {@link module:engine/model/schema~SchemaPath} to an array of strings.
	 *
	 * @protected
	 * @param {module:engine/model/schema~SchemaPath} path Path to normalize.
	 * @returns {Array.<String>} Normalized path.
	 */
	static _normalizeQueryPath( path ) {
		let normalized = [];

		if ( Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_lib_lodash_isArray__["a" /* default */])( path ) ) {
			for ( const pathItem of path ) {
				if ( pathItem instanceof __WEBPACK_IMPORTED_MODULE_1__element__["a" /* default */] ) {
					normalized.push( pathItem.name );
				} else if ( Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_lib_lodash_isString__["a" /* default */])( pathItem ) ) {
					normalized.push( pathItem );
				}
			}
		} else if ( path instanceof __WEBPACK_IMPORTED_MODULE_0__position__["a" /* default */] ) {
			let parent = path.parent;

			while ( parent !== null ) {
				normalized.push( parent.name );
				parent = parent.parent;
			}

			normalized.reverse();
		} else if ( Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_lib_lodash_isString__["a" /* default */])( path ) ) {
			normalized = path.split( ' ' );
		}

		return normalized;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Schema;


/**
 * SchemaItem is a singular registry item in {@link module:engine/model/schema~Schema} that groups and holds allow/disallow rules for
 * one entity. This class is used internally in {@link module:engine/model/schema~Schema} and should not be used outside it.
 *
 * @see module:engine/model/schema~Schema
 * @protected
 */
class SchemaItem {
	/**
	 * Creates SchemaItem instance.
	 *
	 * @param {module:engine/model/schema~Schema} schema Schema instance that owns this item.
	 */
	constructor( schema ) {
		/**
		 * Schema instance that owns this item.
		 *
		 * @private
		 * @member {module:engine/model/schema~Schema} module:engine/model/schema~SchemaItem#_schema
		 */
		this._schema = schema;

		/**
		 * Paths in which the entity, represented by this item, is allowed.
		 *
		 * @private
		 * @member {Array} module:engine/model/schema~SchemaItem#_allowed
		 */
		this._allowed = [];

		/**
		 * Paths in which the entity, represented by this item, is disallowed.
		 *
		 * @private
		 * @member {Array} module:engine/model/schema~SchemaItem#_disallowed
		 */
		this._disallowed = [];

		/**
		 * Attributes that are required by the entity represented by this item.
		 *
		 * @protected
		 * @member {Array} module:engine/model/schema~SchemaItem#_requiredAttributes
		 */
		this._requiredAttributes = [];
	}

	/**
	 * Allows entity, represented by this item, to be in given path.
	 *
	 * @param {Array.<String>} path Path in which entity is allowed.
	 * @param {Array.<String>|String} [attributes] If set, this path will be used only for entities that have attribute(s) with this key.
	 */
	allow( path, attributes ) {
		this._addPath( '_allowed', path, attributes );
	}

	/**
	 * Disallows entity, represented by this item, to be in given path.
	 *
	 * @param {Array.<String>} path Path in which entity is disallowed.
	 * @param {Array.<String>|String} [attributes] If set, this path will be used only for entities that have an attribute(s) with this key.
	 */
	disallow( path, attributes ) {
		this._addPath( '_disallowed', path, attributes );
	}

	/**
	 * Specifies that the entity, to be valid, requires given attributes set. It is possible to register multiple
	 * different attributes set. If there are more than one attributes set required, the entity will be valid if
	 * at least one of them is fulfilled.
	 *
	 * @param {Array.<String>} attributes Attributes that has to be set on the entity to make it valid.
	 */
	requireAttributes( attributes ) {
		this._requiredAttributes.push( attributes );
	}

	/**
	 * Custom toJSON method to solve child-parent circular dependencies.
	 *
	 * @returns {Object} Clone of this object with the parent property replaced with its name.
	 */
	toJSON() {
		const json = Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_lib_lodash_clone__["a" /* default */])( this );

		// Due to circular references we need to remove parent reference.
		json._schema = '[model.Schema]';

		return json;
	}

	/**
	 * Adds path to the SchemaItem instance.
	 *
	 * @private
	 * @param {String} member Name of the array member into which the path will be added. Possible values are `_allowed` or `_disallowed`.
	 * @param {Array.<String>} path Path to add.
	 * @param {Array.<String>|String} [attributes] If set, this path will be used only for entities that have attribute(s) with this key.
	 */
	_addPath( member, path, attributes ) {
		path = path.slice();

		if ( !Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_lib_lodash_isArray__["a" /* default */])( attributes ) ) {
			attributes = [ attributes ];
		}

		for ( const attribute of attributes ) {
			this[ member ].push( { path, attribute } );
		}
	}

	/**
	 * Returns all paths of given type that were previously registered in the item.
	 *
	 * @private
	 * @param {String} type Paths' type. Possible values are `allow` or `disallow`.
	 * @param {String} [attribute] If set, only paths registered for given attribute will be returned.
	 * @returns {Array} Paths registered in the item.
	 */
	_getPaths( type, attribute ) {
		const source = type === 'allow' ? this._allowed : this._disallowed;
		const paths = [];

		for ( const item of source ) {
			if ( item.attribute === attribute ) {
				paths.push( item.path );
			}
		}

		return paths;
	}

	/**
	 * Checks whether given set of attributes fulfills required attributes of this item.
	 *
	 * @protected
	 * @see module:engine/model/schema~SchemaItem#requireAttributes
	 * @param {Array.<String>} attributesToCheck Attributes to check.
	 * @returns {Boolean} `true` if given set or attributes fulfills required attributes, `false` otherwise.
	 */
	_checkRequiredAttributes( attributesToCheck ) {
		let found = true;

		for ( const attributeSet of this._requiredAttributes ) {
			found = true;

			for ( const attribute of attributeSet ) {
				if ( attributesToCheck.indexOf( attribute ) == -1 ) {
					found = false;
					break;
				}
			}

			if ( found ) {
				break;
			}
		}

		return found;
	}

	/**
	 * Checks whether this item has any registered path of given type that matches the provided path.
	 *
	 * @protected
	 * @param {String} type Paths' type. Possible values are `allow` or `disallow`.
	 * @param {Array.<String>} pathToCheck Path to check.
	 * @param {String} [attribute] If set, only paths registered for given attribute will be checked.
	 * @returns {Boolean} `true` if item has any registered matching path, `false` otherwise.
	 */
	_hasMatchingPath( type, pathToCheck, attribute ) {
		const registeredPaths = this._getPaths( type, attribute );

		for ( const registeredPathPath of registeredPaths ) {
			if ( matchPaths( this._schema, pathToCheck, registeredPathPath ) ) {
				return true;
			}
		}

		return false;
	}
}
/* unused harmony export SchemaItem */


/**
 * Object with query used by {@link module:engine/model/schema~Schema} to query schema or add allow/disallow rules to schema.
 *
 * @typedef {Object} module:engine/model/schema~SchemaQuery
 * @property {String} name Entity name.
 * @property {module:engine/model/schema~SchemaPath} inside Path inside which the entity is placed.
 * @property {Array.<String>|String} [attributes] If set, the query applies only to entities that has attribute(s) with given key.
 */

/**
 * Path to an entity, begins from the top-most ancestor. Can be passed in multiple formats. Internally, normalized to
 * an array of strings. If string is passed, entities from the path should be divided by ` ` (space character). If
 * an array is passed, unrecognized items are skipped. If position is passed, it is assumed that the entity is at given position.
 *
 * @typedef {String|Array.<String|module:engine/model/element~Element>|module:engine/model/position~Position}
 * module:engine/model/schema~SchemaPath
 */

// Checks whether the given pathToCheck and registeredPath right ends match.
//
// pathToCheck: C, D
// registeredPath: A, B, C, D
// result: OK
//
// pathToCheck: A, B, C
// registeredPath: A, B, C, D
// result: NOK
//
// Note  when matching paths, element extension chains (inheritance) are taken into consideration.
//
// @param {Schema} schema
// @param {Array.<String>} pathToCheck
// @param {Array.<String>} registeredPath
function matchPaths( schema, pathToCheck, registeredPath ) {
	// Start checking from the right end of both tables.
	let registeredPathIndex = registeredPath.length - 1;
	let pathToCheckIndex = pathToCheck.length - 1;

	// And finish once reaching an end of the shorter table.
	while ( registeredPathIndex >= 0 && pathToCheckIndex >= 0 ) {
		const checkName = pathToCheck[ pathToCheckIndex ];

		// Fail when checking a path which contains element which aren't even registered to the schema.
		if ( !schema.hasItem( checkName ) ) {
			return false;
		}

		const extChain = schema._extensionChains.get( checkName );

		if ( extChain.includes( registeredPath[ registeredPathIndex ] ) ) {
			registeredPathIndex--;
			pathToCheckIndex--;
		} else {
			return false;
		}
	}

	return true;
}

/**
 * Item with specified name does not exist in schema.
 *
 * @error model-schema-no-item
 */


/***/ }),
/* 416 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__liverange__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/model/markercollection
 */








/**
 * Creates, stores and manages {@link ~Marker markers}.
 *
 * Markers are created by {@link ~MarkerCollection#set setting} a name for a {@link module:engine/model/liverange~LiveRange live range}
 * in `MarkerCollection`. Name is used to group and identify markers. Names have to be unique, but markers can be grouped by
 * using common prefixes, separated with `:`, for example: `user:john` or `search:3`.
 *
 * Since markers are based on {@link module:engine/model/liverange~LiveRange live ranges}, for efficiency reasons, it's
 * best to create and keep at least markers as possible.
 */
class MarkerCollection {
	/**
	 * Creates a markers collection.
	 */
	constructor() {
		/**
		 * Stores {@link ~Marker markers} added to the collection.
		 *
		 * @private
		 * @member {Map} #_markers
		 */
		this._markers = new Map();
	}

	/**
	 * Returns an iterator that iterates over all {@link ~Marker markers} added to the collection.
	 *
	 * @returns {Iterator}
	 */
	[ Symbol.iterator ]() {
		return this._markers.values();
	}

	/**
	 * Checks if marker with given `markerName` is in the collection.
	 *
	 * @param {String} markerName Marker name.
	 * @returns {Boolean} `true` if marker with given `markerName` is in the collection, `false` otherwise.
	 */
	has( markerName ) {
		return this._markers.has( markerName );
	}

	/**
	 * Returns {@link ~Marker marker} with given `markerName`.
	 *
	 * @param {String} markerName Name of marker to get.
	 * @returns {module:engine/model/markercollection~Marker|null} Marker with given name or `null` if such marker was
	 * not added to the collection.
	 */
	get( markerName ) {
		return this._markers.get( markerName ) || null;
	}

	/**
	 * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given
	 * {@link module:engine/model/range~Range range}.
	 *
	 * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed) and the range to
	 * set is different, the marker in collection is removed and then new marker is added. If the range was same, nothing
	 * happens and `false` is returned.
	 *
	 * @fires module:engine/model/markercollection~MarkerCollection#event:add
	 * @fires module:engine/model/markercollection~MarkerCollection#event:remove
	 * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker to add or Marker instance to update.
	 * @param {module:engine/model/range~Range} range Marker range.
	 * @returns {module:engine/model/markercollection~Marker} `Marker` instance added to the collection.
	 */
	set( markerOrName, range ) {
		const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
		const oldMarker = this._markers.get( markerName );

		if ( oldMarker ) {
			const oldRange = oldMarker.getRange();

			if ( oldRange.isEqual( range ) ) {
				return oldMarker;
			}

			this.remove( markerName );
		}

		const liveRange = __WEBPACK_IMPORTED_MODULE_0__liverange__["a" /* default */].createFromRange( range );
		const marker = new Marker( markerName, liveRange );

		this._markers.set( markerName, marker );
		this.fire( 'add:' + markerName, marker );

		return marker;
	}

	/**
	 * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.
	 *
	 * @param {String} markerOrName Marker or name of a marker to remove.
	 * @returns {Boolean} `true` if marker was found and removed, `false` otherwise.
	 */
	remove( markerOrName ) {
		const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
		const oldMarker = this._markers.get( markerName );

		if ( oldMarker ) {
			this._markers.delete( markerName );
			this.fire( 'remove:' + markerName, oldMarker );

			this._destroyMarker( oldMarker );

			return true;
		}

		return false;
	}

	/**
	 * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.
	 *
	 * @param {module:engine/model/position~Position} position
	 * @returns {Iterator.<module:engine/model/markercollection~Marker>}
	 */
	* getMarkersAtPosition( position ) {
		for ( const marker of this ) {
			if ( marker.getRange().containsPosition( position ) ) {
				yield marker;
			}
		}
	}

	/**
	 * Destroys marker collection and all markers inside it.
	 */
	destroy() {
		for ( const marker of this._markers.values() ) {
			this._destroyMarker( marker );
		}

		this._markers = null;

		this.stopListening();
	}

	/**
	 * Iterates over all markers that starts with given `prefix`.
	 *
	 *		const markerFooA = markersCollection.set( 'foo:a', rangeFooA );
	 *		const markerFooB = markersCollection.set( 'foo:b', rangeFooB );
	 *		const markerBarA = markersCollection.set( 'bar:a', rangeBarA );
	 *		const markerFooBarA = markersCollection.set( 'foobar:a', rangeFooBarA );
	 *		Array.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]
	 *		Array.from( markersCollection.getMarkersGroup( 'a' ) ); // []
	 *
	 * @param prefix
	 * @returns {Iterator.<module:engine/model/markercollection~Marker>}
	 */
	* getMarkersGroup( prefix ) {
		for ( const marker of this._markers.values() ) {
			if ( marker.name.startsWith( prefix + ':' ) ) {
				yield marker;
			}
		}
	}

	/**
	 * Destroys the marker.
	 *
	 * @private
	 * @param {module:engine/model/markercollection~Marker} marker Marker to destroy.
	 */
	_destroyMarker( marker ) {
		marker.stopListening();
		marker._liveRange.detach();
		marker._liveRange = null;
	}

	/**
	 * Fired whenever marker is added to `MarkerCollection`.
	 *
	 * @event add
	 * @param {module:engine/model/markercollection~Marker} The added marker.
	 */

	/**
	 * Fired whenever marker is removed from `MarkerCollection`.
	 *
	 * @event remove
	 * @param {module:engine/model/markercollection~Marker} marker The removed marker.
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MarkerCollection;


Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( MarkerCollection, __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

/**
 * `Marker` is a continuous parts of model (like a range), is named and represent some kind of information about marked
 * part of model document. In contrary to {@link module:engine/model/node~Node nodes}, which are building blocks of
 * model document tree, markers are not stored directly in document tree. Still, they are document data, by giving
 * additional meaning to the part of a model document between marker start and marker end.
 *
 * In this sense, markers are similar to adding and converting attributes on nodes. The difference is that attribute is
 * connected with a given node (e.g. a character is bold no matter if it gets moved or content around it changes).
 * Markers on the other hand are continuous ranges and are characterised by their start and end position. This means that
 * any character in the marker is marked by the marker. For example, if a character is moved outside of marker it stops being
 * "special" and the marker is shrunk. Similarly, when a character is moved into the marker from other place in document
 * model, it starts being "special" and the marker is enlarged.
 *
 * Since markers are based on {@link module:engine/model/liverange~LiveRange live ranges}, for efficiency reasons, it's
 * best to create and keep at least markers as possible.
 *
 * Markers can be converted to view by adding appropriate converters for
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:addMarker} and
 * {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:removeMarker}
 * events, or by building converters for {@link module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher}
 * using {@link module:engine/conversion/buildmodelconverter~buildModelConverter model converter builder}.
 *
 * Another upside of markers is that finding marked part of document is fast and easy. Using attributes to mark some nodes
 * and then trying to find that part of document would require traversing whole document tree. Marker gives instant access
 * to the range which it is marking at the moment.
 *
 * `Marker` instances are created and destroyed only by {@link ~MarkerCollection MarkerCollection}.
 */
class Marker {
	/**
	 * Creates a marker instance.
	 *
	 * @param {String} name Marker name.
	 * @param {module:engine/model/liverange~LiveRange} liveRange Range marked by the marker.
	 */
	constructor( name, liveRange ) {
		/**
		 * Marker's name.
		 *
		 * @readonly
		 * @member {String} #name
		 */
		this.name = name;

		/**
		 * Range marked by the marker.
		 *
		 * @protected
		 * @member {module:engine/model/liverange~LiveRange} #_liveRange
		 */
		this._liveRange = liveRange;

		// Delegating does not work with namespaces. Alternatively, we could delegate all events (using `*`).
		this._liveRange.delegate( 'change:range' ).to( this );
		this._liveRange.delegate( 'change:content' ).to( this );
	}

	/**
	 * Returns current marker start position.
	 *
	 * @returns {module:engine/model/position~Position}
	 */
	getStart() {
		if ( !this._liveRange ) {
			throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'marker-destroyed: Cannot use a destroyed marker instance.' );
		}

		return __WEBPACK_IMPORTED_MODULE_1__position__["a" /* default */].createFromPosition( this._liveRange.start );
	}

	/**
	 * Returns current marker end position.
	 *
	 * @returns {module:engine/model/position~Position}
	 */
	getEnd() {
		if ( !this._liveRange ) {
			throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'marker-destroyed: Cannot use a destroyed marker instance.' );
		}

		return __WEBPACK_IMPORTED_MODULE_1__position__["a" /* default */].createFromPosition( this._liveRange.end );
	}

	/**
	 * Returns a range that represents current state of marker.
	 *
	 * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a
	 * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only
	 * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}
	 * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every
	 * time there is a need to read marker properties. This will guarantee that the marker has not been removed and
	 * that it's data is up-to-date.
	 *
	 * @returns {module:engine/model/range~Range}
	 */
	getRange() {
		if ( !this._liveRange ) {
			throw new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'marker-destroyed: Cannot use a destroyed marker instance.' );
		}

		return __WEBPACK_IMPORTED_MODULE_2__range__["a" /* default */].createFromRange( this._liveRange );
	}

	/**
	 * Fired whenever {@link ~Marker#_liveRange marker range} is changed due to changes on {@link module:engine/model/document~Document}.
	 * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:range LiveRange change:range event}.
	 *
	 * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},
	 * all event listeners listening to it should be removed. It is best to do it on
	 * {@link module:engine/model/markercollection~MarkerCollection#event:remove MarkerCollection remove event}.
	 *
	 * @see module:engine/model/liverange~LiveRange#event:change:range
	 * @event change:range
	 * @param {module:engine/model/range~Range} oldRange
	 * @param {Object} data
	 */

	/**
	 * Fired whenever change on {@link module:engine/model/document~Document} is done inside {@link ~Marker#_liveRange marker range}.
	 * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:content LiveRange change:content event}.
	 *
	 * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},
	 * all event listeners listening to it should be removed. It is best to do it on
	 * {@link module:engine/model/markercollection~MarkerCollection#event:remove MarkerCollection remove event}.
	 *
	 * @see module:engine/model/liverange~LiveRange#event:change:content
	 * @event change:content
	 * @param {module:engine/model/range~Range} oldRange
	 * @param {Object} data
	 */
}

Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Marker, __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

/**
 * Cannot use a {@link module:engine/model/markercollection~MarkerCollection#destroy destroyed marker} instance.
 *
 * @error marker-destroyed
 */


/***/ }),
/* 417 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_keystrokehandler__ = __webpack_require__(49);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module core/editingkeystrokehandler
 */



/**
 * A keystroke handler for editor editing. Its instance is available
 * in {@link module:core/editor/standardeditor~StandardEditor#keystrokes} so plugins
 * can register their keystrokes.
 *
 * E.g. an undo plugin would do this:
 *
 *		editor.keystrokes.set( 'Ctrl+Z', 'undo' );
 *		editor.keystrokes.set( 'Ctrl+Shift+Z', 'redo' );
 *		editor.keystrokes.set( 'Ctrl+Y', 'redo' );
 *
 * @extends utils/keystrokehandler~KeystrokeHandler
 */
class EditingKeystrokeHandler extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_keystrokehandler__["a" /* default */] {
	/**
	 * Creates an instance of the keystroke handler.
	 *
	 * @param {module:core/editor/editor~Editor} editor
	 */
	constructor( editor ) {
		super();

		/**
		 * The editor instance.
		 *
		 * @readonly
		 * @member {module:core/editor/editor~Editor}
		 */
		this.editor = editor;
	}

	/**
	 * Registers a handler for the specified keystroke.
	 *
	 * The handler can be specified as a command name or a callback.
	 *
	 * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by
	 * the {@link module:utils/keyboard~parseKeystroke} function.
	 * @param {Function|String} callback If a string is passed, then the keystroke will
	 * {@link module:core/editor/editor~Editor#execute execute a command}.
	 * If a function, then it will be called with the
	 * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
	 * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.
	 * @param {Object} [options={}] Additional options.
	 * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke
	 * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority
	 * are called in the order they were added.
	 */
	set( keystroke, callback, options = {} ) {
		if ( typeof callback == 'string' ) {
			const commandName = callback;

			callback = ( evtData, cancel ) => {
				this.editor.execute( commandName );
				cancel();
			};
		}

		super.set( keystroke, callback, options );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EditingKeystrokeHandler;



/***/ }),
/* 418 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view_document__ = __webpack_require__(419);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__conversion_mapper__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__conversion_modelconversiondispatcher__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__conversion_model_to_view_converters__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__conversion_view_selection_to_model_converters__ = __webpack_require__(433);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__conversion_model_selection_to_view_converters__ = __webpack_require__(264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/controller/editingcontroller
 */











/**
 * Controller for the editing pipeline. The editing pipeline controls {@link ~EditingController#model model} rendering,
 * including selection handling. It also creates {@link ~EditingController#view view document} which build a
 * browser-independent virtualization over the DOM elements. Editing controller also attach default converters.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */
class EditingController {
	/**
	 * Creates editing controller instance.
	 *
	 * @param {module:engine/model/document~Document} model Document model.
	 */
	constructor( model ) {
		/**
		 * Document model.
		 *
		 * @readonly
		 * @member {module:engine/model/document~Document}
		 */
		this.model = model;

		/**
		 * View document.
		 *
		 * @readonly
		 * @member {module:engine/view/document~Document}
		 */
		this.view = new __WEBPACK_IMPORTED_MODULE_0__view_document__["a" /* default */]();

		/**
		 * Mapper which describes model-view binding.
		 *
		 * @readonly
		 * @member {module:engine/conversion/mapper~Mapper}
		 */
		this.mapper = new __WEBPACK_IMPORTED_MODULE_1__conversion_mapper__["a" /* default */]();

		/**
		 * Model to view conversion dispatcher, which converts changes from the model to
		 * {@link #view editing view}.
		 *
		 * To attach model to view converter to the editing pipeline you need to add lister to this property:
		 *
		 *		editing.modelToView( 'insert:$element', customInsertConverter );
		 *
		 * Or use {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder}:
		 *
		 *		buildModelConverter().for( editing.modelToView ).fromAttribute( 'bold' ).toElement( 'b' );
		 *
		 * @readonly
		 * @member {module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher} #modelToView
		 */
		this.modelToView = new __WEBPACK_IMPORTED_MODULE_2__conversion_modelconversiondispatcher__["a" /* default */]( this.model, {
			mapper: this.mapper,
			viewSelection: this.view.selection
		} );

		// Convert changes in model to view.
		this.listenTo( this.model, 'change', ( evt, type, changes ) => {
			this.modelToView.convertChange( type, changes );
		}, { priority: 'low' } );

		// Convert model selection to view.
		this.listenTo( this.model, 'changesDone', () => {
			const selection = this.model.selection;

			this.modelToView.convertSelection( selection );
			this.view.render();
		}, { priority: 'low' } );

		// Convert model markers changes.
		this.listenTo( this.model.markers, 'add', ( evt, marker ) => {
			this.modelToView.convertMarker( 'addMarker', marker.name, marker.getRange() );
		} );

		this.listenTo( this.model.markers, 'remove', ( evt, marker ) => {
			this.modelToView.convertMarker( 'removeMarker', marker.name, marker.getRange() );
		} );

		// Convert view selection to model.
		this.listenTo( this.view, 'selectionChange', Object(__WEBPACK_IMPORTED_MODULE_4__conversion_view_selection_to_model_converters__["a" /* convertSelectionChange */])( this.model, this.mapper ) );

		// Attach default content converters.
		this.modelToView.on( 'insert:$text', Object(__WEBPACK_IMPORTED_MODULE_3__conversion_model_to_view_converters__["e" /* insertText */])(), { priority: 'lowest' } );
		this.modelToView.on( 'remove', Object(__WEBPACK_IMPORTED_MODULE_3__conversion_model_to_view_converters__["g" /* remove */])(), { priority: 'low' } );

		// Attach default selection converters.
		this.modelToView.on( 'selection', Object(__WEBPACK_IMPORTED_MODULE_5__conversion_model_selection_to_view_converters__["a" /* clearAttributes */])(), { priority: 'low' } );
		this.modelToView.on( 'selection', Object(__WEBPACK_IMPORTED_MODULE_5__conversion_model_selection_to_view_converters__["b" /* clearFakeSelection */])(), { priority: 'low' } );
		this.modelToView.on( 'selection', Object(__WEBPACK_IMPORTED_MODULE_5__conversion_model_selection_to_view_converters__["d" /* convertRangeSelection */])(), { priority: 'low' } );
		this.modelToView.on( 'selection', Object(__WEBPACK_IMPORTED_MODULE_5__conversion_model_selection_to_view_converters__["c" /* convertCollapsedSelection */])(), { priority: 'low' } );
	}

	/**
	 * {@link module:engine/view/document~Document#createRoot Creates} a view root
	 * and {@link module:engine/conversion/mapper~Mapper#bindElements binds}
	 * the model root with view root and and view root with DOM element:
	 *
	 *		editing.createRoot( document.querySelector( div#editor ) );
	 *
	 * If the DOM element is not available at the time you want to create a view root, for instance it is iframe body
	 * element, it is possible to create view element and bind the DOM element later:
	 *
	 *		editing.createRoot( 'body' );
	 *		editing.view.attachDomRoot( iframe.contentDocument.body );
	 *
	 * @param {Element|String} domRoot DOM root element or the name of view root element if the DOM element will be
	 * attached later.
	 * @param {String} [name='main'] Root name.
	 * @returns {module:engine/view/containerelement~ContainerElement} View root element.
	 */
	createRoot( domRoot, name = 'main' ) {
		const viewRoot = this.view.createRoot( domRoot, name );
		const modelRoot = this.model.getRoot( name );

		this.mapper.bindElements( modelRoot, viewRoot );

		return viewRoot;
	}

	/**
	 * Removes all event listeners attached to the `EditingController`. Destroys all objects created
	 * by `EditingController` that need to be destroyed.
	 */
	destroy() {
		this.view.destroy();
		this.stopListening();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EditingController;


Object(__WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( EditingController, __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );


/***/ }),
/* 419 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__renderer__ = __webpack_require__(420);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__domconverter__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__rooteditableelement__ = __webpack_require__(260);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__filler__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__uielement__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_log__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__observer_mutationobserver__ = __webpack_require__(261);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__observer_selectionobserver__ = __webpack_require__(426);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__observer_focusobserver__ = __webpack_require__(428);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__observer_keyobserver__ = __webpack_require__(429);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__observer_fakeselectionobserver__ = __webpack_require__(430);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_utils_src_dom_scroll__ = __webpack_require__(431);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/document
 */

















/**
 * Document class creates an abstract layer over the content editable area.
 * It combines the actual tree of view elements, tree of DOM elements,
 * {@link module:engine/view/domconverter~DomConverter DOM Converter}, {@link module:engine/view/renderer~Renderer renderer} and all
 * {@link module:engine/view/observer/observer~Observer observers}.
 *
 * If you want to only transform the tree of view elements to the DOM elements you can use the
 * {@link module:engine/view/domconverter~DomConverter DomConverter}.
 *
 * Note that the following observers are added by the class constructor and are always available:
 *
 * * {@link module:engine/view/observer/mutationobserver~MutationObserver},
 * * {@link module:engine/view/observer/selectionobserver~SelectionObserver},
 * * {@link module:engine/view/observer/focusobserver~FocusObserver},
 * * {@link module:engine/view/observer/keyobserver~KeyObserver},
 * * {@link module:engine/view/observer/fakeselectionobserver~FakeSelectionObserver}.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */
class Document {
	/**
	 * Creates a Document instance.
	 */
	constructor() {
		/**
		 * Roots of the DOM tree. Map on the `HTMLElement`s with roots names as keys.
		 *
		 * @readonly
		 * @member {Map} module:engine/view/document~Document#domRoots
		 */
		this.domRoots = new Map();

		/**
		 * Selection done on this document.
		 *
		 * @readonly
		 * @member {module:engine/view/selection~Selection} module:engine/view/document~Document#selection
		 */
		this.selection = new __WEBPACK_IMPORTED_MODULE_0__selection__["a" /* default */]();

		/**
		 * Instance of the {@link module:engine/view/domconverter~DomConverter domConverter} use by
		 * {@link module:engine/view/document~Document#renderer renderer}
		 * and {@link module:engine/view/observer/observer~Observer observers}.
		 *
		 * @readonly
		 * @member {module:engine/view/domconverter~DomConverter} module:engine/view/document~Document#domConverter
		 */
		this.domConverter = new __WEBPACK_IMPORTED_MODULE_2__domconverter__["a" /* default */]();

		/**
		 * Roots of the view tree. Map of the {module:engine/view/element~Element view elements} with roots names as keys.
		 *
		 * @readonly
		 * @member {Map} module:engine/view/document~Document#roots
		 */
		this.roots = new Map();

		/**
		 * Defines whether document is in read-only mode.
		 *
		 * When document is read-ony then all roots are read-only as well and caret placed inside this root is hidden.
		 *
		 * @observable
		 * @member {Boolean} #isReadOnly
		 */
		this.set( 'isReadOnly', false );

		/**
		 * True if document is focused.
		 *
		 * This property is updated by the {@link module:engine/view/observer/focusobserver~FocusObserver}.
		 * If the {@link module:engine/view/observer/focusobserver~FocusObserver} is disabled this property will not change.
		 *
		 * @readonly
		 * @observable
		 * @member {Boolean} module:engine/view/document~Document#isFocused
		 */
		this.set( 'isFocused', false );

		/**
		 * Instance of the {@link module:engine/view/document~Document#renderer renderer}.
		 *
		 * @readonly
		 * @member {module:engine/view/renderer~Renderer} module:engine/view/document~Document#renderer
		 */
		this.renderer = new __WEBPACK_IMPORTED_MODULE_1__renderer__["a" /* default */]( this.domConverter, this.selection );
		this.renderer.bind( 'isFocused' ).to( this );

		/**
		 * Map of registered {@link module:engine/view/observer/observer~Observer observers}.
		 *
		 * @private
		 * @member {Map.<Function, module:engine/view/observer/observer~Observer>} module:engine/view/document~Document#_observers
		 */
		this._observers = new Map();

		// Add default observers.
		this.addObserver( __WEBPACK_IMPORTED_MODULE_7__observer_mutationobserver__["a" /* default */] );
		this.addObserver( __WEBPACK_IMPORTED_MODULE_8__observer_selectionobserver__["a" /* default */] );
		this.addObserver( __WEBPACK_IMPORTED_MODULE_9__observer_focusobserver__["a" /* default */] );
		this.addObserver( __WEBPACK_IMPORTED_MODULE_10__observer_keyobserver__["a" /* default */] );
		this.addObserver( __WEBPACK_IMPORTED_MODULE_11__observer_fakeselectionobserver__["a" /* default */] );

		Object(__WEBPACK_IMPORTED_MODULE_4__filler__["f" /* injectQuirksHandling */])( this );
		Object(__WEBPACK_IMPORTED_MODULE_5__uielement__["b" /* injectUiElementHandling */])( this );

		this.decorate( 'render' );
	}

	/**
	 * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it
	 * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future
	 * {@link module:engine/view/document~Document#domRoots DOM roots}.
	 *
	 * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
	 * when registered for the first time. This means that features and other components can register a single observer
	 * multiple times without caring whether it has been already added or not.
	 *
	 * @param {Function} Observer The constructor of an observer to add.
	 * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.
	 * @returns {module:engine/view/observer/observer~Observer} Added observer instance.
	 */
	addObserver( Observer ) {
		let observer = this._observers.get( Observer );

		if ( observer ) {
			return observer;
		}

		observer = new Observer( this );

		this._observers.set( Observer, observer );

		for ( const [ name, domElement ] of this.domRoots ) {
			observer.observe( domElement, name );
		}

		observer.enable();

		return observer;
	}

	/**
	 * Returns observer of the given type or `undefined` if such observer has not been added yet.
	 *
	 * @param {Function} Observer The constructor of an observer to get.
	 * @returns {module:engine/view/observer/observer~Observer|undefined} Observer instance or undefined.
	 */
	getObserver( Observer ) {
		return this._observers.get( Observer );
	}

	/**
	 * Creates a {@link module:engine/view/document~Document#roots view root element}.
	 *
	 * If the DOM element is passed as a first parameter it will be automatically
	 * {@link module:engine/view/document~Document#attachDomRoot attached}:
	 *
	 *		document.createRoot( document.querySelector( 'div#editor' ) ); // Will call document.attachDomRoot.
	 *
	 * However, if the string is passed, then only the view element will be created and the DOM element have to be
	 * attached separately:
	 *
	 *		document.createRoot( 'body' );
	 *		document.attachDomRoot( document.querySelector( 'body#editor' ) );
	 *
	 * In both cases, {@link module:engine/view/rooteditableelement~RootEditableElement#rootName element name} is always
	 * transformed to lower
	 * case.
	 *
	 * @param {Element|String} domRoot DOM root element or the tag name of view root element if the DOM element will be
	 * attached later.
	 * @param {String} [name='main'] Name of the root.
	 * @returns {module:engine/view/rooteditableelement~RootEditableElement} The created view root element.
	 */
	createRoot( domRoot, name = 'main' ) {
		const rootTag = typeof domRoot == 'string' ? domRoot : domRoot.tagName;

		const viewRoot = new __WEBPACK_IMPORTED_MODULE_3__rooteditableelement__["a" /* default */]( rootTag.toLowerCase(), name );
		viewRoot.document = this;

		this.roots.set( name, viewRoot );

		// Mark changed nodes in the renderer.
		viewRoot.on( 'change:children', ( evt, node ) => this.renderer.markToSync( 'children', node ) );
		viewRoot.on( 'change:attributes', ( evt, node ) => this.renderer.markToSync( 'attributes', node ) );
		viewRoot.on( 'change:text', ( evt, node ) => this.renderer.markToSync( 'text', node ) );

		if ( this.domConverter.isElement( domRoot ) ) {
			this.attachDomRoot( domRoot, name );
		}

		return viewRoot;
	}

	/**
	 * Attaches DOM root element to the view element and enable all observers on that element. This method also
	 * {@link module:engine/view/renderer~Renderer#markToSync mark element} to be synchronized with the view what means that all child
	 * nodes will be removed and replaced with content of the view root.
	 *
	 * Note that {@link module:engine/view/document~Document#createRoot} will call this method automatically if the DOM element is
	 * passed to it.
	 *
	 * @param {Element|String} domRoot DOM root element.
	 * @param {String} [name='main'] Name of the root.
	 */
	attachDomRoot( domRoot, name = 'main' ) {
		const viewRoot = this.getRoot( name );

		this.domRoots.set( name, domRoot );

		this.domConverter.bindElements( domRoot, viewRoot );

		this.renderer.markToSync( 'children', viewRoot );
		this.renderer.domDocuments.add( domRoot.ownerDocument );

		for ( const observer of this._observers.values() ) {
			observer.observe( domRoot, name );
		}
	}

	/**
	 * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not
	 * specific "main" root is returned.
	 *
	 * @param {String} [name='main'] Name of the root.
	 * @returns {module:engine/view/rooteditableelement~RootEditableElement} The view root element with the specified name.
	 */
	getRoot( name = 'main' ) {
		return this.roots.get( name );
	}

	/**
	 * Gets DOM root element.
	 *
	 * @param {String} [name='main']  Name of the root.
	 * @returns {Element} DOM root element instance.
	 */
	getDomRoot( name = 'main' ) {
		return this.domRoots.get( name );
	}

	/**
	 * Renders all changes. In order to avoid triggering the observers (e.g. mutations) all observers are disabled
	 * before rendering and re-enabled after that.
	 *
	 * @fires render
	 */
	render() {
		this.disableObservers();
		this.renderer.render();
		this.enableObservers();
	}

	/**
	 * Focuses document. It will focus {@link module:engine/view/editableelement~EditableElement EditableElement} that is currently having
	 * selection inside.
	 */
	focus() {
		if ( !this.isFocused ) {
			const editable = this.selection.editableElement;

			if ( editable ) {
				this.domConverter.focus( editable );
				this.render();
			} else {
				/**
				 * Before focusing view document, selection should be placed inside one of the view's editables.
				 * Normally its selection will be converted from model document (which have default selection), but
				 * when using view document on its own, we need to manually place selection before focusing it.
				 *
				 * @error view-focus-no-selection
				 */
				__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_log__["a" /* default */].warn( 'view-focus-no-selection: There is no selection in any editable to focus.' );
			}
		}
	}

	/**
	 * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the
	 * caret, if not already visible to the user.
	 */
	scrollToTheSelection() {
		const range = this.selection.getFirstRange();

		if ( range ) {
			Object(__WEBPACK_IMPORTED_MODULE_14__ckeditor_ckeditor5_utils_src_dom_scroll__["a" /* scrollViewportToShowTarget */])( {
				target: this.domConverter.viewRangeToDom( range ),
				viewportOffset: 20
			} );
		}
	}

	/**
	 * Disables all added observers.
	 */
	disableObservers() {
		for ( const observer of this._observers.values() ) {
			observer.disable();
		}
	}

	/**
	 * Enables all added observers.
	 */
	enableObservers() {
		for ( const observer of this._observers.values() ) {
			observer.enable();
		}
	}

	/**
	 * Destroys all observers created by view `Document`.
	 */
	destroy() {
		for ( const observer of this._observers.values() ) {
			observer.destroy();
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Document;


Object(__WEBPACK_IMPORTED_MODULE_12__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Document, __WEBPACK_IMPORTED_MODULE_13__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );

/**
 * Enum representing type of the change.
 *
 * Possible values:
 *
 * * `children` - for child list changes,
 * * `attributes` - for element attributes changes,
 * * `text` - for text nodes changes.
 *
 * @typedef {String} module:engine/view/document~ChangeType
 */

/**
 * Fired when {@link #render render} method is called. Actual rendering is executed as a listener to
 * this event with default priority. This way other listeners can be used to run code before or after rendering.
 *
 * @event render
 */


/***/ }),
/* 420 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__text__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__filler__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_diff__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_insertat__ = __webpack_require__(421);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_dom_remove__ = __webpack_require__(422);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/renderer
 */












/**
 * Renderer updates DOM structure and selection, to make them a reflection of the view structure and selection.
 *
 * View nodes which may need to be rendered needs to be {@link module:engine/view/renderer~Renderer#markToSync marked}.
 * Then, on {@link module:engine/view/renderer~Renderer#render render}, renderer compares view nodes with DOM nodes
 * in order to check which ones really need to be refreshed. Finally, it creates DOM nodes from these view nodes,
 * {@link module:engine/view/domconverter~DomConverter#bindElements binds} them and inserts into the DOM tree.
 *
 * Every time {@link module:engine/view/renderer~Renderer#render render} is called, renderer additionally checks if
 * {@link module:engine/view/renderer~Renderer#selection selection} needs update and updates it if so.
 *
 * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform and bind nodes.
 */
class Renderer {
	/**
	 * Creates a renderer instance.
	 *
	 * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.
	 * @param {module:engine/view/selection~Selection} selection View selection.
	 */
	constructor( domConverter, selection ) {
		/**
		 * Set of DOM Documents instances.
		 *
		 * @member {Set.<Document>}
		 */
		this.domDocuments = new Set();

		/**
		 * Converter instance.
		 *
		 * @readonly
		 * @member {module:engine/view/domconverter~DomConverter}
		 */
		this.domConverter = domConverter;

		/**
		 * Set of nodes which attributes changed and may need to be rendered.
		 *
		 * @readonly
		 * @member {Set.<module:engine/view/node~Node>}
		 */
		this.markedAttributes = new Set();

		/**
		 * Set of elements which child lists changed and may need to be rendered.
		 *
		 * @readonly
		 * @member {Set.<module:engine/view/node~Node>}
		 */
		this.markedChildren = new Set();

		/**
		 * Set of text nodes which text data changed and may need to be rendered.
		 *
		 * @readonly
		 * @member {Set.<module:engine/view/node~Node>}
		 */
		this.markedTexts = new Set();

		/**
		 * View selection. Renderer updates DOM selection based on the view selection.
		 *
		 * @readonly
		 * @member {module:engine/view/selection~Selection}
		 */
		this.selection = selection;

		/**
		 * The text node in which the inline filler was rendered.
		 *
		 * @private
		 * @member {Text}
		 */
		this._inlineFiller = null;

		/**
		 * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if
		 * this is set to `false`.
		 *
		 * @member {Boolean}
		 */
		this.isFocused = false;

		/**
		 * DOM element containing fake selection.
		 *
		 * @private
		 * @type {null|HTMLElement}
		 */
		this._fakeSelectionContainer = null;
	}

	/**
	 * Mark node to be synchronized.
	 *
	 * Note that only view nodes which parents have corresponding DOM elements need to be marked to be synchronized.
	 *
	 * @see #markedAttributes
	 * @see #markedChildren
	 * @see #markedTexts
	 *
	 * @param {module:engine/view/document~ChangeType} type Type of the change.
	 * @param {module:engine/view/node~Node} node Node to be marked.
	 */
	markToSync( type, node ) {
		if ( type === 'text' ) {
			if ( this.domConverter.mapViewToDom( node.parent ) ) {
				this.markedTexts.add( node );
			}
		} else {
			// If the node has no DOM element it is not rendered yet,
			// its children/attributes do not need to be marked to be sync.
			if ( !this.domConverter.mapViewToDom( node ) ) {
				return;
			}

			if ( type === 'attributes' ) {
				this.markedAttributes.add( node );
			} else if ( type === 'children' ) {
				this.markedChildren.add( node );
			} else {
				/**
				 * Unknown type passed to Renderer.markToSync.
				 *
				 * @error renderer-unknown-type
				 */
				throw new __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.' );
			}
		}
	}

	/**
	 * Render method checks {@link #markedAttributes},
	 * {@link #markedChildren} and {@link #markedTexts} and updates all
	 * nodes which need to be updated. Then it clears all three sets. Also, every time render is called it compares and
	 * if needed updates the selection.
	 *
	 * Renderer tries not to break text composition (e.g. IME) and x-index of the selection,
	 * so it does as little as it is needed to update the DOM.
	 *
	 * For attributes it adds new attributes to DOM elements, updates values and removes
	 * attributes which do not exist in the view element.
	 *
	 * For text nodes it updates the text string if it is different. Note that if parent element is marked as an element
	 * which changed child list, text node update will not be done, because it may not be possible to
	 * {@link module:engine/view/domconverter~DomConverter#findCorrespondingDomText find a corresponding DOM text}.
	 * The change will be handled in the parent element.
	 *
	 * For elements, which child lists have changed, it calculates a {@link module:utils/diff~diff} and adds or removes children which have
	 * changed.
	 *
	 * Rendering also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed
	 * at selection position and adds or removes it. To prevent breaking text composition inline filler will not be
	 * removed as long selection is in the text node which needed it at first.
	 */
	render() {
		let inlineFillerPosition;

		// There was inline filler rendered in the DOM but it's not
		// at the selection position any more, so we can remove it
		// (cause even if it's needed, it must be placed in another location).
		if ( this._inlineFiller && !this._isSelectionInInlineFiller() ) {
			this._removeInlineFiller();
		}

		// If we've got the filler, let's try to guess its position in the view.
		if ( this._inlineFiller ) {
			inlineFillerPosition = this._getInlineFillerPosition();
		}
		// Otherwise, if it's needed, create it at the selection position.
		else if ( this._needsInlineFillerAtSelection() ) {
			inlineFillerPosition = this.selection.getFirstPosition();

			// Do not use `markToSync` so it will be added even if the parent is already added.
			this.markedChildren.add( inlineFillerPosition.parent );
		}

		for ( const node of this.markedTexts ) {
			if ( !this.markedChildren.has( node.parent ) && this.domConverter.mapViewToDom( node.parent ) ) {
				this._updateText( node, { inlineFillerPosition } );
			}
		}

		for ( const element of this.markedAttributes ) {
			this._updateAttrs( element );
		}

		for ( const element of this.markedChildren ) {
			this._updateChildren( element, { inlineFillerPosition } );
		}

		// Check whether the inline filler is required and where it really is in the DOM.
		// At this point in most cases it will be in the DOM, but there are exceptions.
		// For example, if the inline filler was deep in the created DOM structure, it will not be created.
		// Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,
		// it will not be present.
		// Fix those and similar scenarios.
		if ( inlineFillerPosition ) {
			const fillerDomPosition = this.domConverter.viewPositionToDom( inlineFillerPosition );
			const domDocument = fillerDomPosition.parent.ownerDocument;

			if ( !Object(__WEBPACK_IMPORTED_MODULE_2__filler__["i" /* startsWithFiller */])( fillerDomPosition.parent ) ) {
				// Filler has not been created at filler position. Create it now.
				this._inlineFiller = this._addInlineFiller( domDocument, fillerDomPosition.parent, fillerDomPosition.offset );
			} else {
				// Filler has been found, save it.
				this._inlineFiller = fillerDomPosition.parent;
			}
		} else {
			// There is no filler needed.
			this._inlineFiller = null;
		}

		this._updateSelection();
		this._updateFocus();

		this.markedTexts.clear();
		this.markedAttributes.clear();
		this.markedChildren.clear();
	}

	/**
	 * Adds inline filler at given position.
	 *
	 * The position can be given as an array of DOM nodes and an offset in that array,
	 * or a DOM parent element and offset in that element.
	 *
	 * @private
	 * @param {Document} domDocument
	 * @param {Element|Array.<Node>} domParentOrArray
	 * @param {Number} offset
	 * @returns {Text} The DOM text node that contains inline filler.
	 */
	_addInlineFiller( domDocument, domParentOrArray, offset ) {
		const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;
		const nodeAfterFiller = childNodes[ offset ];

		if ( this.domConverter.isText( nodeAfterFiller ) ) {
			nodeAfterFiller.data = __WEBPACK_IMPORTED_MODULE_2__filler__["b" /* INLINE_FILLER */] + nodeAfterFiller.data;

			return nodeAfterFiller;
		} else {
			const fillerNode = domDocument.createTextNode( __WEBPACK_IMPORTED_MODULE_2__filler__["b" /* INLINE_FILLER */] );

			if ( Array.isArray( domParentOrArray ) ) {
				childNodes.splice( offset, 0, fillerNode );
			} else {
				Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_insertat__["a" /* default */])( domParentOrArray, offset, fillerNode );
			}

			return fillerNode;
		}
	}

	/**
	 * Gets the position of the inline filler based on the current selection.
	 * Here, we assume that we know that the filler is needed and
	 * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it's needed,
	 * it's somewhere at the selection postion.
	 *
	 * Note: we cannot restore the filler position based on the filler's DOM text node, because
	 * when this method is called (before rendering) the bindings will often be broken. View to DOM
	 * bindings are only dependable after rendering.
	 *
	 * @private
	 * @returns {module:engine/view/position~Position}
	 */
	_getInlineFillerPosition() {
		const firstPos = this.selection.getFirstPosition();

		if ( firstPos.parent.is( 'text' ) ) {
			return __WEBPACK_IMPORTED_MODULE_1__position__["a" /* default */].createBefore( this.selection.getFirstPosition().parent );
		} else {
			return firstPos;
		}
	}

	/**
	 * Returns `true` if the selection hasn't left the inline filler's text node.
	 * If it is `true` it means that the filler had been added for a reason and the selection does not
	 * left the filler's text node. E.g. the user can be in the middle of a composition so it should not be touched.
	 *
	 * @private
	 * @returns {Boolean} True if the inline filler and selection are in the same place.
	 */
	_isSelectionInInlineFiller() {
		if ( this.selection.rangeCount != 1 || !this.selection.isCollapsed ) {
			return false;
		}

		// Note, we can't check if selection's position equals position of the
		// this._inlineFiller node, because of #663. We may not be able to calculate
		// the filler's position in the view at this stage.
		// Instead, we check it the other way  whether selection is anchored in
		// that text node or next to it.

		// Possible options are:
		// "FILLER{}"
		// "FILLERadded-text{}"
		const selectionPosition = this.selection.getFirstPosition();
		const position = this.domConverter.viewPositionToDom( selectionPosition );

		if ( position && this.domConverter.isText( position.parent ) && Object(__WEBPACK_IMPORTED_MODULE_2__filler__["i" /* startsWithFiller */])( position.parent ) ) {
			return true;
		}

		return false;
	}

	/**
	 * Removes the inline filler.
	 *
	 * @private
	 */
	_removeInlineFiller() {
		const domFillerNode = this._inlineFiller;

		// Something weird happened and the stored node doesn't contain the filler's text.
		if ( !Object(__WEBPACK_IMPORTED_MODULE_2__filler__["i" /* startsWithFiller */])( domFillerNode ) ) {
			/**
			 * The inline filler node was lost. Most likely, something overwrote the filler text node
			 * in the DOM.
			 *
			 * @error view-renderer-filler-was-lost
			 */
			throw new __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-renderer-filler-was-lost: The inline filler node was lost.' );
		}

		if ( Object(__WEBPACK_IMPORTED_MODULE_2__filler__["h" /* isInlineFiller */])( domFillerNode ) ) {
			domFillerNode.parentNode.removeChild( domFillerNode );
		} else {
			domFillerNode.data = domFillerNode.data.substr( __WEBPACK_IMPORTED_MODULE_2__filler__["c" /* INLINE_FILLER_LENGTH */] );
		}

		this._inlineFiller = null;
	}

	/**
	 * Checks if the inline {@link module:engine/view/filler filler} should be added.
	 *
	 * @private
	 * @returns {Boolean} True if the inline fillers should be added.
	 */
	_needsInlineFillerAtSelection() {
		if ( this.selection.rangeCount != 1 || !this.selection.isCollapsed ) {
			return false;
		}

		const selectionPosition = this.selection.getFirstPosition();
		const selectionParent = selectionPosition.parent;
		const selectionOffset = selectionPosition.offset;

		// If there is no DOM root we do not care about fillers.
		if ( !this.domConverter.mapViewToDom( selectionParent.root ) ) {
			return false;
		}

		if ( !( selectionParent.is( 'element' ) ) ) {
			return false;
		}

		// Prevent adding inline filler inside elements with contenteditable=false.
		// https://github.com/ckeditor/ckeditor5-engine/issues/1170
		if ( !_isEditable( selectionParent ) ) {
			return false;
		}

		// We have block filler, we do not need inline one.
		if ( selectionOffset === selectionParent.getFillerOffset() ) {
			return false;
		}

		const nodeBefore = selectionPosition.nodeBefore;
		const nodeAfter = selectionPosition.nodeAfter;

		if ( nodeBefore instanceof __WEBPACK_IMPORTED_MODULE_0__text__["a" /* default */] || nodeAfter instanceof __WEBPACK_IMPORTED_MODULE_0__text__["a" /* default */] ) {
			return false;
		}

		return true;
	}

	/**
	 * Checks if text needs to be updated and possibly updates it.
	 *
	 * @private
	 * @param {module:engine/view/text~Text} viewText View text to update.
	 * @param {Object} options
	 * @param {module:engine/view/position~Position} options.inlineFillerPosition The position on which the inline
	 * filler should be rendered.
	 */
	_updateText( viewText, options ) {
		const domText = this.domConverter.findCorrespondingDomText( viewText );
		const newDomText = this.domConverter.viewToDom( viewText, domText.ownerDocument );

		const actualText = domText.data;
		let expectedText = newDomText.data;

		const filler = options.inlineFillerPosition;

		if ( filler && filler.parent == viewText.parent && filler.offset == viewText.index ) {
			expectedText = __WEBPACK_IMPORTED_MODULE_2__filler__["b" /* INLINE_FILLER */] + expectedText;
		}

		if ( actualText != expectedText ) {
			domText.data = expectedText;
		}
	}

	/**
	 * Checks if attributes list needs to be updated and possibly updates it.
	 *
	 * @private
	 * @param {module:engine/view/element~Element} viewElement View element to update.
	 */
	_updateAttrs( viewElement ) {
		const domElement = this.domConverter.mapViewToDom( viewElement );
		const domAttrKeys = Array.from( domElement.attributes ).map( attr => attr.name );
		const viewAttrKeys = viewElement.getAttributeKeys();

		// Add or overwrite attributes.
		for ( const key of viewAttrKeys ) {
			domElement.setAttribute( key, viewElement.getAttribute( key ) );
		}

		// Remove from DOM attributes which do not exists in the view.
		for ( const key of domAttrKeys ) {
			if ( !viewElement.hasAttribute( key ) ) {
				domElement.removeAttribute( key );
			}
		}
	}

	/**
	 * Checks if elements child list needs to be updated and possibly updates it.
	 *
	 * @private
	 * @param {module:engine/view/element~Element} viewElement View element to update.
	 * @param {Object} options
	 * @param {module:engine/view/position~Position} options.inlineFillerPosition The position on which the inline
	 * filler should be rendered.
	 */
	_updateChildren( viewElement, options ) {
		const domConverter = this.domConverter;
		const domElement = domConverter.mapViewToDom( viewElement );

		if ( !domElement ) {
			// If there is no `domElement` it means that it was already removed from DOM.
			// There is no need to update it. It will be updated when re-inserted.
			return;
		}

		const domDocument = domElement.ownerDocument;
		const filler = options.inlineFillerPosition;
		const actualDomChildren = domElement.childNodes;
		const expectedDomChildren = Array.from( domConverter.viewChildrenToDom( viewElement, domDocument, { bind: true } ) );

		// Inline filler element has to be created during children update because we need it to diff actual dom
		// elements with expected dom elements. We need inline filler in expected dom elements so we won't re-render
		// text node if it is not necessary.
		if ( filler && filler.parent == viewElement ) {
			this._addInlineFiller( domDocument, expectedDomChildren, filler.offset );
		}

		const actions = Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_diff__["a" /* default */])( actualDomChildren, expectedDomChildren, sameNodes );

		let i = 0;
		const nodesToUnbind = new Set();

		for ( const action of actions ) {
			if ( action === 'insert' ) {
				Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_insertat__["a" /* default */])( domElement, i, expectedDomChildren[ i ] );
				i++;
			} else if ( action === 'delete' ) {
				nodesToUnbind.add( actualDomChildren[ i ] );
				Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_dom_remove__["a" /* default */])( actualDomChildren[ i ] );
			} else { // 'equal'
				i++;
			}
		}

		// Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during
		// comparision with the expected DOM. We don't need to check child nodes, because if child node was reinserted,
		// it was moved to DOM tree out of the removed node.
		for ( const node of nodesToUnbind ) {
			if ( !node.parentNode ) {
				this.domConverter.unbindDomElement( node );
			}
		}

		function sameNodes( actualDomChild, expectedDomChild ) {
			// Elements.
			if ( actualDomChild === expectedDomChild ) {
				return true;
			}
			// Texts.
			else if ( domConverter.isText( actualDomChild ) && domConverter.isText( expectedDomChild ) ) {
				return actualDomChild.data === expectedDomChild.data;
			}
			// Block fillers.
			else if ( Object(__WEBPACK_IMPORTED_MODULE_2__filler__["g" /* isBlockFiller */])( actualDomChild, domConverter.blockFiller ) &&
				Object(__WEBPACK_IMPORTED_MODULE_2__filler__["g" /* isBlockFiller */])( expectedDomChild, domConverter.blockFiller ) ) {
				return true;
			}

			// Not matching types.
			return false;
		}
	}

	/**
	 * Checks if selection needs to be updated and possibly updates it.
	 *
	 * @private
	 */
	_updateSelection() {
		// If there is no selection - remove DOM and fake selections.
		if ( this.selection.rangeCount === 0 ) {
			this._removeDomSelection();
			this._removeFakeSelection();

			return;
		}

		const domRoot = this.domConverter.mapViewToDom( this.selection.editableElement );

		// Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.
		if ( !this.isFocused || !domRoot ) {
			return;
		}

		// Render selection.
		if ( this.selection.isFake ) {
			this._updateFakeSelection( domRoot );
		} else {
			this._removeFakeSelection();
			this._updateDomSelection( domRoot );
		}
	}

	/**
	 * Updates fake selection.
	 *
	 * @private
	 * @param {HTMLElement} domRoot Valid DOM root where fake selection container should be added.
	 */
	_updateFakeSelection( domRoot ) {
		const domDocument = domRoot.ownerDocument;

		// Create fake selection container if one does not exist.
		if ( !this._fakeSelectionContainer ) {
			this._fakeSelectionContainer = domDocument.createElement( 'div' );
			this._fakeSelectionContainer.style.position = 'fixed';
			this._fakeSelectionContainer.style.top = 0;
			this._fakeSelectionContainer.style.left = '-9999px';
			this._fakeSelectionContainer.appendChild( domDocument.createTextNode( '\u00A0' ) );
		}

		// Add fake container if not already added.
		if ( !this._fakeSelectionContainer.parentElement ) {
			domRoot.appendChild( this._fakeSelectionContainer );
		}

		// Update contents.
		const content = this.selection.fakeSelectionLabel || '\u00A0';
		this._fakeSelectionContainer.firstChild.data = content;

		// Update selection.
		const domSelection = domDocument.getSelection();
		domSelection.removeAllRanges();

		const domRange = domDocument.createRange();
		domRange.selectNodeContents( this._fakeSelectionContainer );
		domSelection.addRange( domRange );

		// Bind fake selection container with current selection.
		this.domConverter.bindFakeSelection( this._fakeSelectionContainer, this.selection );
	}

	/**
	 * Updates DOM selection.
	 *
	 * @private
	 * @param {HTMLElement} domRoot Valid DOM root where DOM selection should be rendered.
	 */
	_updateDomSelection( domRoot ) {
		const domSelection = domRoot.ownerDocument.defaultView.getSelection();

		// Let's check whether DOM selection needs updating at all.
		if ( !this._domSelectionNeedsUpdate( domSelection ) ) {
			return;
		}

		// Multi-range selection is not available in most browsers, and, at least in Chrome, trying to
		// set such selection, that is not continuous, throws an error. Because of that, we will just use anchor
		// and focus of view selection.
		// Since we are not supporting multi-range selection, we also do not need to check if proper editable is
		// selected. If there is any editable selected, it is okay (editable is taken from selection anchor).
		const anchor = this.domConverter.viewPositionToDom( this.selection.anchor );
		const focus = this.domConverter.viewPositionToDom( this.selection.focus );

		domSelection.collapse( anchor.parent, anchor.offset );
		domSelection.extend( focus.parent, focus.offset );
	}

	/**
	 * Checks whether given DOM selection needs to be updated.
	 *
	 * @private
	 * @param {Selection} domSelection DOM selection to check.
	 * @returns {Boolean}
	 */
	_domSelectionNeedsUpdate( domSelection ) {
		if ( !this.domConverter.isDomSelectionCorrect( domSelection ) ) {
			// Current DOM selection is in incorrect position. We need to update it.
			return true;
		}

		const oldViewSelection = domSelection && this.domConverter.domSelectionToView( domSelection );

		if ( oldViewSelection && this.selection.isEqual( oldViewSelection ) ) {
			return false;
		}

		// If selection is not collapsed, it does not need to be updated if it is similar.
		if ( !this.selection.isCollapsed && this.selection.isSimilar( oldViewSelection ) ) {
			// Selection did not changed and is correct, do not update.
			return false;
		}

		// Selections are not similar.
		return true;
	}

	/**
	 * Removes DOM selection.
	 *
	 * @private
	 */
	_removeDomSelection() {
		for ( const doc of this.domDocuments ) {
			const domSelection = doc.getSelection();

			if ( domSelection.rangeCount ) {
				const activeDomElement = doc.activeElement;
				const viewElement = this.domConverter.mapDomToView( activeDomElement );

				if ( activeDomElement && viewElement ) {
					doc.getSelection().removeAllRanges();
				}
			}
		}
	}

	/**
	 * Removes fake selection.
	 *
	 * @private
	 */
	_removeFakeSelection() {
		const container = this._fakeSelectionContainer;

		if ( container ) {
			container.remove();
		}
	}

	/**
	 * Checks if focus needs to be updated and possibly updates it.
	 *
	 * @private
	 */
	_updateFocus() {
		if ( this.isFocused ) {
			const editable = this.selection.editableElement;

			if ( editable ) {
				this.domConverter.focus( editable );
			}
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Renderer;


Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Renderer, __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );

// Checks if provided element is editable.
//
// @private
// @param {module:engine/view/element~Element} element
// @returns {Boolean}
function _isEditable( element ) {
	if ( element.getAttribute( 'contenteditable' ) == 'false' ) {
		return false;
	}

	const parent = element.findAncestor( element => element.hasAttribute( 'contenteditable' ) );

	return !parent || parent.getAttribute( 'contenteditable' ) == 'true';
}


/***/ }),
/* 421 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = insertAt;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/insertat
 */

/**
 * Inserts node to the parent at given index.
 *
 * @param {Element} parentElement Parent element.
 * @param {Number} index Insertions index.
 * @param {Node} nodeToInsert Node to insert.
 */
function insertAt( parentElement, index, nodeToInsert ) {
	parentElement.insertBefore( nodeToInsert, parentElement.childNodes[ index ] || null );
}


/***/ }),
/* 422 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = remove;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/remove
 */

/**
 * Removes given node from parent.
 *
 * @param {Node} node Node to remove.
 */
function remove( node ) {
	const parent = node.parentNode;

	if ( parent ) {
		parent.removeChild( node );
	}
}


/***/ }),
/* 423 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = indexOf;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/indexof
 */

/**
 * Returns index of the node in the parent element.
 *
 * @param {Node} node Node which index is tested.
 * @returns {Number} Index of the node in the parent element. Returns 0 if node has no parent.
 */
function indexOf( node ) {
	let index = 0;

	while ( node.previousSibling ) {
		node = node.previousSibling;
		index++;
	}

	return index;
}


/***/ }),
/* 424 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getCommonAncestor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getancestors__ = __webpack_require__(259);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/getcommonancestor
 */



/**
 * Searches and returns the lowest common ancestor of two given nodes.
 *
 * @param {Node} nodeA First node.
 * @param {Node} nodeB Second node.
 * @returns {Node|DocumentFragment|Document|null} Lowest common ancestor of both nodes or `null` if nodes do not have a common ancestor.
 */
function getCommonAncestor( nodeA, nodeB ) {
	const ancestorsA = Object(__WEBPACK_IMPORTED_MODULE_0__getancestors__["a" /* default */])( nodeA );
	const ancestorsB = Object(__WEBPACK_IMPORTED_MODULE_0__getancestors__["a" /* default */])( nodeB );

	let i = 0;

	// It does not matter which array is shorter.
	while ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {
		i++;
	}

	return i === 0 ? null : ancestorsA[ i - 1 ];
}


/***/ }),
/* 425 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsEqual__ = __webpack_require__(94);


/**
 * This method is like `_.isEqual` except that it accepts `customizer` which
 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
 * are handled by the method instead. The `customizer` is invoked with up to
 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if the values are equivalent,
 *  else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 *
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * _.isEqualWith(array, other, customizer);
 * // => true
 */
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  var result = customizer ? customizer(value, other) : undefined;
  return result === undefined ? Object(__WEBPACK_IMPORTED_MODULE_0__baseIsEqual__["a" /* default */])(value, other, customizer) : !!result;
}

/* harmony default export */ __webpack_exports__["a"] = (isEqualWith);


/***/ }),
/* 426 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__observer__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mutationobserver__ = __webpack_require__(261);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_log__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_debounce__ = __webpack_require__(154);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/selectionobserver
 */

/* global setInterval, clearInterval */






/**
 * Selection observer class observes selection changes in the document. If selection changes on the document this
 * observer checks if there are any mutations and if DOM selection is different than the
 * {@link module:engine/view/document~Document#selection view selection}. Selection observer fires
 * {@link module:engine/view/document~Document#event:selectionChange} event only if selection change was the only change in the document
 * and DOM selection is different then the view selection.
 *
 * Note that this observer is attached by the {@link module:engine/view/document~Document} and is available by default.
 *
 * @see module:engine/view/observer/mutationobserver~MutationObserver
 * @extends module:engine/view/observer/observer~Observer
 */
class SelectionObserver extends __WEBPACK_IMPORTED_MODULE_0__observer__["a" /* default */] {
	constructor( document ) {
		super( document );

		/**
		 * Instance of the mutation observer. Selection observer calls
		 * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled
		 * before the {@link module:engine/view/document~Document#event:selectionChange} event is fired.
		 *
		 * @readonly
		 * @member {module:engine/view/observer/mutationobserver~MutationObserver}
		 * module:engine/view/observer/selectionobserver~SelectionObserver#mutationObserver
		 */
		this.mutationObserver = document.getObserver( __WEBPACK_IMPORTED_MODULE_1__mutationobserver__["a" /* default */] );

		/**
		 * Reference to the {@link module:engine/view/document~Document} object.
		 *
		 * @readonly
		 * @member {module:engine/view/document~Document} module:engine/view/observer/selectionobserver~SelectionObserver#document
		 */
		this.document = document;

		/**
		 * Reference to the view {@link module:engine/view/selection~Selection} object used to compare new selection with it.
		 *
		 * @readonly
		 * @member {module:engine/view/selection~Selection} module:engine/view/observer/selectionobserver~SelectionObserver#selection
		 */
		this.selection = document.selection;

		/* eslint-disable max-len */
		/**
		 * Reference to the {@link module:engine/view/document~Document#domConverter}.
		 *
		 * @readonly
		 * @member {module:engine/view/domconverter~DomConverter} module:engine/view/observer/selectionobserver~SelectionObserver#domConverter
		 */
		/* eslint-enable max-len */
		this.domConverter = document.domConverter;

		/**
		 * Set of documents which have added "selectionchange" listener to avoid adding listener twice to the same
		 * document.
		 *
		 * @private
		 * @member {WeakSet.<Document>} module:engine/view/observer/selectionobserver~SelectionObserver#_documents
		 */
		this._documents = new WeakSet();

		/**
		 * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.
		 *
		 * @private
		 * @param {Object} data Selection change data.
		 * @method #_fireSelectionChangeDoneDebounced
		 */
		this._fireSelectionChangeDoneDebounced = Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_debounce__["a" /* default */])( data => this.document.fire( 'selectionChangeDone', data ), 200 );

		this._clearInfiniteLoopInterval = setInterval( () => this._clearInfiniteLoop(), 1000 );

		/**
		 * Private property to check if the code does not enter infinite loop.
		 *
		 * @private
		 * @member {Number} module:engine/view/observer/selectionobserver~SelectionObserver#_loopbackCounter
		 */
		this._loopbackCounter = 0;
	}

	/**
	 * @inheritDoc
	 */
	observe( domElement ) {
		const domDocument = domElement.ownerDocument;

		// Add listener once per each document.
		if ( this._documents.has( domDocument ) ) {
			return;
		}

		this.listenTo( domDocument, 'selectionchange', () => {
			this._handleSelectionChange( domDocument );
		} );

		this._documents.add( domDocument );
	}

	/**
	 * @inheritDoc
	 */
	destroy() {
		super.destroy();

		clearInterval( this._clearInfiniteLoopInterval );
		this._fireSelectionChangeDoneDebounced.cancel();
	}

	/**
	 * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if
	 * selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change
	 * and {@link module:engine/view/document~Document#event:selectionChangeDone} when selection stop changing.
	 *
	 * @private
	 * @param {Document} domDocument DOM document.
	 */
	_handleSelectionChange( domDocument ) {
		// Selection is handled when document is not focused but is read-only. This is because in read-only
		// mode contenteditable is set as false and editor won't receive focus but we still need to know
		// selection position.
		if ( !this.isEnabled || ( !this.document.isFocused && !this.document.isReadOnly ) ) {
			return;
		}

		// Ensure the mutation event will be before selection event on all browsers.
		this.mutationObserver.flush();

		// If there were mutations then the view will be re-rendered by the mutation observer and selection
		// will be updated, so selections will equal and event will not be fired, as expected.
		const domSelection = domDocument.defaultView.getSelection();
		const newViewSelection = this.domConverter.domSelectionToView( domSelection );

		if ( this.selection.isEqual( newViewSelection ) && this.domConverter.isDomSelectionCorrect( domSelection ) ) {
			return;
		}

		// Ensure we are not in the infinite loop (#400).
		// This counter is reset each second. 60 selection changes in 1 second is enough high number
		// to be very difficult (impossible) to achieve using just keyboard keys (during normal editor use).
		if ( ++this._loopbackCounter > 60 ) {
			/**
			 * Selection change observer detected an infinite rendering loop.
			 * Most probably you try to put the selection in the position which is not allowed
			 * by the browser and browser fixes it automatically what causes `selectionchange` event on
			 * which a loopback through a model tries to re-render the wrong selection and again.
			 *
			 * @error selectionchange-infinite-loop
			 */
			__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_log__["a" /* default */].warn( 'selectionchange-infinite-loop: Selection change observer detected an infinite rendering loop.' );

			return;
		}

		if ( this.selection.isSimilar( newViewSelection ) ) {
			// If selection was equal and we are at this point of algorithm, it means that it was incorrect.
			// Just re-render it, no need to fire any events, etc.
			this.document.render();
		} else {
			const data = {
				oldSelection: this.selection,
				newSelection: newViewSelection,
				domSelection
			};

			// Prepare data for new selection and fire appropriate events.
			this.document.fire( 'selectionChange', data );

			// Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.
			// This function is debounced what means that `selectionChangeDone` event will be fired only when
			// defined int the function time will elapse since the last time the function was called.
			// So `selectionChangeDone` will be fired when selection will stop changing.
			this._fireSelectionChangeDoneDebounced( data );
		}
	}

	/**
	 * Clears `SelectionObserver` internal properties connected with preventing infinite loop.
	 *
	 * @protected
	 */
	_clearInfiniteLoop() {
		this._loopbackCounter = 0;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = SelectionObserver;


/**
 * Fired when selection has changed. This event is fired only when the selection change was the only change that happened
 * in the document, and old selection is different then the new selection.
 *
 * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
 *
 * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the
 * {@link module:engine/view/document~Document}
 * this event is available by default.
 *
 * @see module:engine/view/observer/selectionobserver~SelectionObserver
 * @event module:engine/view/document~Document#event:selectionChange
 * @param {Object} data
 * @param {module:engine/view/selection~Selection} data.oldSelection Old View selection which is
 * {@link module:engine/view/document~Document#selection}.
 * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.
 * @param {Selection} data.domSelection Native DOM selection.
 */

/**
 * Fired when selection stops changing.
 *
 * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
 *
 * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the
 * {@link module:engine/view/document~Document}
 * this event is available by default.
 *
 * @see module:engine/view/observer/selectionobserver~SelectionObserver
 * @event module:engine/view/document~Document#event:selectionChangeDone
 * @param {Object} data
 * @param {module:engine/view/selection~Selection} data.oldSelection Old View selection which is
 * {@link module:engine/view/document~Document#selection}.
 * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.
 * @param {Selection} data.domSelection Native DOM selection.
 */


/***/ }),
/* 427 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @type {Function}
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred function to be invoked.
 */
var now = Date.now;

/* harmony default export */ __webpack_exports__["a"] = (now);


/***/ }),
/* 428 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__domeventobserver__ = __webpack_require__(74);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/focusobserver
 */

/* globals setTimeout, clearTimeout */



/**
 * {@link module:engine/view/document~Document#event:focus Focus}
 * and {@link module:engine/view/document~Document#event:blur blur} events observer.
 * Focus observer handle also {@link module:engine/view/rooteditableelement~RootEditableElement#isFocused isFocused} property of the
 * {@link module:engine/view/rooteditableelement~RootEditableElement root elements}.
 *
 * Note that this observer is attached by the {@link module:engine/view/document~Document} and is available by default.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */
class FocusObserver extends __WEBPACK_IMPORTED_MODULE_0__domeventobserver__["a" /* default */] {
	constructor( document ) {
		super( document );

		this.domEventType = [ 'focus', 'blur' ];
		this.useCapture = true;

		document.on( 'focus', () => {
			document.isFocused = true;

			// Unfortunately native `selectionchange` event is fired asynchronously.
			// We need to wait until `SelectionObserver` handle the event and then render. Otherwise rendering will
			// overwrite new DOM selection with selection from the view.
			// See https://github.com/ckeditor/ckeditor5-engine/issues/795 for more details.
			this._renderTimeoutId = setTimeout( () => document.render(), 0 );
		} );

		document.on( 'blur', ( evt, data ) => {
			const selectedEditable = document.selection.editableElement;

			if ( selectedEditable === null || selectedEditable === data.target ) {
				document.isFocused = false;

				// Re-render the document to update view elements.
				document.render();
			}
		} );

		/**
		 * Identifier of the timeout currently used by focus listener to delay rendering execution.
		 *
		 * @private
		 * @member {Number} #_renderTimeoutId
		 */
	}

	onDomEvent( domEvent ) {
		this.fire( domEvent.type, domEvent );
	}

	/**
	 * @inheritDoc
	 */
	destroy() {
		if ( this._renderTimeoutId ) {
			clearTimeout( this._renderTimeoutId );
		}

		super.destroy();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FocusObserver;


/**
 * Fired when one of the editables gets focus.
 *
 * Introduced by {@link module:engine/view/observer/focusobserver~FocusObserver}.
 *
 * Note that because {@link module:engine/view/observer/focusobserver~FocusObserver} is attached by the
 * {@link module:engine/view/document~Document}
 * this event is available by default.
 *
 * @see module:engine/view/observer/focusobserver~FocusObserver
 * @event module:engine/view/document~Document#event:focus
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */

/**
 * Fired when one of the editables loses focus.
 *
 * Introduced by {@link module:engine/view/observer/focusobserver~FocusObserver}.
 *
 * Note that because {@link module:engine/view/observer/focusobserver~FocusObserver} is attached by the
 * {@link module:engine/view/document~Document}
 * this event is available by default.
 *
 * @see module:engine/view/observer/focusobserver~FocusObserver
 * @event module:engine/view/document~Document#event:blur
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */


/***/ }),
/* 429 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__domeventobserver__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_keyboard__ = __webpack_require__(28);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/keyobserver
 */




/**
 * {@link module:engine/view/document~Document#event:keydown Key down} event observer.
 *
 * Note that this observer is attached by the {@link module:engine/view/document~Document} and is available by default.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */
class KeyObserver extends __WEBPACK_IMPORTED_MODULE_0__domeventobserver__["a" /* default */] {
	constructor( document ) {
		super( document );

		this.domEventType = [ 'keydown', 'keyup' ];
	}

	onDomEvent( domEvt ) {
		this.fire( domEvt.type, domEvt, {
			keyCode: domEvt.keyCode,

			altKey: domEvt.altKey,
			ctrlKey: domEvt.ctrlKey || domEvt.metaKey,
			shiftKey: domEvt.shiftKey,

			get keystroke() {
				return Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_keyboard__["a" /* getCode */])( this );
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = KeyObserver;


/**
 * Fired when a key has been pressed.
 *
 * Introduced by {@link module:engine/view/observer/keyobserver~KeyObserver}.
 *
 * Note that because {@link module:engine/view/observer/keyobserver~KeyObserver} is attached by the
 * {@link module:engine/view/document~Document}
 * this event is available by default.
 *
 * @see module:engine/view/observer/keyobserver~KeyObserver
 * @event module:engine/view/document~Document#event:keydown
 * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEventData
 */

/**
 * Fired when a key has been released.
 *
 * Introduced by {@link module:engine/view/observer/keyobserver~KeyObserver}.
 *
 * Note that because {@link module:engine/view/observer/keyobserver~KeyObserver} is attached by the
 * {@link module:engine/view/document~Document}
 * this event is available by default.
 *
 * @see module:engine/view/observer/keyobserver~KeyObserver
 * @event module:engine/view/document~Document#event:keyup
 * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEventData
 */

/**
 * The value of both events - {@link module:engine/view/document~Document#event:keydown} and
 * {@link module:engine/view/document~Document#event:keyup}.
 *
 * @class module:engine/view/observer/keyobserver~KeyEventData
 * @extends module:engine/view/observer/domeventdata~DomEventData
 * @implements module:utils/keyboard~KeystrokeInfo
 */

/**
 * Code of the whole keystroke. See {@link module:utils/keyboard~getCode}.
 *
 * @readonly
 * @member {Number} module:engine/view/observer/keyobserver~KeyEventData#keystroke
 */


/***/ }),
/* 430 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__observer__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selection__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_debounce__ = __webpack_require__(154);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/fakeselectionobserver
 */






/**
 * Fake selection observer class. If view selection is fake it is placed in dummy DOM container. This observer listens
 * on {@link module:engine/view/document~Document#event:keydown keydown} events and handles moving fake view selection to the correct place
 * if arrow keys are pressed.
 * Fires {@link module:engine/view/document~Document#event:selectionChange selectionChange event} simulating natural behaviour of
 * {@link module:engine/view/observer/selectionobserver~SelectionObserver SelectionObserver}.
 *
 * @extends module:engine/view/observer/observer~Observer.Observer
 */
class FakeSelectionObserver extends __WEBPACK_IMPORTED_MODULE_0__observer__["a" /* default */] {
	/**
	 * Creates new FakeSelectionObserver instance.
	 *
	 * @param {module:engine/view/document~Document} document
	 */
	constructor( document ) {
		super( document );

		/**
		 * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.
		 *
		 * @private
		 * @param {Object} data Selection change data.
		 * @method #_fireSelectionChangeDoneDebounced
		 */
		this._fireSelectionChangeDoneDebounced = Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_lib_lodash_debounce__["a" /* default */])( data => this.document.fire( 'selectionChangeDone', data ), 200 );
	}

	/**
	 * @inheritDoc
	 */
	observe() {
		const document = this.document;

		document.on( 'keydown', ( eventInfo, data ) => {
			const selection = document.selection;

			if ( selection.isFake && _isArrowKeyCode( data.keyCode ) && this.isEnabled ) {
				// Prevents default key down handling - no selection change will occur.
				data.preventDefault();

				this._handleSelectionMove( data.keyCode );
			}
		}, { priority: 'lowest' } );
	}

	/**
	 * @inheritDoc
	 */
	destroy() {
		super.destroy();

		this._fireSelectionChangeDoneDebounced.cancel();
	}

	/**
	 * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be
	 * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.
	 *
	 * This method fires {@link module:engine/view/document~Document#event:selectionChange} and
	 * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of
	 * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
	 *
	 * @private
	 * @param {Number} keyCode
	 * @fires module:engine/view/document~Document#event:selectionChange
	 * @fires module:engine/view/document~Document#event:selectionChangeDone
	 */
	_handleSelectionMove( keyCode ) {
		const selection = this.document.selection;
		const newSelection = __WEBPACK_IMPORTED_MODULE_1__selection__["a" /* default */].createFromSelection( selection );
		newSelection.setFake( false );

		// Left or up arrow pressed - move selection to start.
		if ( keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowleft || keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowup ) {
			newSelection.collapseToStart();
		}

		// Right or down arrow pressed - move selection to end.
		if ( keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowright || keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowdown ) {
			newSelection.collapseToEnd();
		}

		const data = {
			oldSelection: selection,
			newSelection,
			domSelection: null
		};

		// Fire dummy selection change event.
		this.document.fire( 'selectionChange', data );

		// Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.
		// This function is debounced what means that `selectionChangeDone` event will be fired only when
		// defined int the function time will elapse since the last time the function was called.
		// So `selectionChangeDone` will be fired when selection will stop changing.
		this._fireSelectionChangeDoneDebounced( data );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FakeSelectionObserver;


// Checks if one of the arrow keys is pressed.
//
// @private
// @param {Number} keyCode
// @returns {Boolean}
function _isArrowKeyCode( keyCode ) {
	return keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowright ||
		keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowleft ||
		keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowup ||
		keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowdown;
}



/***/ }),
/* 431 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = scrollViewportToShowTarget;
/* unused harmony export scrollAncestorsToShowTarget */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isrange__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rect__ = __webpack_require__(157);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* global Node */

/**
 * @module utils/dom/scroll
 */




const utils = {};

/**
 * Makes any page `HTMLElement` or `Range` (`target`) visible inside the browser viewport.
 * This helper will scroll all `target` ancestors and the web browser viewport to reveal the target to
 * the user. If the `target` is already visible, nothing will happen.
 *
 * @param {HTMLElement|Range} options.target A target, which supposed to become visible to the user.
 * @param {Number} [options.viewportOffset] An offset from the edge of the viewport (in pixels)
 * the `target` will be moved by when the viewport is scrolled. It enhances the user experience
 * by keeping the `target` some distance from the edge of the viewport and thus making it easier to
 * read or edit by the user.
 */
function scrollViewportToShowTarget( { target, viewportOffset = 0 } ) {
	const targetWindow = getWindow( target );
	let currentWindow = targetWindow;
	let currentFrame = null;

	// Iterate over all windows, starting from target's parent window up to window#top.
	while ( currentWindow ) {
		let firstAncestorToScroll;

		// Let's scroll target's ancestors first to reveal it. Then, once the ancestor scrolls
		// settled down, the algorithm can eventually scroll the viewport of the current window.
		//
		// Note: If the current window is target's **original** window (e.g. the first one),
		// start scrolling the closest parent of the target. If not, scroll the closest parent
		// of an iframe that resides in the current window.
		if ( currentWindow == targetWindow ) {
			firstAncestorToScroll = getParentElement( target );
		} else {
			firstAncestorToScroll = getParentElement( currentFrame );
		}

		// Scroll the target's ancestors first. Once done, scrolling the viewport is easy.
		scrollAncestorsToShowRect( firstAncestorToScroll, () => {
			// Note: If the target does not belong to the current window **directly**,
			// i.e. it resides in an iframe belonging to the window, obtain the target's rect
			// in the coordinates of the current window. By default, a Rect returns geometry
			// relative to the current window's viewport. To make it work in a parent window,
			// it must be shifted.
			return getRectRelativeToWindow( target, currentWindow );
		} );

		// Obtain the rect of the target after it has been scrolled within its ancestors.
		// It's time to scroll the viewport.
		const targetRect = getRectRelativeToWindow( target, currentWindow );

		scrollWindowToShowRect( currentWindow, targetRect, viewportOffset );

		if ( currentWindow.parent != currentWindow ) {
			// Keep the reference to the <iframe> element the "previous current window" was
			// rendered within. It will be useful to recalculate the rect of the target
			// in the parent window's relative geometry. The target's rect must be shifted
			// by it's iframe's position.
			currentFrame = currentWindow.frameElement;
			currentWindow = currentWindow.parent;
		} else {
			currentWindow = null;
		}
	}
}

/**
 * Makes any page `HTMLElement` or `Range` (target) visible within its scrollable ancestors,
 * e.g. if they have `overflow: scroll` CSS style.
 *
 * @param {HTMLElement|Range} target A target, which supposed to become visible to the user.
 */
function scrollAncestorsToShowTarget( target ) {
	const targetParent = getParentElement( target );

	scrollAncestorsToShowRect( targetParent, () => {
		return new __WEBPACK_IMPORTED_MODULE_1__rect__["a" /* default */]( target );
	} );
}

// TODO: Using a property value shorthand in the top of the file
// causes JSDoc to throw errors. See https://github.com/cksource/docs-builder/issues/75.
Object.assign( utils, {
	scrollViewportToShowTarget,
	scrollAncestorsToShowTarget
} );

// Makes a given rect visible within its parent window.
//
// Note: Avoid the situation where the caret is still in the viewport, but totally
// at the edge of it. In such situation, if it moved beyond the viewport in the next
// action e.g. after paste, the scrolling would move it to the viewportOffset level
// and it all would look like the caret visually moved up/down:
//
// 1.
//		| foo[]
//		|                                    <--- N px of space below the caret
//		+---------------------------------...
//
// 2. *paste*
// 3.
//		|
//		|
//		+-foo-----------------------------...
//		  bar[]                              <--- caret below viewport, scrolling...
//
// 4. *scrolling*
// 5.
//		|
//		| foo
//		| bar[]                              <--- caret precisely at the edge
//		+---------------------------------...
//
// To prevent this, this method checks the rects moved by the viewportOffset to cover
// the upper/lower edge of the viewport. It makes sure if the action repeats, there's
// no twitching  it's a purely visual improvement:
//
// 5. (after fix)
//		|
//		| foo
//		| bar[]
//		|                                    <--- N px of space below the caret
//		+---------------------------------...
//
// @private
// @param {Window} window A window which is scrolled to reveal the rect.
// @param {module:utils/dom/rect~Rect} rect A rect which is to be revealed.
// @param {Number} viewportOffset See scrollViewportToShowTarget.
function scrollWindowToShowRect( window, rect, viewportOffset ) {
	const targetShiftedDownRect = rect.clone().moveBy( 0, viewportOffset );
	const targetShiftedUpRect = rect.clone().moveBy( 0, -viewportOffset );
	const viewportRect = new __WEBPACK_IMPORTED_MODULE_1__rect__["a" /* default */]( window ).excludeScrollbarsAndBorders();

	const rects = [ targetShiftedUpRect, targetShiftedDownRect ];

	if ( !rects.every( rect => viewportRect.contains( rect ) ) ) {
		let { scrollX, scrollY } = window;

		if ( isAbove( targetShiftedUpRect, viewportRect ) ) {
			scrollY -= viewportRect.top - rect.top + viewportOffset;
		} else if ( isBelow( targetShiftedDownRect, viewportRect ) ) {
			scrollY += rect.bottom - viewportRect.bottom + viewportOffset;
		}

		// TODO: Web browsers scroll natively to place the target in the middle
		// of the viewport. It's not a very popular case, though.
		if ( isLeftOf( rect, viewportRect ) ) {
			scrollX -= viewportRect.left - rect.left + viewportOffset;
		} else if ( isRightOf( rect, viewportRect ) ) {
			scrollX += rect.right - viewportRect.right + viewportOffset;
		}

		window.scrollTo( scrollX, scrollY );
	}
}

// Recursively scrolls element ancestors to visually reveal a rect.
//
// @private
// @param {HTMLElement} A parent The first ancestors to start scrolling.
// @param {Function} getRect A function which returns the Rect, which is to be revealed.
function scrollAncestorsToShowRect( parent, getRect ) {
	const parentWindow = getWindow( parent );
	let parentRect, targetRect;

	while ( parent != parentWindow.document.body ) {
		targetRect = getRect();
		parentRect = new __WEBPACK_IMPORTED_MODULE_1__rect__["a" /* default */]( parent ).excludeScrollbarsAndBorders();

		if ( !parentRect.contains( targetRect ) ) {
			if ( isAbove( targetRect, parentRect ) ) {
				parent.scrollTop -= parentRect.top - targetRect.top;
			} else if ( isBelow( targetRect, parentRect ) ) {
				parent.scrollTop += targetRect.bottom - parentRect.bottom;
			}

			if ( isLeftOf( targetRect, parentRect ) ) {
				parent.scrollLeft -= parentRect.left - targetRect.left;
			} else if ( isRightOf( targetRect, parentRect ) ) {
				parent.scrollLeft += targetRect.right - parentRect.right;
			}
		}

		parent = parent.parentNode;
	}
}

// Determines if a given `Rect` extends beyond the bottom edge of the second `Rect`.
//
// @private
// @param {module:utils/dom/rect~Rect} firstRect
// @param {module:utils/dom/rect~Rect} secondRect
function isBelow( firstRect, secondRect ) {
	return firstRect.bottom > secondRect.bottom;
}

// Determines if a given `Rect` extends beyond the top edge of the second `Rect`.
//
// @private
// @param {module:utils/dom/rect~Rect} firstRect
// @param {module:utils/dom/rect~Rect} secondRect
function isAbove( firstRect, secondRect ) {
	return firstRect.top < secondRect.top;
}

// Determines if a given `Rect` extends beyond the left edge of the second `Rect`.
//
// @private
// @param {module:utils/dom/rect~Rect} firstRect
// @param {module:utils/dom/rect~Rect} secondRect
function isLeftOf( firstRect, secondRect ) {
	return firstRect.left < secondRect.left;
}

// Determines if a given `Rect` extends beyond the right edge of the second `Rect`.
//
// @private
// @param {module:utils/dom/rect~Rect} firstRect
// @param {module:utils/dom/rect~Rect} secondRect
function isRightOf( firstRect, secondRect ) {
	return firstRect.right > secondRect.right;
}

// Returns the closest window of an element or range.
//
// @private
// @param {HTMLElement|Range} firstRect
// @returns {Window}
function getWindow( elementOrRange ) {
	if ( Object(__WEBPACK_IMPORTED_MODULE_0__isrange__["a" /* default */])( elementOrRange ) ) {
		return elementOrRange.startContainer.ownerDocument.defaultView;
	} else {
		return elementOrRange.ownerDocument.defaultView;
	}
}

// Returns the closest parent of an element or DOM range.
//
// @private
// @param {HTMLElement|Range} firstRect
// @returns {HTMLelement}
function getParentElement( elementOrRange ) {
	if ( Object(__WEBPACK_IMPORTED_MODULE_0__isrange__["a" /* default */])( elementOrRange ) ) {
		let parent = elementOrRange.commonAncestorContainer;

		// If a Range is attached to the Text, use the closest element ancestor.
		if ( parent.nodeType == Node.TEXT_NODE ) {
			parent = parent.parentNode;
		}

		return parent;
	} else {
		return elementOrRange.parentNode;
	}
}

// Returns the rect of an element or range residing in an iframe.
// The result rect is relative to the geometry of the passed window instance.
//
// @private
// @param {HTMLElement|Range} target Element or range which rect should be returned.
// @param {Window} relativeWindow A window the rect should be relative to.
// @returns {module:utils/dom/rect~Rect}
function getRectRelativeToWindow( target, relativeWindow ) {
	const targetWindow = getWindow( target );
	const rect = new __WEBPACK_IMPORTED_MODULE_1__rect__["a" /* default */]( target );

	if ( targetWindow === relativeWindow ) {
		return rect;
	} else {
		let currentWindow = targetWindow;

		while ( currentWindow != relativeWindow ) {
			const frame = currentWindow.frameElement;
			const frameRect = new __WEBPACK_IMPORTED_MODULE_1__rect__["a" /* default */]( frame ).excludeScrollbarsAndBorders();

			rect.moveBy( frameRect.left, frameRect.top );

			currentWindow = currentWindow.parent;
		}
	}

	return rect;
}


/***/ }),
/* 432 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isWindow;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/iswindow
 */

/**
 * Checks if the object is a native DOM Window.
 *
 * @param {*} obj
 * @returns {Boolean}
 */
function isWindow( obj ) {
	return Object.prototype.toString.apply( obj ) == '[object Window]';
}


/***/ }),
/* 433 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = convertSelectionChange;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__model_selection__ = __webpack_require__(108);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Contains {@link module:engine/view/selection~Selection view selection}
 * to {@link module:engine/model/selection~Selection model selection} conversion helpers.
 *
 * @module engine/conversion/view-selection-to-model-converters
 */



/**
 * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection view selection} taken
 * from the {@link module:engine/view/document~Document#event:selectionChange} event
 * and sets in on the {@link module:engine/model/document~Document#selection model}.
 *
 * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model
 * conversion mechanism, the callback should be set directly on view document.
 *
 *		view.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );
 *
 * @param {module:engine/model/document~Document} modelDocument Model document on which selection should be updated.
 * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.
 * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.
 */
function convertSelectionChange( modelDocument, mapper ) {
	return ( evt, data ) => {
		const viewSelection = data.newSelection;
		const modelSelection = new __WEBPACK_IMPORTED_MODULE_0__model_selection__["a" /* default */]();

		const ranges = [];

		for ( const viewRange of viewSelection.getRanges() ) {
			ranges.push( mapper.toModelRange( viewRange ) );
		}

		modelSelection.setRanges( ranges, viewSelection.isBackward );

		if ( !modelSelection.isEqual( modelDocument.selection ) ) {
			modelDocument.enqueueChanges( () => {
				modelDocument.selection.setTo( modelSelection );
			} );
		}
	};
}


/***/ }),
/* 434 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getDataFromElement;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals HTMLTextAreaElement */

/**
 * @module utils/dom/getdatafromelement
 */

/**
 * Gets data from a given source element.
 *
 * @param {HTMLElement} el The element from which the data will be retrieved.
 * @returns {String} The data string.
 */
function getDataFromElement( el ) {
	if ( el instanceof HTMLTextAreaElement ) {
		return el.value;
	}

	return el.innerHTML;
}


/***/ }),
/* 435 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/dataprocessor/basichtmlwriter
 */

/* globals document */

/**
 * Basic HTML writer, it uses the native `innerHTML` property for basic conversion
 * from DocumentFragment to an HTML string.
 *
 * @implements module:engine/dataprocessor/htmlwriter~HtmlWriter
 */
class BasicHtmlWriter {
	/**
	 * Returns HTML string created from DocumentFragment.
	 *
	 * @param {DocumentFragment} fragment
	 * @returns {String}
	 */
	getHtml( fragment ) {
		const doc = document.implementation.createHTMLDocument( '' );
		const container = doc.createElement( 'div' );
		container.appendChild( fragment );

		return container.innerHTML;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BasicHtmlWriter;



/***/ }),
/* 436 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_componentfactory__ = __webpack_require__(266);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_focustracker__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_toolbar_enabletoolbarkeyboardfocus__ = __webpack_require__(267);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_toolbar_normalizetoolbarconfig__ = __webpack_require__(268);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module editor-classic/classiceditorui
 */






/**
 * The classic editor UI class.
 *
 * @implements module:core/editor/editorui~EditorUI
 */
class ClassicEditorUI {
	/**
	 * Creates an instance of the editor UI class.
	 *
	 * @param {module:core/editor/editor~Editor} editor The editor instance.
	 * @param {module:ui/editorui/editoruiview~EditorUIView} view The view of the UI.
	 */
	constructor( editor, view ) {
		/**
		 * @inheritDoc
		 */
		this.editor = editor;

		/**
		 * @inheritDoc
		 */
		this.view = view;

		/**
		 * @inheritDoc
		 */
		this.componentFactory = new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_componentfactory__["a" /* default */]( editor );

		/**
		 * @inheritDoc
		 */
		this.focusTracker = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_focustracker__["a" /* default */]();

		/**
		 * A normalized `config.toolbar` object.
		 *
		 * @type {Object}
		 * @private
		 */
		this._toolbarConfig = Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_toolbar_normalizetoolbarconfig__["a" /* default */])( editor.config.get( 'toolbar' ) );
	}

	/**
	 * Initializes the UI.
	 */
	init() {
		const editor = this.editor;
		const view = this.view;

		view.render();

		// Setup the sticky panel with toolbar.
		view.stickyPanel.bind( 'isActive' ).to( this.focusTracker, 'isFocused' );
		view.stickyPanel.limiterElement = view.element;

		if ( this._toolbarConfig.viewportTopOffset ) {
			view.stickyPanel.viewportTopOffset = this._toolbarConfig.viewportTopOffset;
		}

		// Setup the editable.
		const editingRoot = editor.editing.createRoot( 'div' );
		view.editable.bind( 'isReadOnly' ).to( editingRoot );
		view.editable.bind( 'isFocused' ).to( editor.editing.view );
		view.editable.name = editingRoot.rootName;

		this.focusTracker.add( this.view.editableElement );

		this.view.toolbar.fillFromConfig( this._toolbarConfig.items, this.componentFactory );

		Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_toolbar_enabletoolbarkeyboardfocus__["a" /* default */])( {
			origin: editor.editing.view,
			originFocusTracker: this.focusTracker,
			originKeystrokeHandler: editor.keystrokes,
			toolbar: this.view.toolbar
		} );
	}

	/**
	 * Destroys the UI.
	 */
	destroy() {
		this.view.destroy();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ClassicEditorUI;



/***/ }),
/* 437 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_editorui_boxed_boxededitoruiview__ = __webpack_require__(438);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_editableui_inline_inlineeditableuiview__ = __webpack_require__(270);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_panel_sticky_stickypanelview__ = __webpack_require__(441);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_toolbar_toolbarview__ = __webpack_require__(160);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module editor-classic/classiceditoruiview
 */






/**
 * Classic editor UI view. Uses an inline editable and a sticky toolbar, all
 * enclosed in a boxed UI view.
 *
 * @extends module:ui/editorui/boxed/boxededitoruiview~BoxedEditorUIView
 */
class ClassicEditorUIView extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_editorui_boxed_boxededitoruiview__["a" /* default */] {
	/**
	 * Creates an instance of the classic editor UI view.
	 *
	 * @param {module:utils/locale~Locale} locale The {@link module:core/editor/editor~Editor#locale} instance.
	 */
	constructor( locale ) {
		super( locale );

		/**
		 * Sticky panel view instance. This is a parent view of a {@link #toolbar}
		 * that makes toolbar sticky.
		 *
		 * @readonly
		 * @member {module:ui/panel/sticky/stickypanelview~StickyPanelView}
		 */
		this.stickyPanel = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_panel_sticky_stickypanelview__["a" /* default */]( locale );

		/**
		 * Toolbar view instance.
		 *
		 * @readonly
		 * @member {module:ui/toolbar/toolbarview~ToolbarView}
		 */
		this.toolbar = new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_toolbar_toolbarview__["a" /* default */]( locale );

		this.toolbar.extendTemplate( {
			attributes: {
				class: 'ck-editor-toolbar'
			}
		} );

		/**
		 * Editable UI view.
		 *
		 * @readonly
		 * @member {module:ui/editableui/inline/inlineeditableuiview~InlineEditableUIView}
		 */
		this.editable = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_editableui_inline_inlineeditableuiview__["a" /* default */]( locale );
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		// Set toolbar as a child of a stickyPanel and makes toolbar sticky.
		this.stickyPanel.content.add( this.toolbar );

		this.top.add( this.stickyPanel );
		this.main.add( this.editable );
	}

	/**
	 * @inheritDoc
	 */
	get editableElement() {
		return this.editable.element;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ClassicEditorUIView;



/***/ }),
/* 438 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editorui_editoruiview__ = __webpack_require__(269);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_uid__ = __webpack_require__(62);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/editorui/boxed/boxededitoruiview
 */




/**
 * The boxed editor UI view class. This class represents an editor interface
 * consisting of a toolbar and an editable area, enclosed within a box.
 *
 * @extends module:ui/editorui/editoruiview~EditorUIView
 */
class BoxedEditorUIView extends __WEBPACK_IMPORTED_MODULE_0__editorui_editoruiview__["a" /* default */] {
	/**
	 * Creates an instance of the boxed editor UI view class.
	 *
	 * @param {module:utils/locale~Locale} locale The locale instance..
	 */
	constructor( locale ) {
		super( locale );

		const t = this.t;
		const ariaLabelUid = Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_uid__["a" /* default */])();

		/**
		 * Collection of the child views located in the top (`.ck-editor__top`)
		 * area of the UI.
		 *
		 * @readonly
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this.top = this.createCollection();

		/**
		 * Collection of the child views located in the main (`.ck-editor__main`)
		 * area of the UI.
		 *
		 * @readonly
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this.main = this.createCollection();

		this.setTemplate( {
			tag: 'div',

			attributes: {
				class: [
					'ck-reset',
					'ck-editor',
					'ck-rounded-corners'
				],
				role: 'application',
				dir: 'ltr',
				lang: locale.lang,
				'aria-labelledby': `cke-editor__aria-label_${ ariaLabelUid }`
			},

			children: [
				{
					tag: 'span',
					attributes: {
						id: `cke-editor__aria-label_${ ariaLabelUid }`,
						class: 'cke-voice-label'
					},
					children: [
						// TODO: Editor name?
						t( 'Rich Text Editor' )
					]
				},
				{
					tag: 'div',
					attributes: {
						class: 'ck-editor__top ck-reset_all',
						role: 'presentation'
					},
					children: this.top
				},
				{
					tag: 'div',
					attributes: {
						class: 'ck-editor__main',
						role: 'presentation'
					},
					children: this.main
				}
			]
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BoxedEditorUIView;



/***/ }),
/* 439 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseClone__ = __webpack_require__(172);


/**
 * This method is like `_.cloneWith` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the deep cloned value.
 * @see _.cloneWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(true);
 *   }
 * }
 *
 * var el = _.cloneDeepWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 20
 */
function cloneDeepWith(value, customizer) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseClone__["a" /* default */])(value, true, true, customizer);
}

/* harmony default export */ __webpack_exports__["a"] = (cloneDeepWith);


/***/ }),
/* 440 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/editableui/editableuiview
 */



/**
 * The editable UI view class.
 *
 * @extends module:ui/view~View
 */
class EditableUIView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * Creates an instance of EditableUIView class.
	 *
	 * @param {module:utils/locale~Locale} [locale] The locale instance.
	 * @param {HTMLElement} [editableElement] The editable element. If not specified, this view
	 * should create it. Otherwise, the existing element should be used.
	 */
	constructor( locale, editableElement ) {
		super( locale );

		const bind = this.bindTemplate;

		if ( editableElement ) {
			this.element = this.editableElement = editableElement;
		}

		this.setTemplate( {
			tag: 'div',
			attributes: {
				class: [
					bind.to( 'isFocused', value => value ? 'ck-focused' : 'ck-blurred' ),
					'ck-editor__editable',
					'ck-rounded-corners'
				],
				contenteditable: bind.to( 'isReadOnly', value => !value ),
			}
		} );

		/**
		 * Controls whether the editable is writable or not.
		 *
		 * @observable
		 * @member {Boolean} #isReadOnly
		 */
		this.set( 'isReadOnly', false );

		/**
		 * Controls whether the editable is focused, i.e. the user is typing in it.
		 *
		 * @observable
		 * @member {Boolean} #isFocused
		 */
		this.set( 'isFocused', false );

		/**
		 * An external {@link #editableElement} passed into the constructor, which also means
		 * the view will not render its {@link #template}.
		 *
		 * @member {HTMLElement} #externalElement
		 */
		this.externalElement = editableElement;

		/**
		 * The element which is the main editable element (usually the one with `contentEditable="true"`).
		 *
		 * @readonly
		 * @member {HTMLElement} #editableElement
		 */
	}

	/**
	 * Renders the view by either applying the {@link #template} to the existing
	 * {@link #editableElement} or assigning {@link #element} as {@link #editableElement}.
	 */
	render() {
		super.render();

		if ( this.externalElement ) {
			this.template.apply( this.element = this.externalElement );
		} else {
			this.editableElement = this.element;
		}
	}

	/**
	 * @inheritDoc
	 */
	destroy() {
		if ( this.externalElement ) {
			this.template.revert( this.externalElement );
		}

		super.destroy();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EditableUIView;



/***/ }),
/* 441 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_dom_global__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__template__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_dom_tounit__ = __webpack_require__(271);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/panel/sticky/stickypanelview
 */






const toPx = Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_dom_tounit__["a" /* default */])( 'px' );

/**
 * The sticky panel view class.
 */
class StickyPanelView extends __WEBPACK_IMPORTED_MODULE_1__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		const bind = this.bindTemplate;

		/**
		 * Controls whether the sticky panel should be active.
		 *
		 * @readonly
		 * @observable
		 * @member {Boolean} #isActive
		 */
		this.set( 'isActive', false );

		/**
		 * Controls whether the sticky panel is in the "sticky" state.
		 *
		 * @readonly
		 * @observable
		 * @member {Boolean} #isSticky
		 */
		this.set( 'isSticky', false );

		/**
		 * The limiter element for the sticky panel instance. Its bounding rect limits
		 * the "stickyness" of the panel, i.e. when the panel reaches the bottom
		 * edge of the limiter, it becomes sticky to that edge and does not float
		 * off the limiter. It is mandatory for the panel to work properly and once
		 * set, it cannot be changed.
		 *
		 * @readonly
		 * @observable
		 * @member {HTMLElement} #limiterElement
		 */
		this.set( 'limiterElement', null );

		/**
		 * The offset from the bottom edge of {@link #limiterElement}
		 * which stops the panel from stickying any further to prevent limiter's content
		 * from being completely covered.
		 *
		 * @readonly
		 * @observable
		 * @default 50
		 * @member {Number} #limiterBottomOffset
		 */
		this.set( 'limiterBottomOffset', 50 );

		/**
		 * The offset from the top edge of the web browser's viewport which makes the
		 * panel become sticky. The default value is `0`, which means the panel becomes
		 * sticky when it's upper edge touches the top of the page viewport.
		 *
		 * This attribute is useful when the web page has UI elements positioned to the top
		 * either using `position: fixed` or `position: sticky`, which would cover the
		 * sticky panel or viceversa (depending on the `z-index` hierarchy).
		 *
		 * @readonly
		 * @observable
		 * @default 0
		 * @member {Number} #viewportTopOffset
		 */
		this.set( 'viewportTopOffset', 0 );

		/**
		 * Controls the `margin-left` CSS style of the panel.
		 *
		 * @protected
		 * @readonly
		 * @observable
		 * @member {String} #_marginLeft
		 */
		this.set( '_marginLeft', null );

		/**
		 * Set `true` if the sticky panel reached the bottom edge of the
		 * {@link #limiterElement}.
		 *
		 * @protected
		 * @readonly
		 * @observable
		 * @member {Boolean} #_isStickyToTheLimiter
		 */
		this.set( '_isStickyToTheLimiter', false );

		/**
		 * Set `true` if the sticky panel uses the {@link #viewportTopOffset},
		 * i.e. not {@link #_isStickyToTheLimiter} and the {@link #viewportTopOffset}
		 * is not `0`.
		 *
		 * @protected
		 * @readonly
		 * @observable
		 * @member {Boolean} #_hasViewportTopOffset
		 */
		this.set( '_hasViewportTopOffset', false );

		/**
		 * Collection of the child views which creates balloon panel contents.
		 *
		 * @readonly
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this.content = this.createCollection();

		/**
		 * The DOM bounding client rect of the {@link module:ui/view~View#element} of the panel.
		 *
		 * @protected
		 * @member {Object} #_panelRect
		 */

		/**
		 * The DOM bounding client rect of the {@link #limiterElement}
		 * of the panel.
		 *
		 * @protected
		 * @member {Object} #_limiterRect
		 */

		/**
		 * A dummy element which visually fills the space as long as the
		 * actual panel is sticky. It prevents flickering of the UI.
		 *
		 * @protected
		 * @property {HTMLElement}
		 */
		this._contentPanelPlaceholder = new __WEBPACK_IMPORTED_MODULE_2__template__["a" /* default */]( {
			tag: 'div',
			attributes: {
				class: [
					'ck-sticky-panel__placeholder'
				],
				style: {
					display: bind.to( 'isSticky', isSticky => isSticky ? 'block' : 'none' ),
					height: bind.to( 'isSticky', isSticky => {
						return isSticky ? toPx( this._panelRect.height ) : null;
					} )
				}
			}
		} ).render();

		/**
		 * The panel which accepts children into {@link #content} collection.
		 * Also an element which is positioned when {@link #isSticky}.
		 *
		 * @protected
		 * @property {HTMLElement}
		 */
		this._contentPanel = new __WEBPACK_IMPORTED_MODULE_2__template__["a" /* default */]( {
			tag: 'div',

			attributes: {
				class: [
					'ck-sticky-panel__content',
					// Toggle class of the panel when "sticky" state changes in the view.
					bind.if( 'isSticky', 'ck-sticky-panel__content_sticky' ),
					bind.if( '_isStickyToTheLimiter', 'ck-sticky-panel__content_sticky_bottom-limit' ),
				],
				style: {
					width: bind.to( 'isSticky', isSticky => {
						return isSticky ? toPx( this._contentPanelPlaceholder.getBoundingClientRect().width ) : null;
					} ),

					top: bind.to( '_hasViewportTopOffset', _hasViewportTopOffset => {
						return _hasViewportTopOffset ? toPx( this.viewportTopOffset ) : null;
					} ),

					bottom: bind.to( '_isStickyToTheLimiter', _isStickyToTheLimiter => {
						return _isStickyToTheLimiter ? toPx( this.limiterBottomOffset ) : null;
					} ),

					marginLeft: bind.to( '_marginLeft' )
				}
			},

			children: this.content
		} ).render();

		this.setTemplate( {
			tag: 'div',
			attributes: {
				class: [
					'ck-sticky-panel'
				]
			},
			children: [
				this._contentPanelPlaceholder,
				this._contentPanel
			]
		} );
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		// Check if the panel should go into the sticky state immediately.
		this._checkIfShouldBeSticky();

		// Update sticky state of the panel as the window is being scrolled.
		this.listenTo( __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].window, 'scroll', () => {
			this._checkIfShouldBeSticky();
		} );

		// Synchronize with `model.isActive` because sticking an inactive panel is pointless.
		this.listenTo( this, 'change:isActive', () => {
			this._checkIfShouldBeSticky();
		} );
	}

	/**
	 * Analyzes the environment to decide whether the panel should
	 * be sticky or not.
	 *
	 * @protected
	 */
	_checkIfShouldBeSticky() {
		const panelRect = this._panelRect = this._contentPanel.getBoundingClientRect();
		let limiterRect;

		if ( !this.limiterElement ) {
			this.isSticky = false;
		} else {
			limiterRect = this._limiterRect = this.limiterElement.getBoundingClientRect();

			// The panel must be active to become sticky.
			this.isSticky = this.isActive &&
				// The limiter's top edge must be beyond the upper edge of the visible viewport (+the viewportTopOffset).
				limiterRect.top < this.viewportTopOffset &&
				// The model#limiterElement's height mustn't be smaller than the panel's height and model#limiterBottomOffset.
				// There's no point in entering the sticky mode if the model#limiterElement is very, very small, because
				// it would immediately set model#_isStickyToTheLimiter true and, given model#limiterBottomOffset, the panel
				// would be positioned before the model#limiterElement.
				this._panelRect.height + this.limiterBottomOffset < limiterRect.height;
		}

		// Stick the panel to the top edge of the viewport simulating CSS position:sticky.
		// TODO: Possibly replaced by CSS in the future http://caniuse.com/#feat=css-sticky
		if ( this.isSticky ) {
			this._isStickyToTheLimiter =
				limiterRect.bottom < panelRect.height + this.limiterBottomOffset + this.viewportTopOffset;
			this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;
			this._marginLeft = this._isStickyToTheLimiter ? null : toPx( -__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_dom_global__["a" /* default */].window.scrollX );
		}
		// Detach the panel from the top edge of the viewport.
		else {
			this._isStickyToTheLimiter = false;
			this._hasViewportTopOffset = false;
			this._marginLeft = null;
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = StickyPanelView;



/***/ }),
/* 442 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/toolbar/toolbarseparatorview
 */



/**
 * The toolbar separator view class.
 *
 * @extends module:ui/view~View
 */
class ToolbarSeparatorView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		this.setTemplate( {
			tag: 'span',
			attributes: {
				class: [
					'ck-toolbar__separator'
				]
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ToolbarSeparatorView;



/***/ }),
/* 443 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = preventDefault;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/bindings/preventdefault
 */

/**
 * A helper which executes a native `Event.preventDefault()` if the target of an event equals the
 * {@link module:ui/view~View#element element of the view}. It shortens the definition of a
 * {@link module:ui/view~View#template template}.
 *
 *		// In a class extending View.
 *		import preventDefault from '@ckeditor/ckeditor5-ui/src/bindings/preventdefault';
 *
 *		// ...
 *
 *		this.setTemplate( {
 *			tag: 'div',
 *
 *			on: {
 *				// Prevent the default mousedown action on this view.
 *				mousedown: preventDefault( this )
 *			}
 *		} );
 *
 * @param {module:ui/view~View} view View instance that defines the template.
 * @returns {module:ui/template~TemplateToBinding}
 */
function preventDefault( view ) {
	return view.bindTemplate.to( evt => {
		if ( evt.target === view.element ) {
			evt.preventDefault();
		}
	} );
}


/***/ }),
/* 444 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/elementreplacer
 */

/**
 * Utility class allowing to hide existing HTML elements or replace them with given ones in a way that doesn't remove
 * the original elements from the DOM.
 */
class ElementReplacer {
	constructor() {
		/**
		 * The elements replaced by {@link #replace} and their replacements.
		 *
		 * @private
		 * @member {Array.<Object>}
		 */
		this._replacedElements = [];
	}

	/**
	 * Hides the `element` and, if specified, inserts the the given element next to it.
	 *
	 * The effect of this method can be reverted by {@link #restore}.
	 *
	 * @param {HTMLElement} element The element to replace.
	 * @param {HTMLElement} [newElement] The replacement element. If not passed, then the `element` will just be hidden.
	 */
	replace( element, newElement ) {
		this._replacedElements.push( { element, newElement } );

		element.style.display = 'none';

		if ( newElement ) {
			element.parentNode.insertBefore( newElement, element.nextSibling );
		}
	}

	/**
	 * Restores what {@link #replace} did.
	 */
	restore() {
		this._replacedElements.forEach( ( { element, newElement } ) => {
			element.style.display = '';

			if ( newElement ) {
				newElement.remove();
			}
		} );

		this._replacedElements = [];
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ElementReplacer;



/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(446);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(32)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss", function() {
		var newContent = require("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(31)(false);
// imports


// module
exports.push([module.i, ".ck-hidden{display:none!important}.ck-reset,.ck-reset_all,.ck-reset_all *,.ck-reset_all a,.ck-reset_all textarea{box-sizing:border-box;width:auto;height:auto;position:static}svg.ck-icon{min-width:20px;min-height:20px;font-size:1em;vertical-align:middle}svg.ck-icon,svg.ck-icon *{color:inherit;cursor:inherit}svg.ck-icon *{fill:currentColor}.ck-tooltip,.ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:999}.ck-tooltip__text{display:inline-block}.ck-tooltip__text:after{content:\"\";width:0;height:0}.ck-button,a.ck-button{display:inline-block;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.ck-button .ck-tooltip,a.ck-button .ck-tooltip{display:block}.ck-button:hover .ck-tooltip,a.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck-button .ck-button__label,.ck-button:focus:not(:hover) .ck-tooltip,a.ck-button .ck-button__label,a.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck-toolbar__separator{display:inline-block}.ck-toolbar__newline{display:block;clear:left}.ck-dropdown{display:inline-block;position:relative}.ck-dropdown:after{content:\"\";width:0;height:0;pointer-events:none;z-index:1;position:absolute;top:50%;transform:translateY(-50%)}.ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:999;position:absolute;left:0;transform:translateY(100%)}.ck-dropdown__panel-visible{display:inline-block}.ck-label,.ck-list__item{display:block}.cke-voice-label{display:none}.ck-balloon-panel{display:none;position:absolute;z-index:999}.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:\"\";position:absolute}.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:1}.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:2}.ck-balloon-panel.ck-balloon-panel_arrow_n:before,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{z-index:1}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:after{z-index:2}.ck-balloon-panel.ck-balloon-panel_arrow_s:before,.ck-balloon-panel.ck-balloon-panel_arrow_se:before,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{z-index:1}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:after{z-index:2}.ck-balloon-panel_visible{display:block}.ck-editor .ck-sticky-panel .ck-sticky-panel__content_sticky{z-index:999;position:fixed;top:0}.ck-editor .ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{top:auto;position:absolute}.ck-reset,.ck-reset_all,.ck-reset_all *,.ck-reset_all a,.ck-reset_all textarea{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck-reset_all,.ck-reset_all *,.ck-reset_all a,.ck-reset_all textarea{border-collapse:collapse;font:normal normal normal 12px/1.67 Helvetica,Arial,Tahoma,Verdana,Sans-Serif;color:#333;text-align:left;white-space:nowrap;cursor:auto;float:none}.ck-reset_all .ck-rtl *{text-align:right}.ck-reset_all iframe{vertical-align:inherit}.ck-reset_all textarea{white-space:pre-wrap}.ck-reset_all input[type=password],.ck-reset_all input[type=text],.ck-reset_all textarea{cursor:text}.ck-reset_all input[type=password][disabled],.ck-reset_all input[type=text][disabled],.ck-reset_all textarea[disabled]{cursor:default}.ck-reset_all fieldset{padding:10px;border:2px groove #e0dfe3}.ck-reset_all button::-moz-focus-inner{padding:0;border:0}svg.ck-icon{width:1.67em;height:1.67em}.ck-tooltip{left:50%}.ck-tooltip__text{font-size:.9em;line-height:1.5;color:#fff;padding:.4em .64em;background:#333;position:relative;left:-50%}.ck-rounded-corners .ck-tooltip__text,.ck-tooltip__text.ck-rounded-corners{border-radius:2px}.ck-tooltip__text:after{border-style:solid;left:50%}.ck-tooltip.ck-tooltip_s{bottom:-5px;transform:translateY(100%)}.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after{top:-5px;transform:translateX(-50%);border-color:transparent transparent #333;border-width:0 5px 5px}.ck-tooltip.ck-tooltip_n{top:-5px;transform:translateY(-100%)}.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:-5px;transform:translateX(-50%);border-color:#333 transparent transparent;border-width:5px 5px 0}.ck-tooltip,.ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s}.ck-button,a.ck-button{background:#fff;border:1px solid #bfbfbf;white-space:nowrap;cursor:default;vertical-align:middle;padding:.4em;font-size:inherit}.ck-button:not(.ck-disabled):focus,.ck-button:not(.ck-disabled):hover,a.ck-button:not(.ck-disabled):focus,a.ck-button:not(.ck-disabled):hover{background:#e6e6e6;border-color:#acacac}.ck-button:not(.ck-disabled):active,a.ck-button:not(.ck-disabled):active{background:#d9d9d9;border-color:#a3a3a3;box-shadow:inset 0 2px 2px #bfbfbf}.ck-button.ck-disabled,a.ck-button.ck-disabled{background:#fff;border-color:#c6c6c6}.ck-button.ck-rounded-corners,.ck-rounded-corners .ck-button,.ck-rounded-corners a.ck-button,a.ck-button.ck-rounded-corners{border-radius:2px}.ck-button:focus,a.ck-button:focus{outline:none;border:1px solid #48a3f5;box-shadow:0 0 3px 2px #78bbf8}.ck-button .ck-icon,a.ck-button .ck-icon{float:left}.ck-button.ck-disabled .ck-button__label,.ck-button.ck-disabled .ck-icon,a.ck-button.ck-disabled .ck-button__label,a.ck-button.ck-disabled .ck-icon{opacity:.5}.ck-button.ck-button_with-text,a.ck-button.ck-button_with-text{padding:.4em .8em}.ck-button.ck-button_with-text .ck-icon,a.ck-button.ck-button_with-text .ck-icon{margin-left:-.4em;margin-right:.4em}.ck-button.ck-button_with-text .ck-button__label,a.ck-button.ck-button_with-text .ck-button__label{display:block}.ck-button.ck-on,a.ck-button.ck-on{background:#f7f7f7;border-color:#b9b9b9}.ck-button.ck-on:not(.ck-disabled):focus,.ck-button.ck-on:not(.ck-disabled):hover,a.ck-button.ck-on:not(.ck-disabled):focus,a.ck-button.ck-on:not(.ck-disabled):hover{background:#dedede;border-color:#a7a7a7}.ck-button.ck-on:not(.ck-disabled):active,a.ck-button.ck-on:not(.ck-disabled):active{background:#d2d2d2;border-color:#9d9d9d;box-shadow:inset 0 2px 2px #b9b9b9}.ck-button.ck-on.ck-disabled,a.ck-button.ck-on.ck-disabled{background:#f8f8f8;border-color:silver}.ck-button-action,a.ck-button-action{background:#61b145;border-color:#4e8e37;text-shadow:0 -1px #4e8e37;color:#fff}.ck-button-action:not(.ck-disabled):focus,.ck-button-action:not(.ck-disabled):hover,a.ck-button-action:not(.ck-disabled):focus,a.ck-button-action:not(.ck-disabled):hover{background:#579f3e;border-color:#467f32}.ck-button-action:not(.ck-disabled):active,a.ck-button-action:not(.ck-disabled):active{background:#52963b;border-color:#42782f;box-shadow:inset 0 2px 2px #498534}.ck-button-action.ck-disabled,a.ck-button-action.ck-disabled{background:#6fbc54;border-color:#5aa440}.ck-button-action:active,.ck-button-action:focus,.ck-button-action:hover,a.ck-button-action:active,a.ck-button-action:focus,a.ck-button-action:hover{text-shadow:0 -1px #3a6a29}.ck-button-bold,a.ck-button-bold{font-weight:700}.ck-button .ck-icon use,.ck-button .ck-icon use *,a.ck-button .ck-icon use,a.ck-button .ck-icon use *{color:inherit}.ck-button .ck-button__label,a.ck-button .ck-button__label{font-size:inherit;float:left;height:1.67em;line-height:inherit;font-weight:inherit;color:inherit;cursor:inherit}.ck-toolbar{padding:.4em;border:1px solid #bfbfbf;white-space:normal;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.ck-toolbar_floating{white-space:nowrap}.ck-rounded-corners .ck-toolbar,.ck-toolbar.ck-rounded-corners{border-radius:2px}.ck-toolbar__separator{width:1px;height:2.28em;vertical-align:middle;background:#bfbfbf}.ck-toolbar__newline{height:.4em}.ck-toolbar>*{margin-right:.4em}.ck-toolbar>:last-child{margin-right:0}.ck-toolbar-container .ck-toolbar{border:0}.ck-dropdown{font-size:inherit}.ck-dropdown:after{border-style:solid;border-width:.4em .4em 0;border-color:#707070 transparent;right:.8em}.ck-dropdown .ck-button.ck-dropdown__button{padding-right:1.6em}.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:.5}.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck-dropdown__panel{background:#fff;border:1px solid #bfbfbf;bottom:1px;box-shadow:0 1px 2px 0 rgba(0,0,0,.2)}.ck-dropdown__panel.ck-rounded-corners,.ck-rounded-corners .ck-dropdown__panel{border-radius:2px}.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;overflow:hidden;list-style-type:none;background:#fff}.ck-list.ck-rounded-corners,.ck-rounded-corners .ck-list{border-radius:2px}.ck-list__item{padding:.64em;cursor:default;min-width:12em}.ck-list__item:focus,.ck-list__item:hover{background:#f7f7f7}.ck-list__item:focus{box-shadow:0 0 3px 2px #78bbf8;position:relative;z-index:1;outline:none}.ck-list__item_active{background:#1a8bf1;color:#fff}.ck-list__item_active:focus,.ck-list__item_active:hover{background:#0e7ee2}.ck-label{font-weight:700}.ck-input-text{box-shadow:inset 2px 2px 3px rgba(0,0,0,.1);background:#fff;border:1px solid #bfbfbf;padding:.4em .64em;min-width:21em}.ck-input-text.ck-rounded-corners,.ck-rounded-corners .ck-input-text{border-radius:2px}.ck-input-text:focus{outline:none;border:1px solid #48a3f5;box-shadow:0 0 3px 2px #78bbf8,inset 2px 2px 3px rgba(0,0,0,.1)}.ck-input-text[readonly]{border:1px solid #c6c6c6;background:#f2f2f2;color:#5c5c5c}.ck-editor__editable.ck-focused{outline:none;border:1px solid #48a3f5;box-shadow:inset 2px 2px 3px rgba(0,0,0,.1)}.ck-editor__editable_inline{overflow:auto;padding:0 .8em;border:1px solid transparent}.ck-editor-toolbar .ck-button{border-width:0}.ck-editor-toolbar .ck-button.ck-disabled,.ck-editor-toolbar .ck-button:not(:hover):not(:focus):not(.ck-on){background:#f7f7f7}.ck-editor-toolbar .ck-button.ck-on{background:#dedede;border-color:#acacac}.ck-editor-toolbar .ck-button.ck-on:not(.ck-disabled):focus,.ck-editor-toolbar .ck-button.ck-on:not(.ck-disabled):hover{background:#c6c6c6;border-color:#999}.ck-editor-toolbar .ck-button.ck-on:not(.ck-disabled):active{background:#b9b9b9;border-color:#8f8f8f;box-shadow:inset 0 2px 2px #a1a1a1}.ck-editor-toolbar .ck-button.ck-on.ck-disabled{background:#f7f7f7;border-color:#bfbfbf}.ck-editor-toolbar .ck-button.ck-dropdown__button{border-width:1px}.ck-editor-toolbar .ck-button.ck-dropdown__button:not(:hover):not(:focus):not(.ck-on){background:#fff}.ck-toolbar-container .ck-editor-toolbar{background:#f7f7f7}.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_n:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_ne:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_nw:after{border-bottom-color:#f7f7f7}.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_s:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_se:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_sw:after{border-top-color:#f7f7f7}.ck-balloon-panel{box-shadow:0 1px 2px 0 rgba(0,0,0,.2);min-height:15px;background:#fff;border:1px solid #bfbfbf}.ck-balloon-panel.ck-rounded-corners,.ck-rounded-corners .ck-balloon-panel{border-radius:2px}.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_n:before,.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before,.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{border-width:0 10px 15px}.ck-balloon-panel.ck-balloon-panel_arrow_n:before,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{border-color:transparent transparent #bfbfbf}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:after{border-color:transparent transparent #fff;margin-top:2px}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_s:before,.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:before,.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{border-width:15px 10px 0}.ck-balloon-panel.ck-balloon-panel_arrow_s:before,.ck-balloon-panel.ck-balloon-panel_arrow_se:before,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{border-color:#bfbfbf transparent transparent}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:after{border-color:#fff transparent transparent;margin-bottom:2px}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:-10px;top:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:20px;top:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:20px;top:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:-10px;bottom:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:20px;bottom:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:20px;bottom:-15px}.ck-editor .ck-sticky-panel .ck-sticky-panel__content_sticky{box-shadow:0 1px 2px 0 rgba(0,0,0,.2);border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}.ck-editor{position:relative}.ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:999;background:#f7f7f7;border-bottom-width:0}.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners,.ck-rounded-corners .ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:2px;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px}.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners,.ck-rounded-corners .ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-radius:2px;border-radius:0}.ck-editor__editable{border:1px solid #bfbfbf}.ck-editor__editable.ck-rounded-corners,.ck-rounded-corners .ck-editor__editable{border-radius:2px;border-top-left-radius:0;border-top-right-radius:0}", ""]);

// exports


/***/ }),
/* 447 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 448 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_editor_standardeditor__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_dataprocessor_htmldataprocessor__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_toolbar_contextual_contextualtoolbar__ = __webpack_require__(449);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ballooneditorui__ = __webpack_require__(452);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ballooneditoruiview__ = __webpack_require__(453);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_setdatainelement__ = __webpack_require__(265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__theme_theme_scss__ = __webpack_require__(454);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__theme_theme_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__theme_theme_scss__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module editor-balloon/ballooneditor
 */










/**
 * The {@glink builds/guides/overview#Balloon-editor balloon editor} implementation (Medium-like editor).
 * It uses an inline editable and a toolbar based on the {@link module:ui/toolbar/contextual/contextualtoolbar~ContextualToolbar}.
 * See the {@glink examples/builds/balloon-editor demo}.
 *
 * In order to create a balloon editor instance, use the static
 * {@link module:editor-balloon/ballooneditor~BalloonEditor#create `BalloonEditor.create()`} method.
 *
 * # Balloon editor and balloon build
 *
 * The balloon editor can be used directly from source (if you installed the
 * [`@ckeditor/ckeditor5-editor-balloon`](https://www.npmjs.com/package/@ckeditor/ckeditor5-editor-balloon) package)
 * but it is also available in the {@glink builds/guides/overview#Balloon-editor balloon build}.
 *
 * {@glink builds/guides/overview Builds} are ready-to-use editors with plugins bundled in. When using the editor from
 * source you need to take care of loading all plugins by yourself
 * (through the {@link module:core/editor/editorconfig~EditorConfig#plugins `config.plugins`} option).
 * Using the editor from source gives much better flexibility and allows easier customization.
 *
 * Read more about initializing the editor from source or as a build in
 * {@link module:editor-balloon/ballooneditor~BalloonEditor#create `BalloonEditor.create()`}.
 *
 * @extends module:core/editor/standardeditor~StandardEditor
 */
class BalloonEditor extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_editor_standardeditor__["a" /* default */] {
	/**
	 * Creates an instance of the balloon editor.
	 *
	 * **Note:** do not use the constructor to create editor instances. Use the static
	 * {@link module:editor-balloon/ballooneditor~BalloonEditor#create `BalloonEditor.create()`} method instead.
	 *
	 * @protected
	 * @param {HTMLElement} element The DOM element that will be the source for the created editor
	 * (on which the editor will be initialized).
	 * @param {module:core/editor/editorconfig~EditorConfig} config The editor configuration.
	 */
	constructor( element, config ) {
		super( element, config );

		this.config.get( 'plugins' ).push( __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_toolbar_contextual_contextualtoolbar__["a" /* default */] );
		this.config.define( 'contextualToolbar', this.config.get( 'toolbar' ) );

		this.document.createRoot();
		this.data.processor = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_dataprocessor_htmldataprocessor__["a" /* default */]();
		this.ui = new __WEBPACK_IMPORTED_MODULE_3__ballooneditorui__["a" /* default */]( this, new __WEBPACK_IMPORTED_MODULE_4__ballooneditoruiview__["a" /* default */]( this.locale, element ) );
	}

	/**
	 * Destroys the editor instance, releasing all resources used by it.
	 *
	 * Updates the original editor element with the data.
	 *
	 * @returns {Promise}
	 */
	destroy() {
		// Cache the data, then destroy.
		// It's safe to assume that the model->view conversion will not work after super.destroy().
		const data = this.getData();

		this.ui.destroy();

		return super.destroy()
			.then( () => Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_setdatainelement__["a" /* default */])( this.element, data ) );
	}

	/**
	 * Creates a balloon editor instance.
	 *
	 * Creating instance when using {@glink builds/index CKEditor build}:
	 *
	 *		BalloonEditor
	 *			.create( document.querySelector( '#editor' ) )
	 *			.then( editor => {
	 *				console.log( 'Editor was initialized', editor );
	 *			} )
	 *			.catch( err => {
	 *				console.error( err.stack );
	 *			} );
	 *
	 * Creating instance when using CKEditor from source (make sure to specify the list of plugins to load and the toolbar):
	 *
	 *		import BalloonEditor from '@ckeditor/ckeditor5-editor-balloon/src/ballooneditor';
	 *		import Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';
	 *		import Bold from '@ckeditor/ckeditor5-basic-styles/src/bold';
	 *		import Italic from '@ckeditor/ckeditor5-basic-styles/src/italic';
	 *		import ...
	 *
	 *		BalloonEditor
	 *			.create( document.querySelector( '#editor' ), {
	 *				plugins: [ Essentials, Bold, Italic, ... ],
	 *				toolbar: [ 'bold', 'italic', ... ]
	 *			} )
	 *			.then( editor => {
	 *				console.log( 'Editor was initialized', editor );
	 *			} )
	 *			.catch( err => {
	 *				console.error( err.stack );
	 *			} );
	 *
	 * @param {HTMLElement} element The DOM element that will be the source for the created editor
	 * (on which the editor will be initialized).
	 * @param {module:core/editor/editorconfig~EditorConfig} config The editor configuration.
	 * @returns {Promise} A promise resolved once the editor is ready.
	 * The promise returns the created {@link module:editor-balloon/ballooneditor~BalloonEditor} instance.
	 */
	static create( element, config ) {
		return new Promise( resolve => {
			const editor = new this( element, config );

			resolve(
				editor.initPlugins()
					.then( () => {
						editor.ui.init();
						editor.fire( 'uiReady' );
					} )
					.then( () => editor.loadDataFromEditorElement() )
					.then( () => {
						editor.fire( 'dataReady' );
						editor.fire( 'ready' );
					} )
					.then( () => editor )
			);
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BalloonEditor;



/***/ }),
/* 449 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__panel_balloon_contextualballoon__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__toolbarview__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__panel_balloon_balloonpanelview_js__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_lib_lodash_debounce__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_rect__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__normalizetoolbarconfig__ = __webpack_require__(268);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/toolbar/contextual/contextualtoolbar
 */









/**
 * The contextual toolbar.
 *
 * It uses the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon plugin}.
 *
 * @extends module:core/plugin~Plugin
 */
class ContextualToolbar extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'ContextualToolbar';
	}

	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_1__panel_balloon_contextualballoon__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;

		/**
		 * The toolbar view displayed in the balloon.
		 *
		 * @member {module:ui/toolbar/toolbarview~ToolbarView}
		 */
		this.toolbarView = new __WEBPACK_IMPORTED_MODULE_2__toolbarview__["a" /* default */]( editor.locale );

		this.toolbarView.extendTemplate( {
			attributes: {
				class: [
					'ck-editor-toolbar',
					'ck-toolbar_floating'
				]
			}
		} );

		this.toolbarView.render();

		/**
		 * The contextual balloon plugin instance.
		 *
		 * @private
		 * @member {module:ui/panel/balloon/contextualballoon~ContextualBalloon}
		 */
		this._balloon = editor.plugins.get( __WEBPACK_IMPORTED_MODULE_1__panel_balloon_contextualballoon__["a" /* default */] );

		/**
		 * Fires {@link #event:_selectionChangeDebounced} event using `lodash#debounce`.
		 *
		 * This function is stored as a plugin property to make possible to cancel
		 * trailing debounced invocation on destroy.
		 *
		 * @private
		 * @member {Function}
		 */
		this._fireSelectionChangeDebounced = Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_lib_lodash_debounce__["a" /* default */])( () => this.fire( '_selectionChangeDebounced' ), 200 );

		// Attach lifecycle actions.
		this._handleSelectionChange();
		this._handleFocusChange();

		// The appearance of the ContextualToolbar method is eventdriven.
		// It is possible to stop the #show event and this prevent the toolbar from showing up.
		this.decorate( 'show' );
	}

	/**
	 * Creates toolbar components based on given configuration.
	 * This needs to be done when all plugins are ready.
	 *
	 * @inheritDoc
	 */
	afterInit() {
		const config = Object(__WEBPACK_IMPORTED_MODULE_6__normalizetoolbarconfig__["a" /* default */])( this.editor.config.get( 'contextualToolbar' ) );
		const factory = this.editor.ui.componentFactory;

		this.toolbarView.fillFromConfig( config.items, factory );
	}

	/**
	 * Handles the editor focus change and hides the toolbar if it's needed.
	 *
	 * @private
	 */
	_handleFocusChange() {
		const editor = this.editor;

		// Hide the panel View when editor loses focus but no the other way around.
		this.listenTo( editor.ui.focusTracker, 'change:isFocused', ( evt, name, isFocused ) => {
			if ( this._balloon.visibleView === this.toolbarView && !isFocused ) {
				this.hide();
			}
		} );
	}

	/**
	 * Handles {@link module:engine/model/document~Document#selection} change and show or hide toolbar.
	 *
	 * Note that in this case it's better to listen to {@link module:engine/model/document~Document model document}
	 * selection instead of {@link module:engine/view/document~Document view document} selection because the first one
	 * doesn't fire `change` event after text style change (like bold or italic) and toolbar doesn't blink.
	 *
	 * @private
	 */
	_handleSelectionChange() {
		const selection = this.editor.document.selection;
		const editingView = this.editor.editing.view;

		this.listenTo( selection, 'change:range', ( evt, data ) => {
			// When the selection is not changed by a collaboration and when is not collapsed.
			if ( data.directChange || selection.isCollapsed ) {
				// Hide the toolbar when the selection starts changing.
				this.hide();
			}

			// Fire internal `_selectionChangeDebounced` when the selection stops changing.
			this._fireSelectionChangeDebounced();
		} );

		// Hide the toolbar when the selection stops changing.
		this.listenTo( this, '_selectionChangeDebounced', () => {
			// This implementation assumes that only noncollapsed selections gets the contextual toolbar.
			if ( editingView.isFocused && !editingView.selection.isCollapsed ) {
				this.show();
			}
		} );
	}

	/**
	 * Shows the toolbar and attaches it to the selection.
	 *
	 * Fires {@link #event:show} event which can be stopped to prevent the toolbar from showing up.
	 */
	show() {
		// Do not add the toolbar to the balloon stack twice.
		if ( this._balloon.hasView( this.toolbarView ) ) {
			return;
		}

		// Don not show the toolbar when all components inside are disabled
		// see https://github.com/ckeditor/ckeditor5-ui/issues/269.
		if ( Array.from( this.toolbarView.items ).every( item => item.isEnabled !== undefined && !item.isEnabled ) ) {
			return;
		}

		// Update the toolbar position upon #render (e.g. external document changes)
		// while it's visible.
		this.listenTo( this.editor.editing.view, 'render', () => {
			this._balloon.updatePosition( this._getBalloonPositionData() );
		} );

		// Add the toolbar to the common editor contextual balloon.
		this._balloon.add( {
			view: this.toolbarView,
			position: this._getBalloonPositionData(),
			balloonClassName: 'ck-toolbar-container ck-editor-toolbar-container'
		} );
	}

	/**
	 * Hides the toolbar.
	 */
	hide() {
		if ( this._balloon.hasView( this.toolbarView ) ) {
			this.stopListening( this.editor.editing.view, 'render' );
			this._balloon.remove( this.toolbarView );
		}
	}

	/**
	 * Returns positioning options for the {@link #_balloon}. They control the way balloon is attached
	 * to the selection.
	 *
	 * @private
	 * @returns {module:utils/dom/position~Options}
	 */
	_getBalloonPositionData() {
		const editor = this.editor;
		const editingView = editor.editing.view;

		// Get direction of the selection.
		const isBackward = editingView.selection.isBackward;

		return {
			// Because the target for BalloonPanelView is a Rect (not DOMRange), it's geometry will stay fixed
			// as the window scrolls. To let the BalloonPanelView follow such Rect, is must be continuously
			// computed and hence, the target is defined as a function instead of a static value.
			// https://github.com/ckeditor/ckeditor5-ui/issues/195
			target: () => {
				const range = editingView.selection.getFirstRange();
				const rangeRects = __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_dom_rect__["a" /* default */].getDomRangeRects( editingView.domConverter.viewRangeToDom( range ) );

				// Select the proper range rect depending on the direction of the selection.
				if ( isBackward ) {
					return rangeRects[ 0 ];
				} else {
					// Ditch the zero-width "orphan" rect in the next line for the forward selection if there's
					// another one preceding it. It is not rendered as a selection by the web browser anyway.
					// https://github.com/ckeditor/ckeditor5-ui/issues/308
					if ( rangeRects.length > 1 && rangeRects[ rangeRects.length - 1 ].width === 0 ) {
						rangeRects.pop();
					}

					return rangeRects[ rangeRects.length - 1 ];
				}
			},
			positions: getBalloonPositions( isBackward )
		};
	}

	/**
	 * @inheritDoc
	 */
	destroy() {
		this._fireSelectionChangeDebounced.cancel();
		this.stopListening();
		super.destroy();
	}

	/**
	 * This event is fired just before the toolbar shows up. Stopping this event will prevent this.
	 *
	 * @event show
	 */

	/**
	 * This is internal plugin event which is fired 200 ms after model selection last change.
	 * This is to makes easy test debounced action without need to use `setTimeout`.
	 *
	 * @protected
	 * @event _selectionChangeDebounced
	 */
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ContextualToolbar;


// Returns toolbar positions for the given direction of the selection.
//
// @private
// @param {Boolean} isBackward
// @returns {Array.<module:utils/dom/position~Position>}
function getBalloonPositions( isBackward ) {
	const defaultPositions = __WEBPACK_IMPORTED_MODULE_3__panel_balloon_balloonpanelview_js__["a" /* default */].defaultPositions;

	return isBackward ? [
		defaultPositions.northWestArrowSouth,
		defaultPositions.northWestArrowSouthWest,
		defaultPositions.northWestArrowSouthEast,
		defaultPositions.southWestArrowNorth,
		defaultPositions.southWestArrowNorthWest,
		defaultPositions.southWestArrowNorthEast
	] : [
		defaultPositions.southEastArrowNorth,
		defaultPositions.southEastArrowNorthEast,
		defaultPositions.southEastArrowNorthWest,
		defaultPositions.northEastArrowSouth,
		defaultPositions.northEastArrowSouthEast,
		defaultPositions.northEastArrowSouthWest
	];
}

/**
 * Contextual toolbar configuration. Used by the {@link module:ui/toolbar/contextual/contextualtoolbar~ContextualToolbar}
 * feature.
 *
 *		const config = {
 *			contextualToolbar: [ 'bold', 'italic', 'undo', 'redo' ]
 *		};
 *
 * You can also use `'|'` to create a separator between groups of items:
 *
 *		const config = {
 *			contextualToolbar: [ 'bold', 'italic', | 'undo', 'redo' ]
 *		};
 *
 * Read also about configuring the main editor toolbar in {@link module:core/editor/editorconfig~EditorConfig#toolbar}.
 *
 * @member {Array.<String>|Object} module:core/editor/editorconfig~EditorConfig#contextualToolbar
 */


/***/ }),
/* 450 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getOptimalPosition;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__global__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rect__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__getpositionedancestor__ = __webpack_require__(451);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__getborderwidths__ = __webpack_require__(263);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_lodash_isFunction__ = __webpack_require__(64);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/position
 */







/**
 * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the
 * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry
 * into consideration.
 *
 *		// The element which is to be positioned.
 *		const element = document.body.querySelector( '#toolbar' );
 *
 *		// A target to which the element is positioned relatively.
 *		const target = document.body.querySelector( '#container' );
 *
 *		// Finding the optimal coordinates for the positioning.
 *		const { left, top, name } = getOptimalPosition( {
 *			element: element,
 *			target: target,
 *
 * 			// The algorithm will chose among these positions to meet the requirements such
 * 			// as "limiter" element or "fitInViewport", set below. The positions are considered
 * 			// in the order of the array.
 *			positions: [
 *				//
 *			 	//	[ Target ]
 *				//	+-----------------+
 *				//	|     Element     |
 *				//	+-----------------+
 *				//
 *				targetRect => ( {
 *					top: targetRect.bottom,
 *					left: targetRect.left,
 *					name: 'mySouthEastPosition'
 *				} ),
 *
 *				//
 *				//	+-----------------+
 *				//	|     Element     |
 *				//	+-----------------+
 *				//	[ Target ]
 *				//
 *				( targetRect, elementRect ) => ( {
 *					top: targetRect.top - elementRect.height,
 *					left: targetRect.left,
 *					name: 'myNorthEastPosition'
 *				} )
 *			],
 *
 *			// Find a position such guarantees the element remains within visible boundaries of <body>.
 *			limiter: document.body,
 *
 *			// Find a position such guarantees the element remains within visible boundaries of the browser viewport.
 *			fitInViewport: true
 *		} );
 *
 *		// The best position which fits into document.body and the viewport. May be useful
 *		// to set proper class on the `element`.
 *		console.log( name ); -> "myNorthEastPosition"
 *
 *		// Using the absolute coordinates which has been found to position the element
 *		// as in the diagram depicting the "myNorthEastPosition" position.
 *		element.style.top = top;
 *		element.style.left = left;
 *
 * @param {module:utils/dom/position~Options} options Positioning options object.
 * @returns {module:utils/dom/position~Position}
 */
function getOptimalPosition( { element, target, positions, limiter, fitInViewport } ) {
	// If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.
	// https://github.com/ckeditor/ckeditor5-utils/issues/157
	if ( Object(__WEBPACK_IMPORTED_MODULE_4__lib_lodash_isFunction__["a" /* default */])( target ) ) {
		target = target();
	}

	// If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.
	// https://github.com/ckeditor/ckeditor5-ui/issues/260
	if ( Object(__WEBPACK_IMPORTED_MODULE_4__lib_lodash_isFunction__["a" /* default */])( limiter ) ) {
		limiter = limiter();
	}

	const positionedElementAncestor = Object(__WEBPACK_IMPORTED_MODULE_2__getpositionedancestor__["a" /* default */])( element.parentElement );
	const elementRect = new __WEBPACK_IMPORTED_MODULE_1__rect__["a" /* default */]( element );
	const targetRect = new __WEBPACK_IMPORTED_MODULE_1__rect__["a" /* default */]( target );

	let bestPosition;
	let name;

	// If there are no limits, just grab the very first position and be done with that drama.
	if ( !limiter && !fitInViewport ) {
		[ name, bestPosition ] = getPosition( positions[ 0 ], targetRect, elementRect );
	} else {
		const limiterRect = limiter && new __WEBPACK_IMPORTED_MODULE_1__rect__["a" /* default */]( limiter ).getVisible();
		const viewportRect = fitInViewport && new __WEBPACK_IMPORTED_MODULE_1__rect__["a" /* default */]( __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].window );

		[ name, bestPosition ] =
			getBestPosition( positions, targetRect, elementRect, limiterRect, viewportRect ) ||
			// If there's no best position found, i.e. when all intersections have no area because
			// rects have no width or height, then just use the first available position.
			getPosition( positions[ 0 ], targetRect, elementRect );
	}

	let { left, top } = getAbsoluteRectCoordinates( bestPosition );

	if ( positionedElementAncestor ) {
		const ancestorPosition = getAbsoluteRectCoordinates( new __WEBPACK_IMPORTED_MODULE_1__rect__["a" /* default */]( positionedElementAncestor ) );
		const ancestorBorderWidths = Object(__WEBPACK_IMPORTED_MODULE_3__getborderwidths__["a" /* default */])( positionedElementAncestor );

		// (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)
		// If there's some positioned ancestor of the panel, then its `Rect` must be taken into
		// consideration. `Rect` is always relative to the viewport while `position: absolute` works
		// with respect to that positioned ancestor.
		left -= ancestorPosition.left;
		top -= ancestorPosition.top;

		// (https://github.com/ckeditor/ckeditor5-utils/issues/139)
		// If there's some positioned ancestor of the panel, not only its position must be taken into
		// consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`
		// is relative to the viewport (it doesn't care about scrolling), while `position: absolute`
		// must compensate that scrolling.
		left += positionedElementAncestor.scrollLeft;
		top += positionedElementAncestor.scrollTop;

		// (https://github.com/ckeditor/ckeditor5-utils/issues/139)
		// If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`
		// while `position: absolute` positioning does not consider it.
		// E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,
		// not upper-left corner of its border.
		left -= ancestorBorderWidths.left;
		top -= ancestorBorderWidths.top;
	}

	return { left, top, name };
}

// For given position function, returns a corresponding `Rect` instance.
//
// @private
// @param {Function} position A function returning {@link module:utils/dom/position~Position}.
// @param {utils/dom/rect~Rect} targetRect A rect of the target.
// @param {utils/dom/rect~Rect} elementRect A rect of positioned element.
// @returns {Array} An array containing position name and its Rect.
function getPosition( position, targetRect, elementRect ) {
	const { left, top, name } = position( targetRect, elementRect );

	return [ name, elementRect.clone().moveTo( left, top ) ];
}

// For a given array of positioning functions, returns such that provides the best
// fit of the `elementRect` into the `limiterRect` and `viewportRect`.
//
// @private
// @param {module:utils/dom/position~Options#positions} positions Functions returning
// {@link module:utils/dom/position~Position} to be checked, in the order of preference.
// @param {utils/dom/rect~Rect} targetRect A rect of the {@link module:utils/dom/position~Options#target}.
// @param {utils/dom/rect~Rect} elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.
// @param {utils/dom/rect~Rect} limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.
// @param {utils/dom/rect~Rect} viewportRect A rect of the viewport.
// @returns {Array} An array containing the name of the position and it's rect.
function getBestPosition( positions, targetRect, elementRect, limiterRect, viewportRect ) {
	let maxLimiterIntersectArea = 0;
	let maxViewportIntersectArea = 0;
	let bestPositionRect;
	let bestPositionName;

	// This is when element is fully visible.
	const elementRectArea = elementRect.getArea();

	positions.some( position => {
		const [ positionName, positionRect ] = getPosition( position, targetRect, elementRect );
		let limiterIntersectArea;
		let viewportIntersectArea;

		if ( limiterRect ) {
			if ( viewportRect ) {
				// Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.
				const limiterViewportIntersectRect = limiterRect.getIntersection( viewportRect );

				if ( limiterViewportIntersectRect ) {
					// If the limiter is within the viewport, then check the intersection between that part of the
					// limiter and actual position.
					limiterIntersectArea = limiterViewportIntersectRect.getIntersectionArea( positionRect );
				} else {
					limiterIntersectArea = 0;
				}
			} else {
				limiterIntersectArea = limiterRect.getIntersectionArea( positionRect );
			}
		}

		if ( viewportRect ) {
			viewportIntersectArea = viewportRect.getIntersectionArea( positionRect );
		}

		// The only criterion: intersection with the viewport.
		if ( viewportRect && !limiterRect ) {
			if ( viewportIntersectArea > maxViewportIntersectArea ) {
				setBestPosition();
			}
		}
		// The only criterion: intersection with the limiter.
		else if ( !viewportRect && limiterRect ) {
			if ( limiterIntersectArea > maxLimiterIntersectArea ) {
				setBestPosition();
			}
		}
		// Two criteria: intersection with the viewport and the limiter visible in the viewport.
		else {
			if ( viewportIntersectArea > maxViewportIntersectArea && limiterIntersectArea >= maxLimiterIntersectArea ) {
				setBestPosition();
			} else if ( viewportIntersectArea >= maxViewportIntersectArea && limiterIntersectArea > maxLimiterIntersectArea ) {
				setBestPosition();
			}
		}

		function setBestPosition() {
			maxViewportIntersectArea = viewportIntersectArea;
			maxLimiterIntersectArea = limiterIntersectArea;
			bestPositionRect = positionRect;
			bestPositionName = positionName;
		}

		// If a such position is found that element is fully container by the limiter then, obviously,
		// there will be no better one, so finishing.
		return limiterIntersectArea === elementRectArea;
	} );

	return bestPositionRect ? [ bestPositionName, bestPositionRect ] : null;
}

// DOMRect (also Rect) works in a scrollindependent geometry but `position: absolute` doesn't.
// This function converts Rect to `position: absolute` coordinates.
//
// @private
// @param {utils/dom/rect~Rect} rect A rect to be converted.
// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.
function getAbsoluteRectCoordinates( { left, top } ) {
	const { scrollX, scrollY } = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].window;

	return {
		left: left + scrollX,
		top: top + scrollY,
	};
}

/**
 * The `getOptimalPosition` helper options.
 *
 * @interface module:utils/dom/position~Options
 */

/**
 * Element that is to be positioned.
 *
 * @member {HTMLElement} #element
 */

/**
 * Target with respect to which the `element` is to be positioned.
 *
 * @member {HTMLElement|Range|ClientRect|Rect|Function} #target
 */

/**
 * An array of functions which return {@link module:utils/dom/position~Position} relative
 * to the `target`, in the order of preference.
 *
 * @member {Array.<Function>} #positions
 */

/**
 * When set, the algorithm will chose position which fits the most in the
 * limiter's bounding rect.
 *
 * @member {HTMLElement|Range|ClientRect|Rect|Function} #limiter
 */

/**
 * When set, the algorithm will chose such a position which fits `element`
 * the most inside visible viewport.
 *
 * @member {Boolean} #fitInViewport
 */

/**
 * An object describing a position in `position: absolute` coordinate
 * system, along with position name.
 *
 * @typedef {Object} module:utils/dom/position~Position
 *
 * @property {Number} top Top position offset.
 * @property {Number} left Left position offset.
 * @property {String} name Name of the position.
 */


/***/ }),
/* 451 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getPositionedAncestor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__global__ = __webpack_require__(58);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/dom/getpositionedancestor
 */



/**
 * For a given element, returns the nearest ancestor element which CSS position is not "static".
 *
 * @param {HTMLElement} element Native DOM element to be checked.
 * @returns {HTMLElement|null}
 */
function getPositionedAncestor( element ) {
	while ( element && element.tagName.toLowerCase() != 'html' ) {
		if ( __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].window.getComputedStyle( element ).position != 'static' ) {
			return element;
		}

		element = element.parentElement;
	}

	return null;
}


/***/ }),
/* 452 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_componentfactory__ = __webpack_require__(266);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_focustracker__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_toolbar_enabletoolbarkeyboardfocus__ = __webpack_require__(267);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module editor-balloon/ballooneditorui
 */





/**
 * The balloon editor UI class.
 *
 * @implements module:core/editor/editorui~EditorUI
 */
class BalloonEditorUI {
	/**
	 * Creates an instance of the balloon editor UI class.
	 *
	 * @param {module:core/editor/editor~Editor} editor The editor instance.
	 * @param {module:ui/editorui/editoruiview~EditorUIView} view The view of the UI.
	 */
	constructor( editor, view ) {
		/**
		 * @inheritDoc
		 */
		this.editor = editor;

		/**
		 * @inheritDoc
		 */
		this.view = view;

		/**
		 * @inheritDoc
		 */
		this.componentFactory = new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_componentfactory__["a" /* default */]( editor );

		/**
		 * @inheritDoc
		 */
		this.focusTracker = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_focustracker__["a" /* default */]();
	}

	/**
	 * Initializes the UI.
	 */
	init() {
		const editor = this.editor;
		const view = this.view;
		const contextualToolbar = editor.plugins.get( 'ContextualToolbar' );

		view.render();

		// Setup the editable.
		const editingRoot = editor.editing.createRoot( view.editableElement );
		view.editable.bind( 'isReadOnly' ).to( editingRoot );

		// Bind to focusTracker instead of editor.editing.view because otherwise
		// focused editable styles disappear when view#toolbar is focused.
		view.editable.bind( 'isFocused' ).to( this.focusTracker );
		view.editable.name = editingRoot.rootName;

		this.focusTracker.add( view.editableElement );

		Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_toolbar_enabletoolbarkeyboardfocus__["a" /* default */])( {
			origin: editor.editing.view,
			originFocusTracker: this.focusTracker,
			originKeystrokeHandler: editor.keystrokes,
			toolbar: contextualToolbar.toolbarView,
			beforeFocus() {
				contextualToolbar.show();
			},
			afterBlur() {
				contextualToolbar.hide();
			}
		} );
	}

	/**
	 * Destroys the UI.
	 */
	destroy() {
		this.view.destroy();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BalloonEditorUI;



/***/ }),
/* 453 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_editorui_editoruiview__ = __webpack_require__(269);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_editableui_inline_inlineeditableuiview__ = __webpack_require__(270);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module editor-balloon/ballooneditoruiview
 */




/**
 * Contextual editor UI view. Uses the {@link module:ui/editableui/inline/inlineeditableuiview~InlineEditableUIView}.
 *
 * @extends module:ui/editorui/editoruiview~EditorUIView
 */
class BalloonEditorUIView extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_editorui_editoruiview__["a" /* default */] {
	/**
	 * Creates an instance of the balloon editor UI view.
	 *
	 * @param {module:utils/locale~Locale} locale The {@link module:core/editor/editor~Editor#locale} instance.
	 */
	constructor( locale, editableElement ) {
		super( locale );

		/**
		 * The editable UI view.
		 *
		 * @readonly
		 * @member {module:ui/editableui/inline/inlineeditableuiview~InlineEditableUIView}
		 */
		this.editable = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_editableui_inline_inlineeditableuiview__["a" /* default */]( locale, editableElement );

		this.registerChildren( this.editable );
	}

	/**
	 * @inheritDoc
	 */
	get editableElement() {
		return this.editable.element;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BalloonEditorUIView;



/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(455);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(32)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss", function() {
		var newContent = require("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(31)(false);
// imports


// module
exports.push([module.i, ".ck-hidden{display:none!important}.ck-reset,.ck-reset_all,.ck-reset_all *,.ck-reset_all a,.ck-reset_all textarea{box-sizing:border-box;width:auto;height:auto;position:static}svg.ck-icon{min-width:20px;min-height:20px;font-size:1em;vertical-align:middle}svg.ck-icon,svg.ck-icon *{color:inherit;cursor:inherit}svg.ck-icon *{fill:currentColor}.ck-tooltip,.ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:999}.ck-tooltip__text{display:inline-block}.ck-tooltip__text:after{content:\"\";width:0;height:0}.ck-button,a.ck-button{display:inline-block;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.ck-button .ck-tooltip,a.ck-button .ck-tooltip{display:block}.ck-button:hover .ck-tooltip,a.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck-button .ck-button__label,.ck-button:focus:not(:hover) .ck-tooltip,a.ck-button .ck-button__label,a.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck-toolbar__separator{display:inline-block}.ck-toolbar__newline{display:block;clear:left}.ck-dropdown{display:inline-block;position:relative}.ck-dropdown:after{content:\"\";width:0;height:0;pointer-events:none;z-index:1;position:absolute;top:50%;transform:translateY(-50%)}.ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:999;position:absolute;left:0;transform:translateY(100%)}.ck-dropdown__panel-visible{display:inline-block}.ck-label,.ck-list__item{display:block}.cke-voice-label{display:none}.ck-balloon-panel{display:none;position:absolute;z-index:999}.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:\"\";position:absolute}.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:1}.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:2}.ck-balloon-panel.ck-balloon-panel_arrow_n:before,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{z-index:1}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:after{z-index:2}.ck-balloon-panel.ck-balloon-panel_arrow_s:before,.ck-balloon-panel.ck-balloon-panel_arrow_se:before,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{z-index:1}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:after{z-index:2}.ck-balloon-panel_visible{display:block}.ck-editor .ck-sticky-panel .ck-sticky-panel__content_sticky{z-index:999;position:fixed;top:0}.ck-editor .ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{top:auto;position:absolute}.ck-reset,.ck-reset_all,.ck-reset_all *,.ck-reset_all a,.ck-reset_all textarea{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck-reset_all,.ck-reset_all *,.ck-reset_all a,.ck-reset_all textarea{border-collapse:collapse;font:normal normal normal 12px/1.67 Helvetica,Arial,Tahoma,Verdana,Sans-Serif;color:#333;text-align:left;white-space:nowrap;cursor:auto;float:none}.ck-reset_all .ck-rtl *{text-align:right}.ck-reset_all iframe{vertical-align:inherit}.ck-reset_all textarea{white-space:pre-wrap}.ck-reset_all input[type=password],.ck-reset_all input[type=text],.ck-reset_all textarea{cursor:text}.ck-reset_all input[type=password][disabled],.ck-reset_all input[type=text][disabled],.ck-reset_all textarea[disabled]{cursor:default}.ck-reset_all fieldset{padding:10px;border:2px groove #e0dfe3}.ck-reset_all button::-moz-focus-inner{padding:0;border:0}svg.ck-icon{width:1.67em;height:1.67em}.ck-tooltip{left:50%}.ck-tooltip__text{font-size:.9em;line-height:1.5;color:#fff;padding:.4em .64em;background:#333;position:relative;left:-50%}.ck-rounded-corners .ck-tooltip__text,.ck-tooltip__text.ck-rounded-corners{border-radius:2px}.ck-tooltip__text:after{border-style:solid;left:50%}.ck-tooltip.ck-tooltip_s{bottom:-5px;transform:translateY(100%)}.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after{top:-5px;transform:translateX(-50%);border-color:transparent transparent #333;border-width:0 5px 5px}.ck-tooltip.ck-tooltip_n{top:-5px;transform:translateY(-100%)}.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:-5px;transform:translateX(-50%);border-color:#333 transparent transparent;border-width:5px 5px 0}.ck-tooltip,.ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s}.ck-button,a.ck-button{background:#fff;border:1px solid #bfbfbf;white-space:nowrap;cursor:default;vertical-align:middle;padding:.4em;font-size:inherit}.ck-button:not(.ck-disabled):focus,.ck-button:not(.ck-disabled):hover,a.ck-button:not(.ck-disabled):focus,a.ck-button:not(.ck-disabled):hover{background:#e6e6e6;border-color:#acacac}.ck-button:not(.ck-disabled):active,a.ck-button:not(.ck-disabled):active{background:#d9d9d9;border-color:#a3a3a3;box-shadow:inset 0 2px 2px #bfbfbf}.ck-button.ck-disabled,a.ck-button.ck-disabled{background:#fff;border-color:#c6c6c6}.ck-button.ck-rounded-corners,.ck-rounded-corners .ck-button,.ck-rounded-corners a.ck-button,a.ck-button.ck-rounded-corners{border-radius:2px}.ck-button:focus,a.ck-button:focus{outline:none;border:1px solid #48a3f5;box-shadow:0 0 3px 2px #78bbf8}.ck-button .ck-icon,a.ck-button .ck-icon{float:left}.ck-button.ck-disabled .ck-button__label,.ck-button.ck-disabled .ck-icon,a.ck-button.ck-disabled .ck-button__label,a.ck-button.ck-disabled .ck-icon{opacity:.5}.ck-button.ck-button_with-text,a.ck-button.ck-button_with-text{padding:.4em .8em}.ck-button.ck-button_with-text .ck-icon,a.ck-button.ck-button_with-text .ck-icon{margin-left:-.4em;margin-right:.4em}.ck-button.ck-button_with-text .ck-button__label,a.ck-button.ck-button_with-text .ck-button__label{display:block}.ck-button.ck-on,a.ck-button.ck-on{background:#f7f7f7;border-color:#b9b9b9}.ck-button.ck-on:not(.ck-disabled):focus,.ck-button.ck-on:not(.ck-disabled):hover,a.ck-button.ck-on:not(.ck-disabled):focus,a.ck-button.ck-on:not(.ck-disabled):hover{background:#dedede;border-color:#a7a7a7}.ck-button.ck-on:not(.ck-disabled):active,a.ck-button.ck-on:not(.ck-disabled):active{background:#d2d2d2;border-color:#9d9d9d;box-shadow:inset 0 2px 2px #b9b9b9}.ck-button.ck-on.ck-disabled,a.ck-button.ck-on.ck-disabled{background:#f8f8f8;border-color:silver}.ck-button-action,a.ck-button-action{background:#61b145;border-color:#4e8e37;text-shadow:0 -1px #4e8e37;color:#fff}.ck-button-action:not(.ck-disabled):focus,.ck-button-action:not(.ck-disabled):hover,a.ck-button-action:not(.ck-disabled):focus,a.ck-button-action:not(.ck-disabled):hover{background:#579f3e;border-color:#467f32}.ck-button-action:not(.ck-disabled):active,a.ck-button-action:not(.ck-disabled):active{background:#52963b;border-color:#42782f;box-shadow:inset 0 2px 2px #498534}.ck-button-action.ck-disabled,a.ck-button-action.ck-disabled{background:#6fbc54;border-color:#5aa440}.ck-button-action:active,.ck-button-action:focus,.ck-button-action:hover,a.ck-button-action:active,a.ck-button-action:focus,a.ck-button-action:hover{text-shadow:0 -1px #3a6a29}.ck-button-bold,a.ck-button-bold{font-weight:700}.ck-button .ck-icon use,.ck-button .ck-icon use *,a.ck-button .ck-icon use,a.ck-button .ck-icon use *{color:inherit}.ck-button .ck-button__label,a.ck-button .ck-button__label{font-size:inherit;float:left;height:1.67em;line-height:inherit;font-weight:inherit;color:inherit;cursor:inherit}.ck-toolbar{padding:.4em;border:1px solid #bfbfbf;white-space:normal;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.ck-toolbar_floating{white-space:nowrap}.ck-rounded-corners .ck-toolbar,.ck-toolbar.ck-rounded-corners{border-radius:2px}.ck-toolbar__separator{width:1px;height:2.28em;vertical-align:middle;background:#bfbfbf}.ck-toolbar__newline{height:.4em}.ck-toolbar>*{margin-right:.4em}.ck-toolbar>:last-child{margin-right:0}.ck-toolbar-container .ck-toolbar{border:0}.ck-dropdown{font-size:inherit}.ck-dropdown:after{border-style:solid;border-width:.4em .4em 0;border-color:#707070 transparent;right:.8em}.ck-dropdown .ck-button.ck-dropdown__button{padding-right:1.6em}.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:.5}.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck-dropdown__panel{background:#fff;border:1px solid #bfbfbf;bottom:1px;box-shadow:0 1px 2px 0 rgba(0,0,0,.2)}.ck-dropdown__panel.ck-rounded-corners,.ck-rounded-corners .ck-dropdown__panel{border-radius:2px}.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;overflow:hidden;list-style-type:none;background:#fff}.ck-list.ck-rounded-corners,.ck-rounded-corners .ck-list{border-radius:2px}.ck-list__item{padding:.64em;cursor:default;min-width:12em}.ck-list__item:focus,.ck-list__item:hover{background:#f7f7f7}.ck-list__item:focus{box-shadow:0 0 3px 2px #78bbf8;position:relative;z-index:1;outline:none}.ck-list__item_active{background:#1a8bf1;color:#fff}.ck-list__item_active:focus,.ck-list__item_active:hover{background:#0e7ee2}.ck-label{font-weight:700}.ck-input-text{box-shadow:inset 2px 2px 3px rgba(0,0,0,.1);background:#fff;border:1px solid #bfbfbf;padding:.4em .64em;min-width:21em}.ck-input-text.ck-rounded-corners,.ck-rounded-corners .ck-input-text{border-radius:2px}.ck-input-text:focus{outline:none;border:1px solid #48a3f5;box-shadow:0 0 3px 2px #78bbf8,inset 2px 2px 3px rgba(0,0,0,.1)}.ck-input-text[readonly]{border:1px solid #c6c6c6;background:#f2f2f2;color:#5c5c5c}.ck-editor__editable.ck-rounded-corners,.ck-rounded-corners .ck-editor__editable{border-radius:2px}.ck-editor__editable.ck-focused{outline:none;border:1px solid #48a3f5;box-shadow:inset 2px 2px 3px rgba(0,0,0,.1)}.ck-editor__editable_inline{overflow:auto;padding:0 .8em;border:1px solid transparent}.ck-editor-toolbar .ck-button{border-width:0}.ck-editor-toolbar .ck-button.ck-disabled,.ck-editor-toolbar .ck-button:not(:hover):not(:focus):not(.ck-on){background:#f7f7f7}.ck-editor-toolbar .ck-button.ck-on{background:#dedede;border-color:#acacac}.ck-editor-toolbar .ck-button.ck-on:not(.ck-disabled):focus,.ck-editor-toolbar .ck-button.ck-on:not(.ck-disabled):hover{background:#c6c6c6;border-color:#999}.ck-editor-toolbar .ck-button.ck-on:not(.ck-disabled):active{background:#b9b9b9;border-color:#8f8f8f;box-shadow:inset 0 2px 2px #a1a1a1}.ck-editor-toolbar .ck-button.ck-on.ck-disabled{background:#f7f7f7;border-color:#bfbfbf}.ck-editor-toolbar .ck-button.ck-dropdown__button{border-width:1px}.ck-editor-toolbar .ck-button.ck-dropdown__button:not(:hover):not(:focus):not(.ck-on){background:#fff}.ck-toolbar-container .ck-editor-toolbar{background:#f7f7f7}.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_n:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_ne:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_nw:after{border-bottom-color:#f7f7f7}.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_s:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_se:after,.ck-toolbar-container.ck-editor-toolbar-container.ck-balloon-panel_arrow_sw:after{border-top-color:#f7f7f7}.ck-balloon-panel{box-shadow:0 1px 2px 0 rgba(0,0,0,.2);min-height:15px;background:#fff;border:1px solid #bfbfbf}.ck-balloon-panel.ck-rounded-corners,.ck-rounded-corners .ck-balloon-panel{border-radius:2px}.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_n:before,.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before,.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{border-width:0 10px 15px}.ck-balloon-panel.ck-balloon-panel_arrow_n:before,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{border-color:transparent transparent #bfbfbf}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:after{border-color:transparent transparent #fff;margin-top:2px}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_s:before,.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:before,.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{border-width:15px 10px 0}.ck-balloon-panel.ck-balloon-panel_arrow_s:before,.ck-balloon-panel.ck-balloon-panel_arrow_se:before,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{border-color:#bfbfbf transparent transparent}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:after{border-color:#fff transparent transparent;margin-bottom:2px}.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:-10px;top:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:20px;top:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:20px;top:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:-10px;bottom:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:20px;bottom:-15px}.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:20px;bottom:-15px}.ck-editor .ck-sticky-panel .ck-sticky-panel__content_sticky{box-shadow:0 1px 2px 0 rgba(0,0,0,.2);border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}", ""]);

// exports


/***/ }),
/* 456 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_clipboard_src_clipboard__ = __webpack_require__(457);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_enter_src_enter__ = __webpack_require__(463);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_typing_src_typing__ = __webpack_require__(466);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_undo_src_undo__ = __webpack_require__(473);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module essentials/essentials
 */








/**
 * A plugin including all essential editing features. It represents a set of features that enables similar functionalities
 * to a `<textarea>` element.
 *
 * It includes:
 *
 * * {@link module:clipboard/clipboard~Clipboard},
 * * {@link module:enter/enter~Enter},
 * * {@link module:typing/typing~Typing},
 * * {@link module:undo/undo~Undo}.
 *
 * This plugin set does not define any block-level containers (such as {@link module:paragraph/paragraph~Paragraph}).
 * If your editor is supposed to handle block content, make sure to include it.
 *
 * @extends module:core/plugin~Plugin
 */
class Essentials extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_clipboard_src_clipboard__["a" /* default */], __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_enter_src_enter__["a" /* default */], __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_typing_src_typing__["a" /* default */], __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_undo_src_undo__["a" /* default */] ];
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Essentials;



/***/ }),
/* 457 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__clipboardobserver__ = __webpack_require__(458);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_plaintexttohtml__ = __webpack_require__(460);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_normalizeclipboarddata__ = __webpack_require__(461);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_viewtoplaintext_js__ = __webpack_require__(462);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_dataprocessor_htmldataprocessor__ = __webpack_require__(112);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module clipboard/clipboard
 */











/**
 * The clipboard feature. Currently, it's responsible for intercepting the `paste` and `drop` events and
 * passing the pasted content through the clipboard pipeline.
 *
 * # Clipboard input pipeline
 *
 * The feature creates the clipboard input pipeline which allows processing clipboard content
 * before it gets inserted into the editor. The pipeline consists of two events on which
 * the features can listen in order to modify or totally override the default behavior.
 *
 * ## On {@link module:engine/view/document~Document#event:paste} and {@link module:engine/view/document~Document#event:drop}
 *
 * The default action is to:
 *
 * 1. get HTML or plain text from the clipboard,
 * 2. prevent the default action of the native `paste` or `drop` event,
 * 3. fire {@link module:engine/view/document~Document#event:clipboardInput} with a
 * {@link module:clipboard/datatransfer~DataTransfer `dataTransfer`} property.
 * 4. fire {@link module:clipboard/clipboard~Clipboard#event:inputTransformation} with a `data` containing the clipboard data parsed to
 * a {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.
 *
 * These action are performed by a low priority listeners, so they can be overridden by a normal ones
 * when a deeper change in pasting behavior is needed. For example, a feature which wants to differently read
 * data from the clipboard (the {@link module:clipboard/datatransfer~DataTransfer `DataTransfer`}).
 * should plug a listener at this stage.
 *
 * ## On {@link module:engine/view/document~Document#event:clipboardInput}
 *
 * This action is performed by a low priority listener, so it can be overridden by a normal one.
 *
 * At this stage the dataTransfer object can be processed by the features, which want to transform the original dataTransform.
 *
 *		this.listenTo( editor.editing.view, 'clipboardInput', ( evt, data ) => {
 *			const content = customTransform( data.dataTransfer.get( 'text/html' ) );
 *			const transformedContent = transform( content );
 *			data.dataTransfer.set( 'text/html', transformedContent );
 *		} );
 *
 * ## On {@link module:clipboard/clipboard~Clipboard#event:inputTransformation}
 *
 * The default action is to insert the content (`data.content`, represented by a
 * {@link module:engine/view/documentfragment~DocumentFragment}) to an editor if the data is not empty.
 *
 * This action is performed by a low priority listener, so it can be overridden by a normal one.
 *
 * At this stage the pasted content can be processed by the features. E.g. a feature which wants to transform
 * a pasted text into a link can be implemented in this way:
 *
 *		this.listenTo( editor.plugins.get( 'Clipboard' ), 'inputTransformation', ( evt, data ) => {
 *			if ( data.content.childCount == 1 && isUrlText( data.content.getChild( 0 ) ) ) {
 *				const linkUrl = data.content.getChild( 0 ).data;
 *
 *				data.content = new ViewDocumentFragment( [
 *					ViewElement(
 *						'a',
 *						{ href: linkUrl },
 *						[ new ViewText( linkUrl ) ]
 *					)
 *				] );
 *			}
 *		} );
 *
 * # Clipboard output pipeline
 *
 * The output pipeline is the equivalent of the input pipeline but for the copy and cut operations.
 * It allows to process the content which will be then put into the clipboard or to override the whole process.
 *
 * ## On {@link module:engine/view/document~Document#event:copy} and {@link module:engine/view/document~Document#event:cut}
 *
 * The default action is to:
 *
 * 1. {@link module:engine/controller/datacontroller~DataController#getSelectedContent get selected content} from the editor,
 * 2. prevent the default action of the native `copy` or `cut` event,
 * 3. fire {@link module:engine/view/document~Document#event:clipboardOutput} with a clone of the selected content
 * converted to a {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.
 *
 * ## On {@link module:engine/view/document~Document#event:clipboardOutput}
 *
 * The default action is to put the content (`data.content`, represented by a
 * {@link module:engine/view/documentfragment~DocumentFragment}) to the clipboard as HTML. In case of the cut operation,
 * the selected content is also deleted from the editor.
 *
 * This action is performed by a low priority listener, so it can be overridden by a normal one.
 *
 * At this stage the copied/cut content can be processed by the features.
 *
 * @extends module:core/plugin~Plugin
 */
class Clipboard extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Clipboard';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const doc = editor.document;
		const editingView = editor.editing.view;

		/**
		 * Data processor used to convert pasted HTML to a view structure.
		 *
		 * @private
		 * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #_htmlDataProcessor
		 */
		this._htmlDataProcessor = new __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_dataprocessor_htmldataprocessor__["a" /* default */]();

		editingView.addObserver( __WEBPACK_IMPORTED_MODULE_1__clipboardobserver__["a" /* default */] );

		// The clipboard paste pipeline.

		this.listenTo( editingView, 'clipboardInput', ( evt, data ) => {
			// Pasting and dropping is disabled when editor is read-only.
			// See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.
			if ( editor.isReadOnly ) {
				return;
			}

			const dataTransfer = data.dataTransfer;
			let content = '';

			if ( dataTransfer.getData( 'text/html' ) ) {
				content = Object(__WEBPACK_IMPORTED_MODULE_3__utils_normalizeclipboarddata__["a" /* default */])( dataTransfer.getData( 'text/html' ) );
			} else if ( dataTransfer.getData( 'text/plain' ) ) {
				content = Object(__WEBPACK_IMPORTED_MODULE_2__utils_plaintexttohtml__["a" /* default */])( dataTransfer.getData( 'text/plain' ) );
			}

			content = this._htmlDataProcessor.toView( content );

			this.fire( 'inputTransformation', { content } );

			editingView.scrollToTheSelection();
		}, { priority: 'low' } );

		this.listenTo( this, 'inputTransformation', ( evt, data ) => {
			if ( !data.content.isEmpty ) {
				const dataController = this.editor.data;

				// Convert the pasted content to a model document fragment.
				// Conversion is contextual, but in this case we need an "all allowed" context and for that
				// we use the $clipboardHolder item.
				const modelFragment = dataController.toModel( data.content, '$clipboardHolder' );

				if ( modelFragment.childCount == 0 ) {
					return;
				}

				doc.enqueueChanges( () => {
					dataController.insertContent( modelFragment, doc.selection );
				} );
			}
		}, { priority: 'low' } );

		// The clipboard copy/cut pipeline.

		function onCopyCut( evt, data ) {
			const dataTransfer = data.dataTransfer;
			const content = editor.data.toView( editor.data.getSelectedContent( doc.selection ) );

			data.preventDefault();

			editingView.fire( 'clipboardOutput', { dataTransfer, content, method: evt.name } );
		}

		this.listenTo( editingView, 'copy', onCopyCut, { priority: 'low' } );
		this.listenTo( editingView, 'cut', ( evt, data ) => {
			// Cutting is disabled when editor is read-only.
			// See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.
			if ( editor.isReadOnly ) {
				data.preventDefault();
			} else {
				onCopyCut( evt, data );
			}
		}, { priority: 'low' } );

		this.listenTo( editingView, 'clipboardOutput', ( evt, data ) => {
			if ( !data.content.isEmpty ) {
				data.dataTransfer.setData( 'text/html', this._htmlDataProcessor.toData( data.content ) );
				data.dataTransfer.setData( 'text/plain', Object(__WEBPACK_IMPORTED_MODULE_4__utils_viewtoplaintext_js__["a" /* default */])( data.content ) );
			}

			if ( data.method == 'cut' ) {
				doc.enqueueChanges( () => {
					editor.data.deleteContent( doc.selection, doc.batch() );
				} );
			}
		}, { priority: 'low' } );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Clipboard;


/**
 * Fired with a `content`, which comes from the clipboard (was pasted or dropped) and
 * should be processed in order to be inserted into the editor.
 * It's part of the {@link module:clipboard/clipboard~Clipboard "clipboard pipeline"}.
 *
 * @see module:clipboard/clipboardobserver~ClipboardObserver
 * @see module:clipboard/clipboard~Clipboard
 * @event module:clipboard/clipboard~Clipboard#event:inputTransformation
 * @param {Object} data Event data.
 * @param {module:engine/view/documentfragment~DocumentFragment} data.content Event data. Content to be inserted into the editor.
 * It can be modified by the event listeners. Read more about the clipboard pipelines in {@link module:clipboard/clipboard~Clipboard}
 */

/**
 * Fired on {@link module:engine/view/document~Document#event:copy} and {@link module:engine/view/document~Document#event:cut}
 * with a copy of selected content. The content can be processed before it ends up in the clipboard.
 * It's part of the {@link module:clipboard/clipboard~Clipboard "clipboard pipeline"}.
 *
 * @see module:clipboard/clipboardobserver~ClipboardObserver
 * @see module:clipboard/clipboard~Clipboard
 * @event module:engine/view/document~Document#event:clipboardOutput
 * @param {module:clipboard/clipboard~ClipboardOutputEventData} data Event data.
 */

/**
 * The value of the {@link module:engine/view/document~Document#event:clipboardOutput} event.
 *
 * @class module:clipboard/clipboard~ClipboardOutputEventData
 */

/**
 * Data transfer instance.
 *
 * @readonly
 * @member {module:clipboard/datatransfer~DataTransfer} module:clipboard/clipboard~ClipboardOutputEventData#dataTransfer
 */

/**
 * Content to be put into the clipboard. It can be modified by the event listeners.
 * Read more about the clipboard pipelines in {@link module:clipboard/clipboard~Clipboard}.
 *
 * @member {module:engine/view/documentfragment~DocumentFragment} module:clipboard/clipboard~ClipboardOutputEventData#content
 */

/**
 * Whether the event was triggered by copy or cut operation.
 *
 * @member {'copy'|'cut'} module:clipboard/clipboard~ClipboardOutputEventData#method
 */


/***/ }),
/* 458 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_observer_domeventobserver__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__datatransfer__ = __webpack_require__(459);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module clipboard/clipboardobserver
 */




/**
 * {@link module:engine/view/document~Document#event:paste Paste} event observer.
 *
 * Note that this observer is not available by default. To make it available it needs to be added to
 * {@link module:engine/view/document~Document} by the {@link module:engine/view/document~Document#addObserver} method.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */
class ClipboardObserver extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_observer_domeventobserver__["a" /* default */] {
	constructor( doc ) {
		super( doc );

		this.domEventType = [ 'paste', 'copy', 'cut', 'drop', 'dragover' ];

		this.listenTo( doc, 'paste', handleInput, { priority: 'low' } );
		this.listenTo( doc, 'drop', handleInput, { priority: 'low' } );

		function handleInput( evt, data ) {
			data.preventDefault();

			const targetRanges = data.dropRange ? [ data.dropRange ] : Array.from( doc.selection.getRanges() );

			doc.fire( 'clipboardInput', {
				dataTransfer: data.dataTransfer,
				targetRanges
			} );
		}
	}

	onDomEvent( domEvent ) {
		const evtData = {
			dataTransfer: new __WEBPACK_IMPORTED_MODULE_1__datatransfer__["a" /* default */]( domEvent.clipboardData ? domEvent.clipboardData : domEvent.dataTransfer )
		};

		if ( domEvent.type == 'drop' ) {
			evtData.dropRange = getDropViewRange( this.document, domEvent );
		}

		this.fire( domEvent.type, domEvent, evtData );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ClipboardObserver;


function getDropViewRange( doc, domEvent ) {
	const domDoc = domEvent.target.ownerDocument;
	const x = domEvent.clientX;
	const y = domEvent.clientY;
	let domRange;

	// Webkit & Blink.
	if ( domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint( x, y ) ) {
		domRange = domDoc.caretRangeFromPoint( x, y );
	}
	// FF.
	else if ( domEvent.rangeParent ) {
		domRange = domDoc.createRange();
		domRange.setStart( domEvent.rangeParent, domEvent.rangeOffset );
		domRange.collapse( true );
	}

	if ( domRange ) {
		return doc.domConverter.domRangeToView( domRange );
	} else {
		return doc.selection.getFirstRange();
	}
}

/**
 * Fired as a continuation of {@link #event:paste} and {@link #event:drop} events.
 * It's part of the {@link module:clipboard/clipboard~Clipboard "clipboard pipeline"}.
 *
 * Fired with a `dataTransfer` which comes from the clipboard and which content should be processed
 * and inserted into the editor.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/document~Document#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:clipboard/clipboardobserver~ClipboardObserver
 * @see module:clipboard/clipboard~Clipboard
 * @event module:engine/view/document~Document#event:clipboardInput
 * @param {Object} data Event data.
 * @param {module:clipboard/datatransfer~DataTransfer} data.dataTransfer Data transfer instance.
 * @param {Array.<module:engine/view/range~Range>} data.targetRanges Ranges which are the target of the operation
 * (usually  into which the content should be inserted).
 * If clipboard input was triggered by a paste operation, then these are the selection ranges. If by a drop operation,
 * then it's the drop position (which can be different than the selection at the moment of drop).
 */

/**
 * Fired when user drags content over one of the editables.
 *
 * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/document~Document#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:engine/view/document~Document#event:clipboardInput
 * @event module:engine/view/document~Document#event:dragover
 * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.
 */

/**
 * Fired when user dropped content into one of the editables.
 *
 * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/document~Document#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:engine/view/document~Document#event:clipboardInput
 * @event module:engine/view/document~Document#event:drop
 * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.
 * @param {module:engine/view/range~Range} dropRange The position into which the content is dropped.
 */

/**
 * Fired when user pasted content into one of the editables.
 *
 * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/document~Document#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:engine/view/document~Document#event:clipboardInput
 * @event module:engine/view/document~Document#event:paste
 * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.
 */

/**
 * Fired when user copied content from one of the editables.
 *
 * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/document~Document#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:clipboard/clipboardobserver~ClipboardObserver
 * @event module:engine/view/document~Document#event:copy
 * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.
 */

/**
 * Fired when user cut content from one of the editables.
 *
 * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/document~Document#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:clipboard/clipboardobserver~ClipboardObserver
 * @event module:engine/view/document~Document#event:cut
 * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.
 */

/**
 * The value of the {@link module:engine/view/document~Document#event:paste},
 * {@link module:engine/view/document~Document#event:copy} and {@link module:engine/view/document~Document#event:cut} events.
 *
 * In order to access clipboard data use `dataTransfer` property.
 *
 * @class module:clipboard/clipboardobserver~ClipboardEventData
 * @extends module:engine/view/observer/domeventdata~DomEventData
 */

/**
 * Data transfer instance.
 *
 * @readonly
 * @member {module:clipboard/datatransfer~DataTransfer} module:clipboard/clipboardobserver~ClipboardEventData#dataTransfer
 */


/***/ }),
/* 459 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module clipboard/datatransfer
 */

/**
 * Facade over the native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.
 */
class DataTransfer {
	constructor( nativeDataTransfer ) {
		/**
		 * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
		 *
		 * @readonly
		 * @member {Array.<File>} #files
		 */
		this.files = getFiles( nativeDataTransfer );

		/**
		 * The native DataTransfer object.
		 *
		 * @private
		 * @member {DataTransfer} #_native
		 */
		this._native = nativeDataTransfer;
	}

	/**
	 * Returns an array of available native content types.
	 *
	 * @returns {Array.<String>}
	 */
	get types() {
		return this._native.types;
	}

	/**
	 * Gets data from the data transfer by its mime type.
	 *
	 *		dataTransfer.getData( 'text/plain' );
	 *
	 * @param {String} type The mime type. E.g. `text/html` or `text/plain`.
	 * @returns {String}
	 */
	getData( type ) {
		return this._native.getData( type );
	}

	/**
	 * Sets data in the data transfer.
	 *
	 * @param {String} type The mime type. E.g. `text/html` or `text/plain`.
	 * @param {String} data
	 */
	setData( type, data ) {
		this._native.setData( type, data );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DataTransfer;


function getFiles( nativeDataTransfer ) {
	// DataTransfer.files and items are Array-like and might not have an iterable interface.
	const files = nativeDataTransfer.files ? Array.from( nativeDataTransfer.files ) : [];
	const items = nativeDataTransfer.items ? Array.from( nativeDataTransfer.items ) : [];

	if ( files.length ) {
		return files;
	}
	// Chrome have empty DataTransfer.files, but let get files through the items interface.
	return items
		.filter( item => item.kind === 'file' )
		.map( item => item.getAsFile() );
}


/***/ }),
/* 460 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = plainTextToHtml;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module clipboard/utils/plaintexttohtml
 */

/**
 * Converts plain text to its HTML-ized version.
 *
 * @param {String} text The plain text to convert.
 * @returns {String} HTML generated from the plain text.
 */
function plainTextToHtml( text ) {
	text = text
		// Encode <>.
		.replace( /</g, '&lt;' )
		.replace( />/g, '&gt;' )
		// Creates paragraphs for double line breaks and change single line breaks to spaces.
		// In the future single line breaks may be converted into <br>s.
		.replace( /\n\n/g, '</p><p>' )
		.replace( /\n/g, ' ' )
		// Preserve trailing spaces (only the first and last one  the rest is handled below).
		.replace( /^\s/, '&nbsp;' )
		.replace( /\s$/, '&nbsp;' )
		// Preserve other subsequent spaces now.
		.replace( /\s\s/g, ' &nbsp;' );

	if ( text.indexOf( '</p><p>' ) > -1 ) {
		// If we created paragraphs above, add the trailing ones.
		text = `<p>${ text }</p>`;
	}

	// TODO:
	// * What about '\nfoo' vs ' foo'?

	return text;
}


/***/ }),
/* 461 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = normalizeClipboardData;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module clipboard/utils/normalizeclipboarddata
 */

/**
 * Removes some popular browser quirks out of the clipboard data (HTML).
 *
 * @param {String} data The HTML data to normalize.
 * @returns {String} Normalized HTML.
 */
function normalizeClipboardData( data ) {
	return data
		.replace( /<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ( fullMatch, spaces ) => {
			// Handle the most popular and problematic case when even a single space becomes an nbsp;.
			// Decode those to normal spaces. Read more in https://github.com/ckeditor/ckeditor5-clipboard/issues/2.
			if ( spaces.length == 1 ) {
				return ' ';
			}

			return spaces;
		} );
}


/***/ }),
/* 462 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = viewToPlainText;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module clipboard/utils/viewtoplaintext
 */

// Elements which should not have empty-line padding.
// Most `view.ContainerElement` want to be separate by new-line, but some are creating one structure
// together (like `<li>`) so it is better to separate them by only one "\n".
const smallPaddingElements = [ 'figcaption', 'li' ];

/**
 * Converts {@link module:engine/view/item~Item view item} and all of its children to plain text.
 *
 * @param {module:engine/view/item~Item} viewItem View item to convert.
 * @returns {String} Plain text representation of `viewItem`.
 */
function viewToPlainText( viewItem ) {
	let text = '';

	if ( viewItem.is( 'text' ) || viewItem.is( 'textProxy' ) ) {
		// If item is `Text` or `TextProxy` simple take its text data.
		text = viewItem.data;
	} else if ( viewItem.is( 'img' ) && viewItem.hasAttribute( 'alt' ) ) {
		// Special case for images - use alt attribute if it is provided.
		text = viewItem.getAttribute( 'alt' );
	} else {
		// Other elements are document fragments, attribute elements or container elements.
		// They don't have their own text value, so convert their children.
		let prev = null;

		for ( const child of viewItem.getChildren() ) {
			const childText = viewToPlainText( child );

			// Separate container element children with one or more new-line characters.
			if ( prev && ( prev.is( 'containerElement' ) || child.is( 'containerElement' ) ) ) {
				if ( smallPaddingElements.includes( prev.name ) || smallPaddingElements.includes( child.name ) ) {
					text += '\n';
				} else {
					text += '\n\n';
				}
			}

			text += childText;
			prev = child;
		}
	}

	return text;
}


/***/ }),
/* 463 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__entercommand__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__enterobserver__ = __webpack_require__(465);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module enter/enter
 */





/**
 * The Enter feature. Handles the <kbd>Enter</kbd> and <kbd>Shift + Enter</kbd> keys in the editor.
 *
 * @extends module:core/plugin~Plugin
 */
class Enter extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Enter';
	}

	init() {
		const editor = this.editor;
		const editingView = editor.editing.view;

		editingView.addObserver( __WEBPACK_IMPORTED_MODULE_2__enterobserver__["a" /* default */] );

		editor.commands.add( 'enter', new __WEBPACK_IMPORTED_MODULE_1__entercommand__["a" /* default */]( editor ) );

		// TODO We may use the keystroke handler for that.
		this.listenTo( editingView, 'enter', ( evt, data ) => {
			editor.execute( 'enter' );
			data.preventDefault();
			editingView.scrollToTheSelection();
		}, { priority: 'low' } );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Enter;



/***/ }),
/* 464 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module enter/entercommand
 */




/**
 * Enter command. It is used by the {@link module:enter/enter~Enter Enter feature} to handle the <kbd>Enter</kbd> key.
 *
 * @extends module:core/command~Command
 */
class EnterCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	execute() {
		const doc = this.editor.document;
		const batch = doc.batch();

		doc.enqueueChanges( () => {
			enterBlock( this.editor.data, batch, doc.selection, doc.schema );

			this.fire( 'afterExecute', { batch } );
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EnterCommand;


// Creates a new block in the way that the <kbd>Enter</kbd> key is expected to work.
//
// @param {engine.controller.DataController} dataController
// @param {module:engine/model/batch~Batch} batch A batch to which the deltas will be added.
// @param {module:engine/model/selection~Selection} selection Selection on which the action should be performed.
// @param {module:engine/model/schema~Schema} schema
function enterBlock( dataController, batch, selection, schema ) {
	const isSelectionEmpty = selection.isCollapsed;
	const range = selection.getFirstRange();
	const startElement = range.start.parent;
	const endElement = range.end.parent;

	// Don't touch the roots and other limit elements.
	if ( schema.limits.has( startElement.name ) || schema.limits.has( endElement.name ) ) {
		// Delete the selected content but only if inside a single limit element.
		// Abort, when crossing limit elements boundary (e.g. <limit1>x[x</limit1>donttouchme<limit2>y]y</limit2>).
		// This is an edge case and it's hard to tell what should actually happen because such a selection
		// is not entirely valid.
		if ( !isSelectionEmpty && startElement == endElement ) {
			dataController.deleteContent( selection, batch );
		}

		return;
	}

	if ( isSelectionEmpty ) {
		splitBlock( batch, selection, range.start );
	} else {
		const leaveUnmerged = !( range.start.isAtStart && range.end.isAtEnd );
		const isContainedWithinOneElement = ( startElement == endElement );

		dataController.deleteContent( selection, batch, { leaveUnmerged } );

		if ( leaveUnmerged ) {
			// Partially selected elements.
			//
			// <h>x[xx]x</h>		-> <h>x^x</h>			-> <h>x</h><h>^x</h>
			if ( isContainedWithinOneElement ) {
				splitBlock( batch, selection, selection.focus );
			}
			// Selection over multiple elements.
			//
			// <h>x[x</h><p>y]y<p>	-> <h>x^</h><p>y</p>	-> <h>x</h><p>^y</p>
			else {
				selection.setCollapsedAt( endElement );
			}
		}
	}
}

function splitBlock( batch, selection, splitPos ) {
	const oldElement = splitPos.parent;
	const newElement = new oldElement.constructor( oldElement.name, oldElement.getAttributes() );

	if ( splitPos.isAtEnd ) {
		// If the split is at the end of element, instead of splitting, just create a clone of position's parent
		// element and insert it after split element. The result is the same but less operations are done
		// and it's more semantically correct (when it comes to operational transformation).
		batch.insert( __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAfter( splitPos.parent ), newElement );
	} else if ( splitPos.isAtStart ) {
		// If the split is at the start of element, instead of splitting, just create a clone of position's parent
		// element and insert it before split element. The result is the same but less operations are done
		// and it's more semantically correct (when it comes to operational transformation).
		batch.insert( __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( splitPos.parent ), newElement );
	} else {
		batch.split( splitPos );
	}

	selection.setCollapsedAt( splitPos.parent.nextSibling );
}


/***/ }),
/* 465 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_observer_observer__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_observer_domeventdata__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__ = __webpack_require__(28);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module enter/enterobserver
 */





/**
 * Enter observer introduces the {@link module:engine/view/document~Document#event:enter} event.
 *
 * @extends module:engine/view/observer~Observer
 */
class EnterObserver extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_observer_observer__["a" /* default */] {
	constructor( document ) {
		super( document );

		document.on( 'keydown', ( evt, data ) => {
			if ( this.isEnabled && data.keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].enter ) {
				document.fire( 'enter', new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_observer_domeventdata__["a" /* default */]( document, data.domEvent ) );
			}
		} );
	}

	/**
	 * @inheritDoc
	 */
	observe() {}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EnterObserver;


/**
 * Event fired when the user presses the <kbd>Enter</kbd> key.
 *
 * Note: This event is fired by the {@link module:enter/enterobserver~EnterObserver observer}
 * (usually registered by the {@link module:enter/enter~Enter Enter feature}).
 *
 * @event module:engine/view/document~Document#event:enter
 * @param {module:engine/view/observer/domeventdata~DomEventData} data
 */


/***/ }),
/* 466 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__input__ = __webpack_require__(467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__delete__ = __webpack_require__(470);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module typing/typing
 */





/**
 * The typing feature. It handles typing.
 *
 * @extends module:core/plugin~Plugin
 */
class Typing extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_1__input__["a" /* default */], __WEBPACK_IMPORTED_MODULE_2__delete__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Typing';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Typing;


/**
 * The configuration of the typing features. Used by the features from the `@ckeditor/ckeditor5-typing` package.
 *
 * Read more in {@link module:typing/typing~TypingConfig}.
 *
 * @member {module:typing/typing~TypingConfig} module:core/editor/editorconfig~EditorConfig#typing
 */

/**
 * The configuration of the typing features. Used by the typing features in `@ckeditor/ckeditor5-typing` package.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 * 				typing: ... // Typing feature options.
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface TypingConfig
 */

/**
 * The granularity of undo/redo for typing and deleting. The value `20` means (more or less) that a new undo step
 * is created every 20 characters are inserted or deleted.
 *
 * @member {Number} [module:typing/typing~TypingConfig#undoStep=20]
 */


/***/ }),
/* 467 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_view_position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_view_text__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_diff__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_difftochanges__ = __webpack_require__(468);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_keyboard__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_domconverter__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__inputcommand__ = __webpack_require__(469);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module typing/input
 */











/**
 * Handles text input coming from the keyboard or other input methods.
 *
 * @extends module:core/plugin~Plugin
 */
class Input extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Input';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const editingView = editor.editing.view;
		const inputCommand = new __WEBPACK_IMPORTED_MODULE_8__inputcommand__["a" /* default */]( editor, editor.config.get( 'typing.undoStep' ) || 20 );

		// TODO The above default configuration value should be defined using editor.config.define() once it's fixed.

		editor.commands.add( 'input', inputCommand );

		this.listenTo( editingView, 'keydown', ( evt, data ) => {
			this._handleKeydown( data, inputCommand );
		}, { priority: 'lowest' } );

		this.listenTo( editingView, 'mutations', ( evt, mutations, viewSelection ) => {
			this._handleMutations( mutations, viewSelection );
		} );
	}

	/**
	 * Handles the keydown event. We need to guess whether such keystroke is going to result
	 * in typing. If so, then before character insertion happens, any selected content needs
	 * to be deleted. Otherwise the default browser deletion mechanism would be
	 * triggered, resulting in:
	 *
	 * * Hundreds of mutations which could not be handled.
	 * * But most importantly, loss of control over how the content is being deleted.
	 *
	 * The method is used in a low-priority listener, hence allowing other listeners (e.g. delete or enter features)
	 * to handle the event.
	 *
	 * @private
	 * @param {module:engine/view/observer/keyobserver~KeyEventData} evtData
	 * @param {module:typing/inputcommand~InputCommand} inputCommand
	 */
	_handleKeydown( evtData, inputCommand ) {
		const doc = this.editor.document;
		const buffer = inputCommand.buffer;

		// By relying on the state of the input command we allow disabling the entire input easily
		// by just disabling the input command. We couldve used here the delete command but that
		// would mean requiring the delete feature which would block loading one without the other.
		// We could also check the editor.isReadOnly property, but that wouldn't allow to block
		// the input without blocking other features.
		if ( !inputCommand.isEnabled ) {
			return;
		}

		if ( isSafeKeystroke( evtData ) || doc.selection.isCollapsed ) {
			return;
		}

		buffer.lock();

		doc.enqueueChanges( () => {
			this.editor.data.deleteContent( doc.selection, buffer.batch );
		} );

		buffer.unlock();
	}

	/**
	 * Handles DOM mutations.
	 *
	 * @private
	 * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|
	 * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations
	 * @param {module:engine/view/selection~Selection|null} viewSelection
	 */
	_handleMutations( mutations, viewSelection ) {
		new MutationHandler( this.editor ).handle( mutations, viewSelection );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Input;


/**
 * Helper class for translating DOM mutations into model changes.
 *
 * @private
 */
class MutationHandler {
	/**
	 * Creates an instance of the mutation handler.
	 *
	 * @param {module:core/editor/editor~Editor} editor
	 */
	constructor( editor ) {
		/**
		 * Editor instance for which mutations are handled.
		 *
		 * @readonly
		 * @member {module:core/editor/editor~Editor} #editor
		 */
		this.editor = editor;

		/**
		 * The editing controller.
		 *
		 * @readonly
		 * @member {module:engine/controller/editingcontroller~EditingController} #editing
		 */
		this.editing = this.editor.editing;
	}

	/**
	 * Handles given mutations.
	 *
	 * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|
	 * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations
	 * @param {module:engine/view/selection~Selection|null} viewSelection
	 */
	handle( mutations, viewSelection ) {
		if ( containerChildrenMutated( mutations ) ) {
			this._handleContainerChildrenMutations( mutations, viewSelection );
		} else {
			for ( const mutation of mutations ) {
				// Fortunately it will never be both.
				this._handleTextMutation( mutation, viewSelection );
				this._handleTextNodeInsertion( mutation );
			}
		}
	}

	/**
	 * Handles situations when container's children mutated during input. This can happen when
	 * the browser is trying to "fix" DOM in certain situations. For example, when the user starts to type
	 * in `<p><a href=""><i>Link{}</i></a></p>`, the browser might change the order of elements
	 * to `<p><i><a href="">Link</a>x{}</i></p>`. A similar situation happens when the spell checker
	 * replaces a word wrapped with `<strong>` with a word wrapped with a `<b>` element.
	 *
	 * To handle such situations, the common DOM ancestor of all mutations is converted to the model representation
	 * and then compared with the current model to calculate the proper text change.
	 *
	 * Note: Single text node insertion is handled in {@link #_handleTextNodeInsertion} and text node mutation is handled
	 * in {@link #_handleTextMutation}).
	 *
	 * @private
	 * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|
	 * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations
	 * @param {module:engine/view/selection~Selection|null} viewSelection
	 */
	_handleContainerChildrenMutations( mutations, viewSelection ) {
		// Get common ancestor of all mutations.
		const mutationsCommonAncestor = getMutationsContainer( mutations );

		// Quit if there is no common ancestor.
		if ( !mutationsCommonAncestor ) {
			return;
		}

		const domConverter = this.editor.editing.view.domConverter;

		// Get common ancestor in DOM.
		const domMutationCommonAncestor = domConverter.mapViewToDom( mutationsCommonAncestor );

		if ( !domMutationCommonAncestor ) {
			return;
		}

		// Create fresh DomConverter so it will not use existing mapping and convert current DOM to model.
		// This wouldn't be needed if DomConverter would allow to create fresh view without checking any mappings.
		const freshDomConverter = new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_domconverter__["a" /* default */]();
		const modelFromCurrentDom = this.editor.data.toModel( freshDomConverter.domToView( domMutationCommonAncestor ) ).getChild( 0 );

		// Current model.
		const currentModel = this.editor.editing.mapper.toModelElement( mutationsCommonAncestor );

		// Get children from both ancestors.
		const modelFromDomChildren = Array.from( modelFromCurrentDom.getChildren() );
		const currentModelChildren = Array.from( currentModel.getChildren() );

		// Skip situations when common ancestor has any elements (cause they are too hard).
		if ( !hasOnlyTextNodes( modelFromDomChildren ) || !hasOnlyTextNodes( currentModelChildren ) ) {
			return;
		}

		// Replace &nbsp; inserted by the browser with normal space.
		// See comment in `_handleTextMutation`.
		const newText = modelFromDomChildren.map( item => item.data ).join( '' ).replace( /\u00A0/g, ' ' );
		const oldText = currentModelChildren.map( item => item.data ).join( '' );

		// Do nothing if mutations created same text.
		if ( oldText === newText ) {
			return;
		}

		const diffResult = Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_diff__["a" /* default */])( oldText, newText );

		const { firstChangeAt, insertions, deletions } = calculateChanges( diffResult );

		// Try setting new model selection according to passed view selection.
		let modelSelectionRange = null;

		if ( viewSelection ) {
			modelSelectionRange = this.editing.mapper.toModelRange( viewSelection.getFirstRange() );
		}

		const insertText = newText.substr( firstChangeAt, insertions );
		const removeRange = __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_range__["a" /* default */].createFromParentsAndOffsets(
			currentModel,
			firstChangeAt,
			currentModel,
			firstChangeAt + deletions
		);

		this.editor.execute( 'input', {
			text: insertText,
			range: removeRange,
			resultRange: modelSelectionRange
		} );
	}

	_handleTextMutation( mutation, viewSelection ) {
		if ( mutation.type != 'text' ) {
			return;
		}

		// Replace &nbsp; inserted by the browser with normal space.
		// We want only normal spaces in the model and in the view. Renderer and DOM Converter will be then responsible
		// for rendering consecutive spaces using &nbsp;, but the model and the view has to be clear.
		// Other feature may introduce inserting non-breakable space on specific key stroke (for example shift + space).
		// However then it will be handled outside of mutations, like enter key is.
		// The replacing is here because it has to be done before `diff` and `diffToChanges` functions, as they
		// take `newText` and compare it to (cleaned up) view.
		// It could also be done in mutation observer too, however if any outside plugin would like to
		// introduce additional events for mutations, they would get already cleaned up version (this may be good or not).
		const newText = mutation.newText.replace( /\u00A0/g, ' ' );
		// To have correct `diffResult`, we also compare view node text data with &nbsp; replaced by space.
		const oldText = mutation.oldText.replace( /\u00A0/g, ' ' );

		const diffResult = Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_diff__["a" /* default */])( oldText, newText );

		const { firstChangeAt, insertions, deletions } = calculateChanges( diffResult );

		// Try setting new model selection according to passed view selection.
		let modelSelectionRange = null;

		if ( viewSelection ) {
			modelSelectionRange = this.editing.mapper.toModelRange( viewSelection.getFirstRange() );
		}

		// Get the position in view and model where the changes will happen.
		const viewPos = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */]( mutation.node, firstChangeAt );
		const modelPos = this.editing.mapper.toModelPosition( viewPos );
		const removeRange = __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_range__["a" /* default */].createFromPositionAndShift( modelPos, deletions );
		const insertText = newText.substr( firstChangeAt, insertions );

		this.editor.execute( 'input', {
			text: insertText,
			range: removeRange,
			resultRange: modelSelectionRange
		} );
	}

	_handleTextNodeInsertion( mutation ) {
		if ( mutation.type != 'children' ) {
			return;
		}

		const change = getSingleTextNodeChange( mutation );
		const viewPos = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */]( mutation.node, change.index );
		const modelPos = this.editing.mapper.toModelPosition( viewPos );
		const insertedText = change.values[ 0 ].data;

		this.editor.execute( 'input', {
			// Replace &nbsp; inserted by the browser with normal space.
			// See comment in `_handleTextMutation`.
			// In this case we don't need to do this before `diff` because we diff whole nodes.
			// Just change &nbsp; in case there are some.
			text: insertedText.replace( /\u00A0/g, ' ' ),
			range: new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_range__["a" /* default */]( modelPos )
		} );
	}
}

const safeKeycodes = [
	Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_keyboard__["a" /* getCode */])( 'arrowUp' ),
	Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_keyboard__["a" /* getCode */])( 'arrowRight' ),
	Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_keyboard__["a" /* getCode */])( 'arrowDown' ),
	Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_keyboard__["a" /* getCode */])( 'arrowLeft' ),
	9, // Tab
	16, // Shift
	17, // Ctrl
	18, // Alt
	20, // CapsLock
	27, // Escape
	33, // PageUp
	34, // PageDown
	35, // Home
	36, // End
	229 // Composition start key
];

// Function keys.
for ( let code = 112; code <= 135; code++ ) {
	safeKeycodes.push( code );
}

// Returns `true` if a keystroke should not cause any content change caused by "typing".
//
// Note: This implementation is very simple and will need to be refined with time.
//
// @private
// @param {engine.view.observer.keyObserver.KeyEventData} keyData
// @returns {Boolean}
function isSafeKeystroke( keyData ) {
	// Keystrokes which contain Ctrl don't represent typing.
	if ( keyData.ctrlKey ) {
		return true;
	}

	return safeKeycodes.includes( keyData.keyCode );
}

// Helper function that compares whether two given view nodes are same. It is used in `diff` when it's passed an array
// with child nodes.
function compareChildNodes( oldChild, newChild ) {
	if ( oldChild instanceof __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_view_text__["a" /* default */] && newChild instanceof __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_view_text__["a" /* default */] ) {
		return oldChild.data === newChild.data;
	} else {
		return oldChild === newChild;
	}
}

// Returns change made to a single text node. Returns `undefined` if more than a single text node was changed.
//
// @private
// @param mutation
function getSingleTextNodeChange( mutation ) {
	// One new node.
	if ( mutation.newChildren.length - mutation.oldChildren.length != 1 ) {
		return;
	}

	// Which is text.
	const diffResult = Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_diff__["a" /* default */])( mutation.oldChildren, mutation.newChildren, compareChildNodes );
	const changes = Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_difftochanges__["a" /* default */])( diffResult, mutation.newChildren );

	// In case of [ delete, insert, insert ] the previous check will not exit.
	if ( changes.length > 1 ) {
		return;
	}

	const change = changes[ 0 ];

	// Which is text.
	if ( !( change.values[ 0 ] instanceof __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_view_text__["a" /* default */] ) ) {
		return;
	}

	return change;
}

// Returns first common ancestor of all mutations that is either {@link module:engine/view/containerelement~ContainerElement}
// or {@link module:engine/view/rootelement~RootElement}.
//
// @private
// @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|
// module:engine/view/observer/mutationobserver~MutatedChildren>} mutations
// @returns {module:engine/view/containerelement~ContainerElement|engine/view/rootelement~RootElement|undefined}
function getMutationsContainer( mutations ) {
	const lca = mutations
		.map( mutation => mutation.node )
		.reduce( ( commonAncestor, node ) => {
			return commonAncestor.getCommonAncestor( node, { includeSelf: true } );
		} );

	if ( !lca ) {
		return;
	}

	// We need to look for container and root elements only, so check all LCA's
	// ancestors (starting from itself).
	return lca.getAncestors( { includeSelf: true, parentFirst: true } )
		.find( element => element.is( 'containerElement' ) || element.is( 'rootElement' ) );
}

// Returns true if container children have mutated or more than a single text node was changed.
//
// Single text node child insertion is handled in {@link module:typing/input~MutationHandler#_handleTextNodeInsertion}
// while text mutation is handled in {@link module:typing/input~MutationHandler#_handleTextMutation}.
//
// @private
// @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|
// module:engine/view/observer/mutationobserver~MutatedChildren>} mutations
// @returns {Boolean}
function containerChildrenMutated( mutations ) {
	if ( mutations.length == 0 ) {
		return false;
	}

	// Check if there is any mutation of `children` type or any mutation that changes more than one text node.
	for ( const mutation of mutations ) {
		if ( mutation.type === 'children' && !getSingleTextNodeChange( mutation ) ) {
			return true;
		}
	}

	return false;
}

// Returns true if provided array contains only {@link module:engine/model/text~Text model text nodes}.
//
// @param {Array.<module:engine/model/node~Node>} children
// @returns {Boolean}
function hasOnlyTextNodes( children ) {
	return children.every( child => child.is( 'text' ) );
}

// Calculates first change index and number of characters that should be inserted and deleted starting from that index.
//
// @private
// @param diffResult
// @return {{insertions: number, deletions: number, firstChangeAt: *}}
function calculateChanges( diffResult ) {
	// Index where the first change happens. Used to set the position from which nodes will be removed and where will be inserted.
	let firstChangeAt = null;
	// Index where the last change happens. Used to properly count how many characters have to be removed and inserted.
	let lastChangeAt = null;

	// Get `firstChangeAt` and `lastChangeAt`.
	for ( let i = 0; i < diffResult.length; i++ ) {
		const change = diffResult[ i ];

		if ( change != 'equal' ) {
			firstChangeAt = firstChangeAt === null ? i : firstChangeAt;
			lastChangeAt = i;
		}
	}

	// How many characters, starting from `firstChangeAt`, should be removed.
	let deletions = 0;
	// How many characters, starting from `firstChangeAt`, should be inserted.
	let insertions = 0;

	for ( let i = firstChangeAt; i <= lastChangeAt; i++ ) {
		// If there is no change (equal) or delete, the character is existing in `oldText`. We count it for removing.
		if ( diffResult[ i ] != 'insert' ) {
			deletions++;
		}

		// If there is no change (equal) or insert, the character is existing in `newText`. We count it for inserting.
		if ( diffResult[ i ] != 'delete' ) {
			insertions++;
		}
	}

	return { insertions, deletions, firstChangeAt };
}


/***/ }),
/* 468 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = diffToChanges;
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module utils/difftochanges
 */

/**
 * Creates a set of changes which need to be applied to the input in order to transform
 * it into the output. This function can be used with strings or arrays.
 *
 *		const input = Array.from( 'abc' );
 *		const output = Array.from( 'xaby' );
 *		const changes = diffToChanges( diff( input, output ), output );
 *
 *		changes.forEach( change => {
 *			if ( change.type == 'insert' ) {
 *				input.splice( change.index, 0, ...change.values );
 *			} else if ( change.type == 'delete' ) {
 *				input.splice( change.index, change.howMany );
 *			}
 *		} );
 *
 *		input.join( '' ) == output.join( '' ); // -> true
 *
 * @param {Array.<'equal'|'insert'|'delete'>} diff Result of {@link module:utils/diff~diff}.
 * @param {String|Array} output The string or array which was passed as diff's output.
 * @returns {Array.<Object>} Set of changes (insert or delete) which need to be applied to the input
 * in order to transform it into the output.
 */
function diffToChanges( diff, output ) {
	const changes = [];
	let index = 0;
	let lastOperation;

	diff.forEach( change => {
		if ( change == 'equal' ) {
			pushLast();

			index++;
		} else if ( change == 'insert' ) {
			if ( isContinuationOf( 'insert' ) ) {
				lastOperation.values.push( output[ index ] );
			} else {
				pushLast();

				lastOperation = {
					type: 'insert',
					index,
					values: [ output[ index ] ]
				};
			}

			index++;
		} else /* if ( change == 'delete' ) */ {
			if ( isContinuationOf( 'delete' ) ) {
				lastOperation.howMany++;
			} else {
				pushLast();

				lastOperation = {
					type: 'delete',
					index,
					howMany: 1
				};
			}
		}
	} );

	pushLast();

	return changes;

	function pushLast() {
		if ( lastOperation ) {
			changes.push( lastOperation );
			lastOperation = null;
		}
	}

	function isContinuationOf( expected ) {
		return lastOperation && lastOperation.type == expected;
	}
}


/***/ }),
/* 469 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__changebuffer__ = __webpack_require__(272);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module typing/inputcommand
 */




/**
 * The input command. Used by the {@link module:typing/input~Input input feature} to handle typing.
 *
 * @extends module:core/command~Command
 */
class InputCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * Creates an instance of the command.
	 *
	 * @param {module:core/editor/editor~Editor} editor
	 * @param {Number} undoStepSize The maximum number of atomic changes
	 * which can be contained in one batch in the command buffer.
	 */
	constructor( editor, undoStepSize ) {
		super( editor );

		/**
		 * Typing's change buffer used to group subsequent changes into batches.
		 *
		 * @readonly
		 * @private
		 * @member {module:typing/changebuffer~ChangeBuffer} #_buffer
		 */
		this._buffer = new __WEBPACK_IMPORTED_MODULE_1__changebuffer__["a" /* default */]( editor.document, undoStepSize );
	}

	/**
	 * The current change buffer.
	 *
	 * @type {module:typing/changebuffer~ChangeBuffer}
	 */
	get buffer() {
		return this._buffer;
	}

	/**
	 * @inheritDoc
	 */
	destroy() {
		super.destroy();

		this._buffer.destroy();
	}

	/**
	 * Executes the input command. It replaces the content within the given range with the given text.
	 * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
	 * at the beginning of the range (which after the removal is a collapsed range).
	 *
	 * @fires execute
	 * @param {Object} [options] The command options.
	 * @param {String} [options.text=''] The text to be inserted.
	 * @param {module:engine/model/range~Range} [options.range] The range in which the text is inserted. Defaults
	 * to the first range in the current selection.
	 * @param {module:engine/model/range~Range} [options.resultRange] The range where the selection
	 * should be placed after the insertion. If not specified, the selection will be placed right after
	 * the inserted text.
	 */
	execute( options = {} ) {
		const doc = this.editor.document;
		const text = options.text || '';
		const textInsertions = text.length;
		const range = options.range || doc.selection.getFirstRange();
		const resultRange = options.resultRange;

		doc.enqueueChanges( () => {
			const isCollapsedRange = range.isCollapsed;

			this._buffer.lock();

			if ( !isCollapsedRange ) {
				this._buffer.batch.remove( range );
			}

			if ( text ) {
				this._buffer.batch.weakInsert( range.start, text );
			}

			if ( resultRange ) {
				this.editor.data.model.selection.setRanges( [ resultRange ] );
			} else if ( isCollapsedRange ) {
				// If range was collapsed just shift the selection by the number of inserted characters.
				this.editor.data.model.selection.setCollapsedAt( range.start.getShiftedBy( textInsertions ) );
			}

			this._buffer.unlock();

			this._buffer.input( textInsertions );
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = InputCommand;



/***/ }),
/* 470 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__deletecommand__ = __webpack_require__(471);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__deleteobserver__ = __webpack_require__(472);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module typing/delete
 */





/**
 * The delete and backspace feature. Handles the <kbd>Delete</kbd> and <kbd>Backspace</kbd> keys in the editor.
 *
 * @extends module:core/plugin~Plugin
 */
class Delete extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Delete';
	}

	init() {
		const editor = this.editor;
		const editingView = editor.editing.view;

		editingView.addObserver( __WEBPACK_IMPORTED_MODULE_2__deleteobserver__["a" /* default */] );

		editor.commands.add( 'forwardDelete', new __WEBPACK_IMPORTED_MODULE_1__deletecommand__["a" /* default */]( editor, 'forward' ) );
		editor.commands.add( 'delete', new __WEBPACK_IMPORTED_MODULE_1__deletecommand__["a" /* default */]( editor, 'backward' ) );

		this.listenTo( editingView, 'delete', ( evt, data ) => {
			editor.execute( data.direction == 'forward' ? 'forwardDelete' : 'delete', { unit: data.unit, sequence: data.sequence } );
			data.preventDefault();
			editingView.scrollToTheSelection();
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Delete;



/***/ }),
/* 471 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_selection__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__changebuffer__ = __webpack_require__(272);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_count__ = __webpack_require__(153);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module typing/deletecommand
 */









/**
 * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and
 * <kbd>Backspace</kbd> keys.
 *
 * @extends module:core/command~Command
 */
class DeleteCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * Creates an instance of the command.
	 *
	 * @param {module:core/editor/editor~Editor} editor
	 * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it
	 * should consume the content when the selection is collapsed.
	 */
	constructor( editor, direction ) {
		super( editor );

		/**
		 * The directionality of the delete describing in what direction it should
		 * consume the content when the selection is collapsed.
		 *
		 * @readonly
		 * @member {'forward'|'backward'} #direction
		 */
		this.direction = direction;

		/**
		 * Delete's change buffer used to group subsequent changes into batches.
		 *
		 * @readonly
		 * @private
		 * @member {typing.ChangeBuffer} #buffer
		 */
		this._buffer = new __WEBPACK_IMPORTED_MODULE_5__changebuffer__["a" /* default */]( editor.document, editor.config.get( 'typing.undoStep' ) );
	}

	/**
	 * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
	 * or a piece of content in the {@link #direction defined direction}.
	 *
	 * @fires execute
	 * @param {Object} [options] The command options.
	 * @param {'character'} [options.unit='character'] See {@link module:engine/controller/modifyselection~modifySelection}'s options.
	 * @param {Number} [options.sequence=1] A number describing which subsequent delete event it is without the key being released.
	 * See the {@link module:engine/view/document~Document#event:delete} event data.
	 */
	execute( options = {} ) {
		const doc = this.editor.document;
		const dataController = this.editor.data;

		doc.enqueueChanges( () => {
			this._buffer.lock();

			const selection = __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_selection__["a" /* default */].createFromSelection( doc.selection );

			// Do not replace the whole selected content if selection was collapsed.
			// This prevents such situation:
			//
			// <h1></h1><p>[]</p>	-->  <h1>[</h1><p>]</p> 		-->  <p></p>
			// starting content		-->   after `modifySelection`	-->  after `deleteContent`.
			const doNotResetEntireContent = selection.isCollapsed;

			// Try to extend the selection in the specified direction.
			if ( selection.isCollapsed ) {
				dataController.modifySelection( selection, { direction: this.direction, unit: options.unit } );
			}

			// Check if deleting in an empty editor. See #61.
			if ( this._shouldEntireContentBeReplacedWithParagraph( options.sequence || 1 ) ) {
				this._replaceEntireContentWithParagraph();

				return;
			}

			// If selection is still collapsed, then there's nothing to delete.
			if ( selection.isCollapsed ) {
				return;
			}

			let changeCount = 0;

			selection.getFirstRange().getMinimalFlatRanges().forEach( range => {
				changeCount += Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_count__["a" /* default */])(
					range.getWalker( { singleCharacters: true, ignoreElementEnd: true, shallow: true } )
				);
			} );

			dataController.deleteContent( selection, this._buffer.batch, { doNotResetEntireContent } );
			this._buffer.input( changeCount );

			doc.selection.setRanges( selection.getRanges(), selection.isBackward );

			this._buffer.unlock();
		} );
	}

	/**
	 * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
	 * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
	 * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
	 *
	 * But, if the user pressed the key in an empty editable for the first time,
	 * we want to replace the entire content with a paragraph if:
	 *
	 * * the current limit element is empty,
	 * * the paragraph is allowed in the limit element,
	 * * the limit doesn't already have a paragraph inside.
	 *
	 * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
	 *
	 * @private
	 * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.
	 * @returns {Boolean}
	 */
	_shouldEntireContentBeReplacedWithParagraph( sequence ) {
		// Does nothing if user pressed and held the "Backspace" or "Delete" key.
		if ( sequence > 1 ) {
			return false;
		}

		const document = this.editor.document;
		const selection = document.selection;
		const limitElement = document.schema.getLimitElement( selection );

		// If a collapsed selection contains the whole content it means that the content is empty
		// (from the user perspective).
		const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent( limitElement );

		if ( !limitElementIsEmpty ) {
			return false;
		}

		if ( !document.schema.check( { name: 'paragraph', inside: limitElement.name } ) ) {
			return false;
		}

		const limitElementFirstChild = limitElement.getChild( 0 );

		// Does nothing if the limit element already contains only a paragraph.
		// We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)
		// because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.
		if ( limitElementFirstChild && limitElementFirstChild.name === 'paragraph' ) {
			return false;
		}

		return true;
	}

	/**
	 * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
	 *
	 * @private
	 */
	_replaceEntireContentWithParagraph() {
		const document = this.editor.document;
		const selection = document.selection;
		const limitElement = document.schema.getLimitElement( selection );
		const paragraph = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */]( 'paragraph' );

		this._buffer.batch.remove( __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_model_range__["a" /* default */].createIn( limitElement ) );
		this._buffer.batch.insert( __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAt( limitElement ), paragraph );

		selection.setCollapsedAt( paragraph );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DeleteCommand;



/***/ }),
/* 472 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_observer_observer__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_observer_domeventdata__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__ = __webpack_require__(28);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module typing/deleteobserver
 */





/**
 * Delete observer introduces the {@link module:engine/view/document~Document#event:delete} event.
 *
 * @extends module:engine/view/observer/observer~Observer
 */
class DeleteObserver extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_observer_observer__["a" /* default */] {
	constructor( document ) {
		super( document );

		let sequence = 0;

		document.on( 'keyup', ( evt, data ) => {
			if ( data.keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].delete || data.keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].backspace ) {
				sequence = 0;
			}
		} );

		document.on( 'keydown', ( evt, data ) => {
			const deleteData = {};

			if ( data.keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].delete ) {
				deleteData.direction = 'forward';
				deleteData.unit = 'character';
			} else if ( data.keyCode == __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].backspace ) {
				deleteData.direction = 'backward';
				deleteData.unit = 'codePoint';
			} else {
				return;
			}

			deleteData.unit = data.altKey ? 'word' : deleteData.unit;
			deleteData.sequence = ++sequence;

			document.fire( 'delete', new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_observer_domeventdata__["a" /* default */]( document, data.domEvent, deleteData ) );
		} );
	}

	/**
	 * @inheritDoc
	 */
	observe() {}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DeleteObserver;


/**
 * Event fired when the user tries to delete content (e.g. presses <kbd>Delete</kbd> or <kbd>Backspace</kbd>).
 *
 * Note: This event is fired by the {@link module:typing/deleteobserver~DeleteObserver observer}
 * (usually registered by the {@link module:typing/delete~Delete delete feature}).
 *
 * @event module:engine/view/document~Document#event:delete
 * @param {module:engine/view/observer/domeventdata~DomEventData} data
 * @param {'forward'|'delete'} data.direction The direction in which the deletion should happen.
 * @param {'character'|'word'} data.unit The "amount" of content that should be deleted.
 * @param {Number} data.sequence A number describing which subsequent delete event it is without the key being released.
 * If it's 2 or more it means that the key was pressed and hold.
 */


/***/ }),
/* 473 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__undoengine__ = __webpack_require__(474);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__theme_icons_undo_svg__ = __webpack_require__(479);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__theme_icons_undo_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__theme_icons_undo_svg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__theme_icons_redo_svg__ = __webpack_require__(480);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__theme_icons_redo_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__theme_icons_redo_svg__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module undo/undo
 */








/**
 * The undo feature. It introduces the Undo and Redo buttons to the editor.
 *
 * Below is the explanation of the undo mechanism working together with {@link module:engine/model/history~History History}:
 *
 * Whenever a {@link module:engine/model/delta/delta~Delta delta} is applied to the
 * {@link module:engine/model/document~Document document}, it is saved to `History` as is.
 * The {@link module:engine/model/batch~Batch batch} that owns that delta is also saved, in
 * {@link module:undo/undocommand~UndoCommand}, together with the selection that was present in the document before the
 * delta was applied. A batch is saved instead of the delta because changes are undone batch-by-batch, not delta-by-delta
 * and a batch is seen as one undo step.
 *
 * After some changes happen to the document, the `History` and `UndoCommand` stack can be represented as follows:
 *
 *		  History                           Undo stack
 *		===========             ==================================
 *		[delta A1]                          [batch A]
 *		[delta B1]                          [batch B]
 *		[delta B2]                          [batch C]
 *		[delta C1]
 *		[delta C2]
 *		[delta B3]
 *		[delta C3]
 *
 * Where deltas starting with the same letter are from same batch.
 *
 * Undoing a batch means that a set of deltas which will reverse the effects of that batch needs to be generated. For example, if a batch
 * added several letters, undoing the batch should remove them. It is important to apply undoing deltas in the reversed order,
 * so if a batch has delta `X`, `Y`, `Z`, reversed deltas `Zr`, `Yr` and `Xr` need to be applied. Otherwise reversed delta
 * `Xr` would operate on a wrong document state, because delta `X` does not know that deltas `Y` and `Z` happened.
 *
 * After deltas from an undone batch got {@link module:engine/model/delta/delta~Delta#getReversed reversed},
 * one needs to make sure if they are ready to be applied. In the scenario above, delta `C3` is the last delta and `C3r`
 * bases on up-to-date document state, so it can be applied to the document.
 *
 *		  History                           Undo stack
 *		=============             ==================================
 *		[ delta A1  ]                      [  batch A  ]
 *		[ delta B1  ]                      [  batch B  ]
 *		[ delta B2  ]             [   processing undoing batch C   ]
 *		[ delta C1  ]
 *		[ delta C2  ]
 *		[ delta B3  ]
 *		[ delta C3  ]
 *		[ delta C3r ]
 *
 * Next is delta `C2`, reversed to `C2r`. `C2r` bases on `C2`, so it bases on the wrong document state. It needs to be
 * transformed by deltas from history that happened after it, so it "knows" about them. Let us assume that `C2' = C2r * B3 * C3 * C3r`,
 * where `*` means "transformed by". Rest of deltas from that batch are processed in the same fashion.
 *
 *		  History                           Undo stack                                     Redo stack
 *		=============             ==================================             ==================================
 *		[ delta A1  ]                      [  batch A  ]                                  [ batch Cr ]
 *		[ delta B1  ]                      [  batch B  ]
 *		[ delta B2  ]
 *		[ delta C1  ]
 *		[ delta C2  ]
 *		[ delta B3  ]
 *		[ delta C3  ]
 *		[ delta C3r ]
 *		[ delta C2' ]
 *		[ delta C1' ]
 *
 * Selective undo works on the same basis, however, instead of undoing the last batch in the undo stack, any batch can be undone.
 * The same algorithm applies: deltas from a batch (i.e. `A1`) are reversed and then transformed by deltas stored in history.
 *
 * Redo also is very similar to undo. It has its own stack that is filled with undoing (reversed batches). Deltas from
 * batch that is re-done are reversed-back, transformed in proper order and applied to the document.
 *
 *		  History                           Undo stack                                     Redo stack
 *		=============             ==================================             ==================================
 *		[ delta A1  ]                      [  batch A  ]
 *		[ delta B1  ]                      [  batch B  ]
 *		[ delta B2  ]                      [ batch Crr ]
 *		[ delta C1  ]
 *		[ delta C2  ]
 *		[ delta B3  ]
 *		[ delta C3  ]
 *		[ delta C3r ]
 *		[ delta C2' ]
 *		[ delta C1' ]
 *		[ delta C1'r]
 *		[ delta C2'r]
 *		[ delta C3rr]
 *
 * @extends module:core/plugin~Plugin
 */
class Undo extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_1__undoengine__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Undo';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const t = editor.t;

		this._addButton( 'undo', t( 'Undo' ), 'CTRL+Z', __WEBPACK_IMPORTED_MODULE_3__theme_icons_undo_svg___default.a );
		this._addButton( 'redo', t( 'Redo' ), 'CTRL+Y', __WEBPACK_IMPORTED_MODULE_4__theme_icons_redo_svg___default.a );

		editor.keystrokes.set( 'CTRL+Z', 'undo' );
		editor.keystrokes.set( 'CTRL+Y', 'redo' );
		editor.keystrokes.set( 'CTRL+SHIFT+Z', 'redo' );
	}

	/**
	 * Creates a button for the specified command.
	 *
	 * @private
	 * @param {String} name Command name.
	 * @param {String} label Button label.
	 * @param {String} keystroke Command keystroke.
	 * @param {String} Icon Source of the icon.
	 */
	_addButton( name, label, keystroke, Icon ) {
		const editor = this.editor;
		const command = editor.commands.get( name );

		editor.ui.componentFactory.add( name, locale => {
			const view = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__["a" /* default */]( locale );

			view.set( {
				label,
				icon: Icon,
				keystroke,
				tooltip: true
			} );

			view.bind( 'isEnabled' ).to( command, 'isEnabled' );

			this.listenTo( view, 'execute', () => editor.execute( name ) );

			return view;
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Undo;



/***/ }),
/* 474 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__undocommand__ = __webpack_require__(475);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__redocommand__ = __webpack_require__(476);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module undo/undoengine
 */





/**
 * The undo engine feature.
 *
 * Undo brings in possibility to undo and redo changes done in the model by deltas through
 * the {@link module:engine/model/document~Document#batch Batch API}.
 *
 * @extends module:core/plugin~Plugin
 */
class UndoEngine extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( editor ) {
		super( editor );

		/**
		 * The command that manages undo {@link module:engine/model/batch~Batch batches} stack (history).
		 * Created and registered during the {@link #init feature initialization}.
		 *
		 * @private
		 * @member {undo.UndoEngineCommand} #_undoCommand
		 */

		/**
		 * The command that manages redo {@link module:engine/model/batch~Batch batches} stack (history).
		 * Created and registered during the {@link #init feature initialization}.
		 *
		 * @private
		 * @member {undo.UndoEngineCommand} #_redoCommand
		 */

		/**
		 * Keeps track of which batches were registered in undo.
		 *
		 * @private
		 * @member {WeakSet.<module:engine/model/batch~Batch>}
		 */
		this._batchRegistry = new WeakSet();
	}

	/**
	 * @inheritDoc
	 */
	init() {
		// Create commands.
		this._undoCommand = new __WEBPACK_IMPORTED_MODULE_1__undocommand__["a" /* default */]( this.editor );
		this._redoCommand = new __WEBPACK_IMPORTED_MODULE_2__redocommand__["a" /* default */]( this.editor );

		// Register command to the editor.
		this.editor.commands.add( 'undo', this._undoCommand );
		this.editor.commands.add( 'redo', this._redoCommand );

		this.listenTo( this.editor.document, 'change', ( evt, type, changes, batch ) => {
			// If changes are not a part of a batch or this is not a new batch, omit those changes.
			if ( this._batchRegistry.has( batch ) || batch.type == 'transparent' ) {
				return;
			} else {
				if ( this._redoCommand._createdBatches.has( batch ) ) {
					// If this batch comes from `redoCommand`, add it to `undoCommand` stack.
					this._undoCommand.addBatch( batch );
				} else if ( !this._undoCommand._createdBatches.has( batch ) ) {
					// A default batch - these are new changes in the document, not introduced by undo feature.
					// Add them to `undoCommand` stack and clear `redoCommand` stack.
					this._undoCommand.addBatch( batch );
					this._redoCommand.clearStack();
				}
			}

			// Add the batch to the registry so it will not be processed again.
			this._batchRegistry.add( batch );
		}, { priority: 'highest' } );

		this.listenTo( this._undoCommand, 'revert', ( evt, undoneBatch, undoingBatch ) => {
			this._redoCommand.addBatch( undoingBatch );
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = UndoEngine;



/***/ }),
/* 475 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basecommand__ = __webpack_require__(273);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module undo/undocommand
 */



/**
 * The undo command stores {@link module:engine/model/batch~Batch batches} applied to the
 * {@link module:engine/model/document~Document document} and is able to undo a batch by reversing it and transforming by
 * batches from {@link module:engine/model/document~Document#history history} that happened after the reversed batch.
 *
 * The undo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.
 *
 * @extends module:undo/basecommand~BaseCommand
 */
class UndoCommand extends __WEBPACK_IMPORTED_MODULE_0__basecommand__["a" /* default */] {
	/**
	 * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
	 * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.
	 * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
	 *
	 * @fires execute
	 * @fires revert
	 * @param {module:engine/model/batch~Batch} [batch] A batch that should be undone. If not set, the last added batch will be undone.
	 */
	execute( batch = null ) {
		// If batch is not given, set `batchIndex` to the last index in command stack.
		const batchIndex = batch ? this._stack.findIndex( a => a.batch == batch ) : this._stack.length - 1;

		const item = this._stack.splice( batchIndex, 1 )[ 0 ];

		// All changes has to be done in one `enqueueChanges` callback so other listeners will not
		// step between consecutive deltas, or won't do changes to the document before selection is properly restored.
		this.editor.document.enqueueChanges( () => {
			const undoingBatch = this._undo( item.batch );

			const deltas = this.editor.document.history.getDeltas( item.batch.baseVersion );
			this._restoreSelection( item.selection.ranges, item.selection.isBackward, deltas );

			this.fire( 'revert', item.batch, undoingBatch );
		} );

		this.refresh();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = UndoCommand;


/**
 * Fired when execution of the command reverts some batch.
 *
 * @event revert
 */


/***/ }),
/* 476 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basecommand__ = __webpack_require__(273);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module undo/redocommand
 */



/**
 * The redo command stores {@link module:engine/model/batch~Batch batches} that were used to undo a batch by
 * {@link module:undo/undocommand~UndoCommand}. It is able to redo a previously undone batch by reversing the undoing
 * batches created by `UndoCommand`. The reversed batch is transformed by all the batches from
 * {@link module:engine/model/document~Document#history history} that happened after the reversed undo batch.
 *
 * The redo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.
 *
 * @extends module:undo/basecommand~BaseCommand
 */
class RedoCommand extends __WEBPACK_IMPORTED_MODULE_0__basecommand__["a" /* default */] {
	/**
	 * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
	 * the command's stack, applies the reverted and transformed version on the
	 * {@link module:engine/model/document~Document document} and removes the batch from the stack.
	 * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
	 *
	 * @fires execute
	 */
	execute() {
		const item = this._stack.pop();

		// All changes have to be done in one `enqueueChanges` callback so other listeners will not
		// step between consecutive deltas, or won't do changes to the document before selection is properly restored.
		this.editor.document.enqueueChanges( () => {
			const lastDelta = item.batch.deltas[ item.batch.deltas.length - 1 ];
			const nextBaseVersion = lastDelta.baseVersion + lastDelta.operations.length;
			const deltas = this.editor.document.history.getDeltas( nextBaseVersion );

			this._restoreSelection( item.selection.ranges, item.selection.isBackward, deltas );
			this._undo( item.batch );
		} );

		this.refresh();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RedoCommand;



/***/ }),
/* 477 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* global DOMParser */

/**
 * @module ui/icon/iconview
 */



/**
 * The icon view class.
 *
 * @extends module:ui/view~View
 */
class IconView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor() {
		super();

		const bind = this.bindTemplate;

		/**
		 * The SVG source of the icon.
		 *
		 * @observable
		 * @member {String} #content
		 */
		this.set( 'content', '' );

		/**
		 * This attribute specifies the boundaries to which the
		 * icon content should stretch.
		 *
		 * @observable
		 * @default '0 0 20 20'
		 * @member {String} #viewBox
		 */
		this.set( 'viewBox', '0 0 20 20' );

		this.setTemplate( {
			tag: 'svg',
			ns: 'http://www.w3.org/2000/svg',
			attributes: {
				class: 'ck-icon',
				viewBox: bind.to( 'viewBox' )
			}
		} );
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		this._updateXMLContent();

		// This is a hack for lack of innerHTML binding.
		// See: https://github.com/ckeditor/ckeditor5-ui/issues/99.
		this.on( 'change:content', () => this._updateXMLContent() );
	}

	/**
	 * Updates the {@link #element} with the value of {@link #content}.
	 *
	 * @private
	 */
	_updateXMLContent() {
		if ( this.content ) {
			const svg = new DOMParser()
				.parseFromString( this.content.trim(), 'image/svg+xml' )
				.firstChild;

			this.element.innerHTML = '';

			while ( svg.childNodes.length > 0 ) {
				this.element.appendChild( svg.childNodes[ 0 ] );
			}
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IconView;



/***/ }),
/* 478 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/tooltip/tooltipview
 */



/**
 * The tooltip view class.
 *
 * @extends module:ui/view~View
 */
class TooltipView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		/**
		 * The text of the tooltip visible to the user.
		 *
		 * @observable
		 * @member {String} #text
		 */
		this.set( 'text', '' );

		/**
		 * The position of the tooltip (south or north).
		 *
		 *		+-----------+
		 *		|   north   |
		 *		+-----------+
		 *		      V
		 *		  [element]
		 *
		 *		  [element]
		 *		      ^
		 *		+-----------+
		 *		|   south   |
		 *		+-----------+
		 *
		 * @observable
		 * @default 's'
		 * @member {'s'|'n'} #position
		 */
		this.set( 'position', 's' );

		const bind = this.bindTemplate;

		this.setTemplate( {
			tag: 'span',
			attributes: {
				class: [
					'ck-tooltip',
					bind.to( 'position', position => 'ck-tooltip_' + position ),
					bind.if( 'text', 'ck-hidden', value => !value.trim() )
				]
			},
			children: [
				{
					tag: 'span',

					attributes: {
						class: [
							'ck-tooltip__text'
						]
					},

					children: [
						{
							text: bind.to( 'text' ),
						}
					]
				}
			]
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TooltipView;



/***/ }),
/* 479 */
/***/ (function(module, exports) {

module.exports = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 10l8 6-1-3.982c3.417 0 8.616.869 10 3.982 0-5.983-6.601-7.96-10-7.96 0-.85 1-3.32 1-4.04l-8 6z\" fill=\"#454545\" fill-rule=\"evenodd\"/></svg>"

/***/ }),
/* 480 */
/***/ (function(module, exports) {

module.exports = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10 16l1-3.982c-3.417 0-8.616.869-10 3.982 0-5.983 6.601-7.96 10-7.96 0-.85-1-3.32-1-4.04l8 6-8 6z\" fill=\"#454545\" fill-rule=\"evenodd\"/></svg>"

/***/ }),
/* 481 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__blockautoformatengine__ = __webpack_require__(482);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__inlineautoformatengine__ = __webpack_require__(483);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module autoformat/autoformat
 */





/**
 * Includes a set of predefined autoformatting actions. For a detailed overview, check
 * the {@glink features/autoformat Autoformatting feature documentation}.
 *
 * @extends module:core/plugin~Plugin
 */
class Autoformat extends __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Autoformat';
	}

	/**
	 * @inheritDoc
	 */
	afterInit() {
		this._addListAutoformats();
		this._addBasicStylesAutoformats();
		this._addHeadingAutoformats();
		this._addBlockQuoteAutoformats();
	}

	/**
	 * Adds autoformatting related to the {@link module:list/list~List}.
	 *
	 * When typed:
	 * - `* ` or `- ` &ndash; A paragraph will be changed to a bulleted list.
	 * - `1. ` or `1) ` &ndash; A paragraph will be changed to a numbered list ("1" can be any digit or a list of digits).
	 *
	 * @private
	 */
	_addListAutoformats() {
		const commands = this.editor.commands;

		if ( commands.get( 'bulletedList' ) ) {
			// eslint-disable-next-line no-new
			new __WEBPACK_IMPORTED_MODULE_0__blockautoformatengine__["a" /* default */]( this.editor, /^[*-]\s$/, 'bulletedList' );
		}

		if ( commands.get( 'numberedList' ) ) {
			// eslint-disable-next-line no-new
			new __WEBPACK_IMPORTED_MODULE_0__blockautoformatengine__["a" /* default */]( this.editor, /^\d+[.|)]?\s$/, 'numberedList' );
		}
	}

	/**
	 * Adds autoformatting related to the {@link module:basic-styles/bold~Bold},
	 * {@link module:basic-styles/italic~Italic} and {@link module:basic-styles/code~Code}.
	 *
	 * When typed:
	 * - `**foobar**` &ndash; `**` characters are removed and `foobar` is set to bold,
	 * - `__foobar__` &ndash; `__` characters are removed and `foobar` is set to bold,
	 * - `*foobar*` &ndash; `*` characters are removed and `foobar` is set to italic,
	 * - `_foobar_` &ndash; `_` characters are removed and `foobar` is set to italic,
	 * - ``` `foobar` &ndash; ``` ` ``` characters are removed and `foobar` is set to code.
	 *
	 * @private
	 */
	_addBasicStylesAutoformats() {
		const commands = this.editor.commands;

		if ( commands.get( 'bold' ) ) {
			/* eslint-disable no-new */
			new __WEBPACK_IMPORTED_MODULE_1__inlineautoformatengine__["a" /* default */]( this.editor, /(\*\*)([^*]+)(\*\*)$/g, 'bold' );
			new __WEBPACK_IMPORTED_MODULE_1__inlineautoformatengine__["a" /* default */]( this.editor, /(__)([^_]+)(__)$/g, 'bold' );
			/* eslint-enable no-new */
		}

		if ( commands.get( 'italic' ) ) {
			// The italic autoformatter cannot be triggered by the bold markers, so we need to check the
			// text before the pattern (e.g. `(?:^|[^\*])`).

			/* eslint-disable no-new */
			new __WEBPACK_IMPORTED_MODULE_1__inlineautoformatengine__["a" /* default */]( this.editor, /(?:^|[^*])(\*)([^*_]+)(\*)$/g, 'italic' );
			new __WEBPACK_IMPORTED_MODULE_1__inlineautoformatengine__["a" /* default */]( this.editor, /(?:^|[^_])(_)([^_]+)(_)$/g, 'italic' );
			/* eslint-enable no-new */
		}

		if ( commands.get( 'code' ) ) {
			/* eslint-disable no-new */
			new __WEBPACK_IMPORTED_MODULE_1__inlineautoformatengine__["a" /* default */]( this.editor, /(`)([^`]+)(`)$/g, 'code' );
			/* eslint-enable no-new */
		}
	}

	/**
	 * Adds autoformatting related to {@link module:heading/heading~Heading}.
	 *
	 * It is using a number at the end of the command name to associate it with the proper trigger:
	 *
	 * * `heading1` will be executed when typing `#`,
	 * * `heading2` will be executed when typing `##`,
	 * * ... up to `heading6` and `######`.
	 *
	 * @private
	 */
	_addHeadingAutoformats() {
		Array.from( this.editor.commands.names() )
			.filter( name => name.match( /^heading[1-6]$/ ) )
			.forEach( commandName => {
				const level = commandName[ 7 ];
				const pattern = new RegExp( `^(#{${ level }})\\s$` );

				// eslint-disable-next-line no-new
				new __WEBPACK_IMPORTED_MODULE_0__blockautoformatengine__["a" /* default */]( this.editor, pattern, context => {
					const { batch } = context;

					this.editor.execute( commandName, { batch } );
				} );
			} );
	}

	/**
	 * Adds autoformatting related to {@link module:block-quote/blockquote~BlockQuote}.
	 *
	 * When typed:
	 * * `> ` &ndash; A paragraph will be changed to a block quote.
	 *
	 * @private
	 */
	_addBlockQuoteAutoformats() {
		if ( this.editor.commands.get( 'blockQuote' ) ) {
			// eslint-disable-next-line no-new
			new __WEBPACK_IMPORTED_MODULE_0__blockautoformatengine__["a" /* default */]( this.editor, /^>\s$/, 'blockQuote' );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Autoformat;



/***/ }),
/* 482 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_textproxy__ = __webpack_require__(66);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module autoformat/blockautoformatengine
 */




/**
 * The block autoformatting engine. It allows to format various block patterns. For example,
 * it can be configured to turn a paragraph starting with `*` and followed by a space into a list item.
 *
 * The autoformatting operation is integrated with the undo manager,
 * so the autoformatting step can be undone if the user's intention was not to format the text.
 *
 * See the constructors documentation to learn how to create custom inline autoformatters. You can also use
 * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters
 * (lists, headings, bold and italic).
 */
class BlockAutoformatEngine {
	/**
	 * Creates a listener triggered on `change` event in the document.
	 * Calls the callback when inserted text matches the regular expression or the command name
	 * if provided instead of the callback.
	 *
	 * Examples of usage:
	 *
	 * To convert a paragraph to heading 1 when `- ` is typed, using just the commmand name:
	 *
	 *		new BlockAutoformatEngine( editor, /^\- $/, 'heading1' );
	 *
	 * To convert a paragraph to heading 1 when `- ` is typed, using just the callback:
	 *
	 *		new BlockAutoformatEngine( editor, /^\- $/, ( context ) => {
	 *			const { batch, match } = context;
	 *			const headingLevel = match[ 1 ].length;
	 *
	 *			editor.execute( 'heading', {
	 *				batch,
	 *				formatId: `heading${ headingLevel }`
	 *			} );
	 * 		} );
	 *
	 * @param {module:core/editor/editor~Editor} editor The editor instance.
	 * @param {RegExp} pattern The regular expression to execute on just inserted text.
	 * @param {Function|String} callbackOrCommand The callback to execute or the command to run when the text is matched.
	 * In case of providing the callback, it receives the following parameters:
	 * * {module:engine/model/batch~Batch} batch Newly created batch for autoformat changes.
	 * * {Object} match RegExp.exec() result of matching the pattern to inserted text.
	 */
	constructor( editor, pattern, callbackOrCommand ) {
		let callback;

		if ( typeof callbackOrCommand == 'function' ) {
			callback = callbackOrCommand;
		} else {
			// We assume that the actual command name was provided.
			const command = callbackOrCommand;

			callback = context => {
				const { batch } = context;

				// Create new batch for removal and command execution.
				editor.execute( command, { batch } );
			};
		}

		editor.document.on( 'change', ( event, type, changes, batch ) => {
			if ( batch.type == 'transparent' ) {
				return;
			}

			if ( type != 'insert' ) {
				return;
			}

			// Take the first element. Typing shouldn't add more than one element at once.
			// And if it is not typing (e.g. paste), Autoformat should not be fired.
			const value = changes.range.getItems().next().value;

			if ( !( value instanceof __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_textproxy__["a" /* default */] ) ) {
				return;
			}

			const textNode = value.textNode;
			const text = textNode.data;

			// Run matching only on non-empty paragraphs.
			if ( textNode.parent.name !== 'paragraph' || !text ) {
				return;
			}

			const match = pattern.exec( text );

			if ( !match ) {
				return;
			}

			editor.document.enqueueChanges( () => {
				// Create new batch to separate typing batch from the Autoformat changes.
				const fixBatch = editor.document.batch();

				// Matched range.
				const range = __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_range__["a" /* default */].createFromParentsAndOffsets( textNode.parent, 0, textNode.parent, match[ 0 ].length );

				// Remove matched text.
				fixBatch.remove( range );

				callback( { fixBatch, match } );
			} );
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BlockAutoformatEngine;



/***/ }),
/* 483 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_liverange__ = __webpack_require__(152);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module autoformat/inlineautoformatengine
 */



/**
 * The inline autoformatting engine. It allows to format various inline patterns. For example,
 * it can be configured to make "foo" bold when typed `**foo**` (the `**` markers will be removed).
 *
 * The autoformatting operation is integrated with the undo manager,
 * so the autoformatting step can be undone if the user's intention was not to format the text.
 *
 * See the constructors documentation to learn how to create custom inline autoformatters. You can also use
 * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters
 * (lists, headings, bold and italic).
 */
class InlineAutoformatEngine {
	/**
	 * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.
	 *
	 * It formats the matched text by applying the given model attribute or by running the provided formatting callback.
	 * On every change applied to the model the autoformatting engine checks the text on the left of the selection
	 * and executes the provided action if the text matches given criteria (regular expression or callback).
	 *
	 * @param {module:core/editor/editor~Editor} editor The editor instance.
	 * @param {Function|RegExp} testRegexpOrCallback The regular expression or callback to execute on text.
	 * Provided regular expression *must* have three capture groups. The first and the third capture group
	 * should match opening and closing delimiters. The second capture group should match the text to format.
	 *
	 *		// Matches the `**bold text**` pattern.
	 *		// There are three capturing groups:
	 *		// - The first to match the starting `**` delimiter.
	 *		// - The second to match the text to format.
	 *		// - The third to match the ending `**` delimiter.
	 *		new InlineAutoformatEngine( editor, /(\*\*)([^\*]+?)(\*\*)$/g, 'bold' );
	 *
	 * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.
	 * The function should return proper "ranges" to delete and format.
	 *
	 *		{
	 *			remove: [
	 *				[ 0, 1 ],	// Remove the first letter from the given text.
	 *				[ 5, 6 ]	// Remove the 6th letter from the given text.
	 *			],
	 *			format: [
	 *				[ 1, 5 ]	// Format all letters from 2nd to 5th.
	 *			]
	 *		}
	 *
	 * @param {Function|String} attributeOrCallback The name of attribute to apply on matching text or a callback for manual
	 * formatting.
	 *
	 *		// Use attribute name:
	 *		new InlineAutoformatEngine( editor, /(\*\*)([^\*]+?)(\*\*)$/g, 'bold' );
	 *
	 *		// Use formatting callback:
	 *		new InlineAutoformatEngine( editor, /(\*\*)([^\*]+?)(\*\*)$/g, ( batch, validRanges ) => {
	 *			for ( let range of validRanges ) {
	 *				batch.setAttribute( range, command, true );
	 *			}
	 *		} );
	 */
	constructor( editor, testRegexpOrCallback, attributeOrCallback ) {
		let regExp;
		let command;
		let testCallback;
		let formatCallback;

		if ( testRegexpOrCallback instanceof RegExp ) {
			regExp = testRegexpOrCallback;
		} else {
			testCallback = testRegexpOrCallback;
		}

		if ( typeof attributeOrCallback == 'string' ) {
			command = attributeOrCallback;
		} else {
			formatCallback = attributeOrCallback;
		}

		// A test callback run on changed text.
		testCallback = testCallback || ( text => {
			let result;
			const remove = [];
			const format = [];

			while ( ( result = regExp.exec( text ) ) !== null ) {
				// There should be full match and 3 capture groups.
				if ( result && result.length < 4 ) {
					break;
				}

				let {
					index,
					'1': leftDel,
					'2': content,
					'3': rightDel
				} = result;

				// Real matched string - there might be some non-capturing groups so we need to recalculate starting index.
				const found = leftDel + content + rightDel;
				index += result[ 0 ].length - found.length;

				// Start and End offsets of delimiters to remove.
				const delStart = [
					index,
					index + leftDel.length
				];
				const delEnd = [
					index + leftDel.length + content.length,
					index + leftDel.length + content.length + rightDel.length
				];

				remove.push( delStart );
				remove.push( delEnd );

				format.push( [ index + leftDel.length, index + leftDel.length + content.length ] );
			}

			return {
				remove,
				format
			};
		} );

		// A format callback run on matched text.
		formatCallback = formatCallback || ( ( batch, validRanges ) => {
			for ( const range of validRanges ) {
				batch.setAttribute( range, command, true );
			}
		} );

		editor.document.on( 'change', ( evt, type, changes, batch ) => {
			if ( batch.type == 'transparent' ) {
				return;
			}

			if ( type !== 'insert' ) {
				return;
			}

			const selection = editor.document.selection;

			if ( !selection.isCollapsed || !selection.focus || !selection.focus.parent ) {
				return;
			}

			const block = selection.focus.parent;
			const text = getText( block ).slice( 0, selection.focus.offset );
			const ranges = testCallback( text );
			const rangesToFormat = [];

			// Apply format before deleting text.
			ranges.format.forEach( range => {
				if ( range[ 0 ] === undefined || range[ 1 ] === undefined ) {
					return;
				}

				rangesToFormat.push( __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_liverange__["a" /* default */].createFromParentsAndOffsets(
					block, range[ 0 ],
					block, range[ 1 ]
				) );
			} );

			const rangesToRemove = [];

			// Reverse order to not mix the offsets while removing.
			ranges.remove.slice().reverse().forEach( range => {
				if ( range[ 0 ] === undefined || range[ 1 ] === undefined ) {
					return;
				}

				rangesToRemove.push( __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_liverange__["a" /* default */].createFromParentsAndOffsets(
					block, range[ 0 ],
					block, range[ 1 ]
				) );
			} );

			if ( !( rangesToFormat.length && rangesToRemove.length ) ) {
				return;
			}

			editor.document.enqueueChanges( () => {
				// Create new batch to separate typing batch from the Autoformat changes.
				const fixBatch = editor.document.batch();

				const validRanges = editor.document.schema.getValidRanges( rangesToFormat, command );

				// Apply format.
				formatCallback( fixBatch, validRanges );

				// Detach ranges used to apply Autoformat. Prevents memory leaks. #39
				rangesToFormat.forEach( range => range.detach() );

				// Remove delimiters.
				for ( const range of rangesToRemove ) {
					fixBatch.remove( range );

					// Prevents memory leaks.
					// https://github.com/ckeditor/ckeditor5-autoformat/issues/39
					range.detach();
				}
			} );
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = InlineAutoformatEngine;


// Returns whole text from parent element by adding all data from text nodes together.
//
// @private
// @param {module:engine/model/element~Element} element
// @returns {String}
function getText( element ) {
	return Array.from( element.getChildren() ).reduce( ( a, b ) => a + b.data, '' );
}


/***/ }),
/* 484 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__boldengine__ = __webpack_require__(485);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__theme_icons_bold_svg__ = __webpack_require__(486);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__theme_icons_bold_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__theme_icons_bold_svg__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module basic-styles/bold
 */






/**
 * The bold feature. It introduces the Bold button and the <kbd>Ctrl+B</kbd> keystroke.
 *
 * It uses the {@link module:basic-styles/boldengine~BoldEngine bold engine feature}.
 *
 * @extends module:core/plugin~Plugin
 */
class Bold extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_1__boldengine__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Bold';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const t = editor.t;
		const command = editor.commands.get( 'bold' );
		const keystroke = 'CTRL+B';

		// Add bold button to feature components.
		editor.ui.componentFactory.add( 'bold', locale => {
			const view = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__["a" /* default */]( locale );

			view.set( {
				label: t( 'Bold' ),
				icon: __WEBPACK_IMPORTED_MODULE_3__theme_icons_bold_svg___default.a,
				keystroke,
				tooltip: true
			} );

			view.bind( 'isOn', 'isEnabled' ).to( command, 'value', 'isEnabled' );

			// Execute command.
			this.listenTo( view, 'execute', () => editor.execute( 'bold' ) );

			return view;
		} );

		// Set the Ctrl+B keystroke.
		editor.keystrokes.set( keystroke, 'bold' );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Bold;



/***/ }),
/* 485 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__attributecommand__ = __webpack_require__(274);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module basic-styles/boldengine
 */






const BOLD = 'bold';

/**
 * The bold engine feature.
 *
 * It registers the `bold` command and introduces the `bold` attribute in the model which renders to the view
 * as a `<strong>` element.
 *
 * @extends module:core/plugin~Plugin
 */
class BoldEngine extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const data = editor.data;
		const editing = editor.editing;

		// Allow bold attribute on all inline nodes.
		editor.document.schema.allow( { name: '$inline', attributes: BOLD, inside: '$block' } );
		// Temporary workaround. See https://github.com/ckeditor/ckeditor5/issues/477.
		editor.document.schema.allow( { name: '$inline', attributes: BOLD, inside: '$clipboardHolder' } );

		// Build converter from model to view for data and editing pipelines.
		Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__["a" /* default */])().for( data.modelToView, editing.modelToView )
			.fromAttribute( BOLD )
			.toElement( 'strong' );

		// Build converter from view to model for data pipeline.
		Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__["a" /* default */])().for( data.viewToModel )
			.fromElement( 'strong' )
			.fromElement( 'b' )
			.fromAttribute( 'style', { 'font-weight': 'bold' } )
			.toAttribute( BOLD, true );

		// Create bold command.
		editor.commands.add( BOLD, new __WEBPACK_IMPORTED_MODULE_3__attributecommand__["a" /* default */]( editor, BOLD ) );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BoldEngine;



/***/ }),
/* 486 */
/***/ (function(module, exports) {

module.exports = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.135 10.409c.361.248.654.56.88.934.225.375.338.816.338 1.324 0 .609-.128 1.123-.385 1.543-.256.42-.624.751-1.103.994a5.908 5.908 0 0 1-1.755.55c-.663.107-1.442.16-2.338.16H4.539v-.66a22.5 22.5 0 0 0 .66-.076c.265-.033.45-.073.558-.118.208-.085.35-.196.427-.334.076-.138.114-.317.114-.537V5.732c0-.203-.031-.372-.093-.507s-.211-.254-.448-.355a3.326 3.326 0 0 0-.61-.182 14.136 14.136 0 0 0-.608-.114v-.66h6.52c1.64 0 2.825.226 3.552.677.727.45 1.09 1.116 1.09 1.995 0 .406-.08.763-.244 1.07a2.388 2.388 0 0 1-.702.8 4.214 4.214 0 0 1-.99.54c-.383.153-.795.28-1.234.381v.16c.44.046.896.143 1.37.292.473.15.885.343 1.234.58zm-2.723-3.611c0-.665-.187-1.184-.562-1.556-.375-.372-.937-.558-1.687-.558-.107 0-.247.004-.419.012l-.444.021v4.449h.44c.913 0 1.587-.213 2.021-.639.434-.425.651-1.002.651-1.73zm.592 5.759c0-.835-.248-1.475-.744-1.92-.496-.445-1.21-.668-2.14-.668a22.977 22.977 0 0 0-.82.034v4.389c.05.208.209.385.474.528.265.144.586.216.964.216.67 0 1.216-.225 1.636-.676.42-.452.63-1.086.63-1.903z\" fill=\"#454545\" fill-rule=\"evenodd\"/></svg>"

/***/ }),
/* 487 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__italicengine__ = __webpack_require__(488);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__theme_icons_italic_svg__ = __webpack_require__(489);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__theme_icons_italic_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__theme_icons_italic_svg__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module basic-styles/italic
 */






/**
 * The italic feature. It introduces the Italic button and the <kbd>Ctrl+I</kbd> keystroke.
 *
 * It uses the {@link module:basic-styles/italicengine~ItalicEngine italic engine feature}.
 *
 * @extends module:core/plugin~Plugin
 */
class Italic extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_1__italicengine__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Italic';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const t = editor.t;
		const command = editor.commands.get( 'italic' );
		const keystroke = 'CTRL+I';

		// Add bold button to feature components.
		editor.ui.componentFactory.add( 'italic', locale => {
			const view = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__["a" /* default */]( locale );

			view.set( {
				label: t( 'Italic' ),
				icon: __WEBPACK_IMPORTED_MODULE_3__theme_icons_italic_svg___default.a,
				keystroke,
				tooltip: true
			} );

			view.bind( 'isOn', 'isEnabled' ).to( command, 'value', 'isEnabled' );

			// Execute command.
			this.listenTo( view, 'execute', () => editor.execute( 'italic' ) );

			return view;
		} );

		// Set the Ctrl+I keystroke.
		editor.keystrokes.set( keystroke, 'italic' );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Italic;



/***/ }),
/* 488 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__attributecommand__ = __webpack_require__(274);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module basic-styles/italicengine
 */






const ITALIC = 'italic';

/**
 * The italic engine feature.
 *
 * It registers the `italic` command and introduces the `italic` attribute in the model which renders to the view
 * as an `<em>` element.
 *
 * @extends module:core/plugin~Plugin
 */
class ItalicEngine extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const data = editor.data;
		const editing = editor.editing;

		// Allow italic attribute on all inline nodes.
		editor.document.schema.allow( { name: '$inline', attributes: ITALIC, inside: '$block' } );
		// Temporary workaround. See https://github.com/ckeditor/ckeditor5/issues/477.
		editor.document.schema.allow( { name: '$inline', attributes: ITALIC, inside: '$clipboardHolder' } );

		// Build converter from model to view for data and editing pipelines.
		Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__["a" /* default */])().for( data.modelToView, editing.modelToView )
			.fromAttribute( ITALIC )
			.toElement( 'i' );

		// Build converter from view to model for data pipeline.
		Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__["a" /* default */])().for( data.viewToModel )
			.fromElement( 'em' )
			.fromElement( 'i' )
			.fromAttribute( 'style', { 'font-style': 'italic' } )
			.toAttribute( ITALIC, true );

		// Create italic command.
		editor.commands.add( ITALIC, new __WEBPACK_IMPORTED_MODULE_3__attributecommand__["a" /* default */]( editor, ITALIC ) );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ItalicEngine;



/***/ }),
/* 489 */
/***/ (function(module, exports) {

module.exports = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.825 3.914l-.126.558a5.701 5.701 0 0 0-.685.076c-.282.045-.49.088-.626.127-.237.073-.406.186-.508.338a1.586 1.586 0 0 0-.22.5l-2.03 8.769a1.24 1.24 0 0 0-.034.27c.001.13.03.24.086.33.056.09.157.17.304.237.085.04.27.086.558.14.288.053.502.086.643.097l-.127.558H5.656l.127-.558.677-.05c.293-.023.501-.057.625-.102a1.11 1.11 0 0 0 .5-.326c.112-.138.188-.306.228-.503l2.02-8.778a1.428 1.428 0 0 0 .035-.305.59.59 0 0 0-.072-.295c-.048-.085-.148-.161-.3-.229a3.457 3.457 0 0 0-.622-.19 5.001 5.001 0 0 0-.58-.106l.128-.558h5.403z\" fill=\"#454545\" fill-rule=\"evenodd\"/></svg>"

/***/ }),
/* 490 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__blockquoteengine__ = __webpack_require__(491);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_core_theme_icons_quote_svg__ = __webpack_require__(493);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_core_theme_icons_quote_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_core_theme_icons_quote_svg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__theme_theme_scss__ = __webpack_require__(494);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__theme_theme_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__theme_theme_scss__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module block-quote/blockquote
 */









/**
 * The block quote plugin.
 *
 * It introduces the `'blockQuote'` button and requires the {@link module:block-quote/blockquoteengine~BlockQuoteEngine}
 * plugin. It also changes <kbd>Enter</kbd> key behavior so it escapes block quotes when pressed in an
 * empty quoted block.
 *
 * @extends module:core/plugin~Plugin
 */
class BlockQuote extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_1__blockquoteengine__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'BlockQuote';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const t = editor.t;
		const command = editor.commands.get( 'blockQuote' );

		editor.ui.componentFactory.add( 'blockQuote', locale => {
			const buttonView = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__["a" /* default */]( locale );

			buttonView.set( {
				label: t( 'Block quote' ),
				icon: __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_core_theme_icons_quote_svg___default.a,
				tooltip: true
			} );

			// Bind button model to command.
			buttonView.bind( 'isOn', 'isEnabled' ).to( command, 'value', 'isEnabled' );

			// Execute command.
			this.listenTo( buttonView, 'execute', () => editor.execute( 'blockQuote' ) );

			return buttonView;
		} );
	}

	/**
	 * @inheritDoc
	 */
	afterInit() {
		const editor = this.editor;
		const command = editor.commands.get( 'blockQuote' );

		// Overwrite default Enter key behavior.
		// If Enter key is pressed with selection collapsed in empty block inside a quote, break the quote.
		// This listener is added in afterInit in order to register it after list's feature listener.
		// We can't use a priority for this, because 'low' is already used by the enter feature, unless
		// we'd use numeric priority in this case.
		this.listenTo( this.editor.editing.view, 'enter', ( evt, data ) => {
			const doc = this.editor.document;
			const positionParent = doc.selection.getLastPosition().parent;

			if ( doc.selection.isCollapsed && positionParent.isEmpty && command.value ) {
				this.editor.execute( 'blockQuote' );
				this.editor.editing.view.scrollToTheSelection();

				data.preventDefault();
				evt.stop();
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BlockQuote;



/***/ }),
/* 491 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__blockquotecommand__ = __webpack_require__(492);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__ = __webpack_require__(51);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module block-quote/blockquoteengine
 */








/**
 * The block quote engine.
 *
 * Introduces the `'blockQuote'` command and the `'blockQuote'` model element.
 *
 * @extends module:core/plugin~Plugin
 */
class BlockQuoteEngine extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const schema = editor.document.schema;

		editor.commands.add( 'blockQuote', new __WEBPACK_IMPORTED_MODULE_1__blockquotecommand__["a" /* default */]( editor ) );

		schema.registerItem( 'blockQuote' );
		schema.allow( { name: 'blockQuote', inside: '$root' } );
		schema.allow( { name: '$block', inside: 'blockQuote' } );

		Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__["a" /* default */])().for( editor.data.viewToModel )
			.fromElement( 'blockquote' )
			.toElement( 'blockQuote' );

		Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__["a" /* default */])().for( editor.data.modelToView, editor.editing.modelToView )
			.fromElement( 'blockQuote' )
			.toElement( 'blockquote' );
	}

	/**
	 * @inheritDoc
	 */
	afterInit() {
		const schema = this.editor.document.schema;

		// TODO
		// Workaround for https://github.com/ckeditor/ckeditor5-engine/issues/532#issuecomment-280924650.
		if ( schema.hasItem( 'listItem' ) ) {
			schema.allow( {
				name: 'listItem',
				inside: 'blockQuote',
				attributes: [ 'type', 'indent' ]
			} );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BlockQuoteEngine;



/***/ }),
/* 492 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_first__ = __webpack_require__(60);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module block-quote/blockquotecommand
 */








/**
 * The block quote command plugin.
 *
 * @extends module:core/command~Command
 */
class BlockQuoteCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * Whether the selection starts in a block quote.
	 *
	 * @observable
	 * @readonly
	 * @member {Boolean} #value
	 */

	/**
	 * @inheritDoc
	 */
	refresh() {
		this.value = this._getValue();
		this.isEnabled = this._checkEnabled();
	}

	/**
	 * Executes the command. When the command {@link #value is on}, all block quotes within
	 * the selection will be removed. If it is off, all selected blocks will be wrapped with
	 * a block quote.
	 *
	 * @fires execute
	 * @param {Object} [options] Options for executed command.
	 * @param {module:engine/model/batch~Batch} [options.batch] Batch to collect all the change steps.
	 * A new batch will be created if this option is not set.
	 */
	execute( options = {} ) {
		const doc = this.editor.document;
		const schema = doc.schema;
		const batch = options.batch || doc.batch();
		const blocks = Array.from( doc.selection.getSelectedBlocks() );

		doc.enqueueChanges( () => {
			if ( this.value ) {
				this._removeQuote( batch, blocks.filter( findQuote ) );
			} else {
				const blocksToQuote = blocks.filter( block => {
					// Already quoted blocks needs to be considered while quoting too
					// in order to reuse their <bQ> elements.
					return findQuote( block ) || checkCanBeQuoted( schema, block );
				} );

				this._applyQuote( batch, blocksToQuote );
			}
		} );
	}

	/**
	 * Checks the command's {@link #value}.
	 *
	 * @private
	 * @returns {Boolean} The current value.
	 */
	_getValue() {
		const firstBlock = Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_first__["a" /* default */])( this.editor.document.selection.getSelectedBlocks() );

		// In the current implementation, the block quote must be an immediate parent of a block element.
		return !!( firstBlock && findQuote( firstBlock ) );
	}

	/**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @private
	 * @returns {Boolean} Whether the command should be enabled.
	 */
	_checkEnabled() {
		if ( this.value ) {
			return true;
		}

		const selection = this.editor.document.selection;
		const schema = this.editor.document.schema;

		const firstBlock = Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_first__["a" /* default */])( selection.getSelectedBlocks() );

		if ( !firstBlock ) {
			return false;
		}

		return checkCanBeQuoted( schema, firstBlock );
	}

	/**
	 * Removes the quote from given blocks.
	 *
	 * If blocks which are supposed to be "unquoted" are in the middle of a quote,
	 * start it or end it, then the quote will be split (if needed) and the blocks
	 * will be moved out of it, so other quoted blocks remained quoted.
	 *
	 * @private
	 * @param {module:engine/model/batch~Batch} batch
	 * @param {Array.<module:engine/model/element~Element>} blocks
	 */
	_removeQuote( batch, blocks ) {
		// Unquote all groups of block. Iterate in the reverse order to not break following ranges.
		getRangesOfBlockGroups( blocks ).reverse().forEach( groupRange => {
			if ( groupRange.start.isAtStart && groupRange.end.isAtEnd ) {
				batch.unwrap( groupRange.start.parent );

				return;
			}

			// The group of blocks are at the beginning of an <bQ> so let's move them left (out of the <bQ>).
			if ( groupRange.start.isAtStart ) {
				const positionBefore = __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( groupRange.start.parent );

				batch.move( groupRange, positionBefore );

				return;
			}

			// The blocks are in the middle of an <bQ> so we need to split the <bQ> after the last block
			// so we move the items there.
			if ( !groupRange.end.isAtEnd ) {
				batch.split( groupRange.end );
			}

			// Now we are sure that groupRange.end.isAtEnd is true, so let's move the blocks right.

			const positionAfter = __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAfter( groupRange.end.parent );

			batch.move( groupRange, positionAfter );
		} );
	}

	/**
	 * Applies the quote to given blocks.
	 *
	 * @private
	 * @param {module:engine/model/batch~Batch} batch
	 * @param {Array.<module:engine/model/element~Element>} blocks
	 */
	_applyQuote( batch, blocks ) {
		const quotesToMerge = [];

		// Quote all groups of block. Iterate in the reverse order to not break following ranges.
		getRangesOfBlockGroups( blocks ).reverse().forEach( groupRange => {
			let quote = findQuote( groupRange.start );

			if ( !quote ) {
				quote = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */]( 'blockQuote' );

				batch.wrap( groupRange, quote );
			}

			quotesToMerge.push( quote );
		} );

		// Merge subsequent <bQ> elements. Reverse the order again because this time we want to go through
		// the <bQ> elements in the source order (due to how merge works  it moves the right element's content
		// to the first element and removes the right one. Since we may need to merge a couple of subsequent `<bQ>` elements
		// we want to keep the reference to the first (furthest left) one.
		quotesToMerge.reverse().reduce( ( currentQuote, nextQuote ) => {
			if ( currentQuote.nextSibling == nextQuote ) {
				batch.merge( __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAfter( currentQuote ) );

				return currentQuote;
			}

			return nextQuote;
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BlockQuoteCommand;


function findQuote( elementOrPosition ) {
	return elementOrPosition.parent.name == 'blockQuote' ? elementOrPosition.parent : null;
}

// Returns a minimal array of ranges containing groups of subsequent blocks.
//
// content:         abcdefgh
// blocks:          [ a, b, d , f, g, h ]
// output ranges:   [ab]c[d]e[fgh]
//
// @param {Array.<module:engine/model/element~Element>} blocks
// @returns {Array.<module:engine/model/range~Range>}
function getRangesOfBlockGroups( blocks ) {
	let startPosition;
	let i = 0;
	const ranges = [];

	while ( i < blocks.length ) {
		const block = blocks[ i ];
		const nextBlock = blocks[ i + 1 ];

		if ( !startPosition ) {
			startPosition = __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( block );
		}

		if ( !nextBlock || block.nextSibling != nextBlock ) {
			ranges.push( new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_range__["a" /* default */]( startPosition, __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAfter( block ) ) );
			startPosition = null;
		}

		i++;
	}

	return ranges;
}

// Checks whether <bQ> can wrap the block.
function checkCanBeQuoted( schema, block ) {
	const isBQAllowed = schema.check( {
		name: 'blockQuote',
		inside: __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( block )
	} );
	const isBlockAllowedInBQ = schema.check( {
		name: block.name,
		attributes: Array.from( block.getAttributeKeys() ),
		inside: 'blockQuote'
	} );

	return isBQAllowed && isBlockAllowedInBQ;
}


/***/ }),
/* 493 */
/***/ (function(module, exports) {

module.exports = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.061 15.51v-.882c1.395-.847 2.345-1.633 2.85-2.358.37-.533.554-1.162.554-1.887 0-.437-.082-.759-.246-.964-.15-.205-.328-.307-.533-.307-.137 0-.328.048-.574.143-.37.123-.67.185-.902.185-.547 0-1.033-.205-1.456-.615-.424-.41-.636-.923-.636-1.538 0-.698.212-1.238.636-1.62a3.002 3.002 0 0 1 2.05-.78c.93 0 1.757.39 2.482 1.17.724.778 1.087 1.742 1.087 2.89 0 1.614-.602 3.084-1.805 4.41-.807.875-1.976 1.593-3.507 2.153zm-8.386 0v-.882c1.394-.847 2.345-1.633 2.85-2.358.37-.533.554-1.162.554-1.887 0-.437-.082-.759-.246-.964-.15-.205-.328-.307-.533-.307-.137 0-.328.048-.574.143-.37.123-.67.185-.903.185-.547 0-1.032-.205-1.456-.615-.424-.41-.636-.923-.636-1.538 0-.698.212-1.238.636-1.62a3.002 3.002 0 0 1 2.051-.78c.93 0 1.757.39 2.481 1.17.725.778 1.087 1.742 1.087 2.89 0 1.614-.601 3.084-1.804 4.41-.807.875-1.976 1.593-3.507 2.153z\" fill=\"#454545\" fill-rule=\"evenodd\"/></svg>"

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(495);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(32)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss", function() {
		var newContent = require("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(31)(false);
// imports


// module
exports.push([module.i, "blockquote{border-left:5px solid #ccc;padding-left:20px;margin-left:0;font-style:italic;overflow:hidden}", ""]);

// exports


/***/ }),
/* 496 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_paragraph_src_paragraph__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__headingengine__ = __webpack_require__(498);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_model__ = __webpack_require__(500);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_ui_src_dropdown_list_createlistdropdown__ = __webpack_require__(501);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_collection__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__theme_theme_scss__ = __webpack_require__(507);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__theme_theme_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__theme_theme_scss__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module heading/heading
 */










/**
 * The headings feature. It introduces the `headings` drop-down and the `heading1`-`headingN` commands which allow
 * to convert paragraphs into headings.
 *
 * For a detailed overview, check the {@glink features/headings Headings feature documentation}.
 *
 * @extends module:core/plugin~Plugin
 */
class Heading extends __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_paragraph_src_paragraph__["a" /* default */], __WEBPACK_IMPORTED_MODULE_1__headingengine__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Heading';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const dropdownItems = new __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_utils_src_collection__["a" /* default */]();
		const options = this._getLocalizedOptions();
		const commands = [];
		const t = editor.t;
		const defaultTitle = t( 'Choose heading' );
		const dropdownTooltip = t( 'Heading' );

		for ( const option of options ) {
			const command = editor.commands.get( option.modelElement );
			const itemModel = new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_model__["a" /* default */]( {
				commandName: option.modelElement,
				label: option.title,
				class: option.class
			} );

			itemModel.bind( 'isActive' ).to( command, 'value' );

			// Add the option to the collection.
			dropdownItems.add( itemModel );

			commands.push( command );
		}

		// Create dropdown model.
		const dropdownModel = new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_model__["a" /* default */]( {
			withText: true,
			items: dropdownItems,
			tooltip: dropdownTooltip
		} );

		dropdownModel.bind( 'isEnabled' ).to(
			// Bind to #isEnabled of each command...
			...getCommandsBindingTargets( commands, 'isEnabled' ),
			// ...and set it true if any command #isEnabled is true.
			( ...areEnabled ) => areEnabled.some( isEnabled => isEnabled )
		);

		dropdownModel.bind( 'label' ).to(
			// Bind to #value of each command...
			...getCommandsBindingTargets( commands, 'value' ),
			// ...and chose the title of the first one which #value is true.
			( ...areActive ) => {
				const index = areActive.findIndex( value => value );

				// If none of the commands is active, display default title.
				return options[ index ] ? options[ index ].title : defaultTitle;
			}
		);

		// Register UI component.
		editor.ui.componentFactory.add( 'headings', locale => {
			const dropdown = Object(__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_ui_src_dropdown_list_createlistdropdown__["a" /* default */])( dropdownModel, locale );

			dropdown.extendTemplate( {
				attributes: {
					class: [
						'ck-heading-dropdown'
					]
				}
			} );

			// Execute command when an item from the dropdown is selected.
			this.listenTo( dropdown, 'execute', evt => {
				editor.execute( evt.source.commandName );
				editor.editing.view.focus();
			} );

			return dropdown;
		} );
	}

	/**
	 * Returns heading options as defined in `config.heading.options` but processed to consider
	 * editor localization, i.e. to display {@link module:heading/heading~HeadingOption}
	 * in the correct language.
	 *
	 * Note: The reason behind this method is that there's no way to use {@link module:utils/locale~Locale#t}
	 * when the user config is defined because the editor does not exist yet.
	 *
	 * @private
	 * @returns {Array.<module:heading/heading~HeadingOption>}.
	 */
	_getLocalizedOptions() {
		const editor = this.editor;
		const t = editor.t;
		const localizedTitles = {
			Paragraph: t( 'Paragraph' ),
			'Heading 1': t( 'Heading 1' ),
			'Heading 2': t( 'Heading 2' ),
			'Heading 3': t( 'Heading 3' )
		};

		return editor.config.get( 'heading.options' ).map( option => {
			const title = localizedTitles[ option.title ];

			if ( title && title != option.title ) {
				// Clone the option to avoid altering the original `config.heading.options`.
				option = Object.assign( {}, option, { title } );
			}

			return option;
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Heading;


// Returns an array of binding components for
// {@link module:utils/observablemixin~Observable#bind} from a set of iterable
// commands.
//
// @private
// @param {Iterable.<module:core/command~Command>} commands
// @param {String} attribute
// @returns {Array.<String>}
function getCommandsBindingTargets( commands, attribute ) {
	return Array.prototype.concat( ...commands.map( c => [ c, attribute ] ) );
}

/**
 * Heading option descriptor.
 *
 * @typedef {Object} module:heading/heading~HeadingOption
 * @property {String} modelElement Element's name in the model.
 * @property {String} viewElement The name of the view element that will be used to represent the model element in the view.
 * @property {String} title The user-readable title of the option.
 * @property {String} class The class which will be added to the dropdown item representing this option.
 */

/**
 * The configuration of the heading feature. Introduced by the {@link module:heading/headingengine~HeadingEngine} feature.
 *
 * Read more in {@link module:heading/heading~HeadingConfig}.
 *
 * @member {module:heading/heading~HeadingConfig} module:core/editor/editorconfig~EditorConfig#heading
 */

/**
 * The configuration of the heading feature.
 * The option is used by the {@link module:heading/headingengine~HeadingEngine} feature.
 *
 *		ClassicEditor
 *			.create( {
 * 				heading: ... // Heading feature config.
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface HeadingConfig
 */

/**
 * The available heading options.
 *
 * The default value is:
 *
 *		const headingConfig = {
 *			options: [
 *				{ modelElement: 'paragraph', title: 'Paragraph', class: 'ck-heading_paragraph' },
 *				{ modelElement: 'heading1', viewElement: 'h2', title: 'Heading 1', class: 'ck-heading_heading1' },
 *				{ modelElement: 'heading2', viewElement: 'h3', title: 'Heading 2', class: 'ck-heading_heading2' },
 *				{ modelElement: 'heading3', viewElement: 'h4', title: 'Heading 3', class: 'ck-heading_heading3' }
 *			]
 *		};
 *
 * It defines 3 levels of headings. In the editor model they will use `heading1`, `heading2`, and `heading3` elements.
 * Their respective view elements (so the elements output by the editor) will be: `h2`, `h3`, and `h4`. This means that
 * if you choose "Heading 1" in the headings dropdown the editor will turn the current block to `<heading1>` in the model
 * which will result in rendering (and outputting to data) the `<h2>` element.
 *
 * The `title` and `class` properties will be used by the `headings` dropdown to render available options.
 * Usually, the first option in the headings dropdown is the "Paragraph" option, hence it's also defined on the list.
 * However, you don't need to define its view representation because it's handled by
 * the {@link module:paragraph/paragraph~Paragraph} feature (which is required by
 * the {@link module:heading/headingengine~HeadingEngine} feature).
 *
 * Note: In the model you should always start from `heading1`, regardless of how the headings are represented in the view.
 * That's assumption is used by features like {@link module:autoformat/autoformat~Autoformat} to know which element
 * they should use when applying the first level heading.
 *
 * The defined headings are also available in {@link module:core/commandcollection~CommandCollection} under their model names.
 * For example, the below code will apply `<heading1>` to the current selection:
 *
 *		editor.execute( 'heading1' );
 *
 * @member {Array.<module:heading/heading~HeadingOption>} module:heading/heading~HeadingConfig#options
 */


/***/ }),
/* 497 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_first__ = __webpack_require__(60);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module paragraph/paragraphcommand
 */





/**
 * The paragraph command.
 *
 * @extends module:core/command~Command
 */
class ParagraphCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * The value of the command. Indicates whether the selection start is placed in a paragraph.
	 *
	 * @readonly
	 * @observable
	 * @member {Boolean} #value
	 */

	/**
	 * @inheritDoc
	 */
	refresh() {
		const document = this.editor.document;
		const block = Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_first__["a" /* default */])( document.selection.getSelectedBlocks() );

		this.value = !!block && block.is( 'paragraph' );
		this.isEnabled = !!block && checkCanBecomeParagraph( block, document.schema );
	}

	/**
	 * Executes the command. All the blocks (see {@link module:engine/model/schema~Schema}) in the selection
	 * will be turned to paragraphs.
	 *
	 * @fires execute
	 * @param {Object} [options] Options for the executed command.
	 * @param {module:engine/model/batch~Batch} [options.batch] A batch to collect all the change steps.
	 * A new batch will be created if this option is not set.
	 * @param {module:engine/model/selection~Selection} [options.selection] The selection that the command should be applied to.
	 * By default, if not provided, the command is applied to the {@link module:engine/model/document~Document#selection}.
	 */
	execute( options = {} ) {
		const document = this.editor.document;

		document.enqueueChanges( () => {
			const batch = options.batch || document.batch();
			const blocks = ( options.selection || document.selection ).getSelectedBlocks();

			for ( const block of blocks ) {
				if ( !block.is( 'paragraph' ) && checkCanBecomeParagraph( block, document.schema ) ) {
					batch.rename( block, 'paragraph' );
				}
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ParagraphCommand;


// Checks whether the given block can be replaced by a paragraph.
//
// @private
// @param {module:engine/model/element~Element} block A block to be tested.
// @param {module:engine/model/schema~Schema} schema The schema of the document.
// @returns {Boolean}
function checkCanBecomeParagraph( block, schema ) {
	return schema.check( {
		name: 'paragraph',
		inside: __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( block )
	} );
}


/***/ }),
/* 498 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_paragraph_src_paragraph__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__headingcommand__ = __webpack_require__(499);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module heading/headingengine
 */







const defaultModelElement = 'paragraph';

/**
 * The headings engine feature. It handles switching between block formats &ndash; headings and paragraph.
 * This class represents the engine part of the heading feature. See also {@link module:heading/heading~Heading}.
 *
 * @extends module:core/plugin~Plugin
 */
class HeadingEngine extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( editor ) {
		super( editor );

		editor.config.define( 'heading', {
			options: [
				{ modelElement: 'paragraph', title: 'Paragraph', class: 'ck-heading_paragraph' },
				{ modelElement: 'heading1', viewElement: 'h2', title: 'Heading 1', class: 'ck-heading_heading1' },
				{ modelElement: 'heading2', viewElement: 'h3', title: 'Heading 2', class: 'ck-heading_heading2' },
				{ modelElement: 'heading3', viewElement: 'h4', title: 'Heading 3', class: 'ck-heading_heading3' }
			]
		} );
	}

	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_paragraph_src_paragraph__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const data = editor.data;
		const editing = editor.editing;
		const options = editor.config.get( 'heading.options' );

		for ( const option of options ) {
			// Skip paragraph - it is defined in required Paragraph feature.
			if ( option.modelElement !== defaultModelElement ) {
				// Schema.
				editor.document.schema.registerItem( option.modelElement, '$block' );

				// Build converter from model to view for data and editing pipelines.
				Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__["a" /* default */])().for( data.modelToView, editing.modelToView )
					.fromElement( option.modelElement )
					.toElement( option.viewElement );

				// Build converter from view to model for data pipeline.
				Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__["a" /* default */])().for( data.viewToModel )
					.fromElement( option.viewElement )
					.toElement( option.modelElement );

				// Register the heading command for this option.
				editor.commands.add( option.modelElement, new __WEBPACK_IMPORTED_MODULE_4__headingcommand__["a" /* default */]( editor, option.modelElement ) );
			}
		}
	}

	/**
	 * @inheritDoc
	 */
	afterInit() {
		// If the enter command is added to the editor, alter its behavior.
		// Enter at the end of a heading element should create a paragraph.
		const editor = this.editor;
		const enterCommand = editor.commands.get( 'enter' );
		const options = editor.config.get( 'heading.options' );

		if ( enterCommand ) {
			this.listenTo( enterCommand, 'afterExecute', ( evt, data ) => {
				const positionParent = editor.document.selection.getFirstPosition().parent;
				const batch = data.batch;
				const isHeading = options.some( option => positionParent.is( option.modelElement ) );

				if ( isHeading && !positionParent.is( defaultModelElement ) && positionParent.childCount === 0 ) {
					batch.rename( positionParent, defaultModelElement );
				}
			} );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = HeadingEngine;



/***/ }),
/* 499 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_first__ = __webpack_require__(60);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module heading/headingcommand
 */





/**
 * The heading command. It is used by the {@link module:heading/heading~Heading heading feature} to apply headings.
 *
 * @extends module:core/command~Command
 */
class HeadingCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * Creates an instance of the command.
	 *
	 * @param {module:core/editor/editor~Editor} editor Editor instance.
	 * @param {String} modelElement Name of the element which this command will apply in the model.
	 */
	constructor( editor, modelElement ) {
		super( editor );

		/**
		 * Whether the selection starts in a heading of {@link #modelElement this level}.
		 *
		 * @observable
		 * @readonly
		 * @member {Boolean} #value
		 */

		/**
		 * Unique identifier of the command, also element's name in the model.
		 * See {@link module:heading/heading~HeadingOption}.
		 *
		 * @readonly
		 * @member {String}
		 */
		this.modelElement = modelElement;
	}

	/**
	 * @inheritDoc
	 */
	refresh() {
		const block = Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_first__["a" /* default */])( this.editor.document.selection.getSelectedBlocks() );

		this.value = !!block && block.is( this.modelElement );
		this.isEnabled = !!block && checkCanBecomeHeading( block, this.modelElement, this.editor.document.schema );
	}

	/**
	 * Executes the command. Applies the heading to the selected blocks or, if the first selected
	 * block is a heading already, turns selected headings (of this level only) to paragraphs.
	 *
	 * @fires execute
	 * @param {Object} [options] Options for executed command.
	 * @param {module:engine/model/batch~Batch} [options.batch] Batch to collect all the change steps.
	 * New batch will be created if this option is not set.
	 */
	execute( options = {} ) {
		const editor = this.editor;
		const document = editor.document;

		document.enqueueChanges( () => {
			const batch = options.batch || document.batch();
			const blocks = Array.from( document.selection.getSelectedBlocks() )
				.filter( block => {
					return checkCanBecomeHeading( block, this.modelElement, document.schema );
				} );

			for ( const block of blocks ) {
				if ( !block.is( this.modelElement ) ) {
					batch.rename( block, this.modelElement );
				}
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = HeadingCommand;


// Checks whether the given block can be replaced by a specific heading.
//
// @private
// @param {module:engine/model/element~Element} block A block to be tested.
// @param {module:heading/headingcommand~HeadingCommand#modelElement} heading Command element name in the model.
// @param {module:engine/model/schema~Schema} schema The schema of the document.
// @returns {Boolean}
function checkCanBecomeHeading( block, heading, schema ) {
	return schema.check( {
		name: heading,
		inside: __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( block )
	} );
}


/***/ }),
/* 500 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_extend__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_observablemixin__ = __webpack_require__(15);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/model
 */





/**
 * The base MVC model class.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */
class Model {
	/**
	 * Creates a new Model instance.
	 *
	 * @param {Object} [attributes] The model state attributes to be defined during the instance creation.
	 * @param {Object} [properties] The (out of state) properties to be appended to the instance during creation.
	 */
	constructor( attributes, properties ) {
		// Extend this instance with the additional (out of state) properties.
		if ( properties ) {
			Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_extend__["a" /* default */])( this, properties );
		}

		// Initialize the attributes.
		if ( attributes ) {
			this.set( attributes );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Model;


Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( Model, __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_observablemixin__["a" /* default */] );


/***/ }),
/* 501 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createListDropdown;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__list_listview__ = __webpack_require__(502);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__list_listitemview__ = __webpack_require__(503);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__createdropdown__ = __webpack_require__(504);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/dropdown/list/createlistdropdown
 */

/* global document */





/**
 * Creates an instance of {@link module:ui/dropdown/list/listdropdownview~ListDropdownView} class using
 * a provided {@link module:ui/dropdown/list/listdropdownmodel~ListDropdownModel}.
 *
 *		const items = new Collection();
 *
 *		items.add( new Model( { label: 'First item', style: 'color: red' } ) );
 *		items.add( new Model( { label: 'Second item', style: 'color: green', class: 'foo' } ) );
 *
 *		const model = new Model( {
 *			isEnabled: true,
 *			items,
 *			isOn: false,
 *			label: 'A dropdown'
 *		} );
 *
 *		const dropdown = createListDropdown( model, locale );
 *
 *		// Will render a dropdown labeled "A dropdown" with a list in the panel
 *		// containing two items.
 *		dropdown.render()
 *		document.body.appendChild( dropdown.element );
 *
 * The model instance remains in control of the dropdown after it has been created. E.g. changes to the
 * {@link module:ui/dropdown/dropdownmodel~DropdownModel#label `model.label`} will be reflected in the
 * dropdown button's {@link module:ui/button/buttonview~ButtonView#label} attribute and in DOM.
 *
 * The
 * {@link module:ui/dropdown/list/listdropdownmodel~ListDropdownModel#items items collection}
 * of the {@link module:ui/dropdown/list/listdropdownmodel~ListDropdownModel model} also controls the
 * presence and attributes of respective {@link module:ui/list/listitemview~ListItemView list items}.
 *
 * See {@link module:ui/dropdown/createdropdown~createDropdown} and {@link module:list/list~List}.
 *
 * @param {module:ui/dropdown/list/listdropdownmodel~ListDropdownModel} model Model of the list dropdown.
 * @param {module:utils/locale~Locale} locale The locale instance.
 * @returns {module:ui/dropdown/list/listdropdownview~ListDropdownView} The list dropdown view instance.
 */
function createListDropdown( model, locale ) {
	const dropdownView = Object(__WEBPACK_IMPORTED_MODULE_2__createdropdown__["a" /* default */])( model, locale );
	const listView = dropdownView.listView = new __WEBPACK_IMPORTED_MODULE_0__list_listview__["a" /* default */]( locale );

	listView.items.bindTo( model.items ).using( itemModel => {
		const item = new __WEBPACK_IMPORTED_MODULE_1__list_listitemview__["a" /* default */]( locale );

		// Bind all attributes of the model to the item view.
		item.bind( ...Object.keys( itemModel ) ).to( itemModel );

		return item;
	} );

	// TODO: Delegate all events instead of just execute.
	listView.items.delegate( 'execute' ).to( dropdownView );

	dropdownView.panelView.children.add( listView );

	dropdownView.on( 'change:isOpen', ( evt, name, value ) => {
		if ( value ) {
			attachDocumentClickListener( dropdownView );
		} else {
			dropdownView.stopListening( document );
		}
	} );

	// Close the dropdown when one of the list items has been executed.
	dropdownView.on( 'execute', () => {
		dropdownView.isOpen = false;
	} );

	// If the dropdown panel is already open, the arrow down key should
	// focus the first element in list.
	dropdownView.keystrokes.set( 'arrowdown', ( data, cancel ) => {
		if ( dropdownView.isOpen ) {
			listView.focus();
			cancel();
		}
	} );

	// If the dropdown panel is already open, the arrow up key should
	// focus the last element in the list.
	dropdownView.keystrokes.set( 'arrowup', ( data, cancel ) => {
		if ( dropdownView.isOpen ) {
			listView.focusLast();
			cancel();
		}
	} );

	return dropdownView;
}

// Attaches a "click" listener in DOM to check if any element outside
// the dropdown has been clicked.
//
// @private
// @param {module:ui/dropdown/listdropdownview~ListDropdownView} dropdownView
function attachDocumentClickListener( dropdownView ) {
	// TODO: It will probably be focus/blur-based rather than click. It should be bound
	// to focusmanager of some sort.
	dropdownView.listenTo( document, 'click', ( evtInfo, { target: domEvtTarget } ) => {
		// Collapse the dropdown when the webpage outside of the component is clicked.
		if ( dropdownView.element != domEvtTarget && !dropdownView.element.contains( domEvtTarget ) ) {
			dropdownView.isOpen = false;
		}
	} );
}


/***/ }),
/* 502 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_focustracker__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__focuscycler__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_keystrokehandler__ = __webpack_require__(49);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/list/listview
 */






/**
 * The list view class.
 *
 * @extends module:ui/view~View
 */
class ListView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor() {
		super();

		/**
		 * Collection of the child list views.
		 *
		 * @readonly
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this.items = this.createCollection();

		/**
		 * Tracks information about DOM focus in the list.
		 *
		 * @readonly
		 * @member {module:utils/focustracker~FocusTracker}
		 */
		this.focusTracker = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_focustracker__["a" /* default */]();

		/**
		 * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
		 *
		 * @readonly
		 * @member {module:utils/keystrokehandler~KeystrokeHandler}
		 */
		this.keystrokes = new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_utils_src_keystrokehandler__["a" /* default */]();

		/**
		 * Helps cycling over focusable {@link #items} in the list.
		 *
		 * @readonly
		 * @protected
		 * @member {module:ui/focuscycler~FocusCycler}
		 */
		this._focusCycler = new __WEBPACK_IMPORTED_MODULE_2__focuscycler__["a" /* default */]( {
			focusables: this.items,
			focusTracker: this.focusTracker,
			keystrokeHandler: this.keystrokes,
			actions: {
				// Navigate list items backwards using the arrowup key.
				focusPrevious: 'arrowup',

				// Navigate toolbar items forwards using the arrowdown key.
				focusNext: 'arrowdown',
			}
		} );

		this.setTemplate( {
			tag: 'ul',

			attributes: {
				class: [
					'ck-reset',
					'ck-list'
				]
			},

			children: this.items
		} );
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		// Items added before rendering should be known to the #focusTracker.
		for ( const item of this.items ) {
			this.focusTracker.add( item.element );
		}

		this.items.on( 'add', ( evt, item ) => {
			this.focusTracker.add( item.element );
		} );

		this.items.on( 'remove', ( evt, item ) => {
			this.focusTracker.remove( item.element );
		} );

		// Start listening for the keystrokes coming from #element.
		this.keystrokes.listenTo( this.element );
	}

	/**
	 * Focuses the first focusable in {@link #items}.
	 */
	focus() {
		this._focusCycler.focusFirst();
	}

	/**
	 * Focuses the last focusable in {@link #items}.
	 */
	focusLast() {
		this._focusCycler.focusLast();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ListView;



/***/ }),
/* 503 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_keystrokehandler__ = __webpack_require__(49);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/list/listitemview
 */




/**
 * The list item view class.
 *
 * @extends module:ui/view~View
 */
class ListItemView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor() {
		super();

		/**
		 * Controls the `tabindex` attribute of the item.
		 *
		 * @observable
		 * @default -1
		 * @member {String} #tabindex
		 */
		this.set( 'tabindex', -1 );

		/**
		 * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
		 *
		 * @readonly
		 * @member {module:utils/keystrokehandler~KeystrokeHandler}
		 */
		this.keystrokes = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_keystrokehandler__["a" /* default */]();

		const bind = this.bindTemplate;

		this.setTemplate( {
			tag: 'li',

			attributes: {
				class: [
					'ck-list__item',
					bind.to( 'class' ),
					bind.if( 'isActive', 'ck-list__item_active' )
				],
				style: bind.to( 'style' ),
				tabindex: bind.to( 'tabindex' )
			},

			children: [
				{
					text: bind.to( 'label' )
				}
			],

			on: {
				click: bind.to( 'execute' )
			}
		} );

		/**
		 * The label of the list item.
		 *
		 * @observable
		 * @member {String} #label
		 */

		/**
		 * (Optional) The DOM style attribute of the list item.
		 *
		 * @observable
		 * @member {String} #style
		 */

		/**
		 * (Optional) The additional class set on the {@link #element}.
		 *
		 * @observable
		 * @member {String} #class
		 */

		/**
		 * (Optional) When set, it marks the item as active among the others.
		 *
		 * @observable
		 * @member {Boolean} #isActive
		 */

		/**
		 * Fired when the list item has been clicked.
		 *
		 * @event execute
		 */
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		const onKeystrokePress = ( data, cancel ) => {
			this.fire( 'execute' );
			cancel();
		};

		this.keystrokes.listenTo( this.element );

		// Execute on Enter and Space key press.
		this.keystrokes.set( 'Enter', onKeystrokePress );
		this.keystrokes.set( 'Space', onKeystrokePress );
	}

	/**
	 * Focuses the list item.
	 */
	focus() {
		this.element.focus();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ListItemView;



/***/ }),
/* 504 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createDropdown;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__button_buttonview__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dropdownview__ = __webpack_require__(505);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dropdownpanelview__ = __webpack_require__(506);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/dropdown/createdropdown
 */





/**
 * A helper which creates an instance of {@link module:ui/dropdown/dropdownview~DropdownView} class using
 * a provided {@link module:ui/dropdown/dropdownmodel~DropdownModel}.
 *
 *		const model = new Model( {
 *			label: 'A dropdown',
 *			isEnabled: true,
 *			isOn: false,
 *			withText: true
 *		} );
 *
 *		const dropdown = createDropdown( model );
 *
 *		dropdown.render();
 *
 *		// Will render a dropdown labeled "A dropdown" with an empty panel.
 *		document.body.appendChild( dropdown.element );
 *
 * The model instance remains in control of the dropdown after it has been created. E.g. changes to the
 * {@link module:ui/dropdown/dropdownmodel~DropdownModel#label `model.label`} will be reflected in the
 * dropdown button's {@link module:ui/button/buttonview~ButtonView#label} attribute and in DOM.
 *
 * Also see {@link module:ui/dropdown/list/createlistdropdown~createListDropdown}.
 *
 * @param {module:ui/dropdown/dropdownmodel~DropdownModel} model Model of this dropdown.
 * @param {module:utils/locale~Locale} locale The locale instance.
 * @returns {module:ui/dropdown/dropdownview~DropdownView} The dropdown view instance.
 */
function createDropdown( model, locale ) {
	const buttonView = new __WEBPACK_IMPORTED_MODULE_0__button_buttonview__["a" /* default */]( locale );
	buttonView.bind( 'label', 'isOn', 'isEnabled', 'withText', 'keystroke', 'tooltip' ).to( model );

	const panelView = new __WEBPACK_IMPORTED_MODULE_2__dropdownpanelview__["a" /* default */]( locale );

	return new __WEBPACK_IMPORTED_MODULE_1__dropdownview__["a" /* default */]( locale, buttonView, panelView );
}


/***/ }),
/* 505 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_focustracker__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keystrokehandler__ = __webpack_require__(49);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/dropdown/dropdownview
 */





/**
 * The dropdown view class.
 *
 *		const button = new ButtonView( locale );
 *		const panel = new DropdownPanelView( locale );
 *		const dropdown = new DropdownView( locale, button, panel );
 *
 *		panel.element.textContent = 'Content of the panel';
 *		button.set( {
 *			label: 'A dropdown',
 *			withText: true
 *		} );
 *
 *		dropdown.render();
 *
 *		// Will render a dropdown with a panel containing a "Content of the panel" text.
 *		document.body.appendChild( dropdown.element );
 *
 * Also see {@link module:ui/dropdown/createdropdown~createDropdown} and
 * {@link module:ui/dropdown/list/createlistdropdown~createListDropdown} to learn about different
 * dropdown creation helpers.
 *
 * @extends module:ui/view~View
 */
class DropdownView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale, buttonView, panelView ) {
		super( locale );

		// Extend button's template before it's registered as a child of the dropdown because
		// by doing so, its #element is rendered and any postrender template extension will
		// not be reflected in DOM.
		buttonView.extendTemplate( {
			attributes: {
				class: [
					'ck-dropdown__button'
				]
			}
		} );

		/**
		 * Button of the dropdown view. Clicking the button opens the {@link #panelView}.
		 *
		 * @readonly
		 * @member {module:ui/button/buttonview~ButtonView} #buttonView
		 */
		this.buttonView = buttonView;

		/**
		 * Panel of the dropdown. It opens when the {@link #buttonView} is
		 * {@link module:ui/button/buttonview~ButtonView#event:execute executed} (i.e. clicked).
		 *
		 * Child views can be added to the panel's `children` collection:
		 *
		 *		dropdown.panelView.children.add( childView );
		 *
		 * See {@link module:ui/dropdown/dropdownpanelview~DropdownPanelView#children} and
		 * {@link module:ui/viewcollection~ViewCollection#add}.
		 *
		 * @readonly
		 * @member {module:ui/dropdown/dropdownpanelview~DropdownPanelView} #panelView
		 */
		this.panelView = panelView;

		/**
		 * Controls whether the dropdown view is open, i.e. shows or hides the {@link #panelView panel}.
		 *
		 * @observable
		 * @member {Boolean} #isOpen
		 */
		this.set( 'isOpen', false );

		/**
		 * Tracks information about DOM focus in the dropdown.
		 *
		 * @readonly
		 * @member {module:utils/focustracker~FocusTracker}
		 */
		this.focusTracker = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_focustracker__["a" /* default */]();

		/**
		 * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
		 * keystrokes of the dropdown:
		 *
		 * * <kbd></kbd> opens the dropdown,
		 * * <kbd></kbd> and <kbd>Esc</kbd> closes the dropdown.
		 *
		 * @readonly
		 * @member {module:utils/keystrokehandler~KeystrokeHandler}
		 */
		this.keystrokes = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_keystrokehandler__["a" /* default */]();

		this.setTemplate( {
			tag: 'div',

			attributes: {
				class: [
					'ck-dropdown'
				]
			},

			children: [
				buttonView,
				panelView
			]
		} );
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		// Toggle the the dropdown when it's button has been clicked.
		this.listenTo( this.buttonView, 'execute', () => {
			this.isOpen = !this.isOpen;
		} );

		// Toggle the visibility of the panel when the dropdown becomes open.
		this.panelView.bind( 'isVisible' ).to( this, 'isOpen' );

		// Listen for keystrokes coming from within #element.
		this.keystrokes.listenTo( this.element );

		// Register #element in the focus tracker.
		this.focusTracker.add( this.element );

		const closeDropdown = ( data, cancel ) => {
			if ( this.isOpen ) {
				this.buttonView.focus();
				this.isOpen = false;
				cancel();
			}
		};

		// Open the dropdown panel using the arrow down key, just like with return or space.
		this.keystrokes.set( 'arrowdown', ( data, cancel ) => {
			// Don't open if the dropdown is disabled or already open.
			if ( this.buttonView.isEnabled && !this.isOpen ) {
				this.isOpen = true;
				cancel();
			}
		} );

		// Block the right arrow key (until nested dropdowns are implemented).
		this.keystrokes.set( 'arrowright', ( data, cancel ) => {
			if ( this.isOpen ) {
				cancel();
			}
		} );

		// Close the dropdown using the arrow left/escape key.
		this.keystrokes.set( 'arrowleft', closeDropdown );
		this.keystrokes.set( 'esc', closeDropdown );
	}

	/**
	 * Focuses the {@link #buttonView}.
	 */
	focus() {
		this.buttonView.focus();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DropdownView;



/***/ }),
/* 506 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/dropdown/dropdownpanelview
 */



/**
 * The dropdown panel view class.
 *
 * See {@link module:ui/dropdown/dropdownview~DropdownView} to learn about the common usage.
 *
 * @extends module:ui/view~View
 */
class DropdownPanelView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		const bind = this.bindTemplate;

		/**
		 * Controls whether the panel is visible.
		 *
		 * @observable
		 * @member {Boolean} #isVisible
		 */
		this.set( 'isVisible', false );

		/**
		 * Collection of the child views in this panel.
		 *
		 * A common child type is the {@link module:list/list~List}. See
		 * {@link module:ui/dropdown/list/createlistdropdown~createListDropdown} to learn more
		 * about list dropdowns.
		 *
		 * @readonly
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this.children = this.createCollection();

		this.setTemplate( {
			tag: 'div',

			attributes: {
				class: [
					'ck-reset',
					'ck-dropdown__panel',
					bind.if( 'isVisible', 'ck-dropdown__panel-visible' )
				]
			},

			children: this.children,

			on: {
				// Drag and drop in the panel should not break the selection in the editor.
				// https://github.com/ckeditor/ckeditor5-ui/issues/228
				selectstart: bind.to( evt => evt.preventDefault() )
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DropdownPanelView;



/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(508);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(32)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss", function() {
		var newContent = require("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(31)(false);
// imports


// module
exports.push([module.i, ".ck-heading_heading1{font-size:1.5em}.ck-heading_heading2{font-size:1.3em}.ck-heading_heading3{font-size:1.1em}[class*=ck-heading_]{line-height:21.6px;padding:9.6px}[class*=ck-heading_heading]{font-weight:700}.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}", ""]);

// exports


/***/ }),
/* 509 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__image_imageengine__ = __webpack_require__(275);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_widget_src_widget__ = __webpack_require__(512);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__imagetextalternative__ = __webpack_require__(516);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__image_utils__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__theme_theme_scss__ = __webpack_require__(524);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__theme_theme_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__theme_theme_scss__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/image
 */









/**
 * The image plugin.
 *
 * Uses the {@link module:image/image/imageengine~ImageEngine}.
 *
 * @extends module:core/plugin~Plugin
 */
class Image extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_1__image_imageengine__["a" /* default */], __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_widget_src_widget__["a" /* default */], __WEBPACK_IMPORTED_MODULE_3__imagetextalternative__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Image';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const contextualToolbar = editor.plugins.get( 'ContextualToolbar' );

		// If `ContextualToolbar` plugin is loaded, it should be disabled for images
		// which have their own toolbar to avoid duplication.
		// https://github.com/ckeditor/ckeditor5-image/issues/110
		if ( contextualToolbar ) {
			this.listenTo( contextualToolbar, 'show', evt => {
				if ( Object(__WEBPACK_IMPORTED_MODULE_4__image_utils__["b" /* isImageWidgetSelected */])( editor.editing.view.selection ) ) {
					evt.stop();
				}
			}, { priority: 'high' } );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Image;


/**
 * The configuration of the image features. Used by the image features in `@ckeditor/ckeditor5-image` package.
 *
 * Read more in {@link module:image/image~ImageConfig}.
 *
 * @member {module:image/image~ImageConfig} module:core/editor/editorconfig~EditorConfig#image
 */

/**
 * The configuration of the image features. Used by the image features in `@ckeditor/ckeditor5-image` package.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 * 				image: ... // Image feature options.
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface ImageConfig
 */


/***/ }),
/* 510 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = viewFigureToModel;
/* harmony export (immutable) */ __webpack_exports__["b"] = createImageAttributeConverter;
/* harmony export (immutable) */ __webpack_exports__["d"] = srcsetAttributeConverter;
/* harmony export (immutable) */ __webpack_exports__["a"] = convertHoistableImage;
/* harmony export (immutable) */ __webpack_exports__["c"] = hoistImageThroughElement;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_documentfragment__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_writer__ = __webpack_require__(22);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/image/converters
 */





/**
 * Returns a function that converts the image view representation:
 *
 *		<figure class="image"><img src="..." alt="..."></img></figure>
 *
 * to the model representation:
 *
 *		<image src="..." alt="..."></image>
 *
 * The entire content of the `<figure>` element except the first `<img>` is being converted as children
 * of the `<image>` model element.
 *
 * @returns {Function}
 */
function viewFigureToModel() {
	return ( evt, data, consumable, conversionApi ) => {
		// Do not convert if this is not an "image figure".
		if ( !consumable.test( data.input, { name: true, class: 'image' } ) ) {
			return;
		}

		// Do not convert if image cannot be placed in model at this context.
		if ( !conversionApi.schema.check( { name: 'image', inside: data.context, attributes: 'src' } ) ) {
			return;
		}

		// Find an image element inside the figure element.
		const viewImage = Array.from( data.input.getChildren() ).find( viewChild => viewChild.is( 'img' ) );

		// Do not convert if image element is absent, is missing src attribute or was already converted.
		if ( !viewImage || !viewImage.hasAttribute( 'src' ) || !consumable.test( viewImage, { name: true } ) ) {
			return;
		}

		// Convert view image to model image.
		const modelImage = conversionApi.convertItem( viewImage, consumable, data );

		// Convert rest of figure element's children, but in the context of model image, because those converted
		// children will be added as model image children.
		data.context.push( modelImage );

		const modelChildren = conversionApi.convertChildren( data.input, consumable, data );

		data.context.pop();

		// Add converted children to model image.
		__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_writer__["a" /* default */].insert( __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAt( modelImage ), modelChildren );

		// Set model image as conversion result.
		data.output = modelImage;
	};
}

/**
 * Creates the image attribute converter for provided model conversion dispatchers.
 *
 * @param {Array.<module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher>} dispatchers
 * @param {String} attributeName
 * @param {Function} [converter] Custom converter for the attribute - default one converts attribute from model `image` element
 * to the same attribute in `img` in the view.
 */
function createImageAttributeConverter( dispatchers, attributeName, converter = modelToViewAttributeConverter ) {
	for ( const dispatcher of dispatchers ) {
		dispatcher.on( `addAttribute:${ attributeName }:image`, converter() );
		dispatcher.on( `changeAttribute:${ attributeName }:image`, converter() );
		dispatcher.on( `removeAttribute:${ attributeName }:image`, converter() );
	}
}

/**
 * Converter used to convert `srcset` model image's attribute to `srcset`, `sizes` and `width` attributes in the view.
 *
 * @return {Function}
 */
function srcsetAttributeConverter() {
	return ( evt, data, consumable, conversionApi ) => {
		const parts = evt.name.split( ':' );
		const consumableType = parts[ 0 ] + ':' + parts[ 1 ];
		const modelImage = data.item;

		if ( !consumable.consume( modelImage, consumableType ) ) {
			return;
		}

		const figure = conversionApi.mapper.toViewElement( modelImage );
		const img = figure.getChild( 0 );
		const type = parts[ 0 ];

		if ( type == 'removeAttribute' ) {
			const srcset = data.attributeOldValue;

			if ( srcset.data ) {
				img.removeAttribute( 'srcset' );
				img.removeAttribute( 'sizes' );

				if ( srcset.width ) {
					img.removeAttribute( 'width' );
				}
			}
		} else {
			const srcset = data.attributeNewValue;

			if ( srcset.data ) {
				img.setAttribute( 'srcset', srcset.data );
				// Always outputting `100vw`. See https://github.com/ckeditor/ckeditor5-image/issues/2.
				img.setAttribute( 'sizes', '100vw' );

				if ( srcset.width ) {
					img.setAttribute( 'width', srcset.width );
				}
			}
		}
	};
}

// Returns model to view image converter converting given attribute, and adding it to `img` element nested inside `figure` element.
//
// @private
function modelToViewAttributeConverter() {
	return ( evt, data, consumable, conversionApi ) => {
		const parts = evt.name.split( ':' );
		const consumableType = parts[ 0 ] + ':' + parts[ 1 ];
		const modelImage = data.item;

		if ( !consumable.consume( modelImage, consumableType ) ) {
			return;
		}

		const figure = conversionApi.mapper.toViewElement( modelImage );
		const img = figure.getChild( 0 );
		const type = parts[ 0 ];

		if ( type == 'removeAttribute' ) {
			img.removeAttribute( data.attributeKey );
		} else {
			img.setAttribute( data.attributeKey, data.attributeNewValue );
		}
	};
}

// Holds all images that were converted for autohoisting.
const autohoistedImages = new WeakSet();

/**
 * A converter which converts `<img>` {@link module:engine/view/element~Element view elements} that can be hoisted.
 *
 * If an `<img>` view element has not been converted, this converter checks if that element could be converted in any
 * context "above". If it could, the converter converts the `<img>` element even though it is not allowed in the current
 * context and marks it to be autohoisted. Then {@link module:image/image/converters~hoistImageThroughElement another converter}
 * moves the converted element to the correct location.
 */
function convertHoistableImage( evt, data, consumable, conversionApi ) {
	const img = data.input;

	// If the image has not been consumed (converted)...
	if ( !consumable.test( img, { name: true, attribute: [ 'src' ] } ) ) {
		return;
	}
	// At this point the image has not been converted because it was not allowed by schema. It might be in wrong
	// context or missing an attribute, but above we already checked whether the image has mandatory src attribute.

	// If the image would be allowed if it was in one of its ancestors...
	const allowedContext = _findAllowedContext( { name: 'image', attributes: [ 'src' ] }, data.context, conversionApi.schema );

	if ( !allowedContext ) {
		return;
	}

	// Convert it in that context...
	const newData = Object.assign( {}, data );
	newData.context = allowedContext;

	data.output = conversionApi.convertItem( img, consumable, newData );

	// And mark that image to be hoisted.
	autohoistedImages.add( data.output );
}

// Basing on passed `context`, searches for "closest" context in which model element represented by `modelData`
// would be allowed by `schema`.
//
// @private
// @param {Object} modelData Object describing model element to check. Has two properties: `name` with model element name
// and `attributes` with keys of attributes of that model element.
// @param {Array} context Context in which original conversion was supposed to take place.
// @param {module:engine/model/schema~Schema} schema Schema to check with.
// @returns {Array|null} Context in which described model element would be allowed by `schema` or `null` if such context
// could not been found.
function _findAllowedContext( modelData, context, schema ) {
	// Copy context array so we won't modify original array.
	context = context.slice();

	// Prepare schema query to check with schema.
	// Since `inside` property is passed as reference to `context` variable, we don't need to modify `schemaQuery`.
	const schemaQuery = {
		name: modelData.name,
		attributes: modelData.attributes,
		inside: context
	};

	// Try out all possible contexts.
	while ( context.length && !schema.check( schemaQuery ) ) {
		const parent = context.pop();
		const parentName = typeof parent === 'string' ? parent : parent.name;

		// Do not try to autohoist "above" limiting element.
		if ( schema.limits.has( parentName ) ) {
			return null;
		}
	}

	// If `context` has any items it means that image is allowed in that context. Return that context.
	// If `context` has no items it means that image was not allowed in any of possible contexts. Return `null`.
	return context.length ? context : null;
}

/**
 * A converter which hoists `<image>` {@link module:engine/model/element~Element model elements} to allowed context.
 *
 * It looks through all children of the converted {@link module:engine/view/element~Element view element} if it
 * was converted to a model element. It breaks the model element if an `<image>` to-be-hoisted is found.
 *
 *		<div><paragraph>x<image src="foo.jpg"></image>x</paragraph></div> ->
 *		<div><paragraph>x</paragraph></div><image src="foo.jpg"></image><div><paragraph>x</paragraph></div>
 *
 * This works deeply, as shown in the example. This converter added for the `<paragraph>` element will break the `<paragraph>`
 *  element and pass the {@link module:engine/model/documentfragment~DocumentFragment document fragment} in `data.output`.
 *  Then, the `<div>` will be handled by this converter and will be once again broken to hoist the `<image>` up to the root.
 *
 * **Note:** This converter should be executed only after the view element has already been converted, which means that
 * `data.output` for that view element should be already generated when this converter is fired.
 */
function hoistImageThroughElement( evt, data ) {
	// If this element has been properly converted...
	if ( !data.output ) {
		return;
	}

	// And it is an element...
	// (If it is document fragment autohoisting does not have to break anything anyway.)
	// (And if it is text there are no children here.)
	if ( !data.output.is( 'element' ) ) {
		return;
	}

	// This will hold newly generated output. At the beginning it is only the original element.
	const newOutput = [];

	// Check if any of its children is to be hoisted...
	// Start from the last child - it is easier to break that way.
	for ( let i = data.output.childCount - 1; i >= 0; i-- ) {
		const child = data.output.getChild( i );

		if ( autohoistedImages.has( child ) ) {
			// Break autohoisted element's parent:
			// <parent>{ left-children... }<authoistedElement />{ right-children... }</parent>   --->
			// <parent>{ left-children... }</parent><autohoistedElement /><parent>{ right-children... }</parent>
			//
			// or
			//
			// <parent>{ left-children... }<autohoistedElement /></parent> --->
			// <parent>{ left-children... }</parent><autohoistedElement />
			//
			// or
			//
			// <parent><autohoistedElement />{ right-children... }</parent> --->
			// <autohoistedElement /><parent>{ right-children... }</parent>
			//
			// or
			//
			// <parent><autohoistedElement /></parent> ---> <autohoistedElement />

			// Check how many right-children there are.
			const rightChildrenCount = data.output.childCount - i - 1;
			let rightParent = null;

			// If there are any right-children, clone the prent element and insert those children there.
			if ( rightChildrenCount > 0 ) {
				rightParent = data.output.clone( false );
				rightParent.appendChildren( data.output.removeChildren( i + 1, rightChildrenCount ) );
			}

			// Remove the autohoisted element from its parent.
			child.remove();

			// Break "leading" `data.output` in `newOutput` into one or more pieces:
			// Remove "leading" `data.output` (note that `data.output` is always first item in `newOutput`).
			newOutput.shift();

			// Add the newly created parent of the right-children at the beginning.
			if ( rightParent ) {
				newOutput.unshift( rightParent );
			}

			// Add autohoisted element at the beginning.
			newOutput.unshift( child );

			// Add `data.output` at the beginning, if there is anything left in it.
			if ( data.output.childCount > 0 ) {
				newOutput.unshift( data.output );
			}
		}
	}

	// If the output has changed pass it further.
	if ( newOutput.length ) {
		data.output = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_documentfragment__["a" /* default */]( newOutput );
	}
}


/***/ }),
/* 511 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__ = __webpack_require__(4);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module widget/highlightstack
 */




/**
 * Class used to handle correct order of
 * {@link module:engine/conversion/buildmodelconverter~ModelConverterBuilder#toHighlight highlights} on
 * elements. When different highlights are applied to same element correct order should be preserved:
 * * highlight with highest priority should be applied,
 * * if two highlights have same priority - sort by CSS class provided in
 * {@link module:engine/conversion/model-to-view-converters~HighlightDescriptor}.
 * This way, highlight will be applied with the same rules it is applied on texts.
 */
class HighlightStack {
	/**
	 * Creates class instance.
	 */
	constructor() {
		this._stack = [];
	}

	/**
	 * Adds highlight descriptor to the stack.
	 *
	 * @fires change:top
	 * @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor} descriptor
	 */
	add( descriptor ) {
		const stack = this._stack;

		// Save top descriptor and insert new one. If top is changed - fire event.
		const oldTop = stack[ 0 ];
		this._insertDescriptor( descriptor );
		const newTop = stack[ 0 ];

		// When new object is at the top and stores different information.
		if ( oldTop !== newTop && !compareDescriptors( oldTop, newTop ) ) {
			this.fire( 'change:top', {
				oldDescriptor: oldTop,
				newDescriptor: newTop
			} );
		}
	}

	/**
	 * Removes highlight descriptor from the stack.
	 *
	 * @fires change:top
	 * @param {String} id Id of the descriptor to remove.
	 */
	remove( id ) {
		const stack = this._stack;

		const oldTop = stack[ 0 ];
		this._removeDescriptor( id );
		const newTop = stack[ 0 ];

		// When new object is at the top and stores different information.
		if ( oldTop !== newTop && !compareDescriptors( oldTop, newTop ) ) {
			this.fire( 'change:top', {
				oldDescriptor: oldTop,
				newDescriptor: newTop
			} );
		}
	}

	/**
	 * Inserts given descriptor in correct place in the stack. It also takes care about updating information when
	 * descriptor with same id is already present.
	 *
	 * @private
	 * @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor} descriptor
	 */
	_insertDescriptor( descriptor ) {
		const stack = this._stack;
		const index = stack.findIndex( item => item.id === descriptor.id );

		// Inserting exact same descriptor - do nothing.
		if ( compareDescriptors( descriptor, stack[ index ] ) ) {
			return;
		}

		// If descriptor with same id but with different information is on the stack - remove it.
		if ( index > -1 ) {
			stack.splice( index, 1 );
		}

		// Find correct place to insert descriptor in the stack.
		// It have different information (for example priority) so it must be re-inserted in correct place.
		let i = 0;

		while ( stack[ i ] && shouldABeBeforeB( stack[ i ], descriptor ) ) {
			i++;
		}

		stack.splice( i, 0, descriptor );
	}

	/**
	 * Removes descriptor with given id from the stack.
	 *
	 * @private
	 * @param {String} id Descriptor's id.
	 */
	_removeDescriptor( id ) {
		const stack = this._stack;
		const index = stack.findIndex( item => item.id === id );

		// If descriptor with same id is on the list - remove it.
		if ( index > -1 ) {
			stack.splice( index, 1 );
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = HighlightStack;


Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_mix__["a" /* default */])( HighlightStack, __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

// Compares two descriptors by checking their priority and class list.
//
// @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor} a
// @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor} b
// @returns {Boolean} Returns true if both descriptors are defined and have same priority and classes.
function compareDescriptors( a, b ) {
	return a && b && a.priority == b.priority && classesToString( a.class ) == classesToString( b.class );
}

// Checks whenever first descriptor should be placed in the stack before second one.
//
// @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor} a
// @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor} b
// @returns {Boolean}
function shouldABeBeforeB( a, b ) {
	if ( a.priority > b.priority ) {
		return true;
	} else if ( a.priority < b.priority ) {
		return false;
	}

	// When priorities are equal and names are different - use classes to compare.
	return classesToString( a.class ) > classesToString( b.class );
}

// Converts CSS classes passed with {@link module:engine/conversion/model-to-view-converters~HighlightDescriptor} to
// sorted string.
//
// @param {String|Array<String>} descriptor
// @returns {String}
function classesToString( classes ) {
	return Array.isArray( classes ) ? classes.sort().join( ',' ) : classes;
}

/**
 * Fired when top element on {@link module:widget/highlightstack~HighlightStack} has been changed
 *
 * @event change:top
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor} [data.newDescriptor] New highlight
 * descriptor. It will be `undefined` when last descriptor is removed from the stack.
 * @param {module:engine/conversion/model-to-view-converters~HighlightDescriptor} [data.oldDescriptor] Old highlight
 * descriptor. It will be `undefined` when first descriptor is added to the stack.
 */


/***/ }),
/* 512 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_observer_mouseobserver__ = __webpack_require__(513);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_selection__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_view_editableelement__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_rooteditableelement__ = __webpack_require__(260);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__theme_theme_scss__ = __webpack_require__(514);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__theme_theme_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__theme_theme_scss__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module widget/widget
 */













const selectAllKeystrokeCode = Object(__WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["d" /* parseKeystroke */])( 'Ctrl+A' );

/**
 * The widget plugin.
 * Registers model to view selection converter for editing pipeline. It is hooked after default selection conversion.
 * If converted selection is placed around widget element, selection is marked as fake. Additionally, proper CSS class
 * is added to indicate that widget has been selected.
 * Adds default {@link module:engine/view/document~Document#event:mousedown mousedown} handling on widget elements.
 *
 * @extends module:core/plugin~Plugin.
 */
class Widget extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Widget';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const viewDocument = this.editor.editing.view;

		/**
		 * Holds previously selected widgets.
		 *
		 * @private
		 * @type {Set.<module:engine/view/element~Element>}
		 */
		this._previouslySelected = new Set();

		// Model to view selection converter.
		// Converts selection placed over widget element to fake selection
		this.editor.editing.modelToView.on( 'selection', ( evt, data, consumable, conversionApi ) => {
			// Remove selected class from previously selected widgets.
			this._clearPreviouslySelectedWidgets();

			const viewSelection = conversionApi.viewSelection;
			const selectedElement = viewSelection.getSelectedElement();

			for ( const range of viewSelection.getRanges() ) {
				for ( const value of range ) {
					const node = value.item;

					if ( node.is( 'element' ) && Object(__WEBPACK_IMPORTED_MODULE_7__utils__["c" /* isWidget */])( node ) ) {
						node.addClass( __WEBPACK_IMPORTED_MODULE_7__utils__["a" /* WIDGET_SELECTED_CLASS_NAME */] );
						this._previouslySelected.add( node );

						// Check if widget is a single element selected.
						if ( node == selectedElement ) {
							viewSelection.setFake( true, { label: Object(__WEBPACK_IMPORTED_MODULE_7__utils__["b" /* getLabel */])( selectedElement ) } );
						}
					}
				}
			}
		}, { priority: 'low' } );

		// If mouse down is pressed on widget - create selection over whole widget.
		viewDocument.addObserver( __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_observer_mouseobserver__["a" /* default */] );
		this.listenTo( viewDocument, 'mousedown', ( ...args ) => this._onMousedown( ...args ) );

		// Handle custom keydown behaviour.
		this.listenTo( viewDocument, 'keydown', ( ...args ) => this._onKeydown( ...args ), { priority: 'high' } );
	}

	/**
	 * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.
	 *
	 * @private
	 * @param {module:utils/eventinfo~EventInfo} eventInfo
	 * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData
	 */
	_onMousedown( eventInfo, domEventData ) {
		const editor = this.editor;
		const viewDocument = editor.editing.view;
		let element = domEventData.target;

		// Do nothing if inside nested editable.
		if ( isInsideNestedEditable( element ) ) {
			return;
		}

		// If target is not a widget element - check if one of the ancestors is.
		if ( !Object(__WEBPACK_IMPORTED_MODULE_7__utils__["c" /* isWidget */])( element ) ) {
			element = element.findAncestor( __WEBPACK_IMPORTED_MODULE_7__utils__["c" /* isWidget */] );

			if ( !element ) {
				return;
			}
		}

		domEventData.preventDefault();

		// Focus editor if is not focused already.
		if ( !viewDocument.isFocused ) {
			viewDocument.focus();
		}

		// Create model selection over widget.
		const modelElement = editor.editing.mapper.toModelElement( element );

		editor.document.enqueueChanges( ( ) => {
			this._setSelectionOverElement( modelElement );
		} );
	}

	/**
	 * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.
	 *
	 * @private
	 * @param {module:utils/eventinfo~EventInfo} eventInfo
	 * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData
	 */
	_onKeydown( eventInfo, domEventData ) {
		const keyCode = domEventData.keyCode;
		const isForward = keyCode == __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].delete || keyCode == __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowdown || keyCode == __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowright;
		let wasHandled = false;

		// Checks if the keys were handled and then prevents the default event behaviour and stops
		// the propagation.
		if ( isDeleteKeyCode( keyCode ) ) {
			wasHandled = this._handleDelete( isForward );
		} else if ( isArrowKeyCode( keyCode ) ) {
			wasHandled = this._handleArrowKeys( isForward );
		} else if ( isSelectAllKeyCode( domEventData ) ) {
			wasHandled = this._selectAllNestedEditableContent() || this._selectAllContent();
		}

		if ( wasHandled ) {
			domEventData.preventDefault();
			eventInfo.stop();
		}
	}

	/**
	 * Handles delete keys: backspace and delete.
	 *
	 * @private
	 * @param {Boolean} isForward Set to true if delete was performed in forward direction.
	 * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.
	 */
	_handleDelete( isForward ) {
		// Do nothing when the read only mode is enabled.
		if ( this.editor.isReadOnly ) {
			return;
		}

		const modelDocument = this.editor.document;
		const modelSelection = modelDocument.selection;

		// Do nothing on non-collapsed selection.
		if ( !modelSelection.isCollapsed ) {
			return;
		}

		const objectElement = this._getObjectElementNextToSelection( isForward );

		if ( objectElement ) {
			modelDocument.enqueueChanges( () => {
				const batch = modelDocument.batch();
				let previousNode = modelSelection.anchor.parent;

				// Remove previous element if empty.
				while ( previousNode.isEmpty ) {
					const nodeToRemove = previousNode;
					previousNode = nodeToRemove.parent;

					batch.remove( nodeToRemove );
				}

				this._setSelectionOverElement( objectElement );
			} );

			return true;
		}
	}

	/**
	 * Handles arrow keys.
	 *
	 * @param {Boolean} isForward Set to true if arrow key should be handled in forward direction.
	 * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.
	 */
	_handleArrowKeys( isForward ) {
		const modelDocument = this.editor.document;
		const schema = modelDocument.schema;
		const modelSelection = modelDocument.selection;
		const objectElement = modelSelection.getSelectedElement();

		// if object element is selected.
		if ( objectElement && schema.objects.has( objectElement.name ) ) {
			const position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();
			const newRange = modelDocument.getNearestSelectionRange( position, isForward ? 'forward' : 'backward' );

			if ( newRange ) {
				modelDocument.enqueueChanges( () => {
					modelSelection.setRanges( [ newRange ] );
				} );
			}

			return true;
		}

		// If selection is next to object element.
		// Return if not collapsed.
		if ( !modelSelection.isCollapsed ) {
			return;
		}

		const objectElement2 = this._getObjectElementNextToSelection( isForward );

		if ( objectElement2 instanceof __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */] && modelDocument.schema.objects.has( objectElement2.name ) ) {
			modelDocument.enqueueChanges( () => {
				this._setSelectionOverElement( objectElement2 );
			} );

			return true;
		}
	}

	/**
	 * Extends the {@link module:engine/model/selection~Selection document's selection} to span the entire
	 * content of the nested editable if already anchored in one.
	 *
	 * See: {@link module:engine/model/schema~Schema#getLimitElement}.
	 *
	 * @private
	 */
	_selectAllNestedEditableContent() {
		const modelDocument = this.editor.document;
		const modelSelection = modelDocument.selection;
		const schema = modelDocument.schema;
		const limitElement = schema.getLimitElement( modelSelection );

		if ( modelSelection.getFirstRange().root == limitElement ) {
			return false;
		}

		modelDocument.enqueueChanges( () => {
			modelSelection.setIn( limitElement );
		} );

		return true;
	}

	/**
	 * Handles <kbd>CTRL + A</kbd> when widget is selected.
	 *
	 * @private
	 * @returns {Boolean} Returns true if widget was selected and selecting all was handled by this method.
	 */
	_selectAllContent() {
		const modelDocument = this.editor.document;
		const modelSelection = modelDocument.selection;
		const editing = this.editor.editing;
		const viewDocument = editing.view;
		const viewSelection = viewDocument.selection;

		const selectedElement = viewSelection.getSelectedElement();

		// Only widget is selected.
		// https://github.com/ckeditor/ckeditor5-widget/issues/23
		if ( selectedElement && Object(__WEBPACK_IMPORTED_MODULE_7__utils__["c" /* isWidget */])( selectedElement ) ) {
			const widgetParent = editing.mapper.toModelElement( selectedElement.parent );

			modelDocument.enqueueChanges( () => {
				modelSelection.setRanges( [ __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_range__["a" /* default */].createIn( widgetParent ) ] );
			} );

			return true;
		}

		return false;
	}

	/**
	 * Sets {@link module:engine/model/selection~Selection document's selection} over given element.
	 *
	 * @private
	 * @param {module:engine/model/element~Element} element
	 */
	_setSelectionOverElement( element ) {
		this.editor.document.selection.setRanges( [ __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_range__["a" /* default */].createOn( element ) ] );
	}

	/**
	 * Checks if {@link module:engine/model/element~Element element} placed next to the current
	 * {@link module:engine/model/selection~Selection model selection} exists and is marked in
	 * {@link module:engine/model/schema~Schema schema} as `object`.
	 *
	 * @private
	 * @param {Boolean} forward Direction of checking.
	 * @returns {module:engine/model/element~Element|null}
	 */
	_getObjectElementNextToSelection( forward ) {
		const modelDocument = this.editor.document;
		const schema = modelDocument.schema;
		const modelSelection = modelDocument.selection;
		const dataController = this.editor.data;

		// Clone current selection to use it as a probe. We must leave default selection as it is so it can return
		// to its current state after undo.
		const probe = __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_selection__["a" /* default */].createFromSelection( modelSelection );
		dataController.modifySelection( probe, { direction: forward ? 'forward' : 'backward' } );
		const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;

		if ( objectElement instanceof __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */] && schema.objects.has( objectElement.name ) ) {
			return objectElement;
		}

		return null;
	}

	/**
	 * Removes CSS class from previously selected widgets.
	 * @private
	 */
	_clearPreviouslySelectedWidgets() {
		for ( const widget of this._previouslySelected ) {
			widget.removeClass( __WEBPACK_IMPORTED_MODULE_7__utils__["a" /* WIDGET_SELECTED_CLASS_NAME */] );
		}

		this._previouslySelected.clear();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Widget;


// Returns 'true' if provided key code represents one of the arrow keys.
//
// @param {Number} keyCode
// @returns {Boolean}
function isArrowKeyCode( keyCode ) {
	return keyCode == __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowright ||
		keyCode == __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowleft ||
		keyCode == __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowup ||
		keyCode == __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].arrowdown;
}

// Returns 'true' if provided key code represents one of the delete keys: delete or backspace.
//
// @param {Number} keyCode
// @returns {Boolean}
function isDeleteKeyCode( keyCode ) {
	return keyCode == __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].delete || keyCode == __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["c" /* keyCodes */].backspace;
}

// Returns 'true' if provided (DOM) key event data corresponds with the Ctrl+A keystroke.
//
// @param {module:engine/view/observer/keyobserver~KeyEventData} domEventData
// @returns {Boolean}
function isSelectAllKeyCode( domEventData ) {
	return Object(__WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keyboard__["a" /* getCode */])( domEventData ) == selectAllKeystrokeCode;
}

// Returns `true` when element is a nested editable or is placed inside one.
//
// @param {module:engine/view/element~Element}
// @returns {Boolean}
function isInsideNestedEditable( element ) {
	while ( element ) {
		if ( element instanceof __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_view_editableelement__["a" /* default */] && !( element instanceof __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_rooteditableelement__["a" /* default */] ) ) {
			return true;
		}

		element = element.parent;
	}

	return false;
}


/***/ }),
/* 513 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__domeventobserver__ = __webpack_require__(74);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/mouseobserver
 */



/**
 * Mouse events observer.
 *
 * Note that this observer is not available by default. To make it available it needs to be added to
 * {@link module:engine/view/document~Document}
 * by {@link module:engine/view/document~Document#addObserver} method.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */
class MouseObserver extends __WEBPACK_IMPORTED_MODULE_0__domeventobserver__["a" /* default */] {
	constructor( document ) {
		super( document );

		this.domEventType = 'mousedown';
	}

	onDomEvent( domEvent ) {
		this.fire( domEvent.type, domEvent );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MouseObserver;


/**
 * Fired when mouse button is pressed down on one of the editables.
 *
 * Introduced by {@link module:engine/view/observer/mouseobserver~MouseObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:engine/view/observer/mouseobserver~MouseObserver}
 * needs to be added to {@link module:engine/view/document~Document} by a {@link module:engine/view/document~Document#addObserver} method.
 *
 * @see module:engine/view/observer/mouseobserver~MouseObserver
 * @event module:engine/view/document~Document#event:mousedown
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */


/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(515);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(32)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss", function() {
		var newContent = require("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(31)(false);
// imports


// module
exports.push([module.i, ".ck-widget{margin:.8em 0;padding:0}.ck-widget.ck-widget_selected,.ck-widget.ck-widget_selected:hover{outline:3px solid #48a3f5}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected{outline:3px solid #ddd}.ck-widget:hover{outline:3px solid #ffd25c}.ck-widget .ck-editable{border:1px solid transparent}.ck-widget .ck-editable.ck-editable_focused,.ck-widget .ck-editable:focus{outline:none;border:1px solid #48a3f5;box-shadow:inset 2px 2px 3px rgba(0,0,0,.1);background-color:#fff}", ""]);

// exports


/***/ }),
/* 516 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_button_buttonview__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__imagetextalternative_imagetextalternativeengine__ = __webpack_require__(517);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_bindings_clickoutsidehandler__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__imagetextalternative_ui_textalternativeformview__ = __webpack_require__(519);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_ui_src_panel_balloon_contextualballoon__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_core_theme_icons_low_vision_svg__ = __webpack_require__(521);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_core_theme_icons_low_vision_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_core_theme_icons_low_vision_svg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__image_ui_utils__ = __webpack_require__(280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__image_utils__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__theme_imagetextalternative_theme_scss__ = __webpack_require__(522);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__theme_imagetextalternative_theme_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__theme_imagetextalternative_theme_scss__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagetextalternative
 */













/**
 * The image text alternative plugin.
 *
 * The plugin uses the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon}.
 *
 * @extends module:core/plugin~Plugin
 */
class ImageTextAlternative extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_2__imagetextalternative_imagetextalternativeengine__["a" /* default */], __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_ui_src_panel_balloon_contextualballoon__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'ImageTextAlternative';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		this._createButton();
		this._createForm();
	}

	/**
	 * Creates a button showing the balloon panel for changing the image text alternative and
	 * registers it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.
	 *
	 * @private
	 */
	_createButton() {
		const editor = this.editor;
		const command = editor.commands.get( 'imageTextAlternative' );
		const t = editor.t;

		editor.ui.componentFactory.add( 'imageTextAlternative', locale => {
			const view = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_button_buttonview__["a" /* default */]( locale );

			view.set( {
				label: t( 'Change image text alternative' ),
				icon: __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_core_theme_icons_low_vision_svg___default.a,
				tooltip: true
			} );

			view.bind( 'isEnabled' ).to( command, 'isEnabled' );

			this.listenTo( view, 'execute', () => this._showForm() );

			return view;
		} );
	}

	/**
	 * Creates the {@link module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}
	 * form.
	 *
	 * @private
	 */
	_createForm() {
		const editor = this.editor;
		const editingView = editor.editing.view;

		/**
		 * The contextual balloon plugin instance.
		 *
		 * @private
		 * @member {module:ui/panel/balloon/contextualballoon~ContextualBalloon}
		 */
		this._balloon = this.editor.plugins.get( 'ContextualBalloon' );

		/**
		 * A form containing a textarea and buttons, used to change the `alt` text value.
		 *
		 * @member {module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView} #form
		 */
		this._form = new __WEBPACK_IMPORTED_MODULE_4__imagetextalternative_ui_textalternativeformview__["a" /* default */]( editor.locale );

		// Render the form so its #element is available for clickOutsideHandler.
		this._form.render();

		this.listenTo( this._form, 'submit', () => {
			editor.execute( 'imageTextAlternative', {
				newValue: this._form.labeledInput.inputView.element.value
			} );

			this._hideForm( true );
		} );

		this.listenTo( this._form, 'cancel', () => {
			this._hideForm( true );
		} );

		// Close the form on Esc key press.
		this._form.keystrokes.set( 'Esc', ( data, cancel ) => {
			this._hideForm( true );
			cancel();
		} );

		// Reposition the balloon or hide the form if an image widget is no longer selected.
		this.listenTo( editingView, 'render', () => {
			if ( !Object(__WEBPACK_IMPORTED_MODULE_8__image_utils__["b" /* isImageWidgetSelected */])( editingView.selection ) ) {
				this._hideForm( true );
			} else if ( this._isVisible ) {
				Object(__WEBPACK_IMPORTED_MODULE_7__image_ui_utils__["b" /* repositionContextualBalloon */])( editor );
			}
		}, { priority: 'low' } );

		// Close on click outside of balloon panel element.
		Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_bindings_clickoutsidehandler__["a" /* default */])( {
			emitter: this._form,
			activator: () => this._isVisible,
			contextElements: [ this._form.element ],
			callback: () => this._hideForm()
		} );
	}

	/**
	 * Shows the {@link #_form} in the {@link #_balloon}.
	 *
	 * @private
	 */
	_showForm() {
		if ( this._isVisible ) {
			return;
		}

		const editor = this.editor;
		const command = editor.commands.get( 'imageTextAlternative' );
		const labeledInput = this._form.labeledInput;

		if ( !this._balloon.hasView( this._form ) ) {
			this._balloon.add( {
				view: this._form,
				position: Object(__WEBPACK_IMPORTED_MODULE_7__image_ui_utils__["a" /* getBalloonPositionData */])( editor )
			} );
		}

		// Make sure that each time the panel shows up, the field remains in sync with the value of
		// the command. If the user typed in the input, then canceled the balloon (`labeledInput#value`
		// stays unaltered) and re-opened it without changing the value of the command, they would see the
		// old value instead of the actual value of the command.
		// https://github.com/ckeditor/ckeditor5-image/issues/114
		labeledInput.value = labeledInput.inputView.element.value = command.value || '';

		this._form.labeledInput.select();
	}

	/**
	 * Removes the {@link #_form} from the {@link #_balloon}.
	 *
	 * @param {Boolean} [focusEditable=false] Controls whether the editing view is focused afterwards.
	 * @private
	 */
	_hideForm( focusEditable ) {
		if ( !this._isVisible ) {
			return;
		}

		this._balloon.remove( this._form );

		if ( focusEditable ) {
			this.editor.editing.view.focus();
		}
	}

	/**
	 * Returns `true` when the {@link #_form} is the visible view
	 * in the {@link #_balloon}.
	 *
	 * @private
	 * @type {Boolean}
	 */
	get _isVisible() {
		return this._balloon.visibleView == this._form;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageTextAlternative;



/***/ }),
/* 517 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__imagetextalternativecommand__ = __webpack_require__(518);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagetextalternative/imagetextalternativeengine
 */




/**
 * The image text alternative engine plugin.
 * Registers the `imageTextAlternative` command.
 *
 * @extends module:core/plugin~Plugin
 */
class ImageTextAlternativeEngine extends __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	init() {
		this.editor.commands.add( 'imageTextAlternative', new __WEBPACK_IMPORTED_MODULE_0__imagetextalternativecommand__["a" /* default */]( this.editor ) );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageTextAlternativeEngine;



/***/ }),
/* 518 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__image_utils__ = __webpack_require__(35);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagetextalternative/imagetextalternativecommand
 */




/**
 * The image text alternative command. It is used to change the `alt` attribute on `<image>` elements.
 *
 * @extends module:core/command~Command
 */
class ImageTextAlternativeCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * The command value: `false` if there is no `alt` attribute, otherwise the value of the `alt` attribute.
	 *
	 * @readonly
	 * @observable
	 * @member {String|Boolean} #value
	 */

	/**
	 * @inheritDoc
	 */
	refresh() {
		const element = this.editor.document.selection.getSelectedElement();

		this.isEnabled = Object(__WEBPACK_IMPORTED_MODULE_1__image_utils__["a" /* isImage */])( element );

		if ( Object(__WEBPACK_IMPORTED_MODULE_1__image_utils__["a" /* isImage */])( element ) && element.hasAttribute( 'alt' ) ) {
			this.value = element.getAttribute( 'alt' );
		} else {
			this.value = false;
		}
	}

	/**
	 * Executes the command.
	 *
	 * @fires execute
	 * @param {Object} options
	 * @param {String} options.newValue The new value of the `alt` attribute to set.
	 * @param {module:engine/model/batch~Batch} [options.batch] A batch to collect all the change steps. A new batch will be
	 * created if this option is not set.
	 */
	execute( options ) {
		const doc = this.editor.document;
		const imageElement = doc.selection.getSelectedElement();

		doc.enqueueChanges( () => {
			const batch = options.batch || doc.batch();

			batch.setAttribute( imageElement, 'alt', options.newValue );
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageTextAlternativeCommand;



/***/ }),
/* 519 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_viewcollection__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_labeledinput_labeledinputview__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_ui_src_inputtext_inputtextview__ = __webpack_require__(278);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_ui_src_bindings_submithandler__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_keystrokehandler__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_focustracker__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_ui_src_focuscycler__ = __webpack_require__(114);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagetextalternative/ui/textalternativeformview
 */













/**
 * The TextAlternativeFormView class.
 *
 * @extends module:ui/view~View
 */
class TextAlternativeFormView extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		const t = this.locale.t;

		/**
		 * Tracks information about DOM focus in the form.
		 *
		 * @readonly
		 * @member {module:utils/focustracker~FocusTracker}
		 */
		this.focusTracker = new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_utils_src_focustracker__["a" /* default */]();

		/**
		 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
		 *
		 * @readonly
		 * @member {module:utils/keystrokehandler~KeystrokeHandler}
		 */
		this.keystrokes = new __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_keystrokehandler__["a" /* default */]();

		/**
		 * A textarea with a label.
		 *
		 * @member {module:ui/labeledinput/labeledinputview~LabeledInputView} #labeledTextarea
		 */
		this.labeledInput = this._createLabeledInputView();

		/**
		 * A button used to submit the form.
		 *
		 * @member {module:ui/button/buttonview~ButtonView} #saveButtonView
		 */
		this.saveButtonView = this._createButton( t( 'Save' ) );
		this.saveButtonView.type = 'submit';

		/**
		 * A button used to cancel the form.
		 *
		 * @member {module:ui/button/buttonview~ButtonView} #cancelButtonView
		 */
		this.cancelButtonView = this._createButton( t( 'Cancel' ), 'cancel' );

		/**
		 * A collection of views which can be focused in the form.
		 *
		 * @readonly
		 * @protected
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this._focusables = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_viewcollection__["a" /* default */]();

		/**
		 * Helps cycling over {@link #_focusables} in the form.
		 *
		 * @readonly
		 * @protected
		 * @member {module:ui/focuscycler~FocusCycler}
		 */
		this._focusCycler = new __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_ui_src_focuscycler__["a" /* default */]( {
			focusables: this._focusables,
			focusTracker: this.focusTracker,
			keystrokeHandler: this.keystrokes,
			actions: {
				// Navigate form fields backwards using the Shift + Tab keystroke.
				focusPrevious: 'shift + tab',

				// Navigate form fields forwards using the Tab key.
				focusNext: 'tab'
			}
		} );

		this.saveButtonView.extendTemplate( {
			attributes: {
				class: [
					'ck-button-action'
				]
			}
		} );

		this.setTemplate( {
			tag: 'form',

			attributes: {
				class: [
					'cke-text-alternative-form',
				],

				// https://github.com/ckeditor/ckeditor5-image/issues/40
				tabindex: '-1'
			},

			children: [
				this.labeledInput,
				{
					tag: 'div',

					attributes: {
						class: [
							'cke-text-alternative-form__actions'
						]
					},

					children: [
						this.saveButtonView,
						this.cancelButtonView
					]
				}
			]
		} );
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		this.keystrokes.listenTo( this.element );

		Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_ui_src_bindings_submithandler__["a" /* default */])( { view: this } );

		[ this.labeledInput, this.saveButtonView, this.cancelButtonView ]
			.forEach( v => {
				// Register the view as focusable.
				this._focusables.add( v );

				// Register the view in the focus tracker.
				this.focusTracker.add( v.element );
			} );
	}

	/**
	 * Creates the button view.
	 *
	 * @private
	 * @param {String} label The button label
	 * @param {String} [eventName] The event name that the ButtonView#execute event will be delegated to.
	 * @returns {module:ui/button/buttonview~ButtonView} The button view instance.
	 */
	_createButton( label, eventName ) {
		const button = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__["a" /* default */]( this.locale );

		button.label = label;
		button.withText = true;

		if ( eventName ) {
			button.delegate( 'execute' ).to( this, eventName );
		}

		return button;
	}

	/**
	 * Creates an input with a label.
	 *
	 * @private
	 * @return {module:ui/labeledinput/labeledinputview~LabeledInputView}
	 */
	_createLabeledInputView() {
		const t = this.locale.t;
		const labeledInput = new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_labeledinput_labeledinputview__["a" /* default */]( this.locale, __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_ui_src_inputtext_inputtextview__["a" /* default */] );
		labeledInput.label = t( 'Text alternative' );

		return labeledInput;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TextAlternativeFormView;



/***/ }),
/* 520 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view__ = __webpack_require__(6);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/label/labelview
 */



/**
 * The label view class.
 *
 * @extends module:ui/view~View
 */
class LabelView extends __WEBPACK_IMPORTED_MODULE_0__view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		/**
		 * The text of the label.
		 *
		 * @observable
		 * @member {String} #text
		 */
		this.set( 'text' );

		/**
		 * The `for` attribute of the label (i.e. to pair with an `<input>` element).
		 *
		 * @observable
		 * @member {String} #for
		 */
		this.set( 'for' );

		const bind = this.bindTemplate;

		this.setTemplate( {
			tag: 'label',
			attributes: {
				class: [
					'ck-label'
				],
				for: bind.to( 'for' )
			},
			children: [
				{
					text: bind.to( 'text' )
				}
			]
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LabelView;



/***/ }),
/* 521 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" stroke-linejoin=\"round\" stroke-miterlimit=\"1.414\"><path d=\"M5.414 6.749L2.903 4.237a.49.49 0 1 1 .694-.694L6.394 6.34a10.662 10.662 0 0 1 2.127-.53c.366-.051.734-.081 1.103-.095a10.628 10.628 0 0 1 1.524.07c1.109.134 2.204.449 3.243.936a9.65 9.65 0 0 1 2.12 1.331c.276.231.542.484.784.766.18.211.349.439.488.692.169.307.301.664.301 1.039 0 .375-.132.732-.301 1.039a4.143 4.143 0 0 1-.488.691 6.668 6.668 0 0 1-.784.767 9.628 9.628 0 0 1-2.092 1.318l2.196 2.197a.49.49 0 1 1-.694.694l-2.485-2.484-.008.003-.931-.931.009-.003-6.215-6.215a9.887 9.887 0 0 0-.945.444l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.483 8.596a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2 1.497 1.497 0 0 0-.108.241.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226 2.613 2.613 0 0 0 .234.379l3.463 3.594a10.565 10.565 0 0 1-2.125-1 9.096 9.096 0 0 1-1.015-.721 6.672 6.672 0 0 1-.798-.764 4.325 4.325 0 0 1-.502-.69c-.184-.319-.329-.693-.329-1.089 0-.375.131-.732.301-1.039.139-.253.307-.481.488-.692.225-.263.471-.5.728-.719a9.538 9.538 0 0 1 2.096-1.341l.019-.009zm6.674.401a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112 6.86 6.86 0 0 0 .727-.613c.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286a1.966 1.966 0 0 0 .148-.292.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891 10.119 10.119 0 0 0-1.027-.301zm-2.85.21l-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.449 2.449 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z\"/></svg>"

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(523);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(32)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../../../css-loader/index.js??ref--3-1!../../../../sass-loader/lib/loader.js!./theme.scss", function() {
		var newContent = require("!!../../../../css-loader/index.js??ref--3-1!../../../../sass-loader/lib/loader.js!./theme.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(31)(false);
// imports


// module
exports.push([module.i, ".cke-text-alternative-form{padding:1.2em;overflow:hidden}.cke-text-alternative-form:focus{outline:none}.cke-text-alternative-form .ck-label{margin-bottom:.4em}.cke-text-alternative-form__actions{clear:both;padding-top:1.2em}.cke-text-alternative-form__actions .ck-button{float:right}.cke-text-alternative-form__actions .ck-button+.ck-button{margin-right:.64em}.cke-text-alternative-form__actions .ck-button+.ck-button+.ck-button{float:left}", ""]);

// exports


/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(525);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(32)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss", function() {
		var newContent = require("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(31)(false);
// imports


// module
exports.push([module.i, ".ck-editor__editable .image{text-align:center;clear:both}.ck-editor__editable .image.image-style-align-center,.ck-editor__editable .image.image-style-align-left,.ck-editor__editable .image.image-style-align-right,.ck-editor__editable .image.image-style-side{max-width:50%}.ck-editor__editable .image.image-style-side{float:right;margin-left:2em}.ck-editor__editable .image.image-style-align-left{float:left;margin-right:2em}.ck-editor__editable .image.image-style-align-center{margin-left:auto;margin-right:auto}.ck-editor__editable .image.image-style-align-right{float:right;margin-left:2em}.ck-editor__editable .image>img{display:block;margin:0 auto;max-width:100%}", ""]);

// exports


/***/ }),
/* 526 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__imagecaption_imagecaptionengine__ = __webpack_require__(527);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__theme_imagecaption_theme_scss__ = __webpack_require__(532);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__theme_imagecaption_theme_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__theme_imagecaption_theme_scss__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagecaption
 */





/**
 * The image caption plugin.
 *
 * @extends module:core/plugin~Plugin
 */
class ImageCaption extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_1__imagecaption_imagecaptionengine__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'ImageCaption';
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageCaption;



/***/ }),
/* 527 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_treewalker__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_view_containerelement__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_view_element__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_view_writer__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__image_utils__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils__ = __webpack_require__(528);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagecaption/imagecaptionengine
 */













/**
 * The image caption engine plugin.
 *
 * It registers proper converters. It takes care of adding a caption element if the image without it is inserted
 * to the model document.
 *
 * @extends module:core/plugin~Plugin
 */
class ImageCaptionEngine extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const document = editor.document;
		const viewDocument = editor.editing.view;
		const schema = document.schema;
		const data = editor.data;
		const editing = editor.editing;
		const t = editor.t;

		/**
		 * Last selected caption editable.
		 * It is used for hiding the editable when it is empty and the image widget is no longer selected.
		 *
		 * @private
		 * @member {module:engine/view/editableelement~EditableElement} #_lastSelectedCaption
		 */

		/**
		 * A function used to create the editable caption element in the editing view.
		 *
		 * @private
		 * @member {Function}
		 */
		this._createCaption = Object(__WEBPACK_IMPORTED_MODULE_10__utils__["a" /* captionElementCreator */])( viewDocument, t( 'Enter image caption' ) );

		// Schema configuration.
		schema.registerItem( 'caption', '$block' );
		schema.allow( { name: '$inline', inside: 'caption' } );
		schema.allow( { name: 'caption', inside: 'image' } );
		schema.limits.add( 'caption' );

		// Add caption element to each image inserted without it.
		document.on( 'change', insertMissingModelCaptionElement );

		// View to model converter for the data pipeline.
		Object(__WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__["a" /* default */])()
			.for( data.viewToModel )
			.from( __WEBPACK_IMPORTED_MODULE_10__utils__["c" /* matchImageCaption */] )
			.toElement( 'caption' );

		// Model to view converter for the data pipeline.
		data.modelToView.on( 'insert:caption', captionModelToView( new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_view_containerelement__["a" /* default */]( 'figcaption' ), false ) );

		// Model to view converter for the editing pipeline.
		editing.modelToView.on( 'insert:caption', captionModelToView( this._createCaption ) );

		// Always show caption in view when something is inserted in model.
		editing.modelToView.on( 'insert', ( evt, data ) => this._fixCaptionVisibility( data.item ), { priority: 'high' } );

		// Hide caption when everything is removed from it.
		editing.modelToView.on( 'remove', ( evt, data ) => this._fixCaptionVisibility( data.sourcePosition.parent ), { priority: 'high' } );

		// Update view before each rendering.
		this.listenTo( viewDocument, 'render', () => this._updateCaptionVisibility(), { priority: 'high' } );
	}

	/**
	 * Updates the view before each rendering, making sure that empty captions (so unnecessary ones) are hidden
	 * and then visible when the image is selected.
	 *
	 * @private
	 */
	_updateCaptionVisibility() {
		const mapper = this.editor.editing.mapper;
		let viewCaption;

		// Hide last selected caption if have no child elements.
		if ( this._lastSelectedCaption && !this._lastSelectedCaption.childCount ) {
			this._lastSelectedCaption.addClass( 'ck-hidden' );
		}

		// If whole image is selected.
		const modelSelection = this.editor.document.selection;
		const selectedElement = modelSelection.getSelectedElement();

		if ( selectedElement && selectedElement.is( 'image' ) ) {
			const modelCaption = Object(__WEBPACK_IMPORTED_MODULE_10__utils__["b" /* getCaptionFromImage */])( selectedElement );
			viewCaption = mapper.toViewElement( modelCaption );
		}

		// If selection is placed inside caption.
		const position = modelSelection.getFirstPosition();
		const modelCaption = getParentCaption( position.parent );

		if ( modelCaption ) {
			viewCaption = mapper.toViewElement( modelCaption );
		}

		if ( viewCaption ) {
			viewCaption.removeClass( 'ck-hidden' );
			this._lastSelectedCaption = viewCaption;
		}
	}

	/**
	 * Fixes caption visibility during the model-to-view conversion.
	 * Checks if the changed node is placed inside the caption element and fixes its visibility in the view.
	 *
	 * @private
	 * @param {module:engine/model/node~Node} node
	 */
	_fixCaptionVisibility( node ) {
		const modelCaption = getParentCaption( node );
		const mapper = this.editor.editing.mapper;

		if ( modelCaption ) {
			const viewCaption = mapper.toViewElement( modelCaption );

			if ( viewCaption ) {
				if ( modelCaption.childCount ) {
					viewCaption.removeClass( 'ck-hidden' );
				} else {
					viewCaption.addClass( 'ck-hidden' );
				}
			}
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageCaptionEngine;


// Checks whether data inserted to the model document have image element that has no caption element inside it.
// If there is none - adds it to the image element.
//
// @private
function insertMissingModelCaptionElement( evt, changeType, data, batch ) {
	if ( changeType !== 'insert' ) {
		return;
	}

	const walker = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_treewalker__["a" /* default */]( {
		boundaries: data.range,
		ignoreElementEnd: true
	} );

	for ( const value of walker ) {
		const item = value.item;

		if ( value.type == 'elementStart' && Object(__WEBPACK_IMPORTED_MODULE_9__image_utils__["a" /* isImage */])( item ) && !Object(__WEBPACK_IMPORTED_MODULE_10__utils__["b" /* getCaptionFromImage */])( item ) ) {
			batch.document.enqueueChanges( () => {
				// Make sure that the image does not have caption already.
				// https://github.com/ckeditor/ckeditor5-image/issues/78
				if ( !Object(__WEBPACK_IMPORTED_MODULE_10__utils__["b" /* getCaptionFromImage */])( item ) ) {
					batch.insert( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAt( item, 'end' ), new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */]( 'caption' ) );
				}
			} );
		}
	}
}
// Creates a converter that converts image caption model element to view element.
//
// @private
// @param {Function|module:engine/view/element~Element} elementCreator
// @param {Boolean} [hide=true] When set to `false` view element will not be inserted when it's empty.
// @return {Function}
function captionModelToView( elementCreator, hide = true ) {
	return ( evt, data, consumable, conversionApi ) => {
		const captionElement = data.item;

		// Return if element shouldn't be present when empty.
		if ( !captionElement.childCount && !hide ) {
			return;
		}

		if ( Object(__WEBPACK_IMPORTED_MODULE_9__image_utils__["a" /* isImage */])( captionElement.parent ) ) {
			if ( !consumable.consume( data.item, 'insert' ) ) {
				return;
			}

			const viewImage = conversionApi.mapper.toViewElement( data.range.start.parent );
			const viewCaption = ( elementCreator instanceof __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_view_element__["a" /* default */] ) ?
				elementCreator.clone( true ) :
				elementCreator();

			// Hide if empty.
			if ( !captionElement.childCount ) {
				viewCaption.addClass( 'ck-hidden' );
			}

			insertViewCaptionAndBind( viewCaption, data.item, viewImage, conversionApi.mapper );
		}
	};
}

// Inserts `viewCaption` at the end of `viewImage` and binds it to `modelCaption`.
//
// @private
// @param {module:engine/view/containerelement~ContainerElement} viewCaption
// @param {module:engine/model/element~Element} modelCaption
// @param {module:engine/view/containerelement~ContainerElement} viewImage
// @param {module:engine/conversion/mapper~Mapper} mapper
function insertViewCaptionAndBind( viewCaption, modelCaption, viewImage, mapper ) {
	const viewPosition = __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAt( viewImage, 'end' );

	__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].insert( viewPosition, viewCaption );
	mapper.bindElements( modelCaption, viewCaption );
}

/**
 * Checks if the provided node or one of its ancestors is a caption element, and returns it.
 *
 * @param {module:engine/model/node~Node} node
 * @returns {module:engine/model/element~Element|null}
 */
function getParentCaption( node ) {
	const ancestors = node.getAncestors( { includeSelf: true } );
	const caption = ancestors.find( ancestor => ancestor.name == 'caption' );

	if ( caption && caption.parent && caption.parent.name == 'image' ) {
		return caption;
	}

	return null;
}


/***/ }),
/* 528 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = captionElementCreator;
/* unused harmony export isCaption */
/* harmony export (immutable) */ __webpack_exports__["b"] = getCaptionFromImage;
/* harmony export (immutable) */ __webpack_exports__["c"] = matchImageCaption;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_editableelement__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_view_placeholder__ = __webpack_require__(529);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_widget_src_utils__ = __webpack_require__(162);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagecaption/utils
 */






const captionSymbol = Symbol( 'imageCaption' );

/**
 * Returns a function that creates a caption editable element for the given {@link module:engine/view/document~Document}.
 *
 * @param {module:engine/view/document~Document} viewDocument
 * @param {String} placeholderText The text to be displayed when the caption is empty.
 * @return {Function}
 */
function captionElementCreator( viewDocument, placeholderText ) {
	return () => {
		const editable = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_editableelement__["a" /* default */]( 'figcaption' );
		editable.document = viewDocument;
		editable.setCustomProperty( captionSymbol, true );
		Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_view_placeholder__["a" /* attachPlaceholder */])( editable, placeholderText );

		return Object(__WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_widget_src_utils__["e" /* toWidgetEditable */])( editable );
	};
}

/**
 * Returns `true` if a given view element is the image caption editable.
 *
 * @param {module:engine/view/element~Element} viewElement
 * @return {Boolean}
 */
function isCaption( viewElement ) {
	return !!viewElement.getCustomProperty( captionSymbol );
}

/**
 * Returns the caption model element from a given image element. Returns `null` if no caption is found.
 *
 * @param {module:engine/model/element~Element} imageModelElement
 * @return {module:engine/model/element~Element|null}
 */
function getCaptionFromImage( imageModelElement ) {
	for ( const node of imageModelElement.getChildren() ) {
		if ( node instanceof __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */] && node.name == 'caption' ) {
			return node;
		}
	}

	return null;
}

/**
 * {@link module:engine/view/matcher~Matcher} pattern. Checks if a given element is a `<figcaption>` element that is placed
 * inside the image `<figure>` element.
 *
 * @param {module:engine/view/element~Element} element
 * @returns {Object|null} Returns the object accepted by {@link module:engine/view/matcher~Matcher} or `null` if the element
 * cannot be matched.
 */
function matchImageCaption( element ) {
	const parent = element.parent;

	// Convert only captions for images.
	if ( element.name == 'figcaption' && parent && parent.name == 'figure' && parent.hasClass( 'image' ) ) {
		return { name: true };
	}

	return null;
}


/***/ }),
/* 529 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = attachPlaceholder;
/* unused harmony export detachPlaceholder */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_extend__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_emittermixin__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__theme_placeholder_scss__ = __webpack_require__(530);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__theme_placeholder_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__theme_placeholder_scss__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/placeholder
 */






const listener = {};
Object(__WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_utils_src_lib_lodash_extend__["a" /* default */])( listener, __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_emittermixin__["c" /* default */] );

// Each document stores information about its placeholder elements and check functions.
const documentPlaceholders = new WeakMap();

/**
 * Attaches placeholder to provided element and updates it's visibility. To change placeholder simply call this method
 * once again with new parameters.
 *
 * @param {module:engine/view/element~Element} element Element to attach placeholder to.
 * @param {String} placeholderText Placeholder text to use.
 * @param {Function} [checkFunction] If provided it will be called before checking if placeholder should be displayed.
 * If function returns `false` placeholder will not be showed.
 */
function attachPlaceholder( element, placeholderText, checkFunction ) {
	const document = element.document;

	if ( !document ) {
		/**
		 * Provided element is not placed in any {@link module:engine/view/document~Document}.
		 *
		 * @error view-placeholder-element-is-detached
		 */
		throw new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_ckeditorerror__["b" /* default */]( 'view-placeholder-element-is-detached: Provided element is not placed in document.' );
	}

	// Detach placeholder if was used before.
	detachPlaceholder( element );

	// Single listener per document.
	if ( !documentPlaceholders.has( document ) ) {
		documentPlaceholders.set( document, new Map() );
		listener.listenTo( document, 'render', () => updateAllPlaceholders( document ), { priority: 'high' } );
	}

	// Store text in element's data attribute.
	// This data attribute is used in CSS class to show the placeholder.
	element.setAttribute( 'data-placeholder', placeholderText );

	// Store information about placeholder.
	documentPlaceholders.get( document ).set( element, checkFunction );

	// Update right away too.
	updateSinglePlaceholder( element, checkFunction );
}

/**
 * Removes placeholder functionality from given element.
 *
 * @param {module:engine/view/element~Element} element
 */
function detachPlaceholder( element ) {
	const document = element.document;

	element.removeClass( 'ck-placeholder' );
	element.removeAttribute( 'data-placeholder' );

	if ( documentPlaceholders.has( document ) ) {
		documentPlaceholders.get( document ).delete( element );
	}
}

// Updates all placeholders of given document.
//
// @private
// @param {module:engine/view/document~Document} document
function updateAllPlaceholders( document ) {
	const placeholders = documentPlaceholders.get( document );

	for ( const [ element, checkFunction ] of placeholders ) {
		updateSinglePlaceholder( element, checkFunction );
	}
}

// Updates placeholder class of given element.
//
// @private
// @param {module:engine/view/element~Element} element
// @param {Function} checkFunction
function updateSinglePlaceholder( element, checkFunction ) {
	const document = element.document;

	// Element was removed from document.
	if ( !document ) {
		return;
	}

	const viewSelection = document.selection;
	const anchor = viewSelection.anchor;

	// If checkFunction is provided and returns false - remove placeholder.
	if ( checkFunction && !checkFunction() ) {
		element.removeClass( 'ck-placeholder' );

		return;
	}

	// Element is empty for placeholder purposes when it has no children or only ui elements.
	// This check is taken from `view.ContainerElement#getFillerOffset`.
	const isEmptyish = !Array.from( element.getChildren() ).some( element => !element.is( 'uiElement' ) );

	// If element is empty and editor is blurred.
	if ( !document.isFocused && isEmptyish ) {
		element.addClass( 'ck-placeholder' );

		return;
	}

	// It there are no child elements and selection is not placed inside element.
	if ( isEmptyish && anchor && anchor.parent !== element ) {
		element.addClass( 'ck-placeholder' );
	} else {
		element.removeClass( 'ck-placeholder' );
	}
}


/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(531);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(32)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./placeholder.scss", function() {
		var newContent = require("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./placeholder.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(31)(false);
// imports


// module
exports.push([module.i, ".ck-placeholder:before{content:attr(data-placeholder);cursor:text;color:#c2c2c2;pointer-events:none}", ""]);

// exports


/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(533);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(32)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../../../css-loader/index.js??ref--3-1!../../../../sass-loader/lib/loader.js!./theme.scss", function() {
		var newContent = require("!!../../../../css-loader/index.js??ref--3-1!../../../../sass-loader/lib/loader.js!./theme.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(31)(false);
// imports


// module
exports.push([module.i, ".ck-editor__editable .image>figcaption{color:#333;background-color:#f7f7f7;padding:.8em;font-size:.75em;outline-offset:-1px}", ""]);

// exports


/***/ }),
/* 534 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__imagestyle_imagestyleengine__ = __webpack_require__(535);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__ = __webpack_require__(25);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagestyle
 */





/**
 * The image style plugin.
 *
 * Uses the {@link module:image/imagestyle/imagestyleengine~ImageStyleEngine}.
 *
 * @extends module:core/plugin~Plugin
 */
class ImageStyle extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_1__imagestyle_imagestyleengine__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'ImageStyle';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const styles = editor.plugins.get( __WEBPACK_IMPORTED_MODULE_1__imagestyle_imagestyleengine__["a" /* default */] ).imageStyles;

		for ( const style of styles ) {
			this._createButton( style );
		}
	}

	/**
	 * Creates a button for each style and stores it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.
	 *
	 * @private
	 * @param {module:image/imagestyle/imagestyleengine~ImageStyleFormat} style
	 */
	_createButton( style ) {
		const editor = this.editor;
		const command = editor.commands.get( style.name );

		editor.ui.componentFactory.add( style.name, locale => {
			const view = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__["a" /* default */]( locale );

			view.set( {
				label: style.title,
				icon: style.icon,
				tooltip: true
			} );

			view.bind( 'isEnabled' ).to( command, 'isEnabled' );
			view.bind( 'isOn' ).to( command, 'value' );

			this.listenTo( view, 'execute', () => editor.execute( style.name ) );

			return view;
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageStyle;


/**
 * Available image styles.
 * The option is used by the {@link module:image/imagestyle/imagestyleengine~ImageStyleEngine} feature.
 *
 * The default value is:
 *
 * 		const imageConfig = {
 *			styles: [ 'imageStyleFull', 'imageStyleSide' ]
 *		};
 *
 * which configures two default styles:
 *
 *  * the "full" style which doesn't apply any class, e.g. for images styled to span 100% width of the content,
 *  * the "side" style with the `.image-style-side` CSS class.
 *
 * See {@link module:image/imagestyle/imagestyleengine~ImageStyleEngine.defaultStyles} to learn more about default
 * styles provided by the image feature.
 *
 * The {@link module:image/imagestyle/imagestyleengine~ImageStyleEngine.defaultStyles default styles} can be customized,
 * e.g. to change the icon, title or CSS class of the style. The feature also provides several
 * {@link module:image/imagestyle/imagestyleengine~ImageStyleEngine.defaultIcons default icons} to chose from.
 *
 *		import customIcon from 'custom-icon.svg';
 *
 *		// ...
 *
 *		const imageConfig = {
 *			styles: [
 *				// This will only customize the icon of the "full" style.
 *				// Note: 'right' is one of default icons provided by the feature.
 *				{ name: 'imageStyleFull', icon: 'right' },
 *
 *				// This will customize the icon, title and CSS class of the default "side" style.
 *				{ name: 'imageStyleSide', icon: customIcon, title: 'My side style', class: 'custom-side-image' }
 *			]
 *		};
 *
 * If none of the default styles is good enough, it is possible to define independent custom styles too:
 *
 *		import fullSizeIcon from '@ckeditor/ckeditor5-core/theme/icons/object-center.svg';
 *		import sideIcon from '@ckeditor/ckeditor5-core/theme/icons/object-right.svg';
 *
 *		// ...
 *
 *		const imageConfig = {
 *			styles: [
 *				// A completely custom full size style with no class, used as a default.
 *				{ name: 'fullSize', title: 'Full size', icon: fullSizeIcon, isDefault: true },
 *
 *				{ name: 'side', title: 'To the side', icon: sideIcon, className: 'side-image' }
 *			]
 *		};
 *
 * Note: Setting `title` to one of {@link module:image/imagestyle/imagestyleengine~ImageStyleEngine#localizedDefaultStylesTitles}
 * will automatically translate it to the language of the editor.
 *
 * Read more about styling images in the {@glink features/image#Image-styles Image styles guide}.
 *
 * The feature creates commands based on defined styles, so you can change the style of a selected image by executing
 * the following command:
 *
 *		editor.execute( 'imageStyleSide' );
 *
 * The features creates also buttons which execute the commands, so assuming that you use the
 * default image styles setting you can {@link module:image/image~ImageConfig#toolbar configure the image toolbar}
 * to contain these options:
 *
 *		const imageConfig = {
 *			toolbar: [ 'imageStyleFull', 'imageStyleSide' ]
 *		};
 *
 * @member {Array.<module:image/imagestyle/imagestyleengine~ImageStyleFormat>} module:image/image~ImageConfig#styles
 */


/***/ }),
/* 535 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__imagestylecommand__ = __webpack_require__(536);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__image_imageengine__ = __webpack_require__(275);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__converters__ = __webpack_require__(537);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_log__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_core_theme_icons_object_full_width_svg__ = __webpack_require__(538);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_core_theme_icons_object_full_width_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_core_theme_icons_object_full_width_svg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_core_theme_icons_object_left_svg__ = __webpack_require__(539);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_core_theme_icons_object_left_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_core_theme_icons_object_left_svg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_core_theme_icons_object_center_svg__ = __webpack_require__(540);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_core_theme_icons_object_center_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_core_theme_icons_object_center_svg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_core_theme_icons_object_right_svg__ = __webpack_require__(541);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_core_theme_icons_object_right_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_core_theme_icons_object_right_svg__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagestyle/imagestyleengine
 */












/**
 * The image style engine plugin. It sets the default configuration, creates converters and registers
 * {@link module:image/imagestyle/imagestylecommand~ImageStyleCommand ImageStyleCommand}.
 *
 * @extends {module:core/plugin~Plugin}
 */
class ImageStyleEngine extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_2__image_imageengine__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'ImageStyleEngine';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const doc = editor.document;
		const schema = doc.schema;
		const data = editor.data;
		const editing = editor.editing;

		// Define default configuration.
		editor.config.define( 'image.styles', [ 'imageStyleFull', 'imageStyleSide' ] );

		// Get configuration.
		const styles = this.imageStyles;

		// Allow imageStyle attribute in image.
		// We could call it 'style' but https://github.com/ckeditor/ckeditor5-engine/issues/559.
		schema.allow( { name: 'image', attributes: 'imageStyle', inside: '$root' } );

		// Converters for imageStyle attribute from model to view.
		const modelToViewConverter = Object(__WEBPACK_IMPORTED_MODULE_3__converters__["a" /* modelToViewStyleAttribute */])( styles );
		editing.modelToView.on( 'addAttribute:imageStyle:image', modelToViewConverter );
		data.modelToView.on( 'addAttribute:imageStyle:image', modelToViewConverter );
		editing.modelToView.on( 'changeAttribute:imageStyle:image', modelToViewConverter );
		data.modelToView.on( 'changeAttribute:imageStyle:image', modelToViewConverter );
		editing.modelToView.on( 'removeAttribute:imageStyle:image', modelToViewConverter );
		data.modelToView.on( 'removeAttribute:imageStyle:image', modelToViewConverter );

		// Converter for figure element from view to model.
		data.viewToModel.on( 'element:figure', Object(__WEBPACK_IMPORTED_MODULE_3__converters__["b" /* viewToModelStyleAttribute */])( styles ), { priority: 'low' } );

		// Register separate command for each style.
		for ( const style of styles ) {
			editor.commands.add( style.name, new __WEBPACK_IMPORTED_MODULE_1__imagestylecommand__["a" /* default */]( editor, style ) );
		}
	}

	/**
	 * Returns {@link module:image/image~ImageConfig#styles} array with items normalized in the
	 * {@link module:image/imagestyle/imagestyleengine~ImageStyleFormat} format, translated
	 * `title` and a complete `icon` markup for each style.
	 *
	 * @readonly
	 * @type {Array.<module:image/imagestyle/imagestyleengine~ImageStyleFormat>}
	 */
	get imageStyles() {
		// Return cached value if there is one to improve the performance.
		if ( this._cachedImageStyles ) {
			return this._cachedImageStyles;
		}

		const styles = [];
		const editor = this.editor;
		const titles = this.localizedDefaultStylesTitles;
		const configuredStyles = editor.config.get( 'image.styles' );

		for ( let style of configuredStyles ) {
			style = normalizeStyle( style );

			// Localize the titles of the styles, if a title corresponds with
			// a localized default provided by the plugin.
			if ( titles[ style.title ] ) {
				style.title = titles[ style.title ];
			}

			// Don't override the user-defined styles array, clone it instead.
			styles.push( style );
		}

		return ( this._cachedImageStyles = styles );
	}

	/**
	 * Returns the default localized style titles provided by the plugin e.g. ready to
	 * use in the {@link #imageStyles}.
	 *
	 * The following localized titles corresponding with
	 * {@link module:image/imagestyle/imagestyleengine~ImageStyleEngine.defaultStyles} are available:
	 *
	 * * `'Full size image'`,
	 * * `'Side image'`,
	 * * `'Left aligned image'`,
	 * * `'Centered image'`,
	 * * `'Right aligned image'`
	 *
	 * @readonly
	 * @type {Object.<String,String>}
	 */
	get localizedDefaultStylesTitles() {
		const t = this.editor.t;

		return {
			'Full size image': t( 'Full size image' ),
			'Side image': t( 'Side image' ),
			'Left aligned image': t( 'Left aligned image' ),
			'Centered image': t( 'Centered image' ),
			'Right aligned image': t( 'Right aligned image' ),
		};
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageStyleEngine;


/**
 * Default image styles provided by the plugin, which can be referred in the
 * {@link module:image/image~ImageConfig#styles} config.
 *
 * Among them, 2 default semantic content styles are available:
 *
 * * `imageStyleFull` is a fullwidth image without any CSS class,
 * * `imageStyleSide` is a side image styled with the `image-style-side` CSS class
 *
 * There are also 3 styles focused on formatting:
 *
 * * `imageStyleAlignLeft` aligns the image to the left using the `image-style-align-left` class,
 * * `imageStyleAlignCenter` centers the image to the left using the `image-style-align-center` class,
 * * `imageStyleAlignRight` aligns the image to the right using the `image-style-align-right` class,
 *
 * @member {Object.<String,Object>}
 */
ImageStyleEngine.defaultStyles = {
	// This option is equal to situation when no style is applied.
	imageStyleFull: {
		name: 'imageStyleFull',
		title: 'Full size image',
		icon: __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_core_theme_icons_object_full_width_svg___default.a,
		isDefault: true
	},

	// This represents side image.
	imageStyleSide: {
		name: 'imageStyleSide',
		title: 'Side image',
		icon: __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_core_theme_icons_object_right_svg___default.a,
		className: 'image-style-side'
	},

	// This style represents an imaged aligned to the left.
	imageStyleAlignLeft: {
		name: 'imageStyleAlignLeft',
		title: 'Left aligned image',
		icon: __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_core_theme_icons_object_left_svg___default.a,
		className: 'image-style-align-left'
	},

	// This style represents a centered imaged.
	imageStyleAlignCenter: {
		name: 'imageStyleAlignCenter',
		title: 'Centered image',
		icon: __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_core_theme_icons_object_center_svg___default.a,
		className: 'image-style-align-center'
	},

	// This style represents an imaged aligned to the right.
	imageStyleAlignRight: {
		name: 'imageStyleAlignRight',
		title: 'Right aligned image',
		icon: __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_core_theme_icons_object_right_svg___default.a,
		className: 'image-style-align-right'
	}
};

/**
 * Default image style icons provided by the plugin, which can be referred in the
 * {@link module:image/image~ImageConfig#styles} config.
 *
 * There are 4 icons available: `'full'`, `'left'`, `'center'` and `'right'`.
 *
 * @member {Object.<String, String>}
 */
ImageStyleEngine.defaultIcons = {
	full: __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_core_theme_icons_object_full_width_svg___default.a,
	left: __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_core_theme_icons_object_left_svg___default.a,
	right: __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_core_theme_icons_object_right_svg___default.a,
	center: __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_core_theme_icons_object_center_svg___default.a,
};

// Normalizes an image style provided in the {@link module:image/image~ImageConfig#styles}
// and returns it in a {@link module:image/imagestyle/imagestyleengine~ImageStyleFormat}.
//
// @private
// @param {Object} style
// @returns {@link module:image/imagestyle/imagestyleengine~ImageStyleFormat}
function normalizeStyle( style ) {
	const defaultStyles = ImageStyleEngine.defaultStyles;
	const defaultIcons = ImageStyleEngine.defaultIcons;

	// Just the name of the style has been passed.
	if ( typeof style == 'string' ) {
		// If it's one of the defaults, just use it.
		// Clone the style to avoid overriding defaults.
		if ( defaultStyles[ style ] ) {
			style = Object.assign( {}, defaultStyles[ style ] );
		}
		// If it's just a name but none of the defaults, warn because probably it's a mistake.
		else {
			__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_utils_src_log__["a" /* default */].warn(
				'image-style-not-found: There is no such image style of given name.',
				{ name: style }
			);

			// Normalize the style anyway to prevent errors.
			style = {
				name: style
			};
		}
	}

	// If an object style has been passed and if the name matches one of the defaults,
	// extend it with defaults  the user wants to customize a default style.
	// Note: Don't override the userdefined style object, clone it instead.
	else if ( defaultStyles[ style.name ] ) {
		const defaultStyle = defaultStyles[ style.name ];
		const extendedStyle = Object.assign( {}, style );

		for ( const prop in defaultStyle ) {
			if ( !style.hasOwnProperty( prop ) ) {
				extendedStyle[ prop ] = defaultStyle[ prop ];
			}
		}

		style = extendedStyle;
	}

	// If an icon is defined as a string and correspond with a name
	// in default icons, use the default icon provided by the plugin.
	if ( typeof style.icon == 'string' && defaultIcons[ style.icon ] ) {
		style.icon = defaultIcons[ style.icon ];
	}

	return style;
}

/**
 * Image style format descriptor.
 *
 *		import fullWidthIcon from 'path/to/icon.svg`;
 *
 *		const imageStyleFormat = {
 *			name: 'fullSizeImage',
 *			icon: fullWidthIcon,
 *			title: 'Full size image',
 *			className: 'image-full-size'
 *		}
 *
 * @typedef {Object} module:image/imagestyle/imagestyleengine~ImageStyleFormat
 * @property {String} name The unique name of the style. It will be used to:
 * * register the {@link module:core/command~Command command} which will apply this style,
 * * store the style's button in the editor {@link module:ui/componentfactory~ComponentFactory},
 * * store the style in the `imageStyle` model attribute.
 * @property {Boolean} [isDefault] When set, the style will be used as the default one.
 * A default style does not apply any CSS class to the view element.
 * @property {String} icon One of the following to be used when creating the style's button:
 *  * An SVG icon source (as an XML string),
 *  * One of {@link module:image/imagestyle/imagestyleengine~ImageStyleEngine.defaultIcons} to use a default icon provided by the plugin.
 * @property {String} title The style's title.
 * @property {String} className The CSS class used to represent the style in view.
 */


/***/ }),
/* 536 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__image_utils__ = __webpack_require__(35);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagestyle/imagestylecommand
 */




/**
 * The image style command. It is used to apply different image styles.
 *
 * @extends module:core/command~Command
 */
class ImageStyleCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * Creates an instance of the image style command. Each command instance is handling one style.
	 *
	 * @param {module:core/editor/editor~Editor} editor The editor instance.
	 * @param {module:image/imagestyle/imagestyleengine~ImageStyleFormat} styles A style to be applied by this command.
	 */
	constructor( editor, style ) {
		super( editor );

		/**
		 * The value of the command &mdash; `true` if a style handled by the command is applied on a currently selected image,
		 * `false` otherwise.
		 *
		 * @readonly
		 * @observable
		 * @member {Boolean} #value
		 */

		/**
		 * A style handled by this command.
		 *
		 * @readonly
		 * @member {module:image/imagestyle/imagestyleengine~ImageStyleFormat} #style
		 */
		this.style = style;
	}

	/**
	 * @inheritDoc
	 */
	refresh() {
		const element = this.editor.document.selection.getSelectedElement();

		this.isEnabled = Object(__WEBPACK_IMPORTED_MODULE_1__image_utils__["a" /* isImage */])( element );

		if ( !element ) {
			this.value = false;
		} else if ( this.style.isDefault ) {
			this.value = !element.hasAttribute( 'imageStyle' );
		} else {
			this.value = ( element.getAttribute( 'imageStyle' ) == this.style.name );
		}
	}

	/**
	 * Executes the command.
	 *
	 * @fires execute
	 * @param {Object} options
	 * @param {module:engine/model/batch~Batch} [options.batch] A batch to collect all the change steps. A new batch will be
	 * created if this option is not set.
	 */
	execute( options = {} ) {
		if ( this.value ) {
			return;
		}

		const doc = this.editor.document;
		const imageElement = doc.selection.getSelectedElement();

		doc.enqueueChanges( () => {
			const batch = options.batch || doc.batch();

			// Default style means that there is no `imageStyle` attribute in the model.
			// https://github.com/ckeditor/ckeditor5-image/issues/147
			if ( this.style.isDefault ) {
				batch.removeAttribute( imageElement, 'imageStyle' );
			} else {
				batch.setAttribute( imageElement, 'imageStyle', this.style.name );
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageStyleCommand;



/***/ }),
/* 537 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = modelToViewStyleAttribute;
/* harmony export (immutable) */ __webpack_exports__["b"] = viewToModelStyleAttribute;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__image_utils__ = __webpack_require__(35);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagestyle/converters
 */



/**
 * Returns a converter for the `imageStyle` attribute. It can be used for adding, changing and removing the attribute.
 *
 * @param {Object} styles An object containing available styles. See {@link module:image/imagestyle/imagestyleengine~ImageStyleFormat}
 * for more details.
 * @returns {Function} A model-to-view attribute converter.
 */
function modelToViewStyleAttribute( styles ) {
	return ( evt, data, consumable, conversionApi ) => {
		const eventType = evt.name.split( ':' )[ 0 ];
		const consumableType = eventType + ':imageStyle';

		if ( !consumable.test( data.item, consumableType ) ) {
			return;
		}

		// Check if there is class name associated with given value.
		const newStyle = getStyleByName( data.attributeNewValue, styles );
		const oldStyle = getStyleByName( data.attributeOldValue, styles );
		const viewElement = conversionApi.mapper.toViewElement( data.item );

		const isRemovalHandled = handleRemoval( eventType, oldStyle, viewElement );
		const isAdditionHandled = handleAddition( eventType, newStyle, viewElement );

		// https://github.com/ckeditor/ckeditor5-image/issues/132
		if ( isRemovalHandled || isAdditionHandled ) {
			consumable.consume( data.item, consumableType );
		}
	};
}

/**
 * Returns a view-to-model converter converting image CSS classes to a proper value in the model.
 *
 * @param {Array.<module:image/imagestyle/imagestyleengine~ImageStyleFormat>} styles Styles for which the converter is created.
 * @returns {Function} A view-to-model converter.
 */
function viewToModelStyleAttribute( styles ) {
	// Convert only nondefault styles.
	const filteredStyles = styles.filter( style => !style.isDefault );

	return ( evt, data, consumable, conversionApi ) => {
		for ( const style of filteredStyles ) {
			viewToModelImageStyle( style, data, consumable, conversionApi );
		}
	};
}

// Converter from view to model converting single style.
// For more information see {@link module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher};
//
// @param {module:image/imagestyle/imagestyleengine~ImageStyleFormat} style
// @param {Object} data
// @param {module:engine/conversion/viewconsumable~ViewConsumable} consumable
// @param {Object} conversionApi
function viewToModelImageStyle( style, data, consumable, conversionApi ) {
	const viewFigureElement = data.input;
	const modelImageElement = data.output;

	// *** Step 1: Validate conversion.
	// Check if view element has proper class to consume.
	if ( !consumable.test( viewFigureElement, { class: style.className } ) ) {
		return;
	}

	// Check if figure is converted to image.
	if ( !Object(__WEBPACK_IMPORTED_MODULE_0__image_utils__["a" /* isImage */])( modelImageElement ) ) {
		return;
	}

	// Check if image element can be placed in current context wit additional attribute.
	const attributes = [ ...modelImageElement.getAttributeKeys(), 'imageStyle' ];

	if ( !conversionApi.schema.check( { name: 'image', inside: data.context, attributes } ) ) {
		return;
	}

	// *** Step2: Convert to model.
	consumable.consume( viewFigureElement, { class: style.className } );
	modelImageElement.setAttribute( 'imageStyle', style.name );
}

// Returns style with given `name` from array of styles.
//
// @param {String} name
// @param {Array.<module:image/imagestyle/imagestyleengine~ImageStyleFormat> } styles
// @return {module:image/imagestyle/imagestyleengine~ImageStyleFormat|undefined}
function getStyleByName( name, styles ) {
	for ( const style of styles ) {
		if ( style.name === name ) {
			return style;
		}
	}
}

// Handles converting removal of the attribute.
// Returns `true` when handling was processed correctly and further conversion can be performed.
//
// @param {String} eventType Type of the event.
// @param {module:image/imagestyle/imagestyleengine~ImageStyleFormat} style
// @param {module:engine/view/element~Element} viewElement
// @returns {Boolean} Whether the change was handled.
function handleRemoval( eventType, style, viewElement ) {
	if ( style && ( eventType == 'changeAttribute' || eventType == 'removeAttribute' ) ) {
		viewElement.removeClass( style.className );

		return true;
	}

	return false;
}

// Handles converting addition of the attribute.
// Returns `true` when handling was processed correctly and further conversion can be performed.
//
// @param {String} eventType Type of the event.
// @param {module:image/imagestyle/imagestyleengine~ImageStyleFormat} style
// @param {module:engine/view/element~Element} viewElement
// @returns {Boolean} Whether the change was handled.
function handleAddition( evenType, style, viewElement ) {
	if ( style && ( evenType == 'addAttribute' || evenType == 'changeAttribute' ) ) {
		viewElement.addClass( style.className );

		return true;
	}

	return false;
}


/***/ }),
/* 538 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 16h16v1H2v-1zm15-2H3V6h14v8zm-1-7H4v6h12V7zM2 3h16v1H2V3z\"/></svg>"

/***/ }),
/* 539 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 15h16v1H2v-1zm11-3h5v1h-5v-1zm-2 1H2V6h9v7zm-1-6H3v5h7V7zm3 2h5v1h-5V9zm0-3h5v1h-5V6zM2 3h16v1H2V3z\"/></svg>"

/***/ }),
/* 540 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" stroke-linejoin=\"round\" stroke-miterlimit=\"1.414\"><path d=\"M2 15h16v1H2v-1zm13-2H5V6h10v7zm-1-6H6v5h8V7zM2 3h16v1H2V3z\" fill-rule=\"nonzero\"/></svg>"

/***/ }),
/* 541 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18 16H2v-1h16v1zM6.978 13H2v-1h4.978v1zM18 6v7H9V6h9zm-1 6V7h-7v5h7zM6.978 10H2V9h4.978v1zm0-3H2V6h4.978v1zM18 4H2V3h16v1z\"/></svg>"

/***/ }),
/* 542 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_toolbar_toolbarview__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_panel_balloon_contextualballoon__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__image_utils__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__image_ui_utils__ = __webpack_require__(280);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module image/imagetoolbar
 */







const balloonClassName = 'ck-toolbar-container ck-editor-toolbar-container';

/**
 * The image toolbar class. Creates an image toolbar that shows up when the image widget is selected.
 *
 * Toolbar components are created using the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}
 * based on the {@link module:core/editor/editor~Editor#config configuration} stored under `image.toolbar`.
 *
 * The toolbar uses the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon}.
 *
 * @extends module:core/plugin~Plugin
 */
class ImageToolbar extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_panel_balloon_contextualballoon__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'ImageToolbar';
	}

	/**
	 * @inheritDoc
	 */
	afterInit() {
		const editor = this.editor;
		const toolbarConfig = editor.config.get( 'image.toolbar' );

		// Don't add the toolbar if there is no configuration.
		if ( !toolbarConfig || !toolbarConfig.length ) {
			return;
		}

		/**
		 * The contextual balloon plugin instance.
		 *
		 * @private
		 * @member {module:ui/panel/balloon/contextualballoon~ContextualBalloon}
		 */
		this._balloon = this.editor.plugins.get( 'ContextualBalloon' );

		/**
		 * A `ToolbarView` instance used to display the buttons specific for image
		 * editing.
		 *
		 * @protected
		 * @type {module:ui/toolbar/toolbarview~ToolbarView}
		 */
		this._toolbar = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_toolbar_toolbarview__["a" /* default */]();

		// Add CSS class to the toolbar.
		this._toolbar.extendTemplate( {
			attributes: {
				class: 'ck-editor-toolbar'
			}
		} );

		// Add buttons to the toolbar.
		this._toolbar.fillFromConfig( toolbarConfig, editor.ui.componentFactory );

		// Show balloon panel each time image widget is selected.
		this.listenTo( editor.editing.view, 'render', () => {
			this._checkIsVisible();
		}, { priority: 'low' } );

		// There is no render method after focus is back in editor, we need to check if balloon panel should be visible.
		this.listenTo( editor.ui.focusTracker, 'change:isFocused', () => {
			this._checkIsVisible();
		}, { priority: 'low' } );
	}

	/**
	 * Checks whether the toolbar should show up or hide depending on the
	 * current selection.
	 *
	 * @private
	 */
	_checkIsVisible() {
		const editor = this.editor;

		if ( !editor.ui.focusTracker.isFocused ) {
			this._hideToolbar();
		} else {
			if ( Object(__WEBPACK_IMPORTED_MODULE_3__image_utils__["b" /* isImageWidgetSelected */])( editor.editing.view.selection ) ) {
				this._showToolbar();
			} else {
				this._hideToolbar();
			}
		}
	}

	/**
	 * Shows the {@link #_toolbar} in the {@link #_balloon}.
	 *
	 * @private
	 */
	_showToolbar() {
		const editor = this.editor;

		if ( this._isVisible ) {
			Object(__WEBPACK_IMPORTED_MODULE_4__image_ui_utils__["b" /* repositionContextualBalloon */])( editor );
		} else {
			if ( !this._balloon.hasView( this._toolbar ) ) {
				this._balloon.add( {
					view: this._toolbar,
					position: Object(__WEBPACK_IMPORTED_MODULE_4__image_ui_utils__["a" /* getBalloonPositionData */])( editor ),
					balloonClassName
				} );
			}
		}
	}

	/**
	 * Removes the {@link #_toolbar} from the {@link #_balloon}.
	 *
	 * @private
	 */
	_hideToolbar() {
		if ( !this._isVisible ) {
			return;
		}

		this._balloon.remove( this._toolbar );
	}

	/**
	 * Returns `true` when the {@link #_toolbar} is the visible view
	 * in the {@link #_balloon}.
	 *
	 * @private
	 * @type {Boolean}
	 */
	get _isVisible() {
		return this._balloon.visibleView == this._toolbar;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageToolbar;


/**
 * Items to be placed in the image toolbar.
 * The option is used by the {@link module:image/imagetoolbar~ImageToolbar} feature.
 *
 * Assuming that you use the following features:
 *
 * * {@link module:image/imagestyle~ImageStyle} (with a default configuration),
 * * {@link module:image/imagetextalternative~ImageTextAlternative}.
 *
 * Three toolbar items will be available in {@link module:ui/componentfactory~ComponentFactory}:
 * `'imageStyleFull'`, `'imageStyleSide'`, and `'imageTextAlternative'` so you can configure the toolbar like this:
 *
 *		const imageConfig = {
 *			toolbar: [ 'imageStyleFull', 'imageStyleSide', '|', 'imageTextAlternative' ]
 *		};
 *
 * Of course, the same buttons can also be used in the
 * {@link module:core/editor/editorconfig~EditorConfig#toolbar main editor toolbar}.
 *
 * Read more about configuring toolbar in {@link module:core/editor/editorconfig~EditorConfig#toolbar}.
 *
 * @member {Array.<String>} module:image/image~ImageConfig#toolbar
 */


/***/ }),
/* 543 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_observer_clickobserver__ = __webpack_require__(544);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_view_range__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__linkengine__ = __webpack_require__(545);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__linkelement__ = __webpack_require__(281);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_ui_src_panel_balloon_contextualballoon__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_ui_src_bindings_clickoutsidehandler__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_ui_src_button_buttonview__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ui_linkformview__ = __webpack_require__(548);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__theme_icons_link_svg__ = __webpack_require__(549);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__theme_icons_link_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__theme_icons_link_svg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__theme_theme_scss__ = __webpack_require__(550);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__theme_theme_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__theme_theme_scss__);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module link/link
 */
















const linkKeystroke = 'Ctrl+K';

/**
 * The link plugin. It introduces the Link and Unlink buttons and the <kbd>Ctrl+K</kbd> keystroke.
 *
 * It uses the {@link module:link/linkengine~LinkEngine link engine plugin} and the
 * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon plugin}.
 *
 * @extends module:core/plugin~Plugin
 */
class Link extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_3__linkengine__["a" /* default */], __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_ui_src_panel_balloon_contextualballoon__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'Link';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;

		editor.editing.view.addObserver( __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_observer_clickobserver__["a" /* default */] );

		/**
		 * The form view displayed inside the balloon.
		 *
		 * @member {module:link/ui/linkformview~LinkFormView}
		 */
		this.formView = this._createForm();

		/**
		 * The contextual balloon plugin instance.
		 *
		 * @private
		 * @member {module:ui/panel/balloon/contextualballoon~ContextualBalloon}
		 */
		this._balloon = editor.plugins.get( __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_ui_src_panel_balloon_contextualballoon__["a" /* default */] );

		// Create toolbar buttons.
		this._createToolbarLinkButton();

		// Attach lifecycle actions to the the balloon.
		this._attachActions();
	}

	/**
	 * Creates the {@link module:link/ui/linkformview~LinkFormView} instance.
	 *
	 * @private
	 * @returns {module:link/ui/linkformview~LinkFormView} The link form instance.
	 */
	_createForm() {
		const editor = this.editor;
		const formView = new __WEBPACK_IMPORTED_MODULE_8__ui_linkformview__["a" /* default */]( editor.locale );
		const linkCommand = editor.commands.get( 'link' );
		const unlinkCommand = editor.commands.get( 'unlink' );

		formView.urlInputView.bind( 'value' ).to( linkCommand, 'value' );

		// Form elements should be read-only when corresponding commands are disabled.
		formView.urlInputView.bind( 'isReadOnly' ).to( linkCommand, 'isEnabled', value => !value );
		formView.saveButtonView.bind( 'isEnabled' ).to( linkCommand );
		formView.unlinkButtonView.bind( 'isEnabled' ).to( unlinkCommand );

		// Execute link command after clicking on formView `Save` button.
		this.listenTo( formView, 'submit', () => {
			editor.execute( 'link', formView.urlInputView.inputView.element.value );
			this._hidePanel( true );
		} );

		// Execute unlink command after clicking on formView `Unlink` button.
		this.listenTo( formView, 'unlink', () => {
			editor.execute( 'unlink' );
			this._hidePanel( true );
		} );

		// Hide the panel after clicking on formView `Cancel` button.
		this.listenTo( formView, 'cancel', () => this._hidePanel( true ) );

		// Close the panel on esc key press when the form has focus.
		formView.keystrokes.set( 'Esc', ( data, cancel ) => {
			this._hidePanel( true );
			cancel();
		} );

		return formView;
	}

	/**
	 * Creates a toolbar Link button. Clicking this button will show
	 * a {@link #_balloon} attached to the selection.
	 *
	 * @private
	 */
	_createToolbarLinkButton() {
		const editor = this.editor;
		const linkCommand = editor.commands.get( 'link' );
		const t = editor.t;

		// Handle the `Ctrl+K` keystroke and show the panel.
		editor.keystrokes.set( linkKeystroke, ( keyEvtData, cancel ) => {
			// Prevent focusing the search bar in FF and opening new tab in Edge. #153, #154.
			cancel();

			if ( linkCommand.isEnabled ) {
				this._showPanel( true );
			}
		} );

		editor.ui.componentFactory.add( 'link', locale => {
			const button = new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_ui_src_button_buttonview__["a" /* default */]( locale );

			button.isEnabled = true;
			button.label = t( 'Link' );
			button.icon = __WEBPACK_IMPORTED_MODULE_9__theme_icons_link_svg___default.a;
			button.keystroke = linkKeystroke;
			button.tooltip = true;

			// Bind button to the command.
			button.bind( 'isEnabled' ).to( linkCommand, 'isEnabled' );

			// Show the panel on button click.
			this.listenTo( button, 'execute', () => this._showPanel( true ) );

			return button;
		} );
	}

	/**
	 * Attaches actions that control whether the balloon panel containing the
	 * {@link #formView} is visible or not.
	 *
	 * @private
	 */
	_attachActions() {
		const viewDocument = this.editor.editing.view;

		// Handle click on view document and show panel when selection is placed inside the link element.
		// Keep panel open until selection will be inside the same link element.
		this.listenTo( viewDocument, 'click', () => {
			const parentLink = this._getSelectedLinkElement();

			if ( parentLink ) {
				// Then show panel but keep focus inside editor editable.
				this._showPanel();
			}
		} );

		// Focus the form if the balloon is visible and the Tab key has been pressed.
		this.editor.keystrokes.set( 'Tab', ( data, cancel ) => {
			if ( this._balloon.visibleView === this.formView && !this.formView.focusTracker.isFocused ) {
				this.formView.focus();
				cancel();
			}
		}, {
			// Use the high priority because the link UI navigation is more important
			// than other feature's actions, e.g. list indentation.
			// https://github.com/ckeditor/ckeditor5-link/issues/146
			priority: 'high'
		} );

		// Close the panel on the Esc key press when the editable has focus and the balloon is visible.
		this.editor.keystrokes.set( 'Esc', ( data, cancel ) => {
			if ( this._balloon.visibleView === this.formView ) {
				this._hidePanel();
				cancel();
			}
		} );

		// Close on click outside of balloon panel element.
		Object(__WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_ui_src_bindings_clickoutsidehandler__["a" /* default */])( {
			emitter: this.formView,
			activator: () => this._balloon.hasView( this.formView ),
			contextElements: [ this._balloon.view.element ],
			callback: () => this._hidePanel()
		} );
	}

	/**
	 * Adds the {@link #formView} to the {@link #_balloon}.
	 *
	 * @protected
	 * @param {Boolean} [focusInput=false] When `true`, the link form will be focused on panel show.
	 */
	_showPanel( focusInput ) {
		const editor = this.editor;
		const linkCommand = editor.commands.get( 'link' );
		const unlinkCommand = editor.commands.get( 'unlink' );
		const editing = editor.editing;
		const showViewDocument = editing.view;
		const showIsCollapsed = showViewDocument.selection.isCollapsed;
		const showSelectedLink = this._getSelectedLinkElement();

		this.listenTo( showViewDocument, 'render', () => {
			const renderSelectedLink = this._getSelectedLinkElement();
			const renderIsCollapsed = showViewDocument.selection.isCollapsed;
			const hasSellectionExpanded = showIsCollapsed && !renderIsCollapsed;

			// Hide the panel if:
			//   * the selection went out of the original link element
			//     (e.g. paragraph containing the link was removed),
			//   * the selection has expanded
			// upon the #render event.
			if ( hasSellectionExpanded || showSelectedLink !== renderSelectedLink ) {
				this._hidePanel( true );
			}
			// Update the position of the panel when:
			//  * the selection remains in the original link element,
			//  * there was no link element in the first place, i.e. creating a new link
			else {
				// If still in a link element, simply update the position of the balloon.
				// If there was no link, upon #render, the balloon must be moved
				// to the new position in the editing view (a new native DOM range).
				this._balloon.updatePosition( this._getBalloonPositionData() );
			}
		} );

		if ( this._balloon.hasView( this.formView ) ) {
			// Check if formView should be focused and focus it if is visible.
			if ( focusInput && this._balloon.visibleView === this.formView ) {
				this.formView.urlInputView.select();
			}
		} else {
			this._balloon.add( {
				view: this.formView,
				position: this._getBalloonPositionData()
			} );

			if ( focusInput ) {
				this.formView.urlInputView.select();
			}
		}

		// https://github.com/ckeditor/ckeditor5-link/issues/53
		this.formView.unlinkButtonView.isVisible = unlinkCommand.isEnabled;

		// Make sure that each time the panel shows up, the URL field remains in sync with the value of
		// the command. If the user typed in the input, then canceled the balloon (`urlInputView#value` stays
		// unaltered) and re-opened it without changing the value of the link command (e.g. because they
		// clicked the same link), they would see the old value instead of the actual value of the command.
		// https://github.com/ckeditor/ckeditor5-link/issues/78
		// https://github.com/ckeditor/ckeditor5-link/issues/123
		this.formView.urlInputView.inputView.element.value = linkCommand.value || '';
	}

	/**
	 * Removes the {@link #formView} from the {@link #_balloon}.
	 *
	 * See {@link #_showPanel}.
	 *
	 * @protected
	 * @param {Boolean} [focusEditable=false] When `true`, editable focus will be restored on panel hide.
	 */
	_hidePanel( focusEditable ) {
		this.stopListening( this.editor.editing.view, 'render' );

		if ( !this._balloon.hasView( this.formView ) ) {
			return;
		}

		if ( focusEditable ) {
			this.editor.editing.view.focus();
		}

		this.stopListening( this.editor.editing.view, 'render' );
		this._balloon.remove( this.formView );
	}

	/**
	 * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
	 * to the target element or selection.
	 *
	 * If the selection is collapsed and inside a link element, the panel will be attached to the
	 * entire link element. Otherwise, it will be attached to the selection.
	 *
	 * @private
	 * @returns {module:utils/dom/position~Options}
	 */
	_getBalloonPositionData() {
		const viewDocument = this.editor.editing.view;
		const targetLink = this._getSelectedLinkElement();

		const target = targetLink ?
			// When selection is inside link element, then attach panel to this element.
			viewDocument.domConverter.mapViewToDom( targetLink ) :
			// Otherwise attach panel to the selection.
			viewDocument.domConverter.viewRangeToDom( viewDocument.selection.getFirstRange() );

		return { target };
	}

	/**
	 * Returns the {@link module:link/linkelement~LinkElement} under
	 * the {@link module:engine/view/document~Document editing view's} selection or `null`
	 * if there is none.
	 *
	 * **Note**: For a noncollapsed selection the `LinkElement` is only returned when **fully**
	 * selected and the **only** element within the selection boundaries.
	 *
	 * @private
	 * @returns {module:link/linkelement~LinkElement|null}
	 */
	_getSelectedLinkElement() {
		const selection = this.editor.editing.view.selection;

		if ( selection.isCollapsed ) {
			return findLinkElementAncestor( selection.getFirstPosition() );
		} else {
			// The range for fully selected link is usually anchored in adjacent text nodes.
			// Trim it to get closer to the actual LinkElement.
			const range = selection.getFirstRange().getTrimmed();
			const startLink = findLinkElementAncestor( range.start );
			const endLink = findLinkElementAncestor( range.end );

			if ( !startLink || startLink != endLink ) {
				return null;
			}

			// Check if the LinkElement is fully selected.
			if ( __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_view_range__["a" /* default */].createIn( startLink ).getTrimmed().isEqual( range ) ) {
				return startLink;
			} else {
				return null;
			}
		}
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Link;


// Returns a `LinkElement` if there's one among the ancestors of the provided `Position`.
//
// @private
// @param {module:engine/view/position~Position} View position to analyze.
// @returns {module:link/linkelement~LinkElement|null} LinkElement at the position or null.
function findLinkElementAncestor( position ) {
	return position.getAncestors().find( ancestor => ancestor instanceof __WEBPACK_IMPORTED_MODULE_4__linkelement__["a" /* default */] );
}


/***/ }),
/* 544 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__domeventobserver__ = __webpack_require__(74);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/clickobserver
 */



/**
 * {@link module:engine/view/document~Document#event:click Click} event observer.
 *
 * Note that this observer is not available by default. To make it available it needs to be added to
 * {@link module:engine/view/document~Document}
 * by a {@link module:engine/view/document~Document#addObserver} method.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */
class ClickObserver extends __WEBPACK_IMPORTED_MODULE_0__domeventobserver__["a" /* default */] {
	constructor( document ) {
		super( document );

		this.domEventType = 'click';
	}

	onDomEvent( domEvent ) {
		this.fire( domEvent.type, domEvent );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ClickObserver;


/**
 * Fired when one of the editables has been clicked.
 *
 * Introduced by {@link module:engine/view/observer/clickobserver~ClickObserver}.
 *
 * Note that this event is not available by default. To make it available
 * {@link module:engine/view/observer/clickobserver~ClickObserver} needs to be added
 * to {@link module:engine/view/document~Document} by a {@link module:engine/view/document~Document#addObserver} method.
 *
 * @see module:engine/view/observer/clickobserver~ClickObserver
 * @event module:engine/view/document~Document#event:click
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */


/***/ }),
/* 545 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__linkelement__ = __webpack_require__(281);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__linkcommand__ = __webpack_require__(546);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__unlinkcommand__ = __webpack_require__(547);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module link/linkengine
 */








/**
 * The link engine feature.
 *
 * It introduces the `linkHref="url"` attribute in the model which renders to the view as a `<a href="url">` element.
 *
 * @extends module:core/plugin~Plugin
 */
class LinkEngine extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;
		const data = editor.data;
		const editing = editor.editing;

		// Allow link attribute on all inline nodes.
		editor.document.schema.allow( { name: '$inline', attributes: 'linkHref', inside: '$block' } );
		// Temporary workaround. See https://github.com/ckeditor/ckeditor5/issues/477.
		editor.document.schema.allow( { name: '$inline', attributes: 'linkHref', inside: '$clipboardHolder' } );

		// Build converter from model to view for data and editing pipelines.
		Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_conversion_buildmodelconverter__["a" /* default */])().for( data.modelToView, editing.modelToView )
			.fromAttribute( 'linkHref' )
			.toElement( linkHref => {
				const linkElement = new __WEBPACK_IMPORTED_MODULE_3__linkelement__["a" /* default */]( 'a', { href: linkHref } );

				// https://github.com/ckeditor/ckeditor5-link/issues/121
				linkElement.priority = 5;

				return linkElement;
			} );

		// Build converter from view to model for data pipeline.
		Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_conversion_buildviewconverter__["a" /* default */])().for( data.viewToModel )
			// Convert <a> with href (value doesn't matter).
			.from( { name: 'a', attribute: { href: /.?/ } } )
			.toAttribute( viewElement => ( {
				key: 'linkHref',
				value: viewElement.getAttribute( 'href' )
			} ) );

		// Create linking commands.
		editor.commands.add( 'link', new __WEBPACK_IMPORTED_MODULE_4__linkcommand__["a" /* default */]( editor ) );
		editor.commands.add( 'unlink', new __WEBPACK_IMPORTED_MODULE_5__unlinkcommand__["a" /* default */]( editor ) );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LinkEngine;



/***/ }),
/* 546 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_text__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__findlinkrange__ = __webpack_require__(282);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module link/linkcommand
 */






/**
 * The link command. It is used by the {@link module:link/link~Link link feature}.
 *
 * @extends module:core/command~Command
 */
class LinkCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * The value of the `'linkHref'` attribute if the start of the selection is located in a node with this attribute.
	 *
	 * @observable
	 * @readonly
	 * @member {Object|undefined} #value
	 */

	/**
	 * @inheritDoc
	 */
	refresh() {
		const doc = this.editor.document;

		this.value = doc.selection.getAttribute( 'linkHref' );
		this.isEnabled = doc.schema.checkAttributeInSelection( doc.selection, 'linkHref' );
	}

	/**
	 * Executes the command.
	 *
	 * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to
	 * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).
	 *
	 * When the selection is collapsed and is not inside the text with the `linkHref` attribute, the
	 * new {@link module:engine/model/text~Text Text node} with the `linkHref` attribute will be inserted in place of caret, but
	 * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.
	 * The selection will be updated to wrap the just inserted text node.
	 *
	 * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.
	 *
	 * @fires execute
	 * @param {String} href Link destination.
	 */
	execute( href ) {
		const doc = this.editor.document;
		const selection = doc.selection;

		doc.enqueueChanges( () => {
			// Keep it as one undo step.
			const batch = doc.batch();

			// If selection is collapsed then update selected link or insert new one at the place of caret.
			if ( selection.isCollapsed ) {
				const position = selection.getFirstPosition();

				// When selection is inside text with `linkHref` attribute.
				if ( selection.hasAttribute( 'linkHref' ) ) {
					// Then update `linkHref` value.
					const linkRange = Object(__WEBPACK_IMPORTED_MODULE_3__findlinkrange__["a" /* default */])( selection.getFirstPosition(), selection.getAttribute( 'linkHref' ) );

					batch.setAttribute( linkRange, 'linkHref', href );

					// Create new range wrapping changed link.
					selection.setRanges( [ linkRange ] );
				}
				// If not then insert text node with `linkHref` attribute in place of caret.
				else {
					const node = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_text__["a" /* default */]( href, { linkHref: href } );

					batch.insert( position, node );

					// Create new range wrapping created node.
					selection.setRanges( [ __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_range__["a" /* default */].createOn( node ) ] );
				}
			} else {
				// If selection has non-collapsed ranges, we change attribute on nodes inside those ranges
				// omitting nodes where `linkHref` attribute is disallowed.
				const ranges = doc.schema.getValidRanges( selection.getRanges(), 'linkHref' );

				for ( const range of ranges ) {
					batch.setAttribute( range, 'linkHref', href );
				}
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LinkCommand;



/***/ }),
/* 547 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__findlinkrange__ = __webpack_require__(282);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module link/unlinkcommand
 */




/**
 * The unlink command. It is used by the {@link module:link/link~Link link plugin}.
 *
 * @extends module:core/command~Command
 */
class UnlinkCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	refresh() {
		this.isEnabled = this.editor.document.selection.hasAttribute( 'linkHref' );
	}

	/**
	 * Executes the command.
	 *
	 * When the selection is collapsed, removes the `linkHref` attribute from each node with the same `linkHref` attribute value.
	 * When the selection is non-collapsed, removes the `linkHref` attribute from each node in selected ranges.
	 *
	 * @fires execute
	 */
	execute() {
		const document = this.editor.document;
		const selection = document.selection;

		document.enqueueChanges( () => {
			// Get ranges to unlink.
			const rangesToUnlink = selection.isCollapsed ?
				[ Object(__WEBPACK_IMPORTED_MODULE_1__findlinkrange__["a" /* default */])( selection.getFirstPosition(), selection.getAttribute( 'linkHref' ) ) ] : selection.getRanges();

			// Keep it as one undo step.
			const batch = document.batch();

			// Remove `linkHref` attribute from specified ranges.
			for ( const range of rangesToUnlink ) {
				batch.removeAttribute( range, 'linkHref' );
			}
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = UnlinkCommand;



/***/ }),
/* 548 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_view__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_viewcollection__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_labeledinput_labeledinputview__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_ui_src_inputtext_inputtextview__ = __webpack_require__(278);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_ui_src_bindings_submithandler__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_focustracker__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_ui_src_focuscycler__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keystrokehandler__ = __webpack_require__(49);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module link/ui/linkformview
 */













/**
 * The link form view controller class.
 *
 * See {@link module:link/ui/linkformview~LinkFormView}.
 *
 * @extends module:ui/view~View
 */
class LinkFormView extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_ui_src_view__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	constructor( locale ) {
		super( locale );

		const t = locale.t;

		/**
		 * Tracks information about DOM focus in the form.
		 *
		 * @readonly
		 * @member {module:utils/focustracker~FocusTracker}
		 */
		this.focusTracker = new __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_utils_src_focustracker__["a" /* default */]();

		/**
		 * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
		 *
		 * @readonly
		 * @member {module:utils/keystrokehandler~KeystrokeHandler}
		 */
		this.keystrokes = new __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_utils_src_keystrokehandler__["a" /* default */]();

		/**
		 * The URL input view.
		 *
		 * @member {module:ui/labeledinput/labeledinputview~LabeledInputView}
		 */
		this.urlInputView = this._createUrlInput();

		/**
		 * The Save button view.
		 *
		 * @member {module:ui/button/buttonview~ButtonView}
		 */
		this.saveButtonView = this._createButton( t( 'Save' ) );
		this.saveButtonView.type = 'submit';

		/**
		 * The Cancel button view.
		 *
		 * @member {module:ui/button/buttonview~ButtonView}
		 */
		this.cancelButtonView = this._createButton( t( 'Cancel' ), 'cancel' );

		/**
		 * The Unlink button view.
		 *
		 * @member {module:ui/button/buttonview~ButtonView}
		 */
		this.unlinkButtonView = this._createButton( t( 'Unlink' ), 'unlink' );

		/**
		 * A collection of views which can be focused in the form.
		 *
		 * @readonly
		 * @protected
		 * @member {module:ui/viewcollection~ViewCollection}
		 */
		this._focusables = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_ui_src_viewcollection__["a" /* default */]();

		/**
		 * Helps cycling over {@link #_focusables} in the form.
		 *
		 * @readonly
		 * @protected
		 * @member {module:ui/focuscycler~FocusCycler}
		 */
		this._focusCycler = new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_ui_src_focuscycler__["a" /* default */]( {
			focusables: this._focusables,
			focusTracker: this.focusTracker,
			keystrokeHandler: this.keystrokes,
			actions: {
				// Navigate form fields backwards using the Shift + Tab keystroke.
				focusPrevious: 'shift + tab',

				// Navigate form fields forwards using the Tab key.
				focusNext: 'tab'
			}
		} );

		this.saveButtonView.extendTemplate( {
			attributes: {
				class: [
					'ck-button-action'
				]
			}
		} );

		this.setTemplate( {
			tag: 'form',

			attributes: {
				class: [
					'ck-link-form',
				],

				// https://github.com/ckeditor/ckeditor5-link/issues/90
				tabindex: '-1'
			},

			children: [
				this.urlInputView,
				{
					tag: 'div',

					attributes: {
						class: [
							'ck-link-form__actions'
						]
					},

					children: [
						this.saveButtonView,
						this.cancelButtonView,
						this.unlinkButtonView
					]
				}
			]
		} );
	}

	/**
	 * @inheritDoc
	 */
	render() {
		super.render();

		Object(__WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_ui_src_bindings_submithandler__["a" /* default */])( {
			view: this
		} );

		const childViews = [
			this.urlInputView,
			this.saveButtonView,
			this.cancelButtonView,
			this.unlinkButtonView
		];

		childViews.forEach( v => {
			// Register the view as focusable.
			this._focusables.add( v );

			// Register the view in the focus tracker.
			this.focusTracker.add( v.element );
		} );

		// Start listening for the keystrokes coming from #element.
		this.keystrokes.listenTo( this.element );
	}

	/**
	 * Focuses the fist {@link #_focusables} in the form.
	 */
	focus() {
		this._focusCycler.focusFirst();
	}

	/**
	 * Creates a labeled input view.
	 *
	 * @private
	 * @returns {module:ui/labeledinput/labeledinputview~LabeledInputView} Labeled input view instance.
	 */
	_createUrlInput() {
		const t = this.locale.t;

		const labeledInput = new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_ui_src_labeledinput_labeledinputview__["a" /* default */]( this.locale, __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_ui_src_inputtext_inputtextview__["a" /* default */] );

		labeledInput.label = t( 'Link URL' );
		labeledInput.inputView.placeholder = 'https://example.com';

		return labeledInput;
	}

	/**
	 * Creates a button view.
	 *
	 * @private
	 * @param {String} label The button label
	 * @param {String} [eventName] An event name that the `ButtonView#execute` event will be delegated to.
	 * @returns {module:ui/button/buttonview~ButtonView} The button view instance.
	 */
	_createButton( label, eventName ) {
		const button = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_ui_src_button_buttonview__["a" /* default */]( this.locale );

		button.label = label;
		button.withText = true;

		if ( eventName ) {
			button.delegate( 'execute' ).to( this, eventName );
		}

		return button;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LinkFormView;


/**
 * Fired when the form view is submitted (when one of the children triggered the submit event),
 * e.g. click on {@link #saveButtonView}.
 *
 * @event submit
 */

/**
 * Fired when the form view is canceled, e.g. click on {@link #cancelButtonView}.
 *
 * @event cancel
 */

/**
 * Fired when the {@link #unlinkButtonView} is clicked.
 *
 * @event unlink
 */


/***/ }),
/* 549 */
/***/ (function(module, exports) {

module.exports = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><g fill=\"#222\" fill-rule=\"evenodd\"><path d=\"M14.2 10.956l1.227-1.227a3.995 3.995 0 0 0-.002-5.654 4 4 0 0 0-5.654-.002L7.698 6.145a3.995 3.995 0 0 0 .003 5.654c.39.39.84.682 1.32.878l-.305-.307.638-.638a2.99 2.99 0 0 1-.946-.64 2.995 2.995 0 0 1-.003-4.24l2.073-2.072a3 3 0 0 1 4.242 4.242l-1.226 1.227.707.707z\"/><path d=\"M10.166 7.405c.41.192.795.457 1.133.796a3.995 3.995 0 0 1 .003 5.654l-2.073 2.072a4 4 0 0 1-5.654-.002 3.995 3.995 0 0 1-.002-5.654l1.362-1.363.707.707-1.362 1.363a3 3 0 0 0 4.243 4.243l2.072-2.073a2.995 2.995 0 0 0-.003-4.24 2.987 2.987 0 0 0-1.196-.733l.77-.77z\"/></g></svg>"

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(551);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(32)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss", function() {
		var newContent = require("!!../../../css-loader/index.js??ref--3-1!../../../sass-loader/lib/loader.js!./theme.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(31)(false);
// imports


// module
exports.push([module.i, ".ck-link-form{padding:1.2em;overflow:hidden}.ck-link-form:focus{outline:none}.ck-link-form .ck-input-text{width:100%}.ck-link-form .ck-label{margin-bottom:.2em}.ck-link-form__actions{clear:both;padding-top:1.2em}.ck-link-form__actions .ck-button{float:right}.ck-link-form__actions .ck-button+.ck-button{margin-right:.64em}.ck-link-form__actions .ck-button:last-child{float:left;margin-right:2.56em}", ""]);

// exports


/***/ }),
/* 552 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__listengine__ = __webpack_require__(553);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__theme_icons_numberedlist_svg__ = __webpack_require__(558);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__theme_icons_numberedlist_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__theme_icons_numberedlist_svg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__theme_icons_bulletedlist_svg__ = __webpack_require__(559);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__theme_icons_bulletedlist_svg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__theme_icons_bulletedlist_svg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_ui_src_button_buttonview__ = __webpack_require__(25);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module list/list
 */









/**
 * The list feature. It introduces the `numberedList` and `bulletedList` buttons that
 * allow to convert paragraphs to and from list items and indent or outdent them.
 *
 * See also {@link module:list/listengine~ListEngine}.
 *
 * @extends module:core/plugin~Plugin
 */
class List extends __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_0__listengine__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	static get pluginName() {
		return 'List';
	}

	/**
	 * @inheritDoc
	 */
	init() {
		// Create two buttons and link them with numberedList and bulletedList commands.
		const t = this.editor.t;
		this._addButton( 'numberedList', t( 'Numbered List' ), __WEBPACK_IMPORTED_MODULE_1__theme_icons_numberedlist_svg___default.a );
		this._addButton( 'bulletedList', t( 'Bulleted List' ), __WEBPACK_IMPORTED_MODULE_2__theme_icons_bulletedlist_svg___default.a );

		// Overwrite default Enter key behavior.
		// If Enter key is pressed with selection collapsed in empty list item, outdent it instead of breaking it.
		this.listenTo( this.editor.editing.view, 'enter', ( evt, data ) => {
			const doc = this.editor.document;
			const positionParent = doc.selection.getLastPosition().parent;

			if ( doc.selection.isCollapsed && positionParent.name == 'listItem' && positionParent.isEmpty ) {
				this.editor.execute( 'outdentList' );

				data.preventDefault();
				evt.stop();
			}
		} );

		// Overwrite default Backspace key behavior.
		// If Backspace key is pressed with selection collapsed on first position in first list item, outdent it. #83
		this.listenTo( this.editor.editing.view, 'delete', ( evt, data ) => {
			// Check conditions from those that require less computations like those immediately available.
			if ( data.direction !== 'backward' ) {
				return;
			}

			const selection = this.editor.document.selection;

			if ( !selection.isCollapsed ) {
				return;
			}

			const firstPosition = selection.getFirstPosition();

			if ( !firstPosition.isAtStart ) {
				return;
			}

			const positionParent = firstPosition.parent;

			if ( positionParent.name !== 'listItem' ) {
				return;
			}

			const previousIsAListItem = positionParent.previousSibling && positionParent.previousSibling.name === 'listItem';

			if ( previousIsAListItem ) {
				return;
			}

			this.editor.execute( 'outdentList' );

			data.preventDefault();
			evt.stop();
		}, { priority: 'high' } );

		const getCommandExecuter = commandName => {
			return ( data, cancel ) => {
				const command = this.editor.commands.get( commandName );

				if ( command.isEnabled ) {
					this.editor.execute( commandName );
					cancel();
				}
			};
		};

		this.editor.keystrokes.set( 'Tab', getCommandExecuter( 'indentList' ) );
		this.editor.keystrokes.set( 'Shift+Tab', getCommandExecuter( 'outdentList' ) );
	}

	/**
	 * Helper method for initializing a button and linking it with an appropriate command.
	 *
	 * @private
	 * @param {String} commandName The name of the command.
	 * @param {Object} label The button label.
	 * @param {String} icon The source of the icon.
	 */
	_addButton( commandName, label, icon ) {
		const editor = this.editor;
		const command = editor.commands.get( commandName );

		editor.ui.componentFactory.add( commandName, locale => {
			const buttonView = new __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_ui_src_button_buttonview__["a" /* default */]( locale );

			buttonView.set( {
				label,
				icon,
				tooltip: true
			} );

			// Bind button model to command.
			buttonView.bind( 'isOn', 'isEnabled' ).to( command, 'value', 'isEnabled' );

			// Execute command.
			this.listenTo( buttonView, 'execute', () => editor.execute( commandName ) );

			return buttonView;
		} );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = List;



/***/ }),
/* 553 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__listcommand__ = __webpack_require__(554);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__indentcommand__ = __webpack_require__(555);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_core_src_plugin__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_paragraph_src_paragraph__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__converters__ = __webpack_require__(556);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module list/listengine
 */









/**
 * The engine of the list feature. It handles creating, editing and removing lists and list items.
 * It registers the `numberedList`, `bulletedList`, `indentList` and `outdentList` commands.
 *
 * @extends module:core/plugin~Plugin
 */
class ListEngine extends __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_core_src_plugin__["a" /* default */] {
	/**
	 * @inheritDoc
	 */
	static get requires() {
		return [ __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_paragraph_src_paragraph__["a" /* default */] ];
	}

	/**
	 * @inheritDoc
	 */
	init() {
		const editor = this.editor;

		// Schema.
		// Note: in case `$block` will be ever allowed in `listItem`, keep in mind that this feature
		// uses `Selection#getSelectedBlocks()` without any additional processing to obtain all selected list items.
		// If there are blocks allowed inside list item, algorithms using `getSelectedBlocks()` will have to be modified.
		const schema = editor.document.schema;
		schema.registerItem( 'listItem', '$block' );
		schema.allow( {
			name: 'listItem',
			inside: '$root',
			attributes: [ 'type', 'indent' ]
		} );
		schema.requireAttributes( 'listItem', [ 'type', 'indent' ] );

		// Converters.
		const data = editor.data;
		const editing = editor.editing;

		this.editor.document.on( 'change', Object(__WEBPACK_IMPORTED_MODULE_4__converters__["c" /* modelChangePostFixer */])( this.editor.document ), { priority: 'high' } );

		// Unbind all moved model elements before conversion happens. This is important for converters.
		// TODO: fix this when changes are converted on `changesDone`.
		this.editor.document.on( 'change', ( evt, type, changes ) => {
			if ( type == 'move' ) {
				for ( const item of changes.range.getItems() ) {
					if ( item.is( 'listItem' ) ) {
						editing.mapper.unbindModelElement( item );
					}
				}
			}
		}, { priority: 'high' } );

		editing.mapper.registerViewToModelLength( 'li', getViewListItemLength );
		data.mapper.registerViewToModelLength( 'li', getViewListItemLength );

		editing.mapper.on( 'modelToViewPosition', __WEBPACK_IMPORTED_MODULE_4__converters__["e" /* modelToViewPosition */] );
		editing.mapper.on( 'viewToModelPosition', __WEBPACK_IMPORTED_MODULE_4__converters__["m" /* viewToModelPosition */] );
		data.mapper.on( 'modelToViewPosition', __WEBPACK_IMPORTED_MODULE_4__converters__["e" /* modelToViewPosition */] );

		editing.modelToView.on( 'insert', __WEBPACK_IMPORTED_MODULE_4__converters__["k" /* modelViewSplitOnInsert */], { priority: 'high' } );
		editing.modelToView.on( 'insert:listItem', __WEBPACK_IMPORTED_MODULE_4__converters__["h" /* modelViewInsertion */] );
		data.modelToView.on( 'insert', __WEBPACK_IMPORTED_MODULE_4__converters__["k" /* modelViewSplitOnInsert */], { priority: 'high' } );
		data.modelToView.on( 'insert:listItem', __WEBPACK_IMPORTED_MODULE_4__converters__["h" /* modelViewInsertion */] );

		// Only change converter is needed. List item's type attribute is required, so it's adding is handled when
		// list item is added and you cannot remove it.
		editing.modelToView.on( 'changeAttribute:type:listItem', __WEBPACK_IMPORTED_MODULE_4__converters__["g" /* modelViewChangeType */] );
		data.modelToView.on( 'changeAttribute:type:listItem', __WEBPACK_IMPORTED_MODULE_4__converters__["g" /* modelViewChangeType */] );

		editing.modelToView.on( 'remove:listItem', __WEBPACK_IMPORTED_MODULE_4__converters__["j" /* modelViewRemove */] );
		editing.modelToView.on( 'remove', __WEBPACK_IMPORTED_MODULE_4__converters__["i" /* modelViewMergeAfter */], { priority: 'low' } );
		data.modelToView.on( 'remove:listItem', __WEBPACK_IMPORTED_MODULE_4__converters__["j" /* modelViewRemove */] );
		data.modelToView.on( 'remove', __WEBPACK_IMPORTED_MODULE_4__converters__["i" /* modelViewMergeAfter */], { priority: 'low' } );

		editing.modelToView.on( 'changeAttribute:indent:listItem', __WEBPACK_IMPORTED_MODULE_4__converters__["f" /* modelViewChangeIndent */] );
		data.modelToView.on( 'changeAttribute:indent:listItem', __WEBPACK_IMPORTED_MODULE_4__converters__["f" /* modelViewChangeIndent */] );

		data.viewToModel.on( 'element:ul', __WEBPACK_IMPORTED_MODULE_4__converters__["a" /* cleanList */], { priority: 'high' } );
		data.viewToModel.on( 'element:ol', __WEBPACK_IMPORTED_MODULE_4__converters__["a" /* cleanList */], { priority: 'high' } );
		data.viewToModel.on( 'element:li', __WEBPACK_IMPORTED_MODULE_4__converters__["b" /* cleanListItem */], { priority: 'high' } );
		data.viewToModel.on( 'element:li', __WEBPACK_IMPORTED_MODULE_4__converters__["l" /* viewModelConverter */] );

		// Fix indentation of pasted items.
		data.on( 'insertContent', __WEBPACK_IMPORTED_MODULE_4__converters__["d" /* modelIndentPasteFixer */], { priority: 'high' } );

		// Register commands for numbered and bulleted list.
		editor.commands.add( 'numberedList', new __WEBPACK_IMPORTED_MODULE_0__listcommand__["a" /* default */]( editor, 'numbered' ) );
		editor.commands.add( 'bulletedList', new __WEBPACK_IMPORTED_MODULE_0__listcommand__["a" /* default */]( editor, 'bulleted' ) );

		// Register commands for indenting.
		editor.commands.add( 'indentList', new __WEBPACK_IMPORTED_MODULE_1__indentcommand__["a" /* default */]( editor, 'forward' ) );
		editor.commands.add( 'outdentList', new __WEBPACK_IMPORTED_MODULE_1__indentcommand__["a" /* default */]( editor, 'backward' ) );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ListEngine;


function getViewListItemLength( element ) {
	let length = 1;

	for ( const child of element.getChildren() ) {
		if ( child.name == 'ul' || child.name == 'ol' ) {
			for ( const item of child.getChildren() ) {
				length += getViewListItemLength( item );
			}
		}
	}

	return length;
}


/***/ }),
/* 554 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_first__ = __webpack_require__(60);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module list/listcommand
 */





/**
 * The list command. It is used by the {@link module:list/list~List list feature}.
 *
 * @extends module:core/command~Command
 */
class ListCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * Creates an instance of the command.
	 *
	 * @param {module:core/editor/editor~Editor} editor The editor instance.
	 * @param {'numbered'|'bulleted'} type List type that will be handled by this command.
	 */
	constructor( editor, type ) {
		super( editor );

		/**
		 * The type of the list created by the command.
		 *
		 * @readonly
		 * @member {'numbered'|'bulleted'}
		 */
		this.type = type == 'bulleted' ? 'bulleted' : 'numbered';

		/**
		 * A flag indicating whether the command is active, which means that the selection starts in a list of the same type.
		 *
		 * @observable
		 * @readonly
		 * @member {Boolean} #value
		 */
	}

	/**
	 * @inheritDoc
	 */
	refresh() {
		this.value = this._getValue();
		this.isEnabled = this._checkEnabled();
	}

	/**
	 * Executes the command.
	 *
	 * @protected
	 * @param {Object} [options] Options for the executed command.
	 * @param {module:engine/model/batch~Batch} [options.batch] A batch to collect all the change steps.
	 * A new batch will be created if this option is not set.
	 */
	execute( options = {} ) {
		const document = this.editor.document;
		const blocks = Array.from( document.selection.getSelectedBlocks() )
			.filter( block => checkCanBecomeListItem( block, document.schema ) );

		// Whether we are turning off some items.
		const turnOff = this.value === true;
		// If we are turning off items, we are going to rename them to paragraphs.

		document.enqueueChanges( () => {
			const batch = options.batch || document.batch();

			// If part of a list got turned off, we need to handle (outdent) all of sub-items of the last turned-off item.
			// To be sure that model is all the time in a good state, we first fix items below turned-off item.
			if ( turnOff ) {
				// Start from the model item that is just after the last turned-off item.
				let next = blocks[ blocks.length - 1 ].nextSibling;
				let currentIndent = Number.POSITIVE_INFINITY;
				let changes = [];

				// Correct indent of all items after the last turned off item.
				// Rules that should be followed:
				// 1. All direct sub-items of turned-off item should become indent 0, because the first item after it
				//    will be the first item of a new list. Other items are at the same level, so should have same 0 index.
				// 2. All items with indent lower than indent of turned-off item should become indent 0, because they
				//    should not end up as a child of any of list items that they were not children of before.
				// 3. All other items should have their indent changed relatively to it's parent.
				//
				// For example:
				// 1  * --------
				// 2     * --------
				// 3        * --------			<-- this is turned off.
				// 4           * --------		<-- this has to become indent = 0, because it will be first item on a new list.
				// 5              * --------	<-- this should be still be a child of item above, so indent = 1.
				// 6        * --------			<-- this has to become indent = 0, because it should not be a child of any of items above.
				// 7           * --------		<-- this should be still be a child of item above, so indent = 1.
				// 8     * --------				<-- this has to become indent = 0.
				// 9        * --------			<-- this should still be a child of item above, so indent = 1.
				// 10          * --------		<-- this should still be a child of item above, so indent = 2.
				// 11          * --------		<-- this should still be at the same level as item above, so indent = 2.
				// 12 * --------				<-- this and all below are left unchanged.
				// 13    * --------
				// 14       * --------
				//
				// After turning off 3 the list becomes:
				//
				// 1  * --------
				// 2     * --------
				//
				// 3  --------
				//
				// 4  * --------
				// 5     * --------
				// 6  * --------
				// 7     * --------
				// 8  * --------
				// 9     * --------
				// 10       * --------
				// 11       * --------
				// 12 * --------
				// 13    * --------
				// 14       * --------
				//
				// Thanks to this algorithm no lists are mismatched and no items get unexpected children/parent, while
				// those parent-child connection which are possible to maintain are still maintained. It's worth noting
				// that this is the same effect that we would be get by multiple use of outdent command. However doing
				// it like this is much more efficient because it's less operation (less memory usage, easier OT) and
				// less conversion (faster).
				while ( next && next.name == 'listItem' && next.getAttribute( 'indent' ) !== 0 ) {
					// Check each next list item, as long as its indent is bigger than 0.
					// If the indent is 0 we are not going to change anything anyway.
					const indent = next.getAttribute( 'indent' );

					// We check if that's item indent is lower as current relative indent.
					if ( indent < currentIndent ) {
						// If it is, current relative indent becomes that indent.
						currentIndent = indent;
					}

					// Fix indent relatively to current relative indent.
					// Note, that if we just changed the current relative indent, the newIndent will be equal to 0.
					const newIndent = indent - currentIndent;

					// Save the entry in changes array. We do not apply it at the moment, because we will need to
					// reverse the changes so the last item is changed first.
					// This is to keep model in correct state all the time.
					changes.push( { element: next, indent: newIndent } );

					// Find next item.
					next = next.nextSibling;
				}

				changes = changes.reverse();

				for ( const item of changes ) {
					batch.setAttribute( item.element, 'indent', item.indent );
				}
			}

			// If we are turning on, we might change some items that are already `listItem`s but with different type.
			// Changing one nested list item to other type should also trigger changing all its siblings so the
			// whole nested list is of the same type.
			// Example (assume changing to numbered list):
			// * ------				<-- do not fix, top level item
			//   * ------			<-- fix, because latter list item of this item's list is changed
			//      * ------		<-- do not fix, item is not affected (different list)
			//   * ------			<-- fix, because latter list item of this item's list is changed
			//      * ------		<-- fix, because latter list item of this item's list is changed
			//      * ---[--		<-- already in selection
			//   * ------			<-- already in selection
			//   * ------			<-- already in selection
			// * ------				<-- already in selection, but does not cause other list items to change because is top-level
			//   * ---]--			<-- already in selection
			//   * ------			<-- fix, because preceding list item of this item's list is changed
			//      * ------		<-- do not fix, item is not affected (different list)
			// * ------				<-- do not fix, top level item
			if ( !turnOff ) {
				// Find lowest indent among selected items. This will be indicator what is the indent of
				// top-most list affected by the command.
				let lowestIndent = Number.POSITIVE_INFINITY;

				for ( const item of blocks ) {
					if ( item.is( 'listItem' ) && item.getAttribute( 'indent' ) < lowestIndent ) {
						lowestIndent = item.getAttribute( 'indent' );
					}
				}

				// Do not execute the fix for top-level lists.
				lowestIndent = lowestIndent === 0 ? 1 : lowestIndent;

				// Fix types of list items that are "before" the selected blocks.
				_fixType( blocks, true, lowestIndent );

				// Fix types of list items that are "after" the selected blocks.
				_fixType( blocks, false, lowestIndent );
			}

			// Phew! Now it will be easier :).
			// For each block element that was in the selection, we will either: turn it to list item,
			// turn it to paragraph, or change it's type. Or leave it as it is.
			// Do it in reverse as there might be multiple blocks (same as with changing indents).
			for ( const element of blocks.reverse() ) {
				if ( turnOff && element.name == 'listItem' ) {
					// We are turning off and the element is a `listItem` - it should be converted to `paragraph`.
					// List item specific attributes are removed by post fixer.
					batch.rename( element, 'paragraph' );
				} else if ( !turnOff && element.name != 'listItem' ) {
					// We are turning on and the element is not a `listItem` - it should be converted to `listItem`.
					// The order of operations is important to keep model in correct state.
					batch.setAttribute( element, 'type', this.type ).setAttribute( element, 'indent', 0 ).rename( element, 'listItem' );
				} else if ( !turnOff && element.name == 'listItem' && element.getAttribute( 'type' ) != this.type ) {
					// We are turning on and the element is a `listItem` but has different type - change it's type and
					// type of it's all siblings that have same indent.
					batch.setAttribute( element, 'type', this.type );
				}
			}
		} );
	}

	/**
	 * Checks the command's {@link #value}.
	 *
	 * @private
	 * @returns {Boolean} The current value.
	 */
	_getValue() {
		// Check whether closest `listItem` ancestor of the position has a correct type.
		const listItem = Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_first__["a" /* default */])( this.editor.document.selection.getSelectedBlocks() );

		return !!listItem && listItem.is( 'listItem' ) && listItem.getAttribute( 'type' ) == this.type;
	}

	/**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @private
	 * @returns {Boolean} Whether the command should be enabled.
	 */
	_checkEnabled() {
		// If command value is true it means that we are in list item, so the command should be enabled.
		if ( this.value ) {
			return true;
		}

		const selection = this.editor.document.selection;
		const schema = this.editor.document.schema;

		const firstBlock = Object(__WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_utils_src_first__["a" /* default */])( selection.getSelectedBlocks() );

		if ( !firstBlock ) {
			return false;
		}

		// Otherwise, check if list item can be inserted at the position start.
		return checkCanBecomeListItem( firstBlock, schema );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ListCommand;


// Helper function used when one or more list item have their type changed. Fixes type of other list items
// that are affected by the change (are in same lists) but are not directly in selection. The function got extracted
// not to duplicated code, as same fix has to be performed before and after selection.
//
// @param {Array.<module:engine/model/node~Node>} blocks Blocks that are in selection.
// @param {Boolean} isBackward Specified whether fix will be applied for blocks before first selected block (`true`)
// or blocks after last selected block (`false`).
// @param {Number} lowestIndent Lowest indent among selected blocks.
function _fixType( blocks, isBackward, lowestIndent ) {
	// We need to check previous sibling of first changed item and next siblings of last changed item.
	const startingItem = isBackward ? blocks[ 0 ] : blocks[ blocks.length - 1 ];

	if ( startingItem.is( 'listItem' ) ) {
		let item = startingItem[ isBackward ? 'previousSibling' : 'nextSibling' ];
		// During processing items, keeps the lowest indent of already processed items.
		// This saves us from changing too many items.
		// Following example is for going forward as it is easier to read, however same applies to going backward.
		// * ------
		//   * ------
		//     * --[---
		//   * ------		<-- `lowestIndent` should be 1
		//     * --]---		<-- `startingItem`, `currentIndent` = 2, `lowestIndent` == 1
		//     * ------		<-- should be fixed, `indent` == 2 == `currentIndent`
		//   * ------		<-- should be fixed, set `currentIndent` to 1, `indent` == 1 == `currentIndent`
		//     * ------		<-- should not be fixed, item is in different list, `indent` = 2, `indent` != `currentIndent`
		//   * ------		<-- should be fixed, `indent` == 1 == `currentIndent`
		// * ------			<-- break loop (`indent` < `lowestIndent`)
		let currentIndent = startingItem.getAttribute( 'indent' );

		// Look back until a list item with indent lower than reference `lowestIndent`.
		// That would be the parent of nested sublist which contains item having `lowestIndent`.
		while ( item && item.is( 'listItem' ) && item.getAttribute( 'indent' ) >= lowestIndent ) {
			if ( currentIndent > item.getAttribute( 'indent' ) ) {
				currentIndent = item.getAttribute( 'indent' );
			}

			// Found an item that is in the same nested sublist.
			if ( item.getAttribute( 'indent' ) == currentIndent ) {
				// Just add the item to selected blocks like it was selected by the user.
				blocks[ isBackward ? 'unshift' : 'push' ]( item );
			}

			item = item[ isBackward ? 'previousSibling' : 'nextSibling' ];
		}
	}
}

// Checks whether the given block can be replaced by a listItem.
//
// @private
// @param {module:engine/model/element~Element} block A block to be tested.
// @param {module:engine/model/schema~Schema} schema The schema of the document.
// @returns {Boolean}
function checkCanBecomeListItem( block, schema ) {
	return schema.check( {
		name: 'listItem',
		attributes: [ 'type', 'indent' ],
		inside: __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( block )
	} );
}


/***/ }),
/* 555 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_first__ = __webpack_require__(60);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module list/indentcommand
 */




/**
 * The list indent command. It is used by the {@link module:list/list~List list feature}.
 *
 * @extends module:core/command~Command
 */
class IndentCommand extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_core_src_command__["a" /* default */] {
	/**
	 * Creates an instance of the command.
	 *
	 * @param {module:core/editor/editor~Editor} editor The editor instance.
	 * @param {'forward'|'backward'} indentDirection The direction of indent. If it is equal to `backward`, the command
	 * will outdent a list item.
	 */
	constructor( editor, indentDirection ) {
		super( editor );

		/**
		 * Determines by how much the command will change the list item's indent attribute.
		 *
		 * @readonly
		 * @private
		 * @member {Number}
		 */
		this._indentBy = indentDirection == 'forward' ? 1 : -1;
	}

	/**
	 * @inheritDoc
	 */
	refresh() {
		this.isEnabled = this._checkEnabled();
	}

	/**
	 * Indents or outdents (depends on the {@link #constructor}'s `indentDirection` parameter) selected list items.
	 *
	 * @fires execute
	 */
	execute() {
		const doc = this.editor.document;
		const batch = doc.batch();
		let itemsToChange = Array.from( doc.selection.getSelectedBlocks() );

		doc.enqueueChanges( () => {
			const lastItem = itemsToChange[ itemsToChange.length - 1 ];

			// Indenting a list item should also indent all the items that are already sub-items of indented item.
			let next = lastItem.nextSibling;

			// Check all items after last indented item, as long as their indent is bigger than indent of that item.
			while ( next && next.name == 'listItem' && next.getAttribute( 'indent' ) > lastItem.getAttribute( 'indent' ) ) {
				itemsToChange.push( next );

				next = next.nextSibling;
			}

			// We need to be sure to keep model in correct state after each small change, because converters
			// bases on that state and assumes that model is correct.
			// Because of that, if the command outdents items, we will outdent them starting from the last item, as
			// it is safer.
			if ( this._indentBy < 0 ) {
				itemsToChange = itemsToChange.reverse();
			}

			for ( const item of itemsToChange ) {
				const indent = item.getAttribute( 'indent' ) + this._indentBy;

				// If indent is lower than 0, it means that the item got outdented when it was not indented.
				// This means that we need to convert that list item to paragraph.
				if ( indent < 0 ) {
					// To keep the model as correct as possible, first rename listItem, then remove attributes,
					// as listItem without attributes is very incorrect and will cause problems in converters.
					// No need to remove attributes, will be removed by post fixer.
					batch.rename( item, 'paragraph' );
				}
				// If indent is >= 0, change the attribute value.
				else {
					batch.setAttribute( item, 'indent', indent );
				}
			}

			// Check whether some of changed list items' type should not be fixed.
			// But first, reverse `itemsToChange` again -- we always want to perform those fixes starting from first item (source-wise).
			if ( this._indentBy < 0 ) {
				itemsToChange = itemsToChange.reverse();
			}

			for ( const item of itemsToChange ) {
				_fixType( item, batch );
			}
		} );
	}

	/**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @private
	 * @returns {Boolean} Whether the command should be enabled.
	 */
	_checkEnabled() {
		// Check whether any of position's ancestor is a list item.
		const listItem = Object(__WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_utils_src_first__["a" /* default */])( this.editor.document.selection.getSelectedBlocks() );

		// If selection is not in a list item, the command is disabled.
		if ( !listItem || !listItem.is( 'listItem' ) ) {
			return false;
		}

		if ( this._indentBy > 0 ) {
			// Cannot indent first item in it's list. Check if before `listItem` is a list item that is in same list.
			// To be in the same list, the item has to have same attributes and cannot be "split" by an item with lower indent.
			const indent = listItem.getAttribute( 'indent' );
			const type = listItem.getAttribute( 'type' );

			let prev = listItem.previousSibling;

			while ( prev && prev.is( 'listItem' ) && prev.getAttribute( 'indent' ) >= indent ) {
				if ( prev.getAttribute( 'indent' ) == indent ) {
					// The item is on the same level.
					// If it has same type, it means that we found a preceding sibling from the same list.
					// If it does not have same type, it means that `listItem` is on different list (this can happen only
					// on top level lists, though).
					return prev.getAttribute( 'type' ) == type;
				}

				prev = prev.previousSibling;
			}

			// Could not find similar list item, this means that `listItem` is first in its list.
			return false;
		}

		// If we are outdenting it is enough to be in list item. Every list item can always be outdented.
		return true;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IndentCommand;


// Fixes type of `item` element after it was indented/outdented. Looks for a sibling of `item` that has the same
// indent and sets `item`'s type to the same as that sibling.
function _fixType( item, batch ) {
	// Find a preceding sibling of `item` that is a list item of the same list as `item`.
	const prev = _seekListItem( item, false );

	// If found, fix type.
	if ( prev ) {
		batch.setAttribute( item, 'type', prev.getAttribute( 'type' ) );

		return;
	}

	// If not found, find a following sibling of `item` that is a list item of the same list as `item`.
	const next = _seekListItem( item, true );

	// If found, fix type.
	if ( next ) {
		batch.setAttribute( item, 'type', next.getAttribute( 'type' ) );
	}
}

// Seeks for a list item that has same indent as given `item`. May look through next siblings (`seekForward = true`) or
// previous siblings (`seekForward = false`). Returns found list item or `null` if item has not been found.
function _seekListItem( item, seekForward ) {
	let result = item[ seekForward ? 'nextSibling' : 'previousSibling' ];

	// Look for the previous/next sibling that has same indent and is before a list item element with lower indent.
	// If elements are split by an element with lower indent, they are on different lists.
	while ( result && result.is( 'listItem' ) && result.getAttribute( 'indent' ) >= item.getAttribute( 'indent' ) ) {
		if ( result.getAttribute( 'indent' ) == item.getAttribute( 'indent' ) ) {
			// We found sibling that is on the same list.
			return result;
		}

		result = result[ seekForward ? 'nextSibling' : 'previousSibling' ];
	}

	return null;
}


/***/ }),
/* 556 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["h"] = modelViewInsertion;
/* harmony export (immutable) */ __webpack_exports__["g"] = modelViewChangeType;
/* harmony export (immutable) */ __webpack_exports__["j"] = modelViewRemove;
/* harmony export (immutable) */ __webpack_exports__["f"] = modelViewChangeIndent;
/* harmony export (immutable) */ __webpack_exports__["k"] = modelViewSplitOnInsert;
/* harmony export (immutable) */ __webpack_exports__["i"] = modelViewMergeAfter;
/* harmony export (immutable) */ __webpack_exports__["l"] = viewModelConverter;
/* harmony export (immutable) */ __webpack_exports__["a"] = cleanList;
/* harmony export (immutable) */ __webpack_exports__["b"] = cleanListItem;
/* harmony export (immutable) */ __webpack_exports__["e"] = modelToViewPosition;
/* harmony export (immutable) */ __webpack_exports__["m"] = viewToModelPosition;
/* harmony export (immutable) */ __webpack_exports__["c"] = modelChangePostFixer;
/* harmony export (immutable) */ __webpack_exports__["d"] = modelIndentPasteFixer;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewlistitemelement__ = __webpack_require__(557);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_documentfragment__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_model_writer__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_view_containerelement__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_range__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_engine_src_view_treewalker__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__ = __webpack_require__(92);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module list/converters
 */














/**
 * A model-to-view converter for `listItem` model element insertion.
 *
 * It creates a `<ul><li></li><ul>` (or `<ol>`) view structure out of a `listItem` model element, inserts it at the correct
 * position, and merges the list with surrounding lists (if available).
 *
 * @see module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:insert
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewInsertion( evt, data, consumable, conversionApi ) {
	if ( !consumable.test( data.item, 'insert' ) ||
		!consumable.test( data.item, 'addAttribute:type' ) ||
		!consumable.test( data.item, 'addAttribute:indent' )
	) {
		return;
	}

	consumable.consume( data.item, 'insert' );
	consumable.consume( data.item, 'addAttribute:type' );
	consumable.consume( data.item, 'addAttribute:indent' );

	const modelItem = data.item;
	const viewItem = generateLiInUl( modelItem, conversionApi.mapper );

	// Providing kind of "default" insert position in case of converting incorrect model.
	const insertPosition = conversionApi.mapper.toViewPosition( __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( modelItem ) );

	injectViewList( modelItem, viewItem, conversionApi.mapper, insertPosition );
}

/**
 * A model-to-view converter for `type` attribute change on `listItem` model element.
 *
 * This change means that `<li>` elements parent changes from `<ul>` to `<ol>` (or vice versa). This is accomplished
 * by breaking view elements, changing their name and merging them.
 *
 * @see module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:changeAttribute
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewChangeType( evt, data, consumable, conversionApi ) {
	if ( !consumable.consume( data.item, 'changeAttribute:type' ) ) {
		return;
	}

	const viewItem = conversionApi.mapper.toViewElement( data.item );

	// 1. Break the container after and before the list item.
	// This will create a view list with one view list item -- the one that changed type.
	__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createBefore( viewItem ) );
	__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAfter( viewItem ) );

	// 2. Change name of the view list that holds the changed view item.
	// We cannot just change name property, because that would not render properly.
	let viewList = viewItem.parent;
	const listName = data.attributeNewValue == 'numbered' ? 'ol' : 'ul';
	viewList = __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].rename( viewList, listName );

	// 3. Merge the changed view list with other lists, if possible.
	mergeViewLists( viewList, viewList.nextSibling );
	mergeViewLists( viewList.previousSibling, viewList );
}

/**
 * A model-to-view converter for `listItem` model element removal.
 *
 * @see module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:remove
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewRemove( evt, data, consumable, conversionApi ) {
	if ( !consumable.consume( data.item, 'remove' ) ) {
		return;
	}

	let viewPosition = conversionApi.mapper.toViewPosition( data.sourcePosition );
	viewPosition = viewPosition.getLastMatchingPosition( value => !value.item.is( 'li' ) );

	const viewItem = viewPosition.nodeAfter;

	// 1. Break the container after and before the list item.
	// This will create a view list with one view list item -- the one that changed type.
	__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createBefore( viewItem ) );
	__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAfter( viewItem ) );

	// 2. Remove the UL that contains just the removed <li>.
	const viewList = viewItem.parent;
	const viewListPrev = viewList.previousSibling;
	const removeRange = __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_range__["a" /* default */].createOn( viewList );
	__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].remove( removeRange );

	if ( viewListPrev && viewListPrev.nextSibling ) {
		mergeViewLists( viewListPrev, viewListPrev.nextSibling );
	}

	// 3. Bring back nested list that was in the removed <li>.
	hoistNestedLists( data.item.getAttribute( 'indent' ) + 1, data.sourcePosition, removeRange.start, viewItem, conversionApi.mapper );

	// Unbind this element only if it was moved to graveyard.
	// See #847.
	if ( data.item.root.rootName == '$graveyard' ) {
		conversionApi.mapper.unbindModelElement( data.item );
	}
}

/**
 * A model-to-view converter for `indent` attribute change on `listItem` model element.
 *
 * @see module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:changeAttribute
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewChangeIndent( evt, data, consumable, conversionApi ) {
	if ( !consumable.consume( data.item, 'changeAttribute:indent' ) ) {
		return;
	}

	const viewItem = conversionApi.mapper.toViewElement( data.item );

	// 1. Break the container after and before the list item.
	// This will create a view list with one view list item -- the one that changed type.
	__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createBefore( viewItem ) );
	__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAfter( viewItem ) );

	// 2. Extract view list with changed view list item and merge "hole" possibly created by breaking and removing elements.
	const viewList = viewItem.parent;
	const viewListPrev = viewList.previousSibling;
	const removeRange = __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_range__["a" /* default */].createOn( viewList );
	__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].remove( removeRange );

	// TODO: get rid of `removePosition` when conversion is done on `changesDone`.
	let removePosition;

	if ( viewListPrev && viewListPrev.nextSibling ) {
		removePosition = mergeViewLists( viewListPrev, viewListPrev.nextSibling );
	}

	if ( !removePosition ) {
		removePosition = removeRange.start;
	}

	// 3. Bring back nested list that was in the removed <li>.
	hoistNestedLists( data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi.mapper );

	// 4. Inject view list like it is newly inserted.
	injectViewList( data.item, viewItem, conversionApi.mapper, removePosition );
}

/**
 * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter is fired for
 * insert change of every model item, and should be fired before the actual converter. The converter checks whether the inserted
 * model item is a non-`listItem` element. If it is, and it is inserted inside a view list, the converter breaks the
 * list so the model element is inserted to the view parent element corresponding to its model parent element.
 *
 * The converter prevents such situations:
 *
 *		// Model:                        // View:
 *		<listItem>foo</listItem>         <ul>
 *		<listItem>bar</listItem>             <li>foo</li>
 *		                                     <li>bar</li>
 *		                                 </ul>
 *
 *		// After change:                 // Correct view guaranteed by this converter:
 *		<listItem>foo</listItem>         <ul><li>foo</li></ul><p>xxx</p><ul><li>bar</li></ul>
 *		<paragraph>xxx</paragraph>       // Instead of this wrong view state:
 *		<listItem>bar</listItem>         <ul><li>foo</li><p>xxx</p><li>bar</li></ul>
 *
 * @see module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:insert
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewSplitOnInsert( evt, data, consumable, conversionApi ) {
	if ( data.item.name != 'listItem' ) {
		let viewPosition = conversionApi.mapper.toViewPosition( data.range.start );

		const lists = [];

		// Break multiple ULs/OLs if there are.
		//
		// Imagine following list:
		//
		// 1 --------
		//   1.1 --------
		//     1.1.1 --------
		//     1.1.2 --------
		//     1.1.3 --------
		//       1.1.3.1 --------
		//   1.2 --------
		//     1.2.1 --------
		// 2 --------
		//
		// Insert paragraph after item 1.1.1:
		//
		// 1 --------
		//   1.1 --------
		//     1.1.1 --------
		//
		// Lorem ipsum.
		//
		//     1.1.2 --------
		//     1.1.3 --------
		//       1.1.3.1 --------
		//   1.2 --------
		//     1.2.1 --------
		// 2 --------
		//
		// In this case 1.1.2 has to become beginning of a new list.
		// We need to break list before 1.1.2 (obvious), then we need to break list also before 1.2.
		// Then we need to move those broken pieces one after another and merge:
		//
		// 1 --------
		//   1.1 --------
		//     1.1.1 --------
		//
		// Lorem ipsum.
		//
		// 1.1.2 --------
		//   1.1.3 --------
		//     1.1.3.1 --------
		// 1.2 --------
		//   1.2.1 --------
		// 2 --------
		//
		while ( viewPosition.parent.name == 'ul' || viewPosition.parent.name == 'ol' ) {
			viewPosition = __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( viewPosition );

			if ( viewPosition.parent.name != 'li' ) {
				break;
			}

			// Remove lists that are after inserted element.
			// They will be brought back later, below the inserted element.
			const removeStart = viewPosition;
			const removeEnd = __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAt( viewPosition.parent, 'end' );

			// Don't remove if there is nothing to remove.
			if ( !removeStart.isEqual( removeEnd ) ) {
				const removed = __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].remove( new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_range__["a" /* default */]( removeStart, removeEnd ) );
				lists.push( removed );
			}

			viewPosition = __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAfter( viewPosition.parent );
		}

		// Bring back removed lists.
		if ( lists.length > 0 ) {
			for ( let i = 0; i < lists.length; i++ ) {
				const previousList = viewPosition.nodeBefore;
				const insertedRange = __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].insert( viewPosition, lists[ i ] );
				viewPosition = insertedRange.end;

				// Don't merge first list! We want a split in that place (this is why this converter is introduced).
				if ( i > 0 ) {
					const mergePos = mergeViewLists( previousList, previousList.nextSibling );

					// If `mergePos` is in `previousList` it means that the lists got merged.
					// In this case, we need to fix insert position.
					if ( mergePos && mergePos.parent == previousList ) {
						viewPosition.offset--;
					}
				}
			}

			// Merge last inserted list with element after it.
			mergeViewLists( viewPosition.nodeBefore, viewPosition.nodeAfter );
		}
	}
}

/**
 * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter takes care of
 * merging view lists after something is removed or moved from near them.
 *
 * Example:
 *
 *		// Model:                        // View:
 *		<listItem>foo</listItem>         <ul><li>foo</li></ul>
 *		<paragraph>xxx</paragraph>       <p>xxx</p>
 *		<listItem>bar</listItem>         <ul><li>bar</li></ul>
 *
 *		// After change:                 // Correct view guaranteed by this converter:
 *		<listItem>foo</listItem>         <ul>
 *		<listItem>bar</listItem>             <li>foo</li>
 *		                                     <li>bar</li>
 *		                                 </ul>
 *
 * @see module:engine/conversion/modelconversiondispatcher~ModelConversionDispatcher#event:remove
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewMergeAfter( evt, data, consumable, conversionApi ) {
	if ( !data.item.is( 'listItem' ) ) {
		const viewPosition = conversionApi.mapper.toViewPosition( data.sourcePosition );
		const viewItemPrev = viewPosition.nodeBefore;
		const viewItemNext = viewPosition.nodeAfter;

		// Merge lists if something (remove, move) was done from inside of list.
		// Merging will be done only if both items are view lists of the same type.
		// The check is done inside the helper function.
		mergeViewLists( viewItemPrev, viewItemNext );
	}
}

/**
 * A view-to-model converter that converts `<li>` view elements into `listItem` model elements.
 *
 * To set correct values of the `type` and `indent` attributes the converter:
 * * checks `<li>`'s parent,
 * * passes the `data.indent` value when `<li>`'s sub-items are converted.
 *
 * @see module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:element
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.
 * @param {module:engine/conversion/viewconsumable~ViewConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface to be used by the callback.
 */
function viewModelConverter( evt, data, consumable, conversionApi ) {
	if ( consumable.consume( data.input, { name: true } ) ) {
		// 1. Create `listItem` model element.
		const listItem = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */]( 'listItem' );

		// 2. Handle `listItem` model element attributes.
		data.indent = data.indent ? data.indent : 0;
		listItem.setAttribute( 'indent', data.indent );

		// Set 'bulleted' as default. If this item is pasted into a context,
		const type = data.input.parent && data.input.parent.name == 'ol' ? 'numbered' : 'bulleted';
		listItem.setAttribute( 'type', type );

		// 3. Handle `<li>` children.
		data.context.push( listItem );

		// `listItem`s created recursively should have bigger indent.
		data.indent++;

		// `listItem`s will be kept in flat structure.
		const items = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_model_documentfragment__["a" /* default */]();
		items.appendChildren( listItem );

		// Check all children of the converted `<li>`.
		// At this point we assume there are no "whitespace" view text nodes in view list, between view list items.
		// This should be handled by `<ul>` and `<ol>` converters.
		for ( const child of data.input.getChildren() ) {
			// Let's convert the child.
			const converted = conversionApi.convertItem( child, consumable, data );

			// If this is a view list element, we will convert it and concat the result (`listItem` model elements)
			// with already gathered results (in `items` array). `converted` should be a `ModelDocumentFragment`.
			if ( child.name == 'ul' || child.name == 'ol' ) {
				items.appendChildren( Array.from( converted.getChildren() ) );
			}
			// If it was not a list it was a "regular" list item content. Just append it to `listItem`.
			else {
				__WEBPACK_IMPORTED_MODULE_4__ckeditor_ckeditor5_engine_src_model_writer__["a" /* default */].insert( __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAt( listItem, 'end' ), converted );
			}
		}

		data.indent--;
		data.context.pop();

		data.output = items;
	}
}

/**
 * A view-to-model converter for `<ul>` and `<ol>` view elements that cleans the input view of garbage.
 * This is mostly to clean whitespaces from between `<li>` view elements inside the view list element, however, also
 * incorrect data can be cleared if the view was incorrect.
 *
 * @see module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:element
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.
 * @param {module:engine/conversion/viewconsumable~ViewConsumable} consumable Values to consume.
 */
function cleanList( evt, data, consumable ) {
	if ( consumable.test( data.input, { name: true } ) ) {
		// Caching children because when we start removing them iterating fails.
		const children = Array.from( data.input.getChildren() );

		for ( const child of children ) {
			if ( !child.is( 'li' ) ) {
				child.remove();
			}
		}
	}
}

/**
 * A view-to-model converter for `<li>` elements that cleans whitespace formatting from the input view.
 *
 * @see module:engine/conversion/viewconversiondispatcher~ViewConversionDispatcher#event:element
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.
 * @param {module:engine/conversion/viewconsumable~ViewConsumable} consumable Values to consume.
 */
function cleanListItem( evt, data, consumable ) {
	if ( consumable.test( data.input, { name: true } ) ) {
		if ( data.input.childCount === 0 ) {
			return;
		}

		const children = [ ...data.input.getChildren() ];

		let foundList = false;
		let firstNode = true;

		for ( const child of children ) {
			if ( foundList && !child.is( 'ul' ) && !child.is( 'ol' ) ) {
				child.remove();
			}

			if ( child.is( 'text' ) ) {
				// If this is the first node and it's a text node, left-trim it.
				if ( firstNode ) {
					child.data = child.data.replace( /^\s+/, '' );
				}

				// If this is the last text node before <ul> or <ol>, right-trim it.
				if ( !child.nextSibling || ( child.nextSibling.is( 'ul' ) || child.nextSibling.is( 'ol' ) ) ) {
					child.data = child.data.replace( /\s+$/, '' );
				}
			} else if ( child.is( 'ul' ) || child.is( 'ol' ) ) {
				// If this is a <ul> or <ol>, do not process it, just mark that we already visited list element.
				foundList = true;
			}

			firstNode = false;
		}
	}
}

/**
 * The callback for model position to view position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes
 * positions between `listItem` elements that would be incorrectly mapped because of how list items are represented in model
 * and view.
 *
 * @see module:engine/conversion/mapper~Mapper#event:modelToViewPosition
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data An object containing additional data and placeholder for mapping result.
 */
function modelToViewPosition( evt, data ) {
	const modelItem = data.modelPosition.nodeBefore;

	if ( modelItem && modelItem.is( 'listItem' ) ) {
		const viewItem = data.mapper.toViewElement( modelItem );
		const topmostViewList = viewItem.getAncestors().find( element => element.is( 'ul' ) || element.is( 'ol' ) );
		const walker = new __WEBPACK_IMPORTED_MODULE_8__ckeditor_ckeditor5_engine_src_view_treewalker__["a" /* default */]( {
			startPosition: __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAt( viewItem, 0 )
		} );

		for ( const value of walker ) {
			if ( value.type == 'elementStart' && value.item.is( 'li' ) ) {
				data.viewPosition = value.previousPosition;

				break;
			} else if ( value.type == 'elementEnd' && value.item == topmostViewList ) {
				data.viewPosition = value.nextPosition;

				break;
			}
		}
	}
}

/**
 * The callback for view position to model position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes
 * positions between `<li>` elements that would be incorrectly mapped because of how list items are represented in model
 * and view.
 *
 * @see module:engine/conversion/mapper~Mapper#event:viewToModelPosition
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data An object containing additional data and placeholder for mapping result.
 */
function viewToModelPosition( evt, data ) {
	const viewPos = data.viewPosition;
	const viewParent = viewPos.parent;
	const mapper = data.mapper;

	if ( viewParent.name == 'ul' || viewParent.name == 'ol' ) {
		// Position is directly in <ul> or <ol>.
		if ( !viewPos.isAtEnd ) {
			// If position is not at the end, it must be before <li>.
			// Get that <li>, map it to `listItem` and set model position before that `listItem`.
			const modelNode = mapper.toModelElement( viewPos.nodeAfter );

			data.modelPosition = __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( modelNode );
		} else {
			// Position is at the end of <ul> or <ol>, so there is no <li> after it to be mapped.
			// There is <li> before the position, but we cannot just map it to `listItem` and set model position after it,
			// because that <li> may contain nested items.
			// We will check "model length" of that <li>, in other words - how many `listItem`s are in that <li>.
			const modelNode = mapper.toModelElement( viewPos.nodeBefore );
			const modelLength = mapper.getModelLength( viewPos.nodeBefore );

			// Then we get model position before mapped `listItem` and shift it accordingly.
			data.modelPosition = __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( modelNode ).getShiftedBy( modelLength );
		}

		evt.stop();
	} else if ( viewParent.name == 'li' && viewPos.nodeBefore && ( viewPos.nodeBefore.name == 'ul' || viewPos.nodeBefore.name == 'ol' ) ) {
		// In most cases when view position is in <li> it is in text and this is a correct position.
		// However, if position is after <ul> or <ol> we have to fix it -- because in model <ul>/<ol> are not in the `listItem`.
		const modelNode = mapper.toModelElement( viewParent );

		// Check all <ul>s and <ol>s that are in the <li> but before mapped position.
		// Get model length of those elements and then add it to the offset of `listItem` mapped to the original <li>.
		let modelLength = 1; // Starts from 1 because the original <li> has to be counted in too.
		let viewList = viewPos.nodeBefore;

		while ( viewList && ( viewList.is( 'ul' ) || viewList.is( 'ol' ) ) ) {
			modelLength += mapper.getModelLength( viewList );

			viewList = viewList.previousSibling;
		}

		data.modelPosition = __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( modelNode ).getShiftedBy( modelLength );

		evt.stop();
	}
}

/**
 * Post-fixer that reacts to changes on document and fixes incorrect model states.
 *
 * Example:
 *
 *		<listItem type="bulleted" indent=0>Item 1</listItem>
 *		<listItem type="bulleted" indent=1>Item 2</listItem>   <--- this is removed.
 *		<listItem type="bulleted" indent=2>Item 3</listItem>
 *
 * Should become:
 *
 *		<listItem type="bulleted" indent=0>Item 1</listItem>
 *		<listItem type="bulleted" indent=1>Item 3</listItem>   <--- note that indent got post-fixed.
 *
 * @param {module:engine/model/document~Document} document The document to observe.
 * @returns {Function} A callback to be attached to the {@link module:engine/model/document~Document#event:change document change event}.
 */
function modelChangePostFixer( document ) {
	return ( evt, type, changes, batch ) => {
		if ( batch.type == 'transparent' ) {
			return;
		}

		if ( type == 'remove' ) {
			const howMany = changes.range.end.offset - changes.range.start.offset;
			const sourcePos = changes.sourcePosition._getTransformedByInsertion( changes.range.start, howMany, true );

			// Fix list items after the cut-out range.
			// This fix is needed if items in model after cut-out range have now wrong indents compared to their previous siblings.
			_fixItemsIndent( sourcePos, document, batch );
			// This fix is needed if two different nested lists got merged, change types of list items "below".
			_fixItemsType( sourcePos, false, document, batch );
		} else if ( type == 'move' ) {
			const howMany = changes.range.end.offset - changes.range.start.offset;
			const sourcePos = changes.sourcePosition._getTransformedByInsertion( changes.range.start, howMany, true );

			// Fix list items after the cut-out range.
			// This fix is needed if items in model after cut-out range have now wrong indents compared to their previous siblings.
			_fixItemsIndent( sourcePos, document, batch );
			// This fix is needed if two different nested lists got merged, change types of list items "below".
			_fixItemsType( sourcePos, false, document, batch );

			// Fix items in moved range.
			// This fix is needed if inserted items are too deeply intended.
			_fixItemsIndent( changes.range.start, document, batch );
			// This fix is needed if one or more first inserted items have different type.
			_fixItemsType( changes.range.start, false, document, batch );

			// Fix list items after inserted range.
			// This fix is needed if items in model after inserted range have wrong indents.
			_fixItemsIndent( changes.range.end, document, batch );
			// This fix is needed if one or more last inserted items have different type.
			_fixItemsType( changes.range.end, true, document, batch );
		} else if ( type == 'rename' && changes.oldName == 'listItem' && changes.newName != 'listItem' ) {
			const element = changes.element;

			// Element name is changed from list to something else. Remove useless attributes.
			document.enqueueChanges( () => {
				batch.removeAttribute( element, 'indent' ).removeAttribute( element, 'type' );
			} );

			const changePos = __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAfter( changes.element );

			// Fix list items after the renamed element.
			// This fix is needed if there are items after renamed element, those items should start from indent = 0.
			_fixItemsIndent( changePos, document, batch );
		} else if ( type == 'insert' ) {
			// Fix list items in inserted range.
			// This fix is needed if inserted items are too deeply intended.
			_fixItemsIndent( changes.range.start, document, batch );
			// This fix is needed if one or more first inserted items have different type.
			_fixItemsType( changes.range.start, false, document, batch );

			// Fix list items after inserted range.
			// This fix is needed if items in model after inserted range have wrong indents.
			_fixItemsIndent( changes.range.end, document, batch );
			// This fix is needed if one or more last inserted items have different type.
			_fixItemsType( changes.range.end, true, document, batch );
		}
	};
}

// Helper function for post fixer callback. Performs fixing of model `listElement` items indent attribute. Checks the model at the
// `changePosition`. Looks at the node before position where change occurred and uses that node as a reference for following list items.
function _fixItemsIndent( changePosition, document, batch ) {
	let nextItem = changePosition.nodeAfter;

	if ( nextItem && nextItem.name == 'listItem' ) {
		document.enqueueChanges( () => {
			const prevItem = nextItem.previousSibling;
			// This is the maximum indent that following model list item may have.
			const maxIndent = prevItem && prevItem.is( 'listItem' ) ? prevItem.getAttribute( 'indent' ) + 1 : 0;

			// Check how much the next item needs to be outdented.
			let outdentBy = nextItem.getAttribute( 'indent' ) - maxIndent;
			const items = [];

			while ( nextItem && nextItem.name == 'listItem' && nextItem.getAttribute( 'indent' ) > maxIndent ) {
				if ( outdentBy > nextItem.getAttribute( 'indent' ) ) {
					outdentBy = nextItem.getAttribute( 'indent' );
				}

				const newIndent = nextItem.getAttribute( 'indent' ) - outdentBy;

				items.push( { item: nextItem, indent: newIndent } );

				nextItem = nextItem.nextSibling;
			}

			if ( items.length > 0 ) {
				// Since we are outdenting list items, it is safer to start from the last one (it will maintain correct model state).
				for ( const item of items.reverse() ) {
					batch.setAttribute( item.item, 'indent', item.indent );
				}
			}
		} );
	}
}

// Helper function for post fixer callback. Performs fixing of model nested `listElement` items type attribute.
// Checks the model at the `changePosition`. Looks at nodes after/before that position and changes those items type
// to the same as node before/after `changePosition`.
function _fixItemsType( changePosition, fixPrevious, document, batch ) {
	let item = changePosition[ fixPrevious ? 'nodeBefore' : 'nodeAfter' ];

	if ( !item || !item.is( 'listItem' ) || item.getAttribute( 'indent' ) === 0 ) {
		// !item - when last item got removed.
		// !item.is( 'listItem' ) - when first element to fix is not a list item already.
		// indent === 0 - do not fix if changes are done on top level lists.
		return;
	}

	document.enqueueChanges( () => {
		const refItem = _getBoundaryItemOfSameList( item, !fixPrevious );

		if ( !refItem || refItem == item ) {
			// !refItem - happens if first list item is inserted.
			// refItem == item - happens if last item is inserted.
			return;
		}

		const refIndent = refItem.getAttribute( 'indent' );
		const refType = refItem.getAttribute( 'type' );

		while ( item && item.is( 'listItem' ) && item.getAttribute( 'indent' ) >= refIndent ) {
			if ( item.getAttribute( 'type' ) != refType && item.getAttribute( 'indent' ) == refIndent ) {
				batch.setAttribute( item, 'type', refType );
			}

			item = item[ fixPrevious ? 'previousSibling' : 'nextSibling' ];
		}
	} );
}

/**
 * A fixer for pasted content that includes list items.
 *
 * It fixes indentation of pasted list items so the pasted items match correctly to the context they are pasted into.
 *
 * Example:
 *
 *		<listItem type="bulleted" indent=0>A</listItem>
 *		<listItem type="bulleted" indent=1>B^</listItem>
 *		// At ^ paste:  <listItem type="bulleted" indent=4>X</listItem>
 *		//              <listItem type="bulleted" indent=5>Y</listItem>
 *		<listItem type="bulleted" indent=2>C</listItem>
 *
 * Should become:
 *
 *		<listItem type="bulleted" indent=0>A</listItem>
 *		<listItem type="bulleted" indent=1>BX</listItem>
 *		<listItem type="bulleted" indent=2>Y/listItem>
 *		<listItem type="bulleted" indent=2>C</listItem>
 *
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Array} args Arguments of {@link module:engine/controller/datacontroller~DataController#insertContent}.
 */
function modelIndentPasteFixer( evt, [ content, selection ] ) {
	// Check whether inserted content starts from a `listItem`. If it does not, it means that there are some other
	// elements before it and there is no need to fix indents, because even if we insert that content into a list,
	// that list will be broken.
	// Note: we also need to handle singular elements because inserting item with indent 0 into 0,1,[],2
	// would create incorrect model.
	let item = content.is( 'documentFragment' ) ? content.getChild( 0 ) : content;

	if ( item && item.is( 'listItem' ) ) {
		// Get a reference list item. Inserted list items will be fixed according to that item.
		const pos = selection.getFirstPosition();
		let refItem = null;

		if ( pos.parent.is( 'listItem' ) ) {
			refItem = pos.parent;
		} else if ( pos.nodeBefore && pos.nodeBefore.is( 'listItem' ) ) {
			refItem = pos.nodeBefore;
		}

		// If there is `refItem` it means that we do insert list items into an existing list.
		if ( refItem ) {
			// First list item in `data` has indent equal to 0 (it is a first list item). It should have indent equal
			// to the indent of reference item. We have to fix the first item and all of it's children and following siblings.
			// Indent of all those items has to be adjusted to reference item.
			const indentChange = refItem.getAttribute( 'indent' );

			// Fix only if there is anything to fix.
			if ( indentChange > 0 ) {
				// Adjust indent of all "first" list items in inserted data.
				while ( item && item.is( 'listItem' ) ) {
					item.setAttribute( 'indent', item.getAttribute( 'indent' ) + indentChange );

					item = item.nextSibling;
				}
			}
		}
	}
}

// Helper function that creates a `<ul><li></li></ul>` or (`<ol>`) structure out of given `modelItem` model `listItem` element.
// Then, it binds created view list item (<li>) with model `listItem` element.
// The function then returns created view list item (<li>).
function generateLiInUl( modelItem, mapper ) {
	const listType = modelItem.getAttribute( 'type' ) == 'numbered' ? 'ol' : 'ul';
	const viewItem = new __WEBPACK_IMPORTED_MODULE_0__viewlistitemelement__["a" /* default */]();

	const viewList = new __WEBPACK_IMPORTED_MODULE_5__ckeditor_ckeditor5_engine_src_view_containerelement__["a" /* default */]( listType, null );
	viewList.appendChildren( viewItem );

	mapper.bindElements( modelItem, viewItem );

	return viewItem;
}

// Helper function that seeks for a list item sibling of given model item (or position) which meets given criteria.
// `options` object may contain one or more of given values (by default they are `false`):
// `options.getNext` - whether next or previous siblings should be checked (default = previous)
// `options.checkAllSiblings` - whether all siblings or just the first one should be checked (default = only one),
// `options.sameIndent` - whether sought sibling should have same indent (default = no),
// `options.biggerIndent` - whether sought sibling should have bigger indent (default = no).
// `options.smallerIndent` - whether sought sibling should have smaller indent (default = no).
// `options.isMapped` - whether sought sibling must be mapped to view (default = no).
// `options.mapper` - used to map model elements when `isMapped` option is set to true.
// `options.indent` - used as reference item when first parameter is a position
// Either `options.sameIndent` or `options.biggerIndent` should be set to `true`.
function getSiblingListItem( modelItemOrPosition, options ) {
	const direction = options.getNext ? 'nextSibling' : 'previousSibling';
	const posDirection = options.getNext ? 'nodeAfter' : 'nodeBefore';
	const checkAllSiblings = !!options.checkAllSiblings;
	const sameIndent = !!options.sameIndent;
	const biggerIndent = !!options.biggerIndent;
	const smallerIndent = !!options.smallerIndent;
	const isMapped = !!options.isMapped;

	const indent = modelItemOrPosition instanceof __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */] ? modelItemOrPosition.getAttribute( 'indent' ) : options.indent;
	let item = modelItemOrPosition instanceof __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_model_element__["a" /* default */] ? modelItemOrPosition[ direction ] : modelItemOrPosition[ posDirection ];

	while ( item && item.name == 'listItem' ) {
		const itemIndent = item.getAttribute( 'indent' );

		if (
			( sameIndent && indent == itemIndent ) ||
			( biggerIndent && indent < itemIndent ) ||
			( smallerIndent && indent > itemIndent )
		) {
			if ( !isMapped || options.mapper.toViewElement( item ) ) {
				return item;
			} else {
				item = item[ direction ];

				continue;
			}
		}

		if ( !checkAllSiblings ) {
			return null;
		}

		item = item[ direction ];
	}

	return null;
}

// Helper function that takes two parameters, that are expected to be view list elements, and merges them.
// The merge happen only if both parameters are UL or OL elements.
function mergeViewLists( firstList, secondList ) {
	if ( firstList && secondList && ( firstList.name == 'ul' || firstList.name == 'ol' ) && firstList.name == secondList.name ) {
		return __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].mergeContainers( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAfter( firstList ) );
	}

	return null;
}

// Helper function that takes model list item element `modelItem`, corresponding view list item element `injectedItem`
// that is not added to the view and is inside a view list element (`ul` or `ol`) and is that's list only child.
// The list is inserted at correct position (element breaking may be needed) and then merged with it's siblings.
// See comments below to better understand the algorithm.
function injectViewList( modelItem, injectedItem, mapper, removePosition ) {
	const injectedList = injectedItem.parent;

	// Position where view list will be inserted.
	let insertPosition;

	// 1. Find previous list item that has same or smaller indent. Basically we are looking for a first model item
	// that is "parent" or "sibling" if injected model item.
	// If there is no such list item, it means that injected list item is the first item in "its list".
	let prevItem = getSiblingListItem( modelItem, { sameIndent: true, smallerIndent: true, checkAllSiblings: true } );

	if ( prevItem && prevItem.getAttribute( 'indent' ) == modelItem.getAttribute( 'indent' ) ) {
		// There is a list item with same indent - we found same-level sibling.
		// Break the list after it. Inserted view item will be inserted in the broken space.
		const viewItem = mapper.toViewElement( prevItem );
		insertPosition = __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAfter( viewItem ) );
	} else {
		// There is no list item with same indent. Check previous model item.
		prevItem = modelItem.previousSibling;

		if ( prevItem && prevItem.name == 'listItem' ) {
			// // If it is a list item, it has to have lower indent.
			// // It means that inserted item should be added to it as its nested item.
			// insertPosition = mapper.toViewPosition( ModelPosition.createAt( prevItem, 'end' ) );
			// ^ ACTUALLY NOT BECAUSE FIXING DOES NOT WORK PROPERLY.
			// TODO: fix this part of code when conversion from model to view is done on `changesDone` event or post/prefixing is better.
			if ( prevItem.getAttribute( 'indent' ) < modelItem.getAttribute( 'indent' ) ) {
				// Lower indent, correct model, previous item is a parent and this model item is its nested item.
				insertPosition = mapper.toViewPosition( __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAt( prevItem, 'end' ) );
			} else {
				// Higher indent, incorrect model that is probably being fixed. Inject the view list where it was.
				// TODO: get rid of `removePosition` when conversion is done on `changesDone`.
				if ( removePosition.parent.is( 'ul' ) || removePosition.parent.is( 'ol' ) ) {
					insertPosition = __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( removePosition );
				} else {
					insertPosition = removePosition;
				}
			}
		} else {
			// Previous item is not a list item (or does not exist at all).
			// Just map the position and insert the view item at mapped position.
			insertPosition = mapper.toViewPosition( __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createBefore( modelItem ) );
		}
	}

	insertPosition = positionAfterUiElements( insertPosition );

	// Insert the view item.
	__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].insert( insertPosition, injectedList );

	// 2. Handle possible children of injected model item.
	// We have to check if next list item in model has bigger indent. If it has, it means that it and possibly
	// some following list items should be nested in the injected view item.
	// Look only after model elements that are already mapped to view. Some following model items might not be mapped
	// if multiple items in model were inserted/moved at once.
	const nextItem = getSiblingListItem(
		modelItem,
		{ biggerIndent: true, getNext: true, isMapped: true, mapper }
	);

	if ( nextItem ) {
		const viewItem = mapper.toViewElement( nextItem );

		// Break the list between found view item and its preceding `<li>`s.
		__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createBefore( viewItem ) );

		// The broken ("lower") part will be moved as nested children of the inserted view item.
		const sourceStart = __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createBefore( viewItem.parent );

		const lastModelItem = _getBoundaryItemOfSameList( nextItem, false );
		const lastViewItem = mapper.toViewElement( lastModelItem );
		const sourceEnd = __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].breakContainer( __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAfter( lastViewItem ) );
		const sourceRange = new __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_range__["a" /* default */]( sourceStart, sourceEnd );

		const targetPosition = __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAt( injectedItem, 'end' );
		__WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].move( sourceRange, targetPosition );
	}

	// Merge inserted view list with its possible neighbour lists.
	mergeViewLists( injectedList, injectedList.nextSibling );
	mergeViewLists( injectedList.previousSibling, injectedList );
}

// Helper function that takes all children of given `viewRemovedItem` and moves them in a correct place, according
// to other given parameters.
function hoistNestedLists( nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, mapper ) {
	// Find correct previous model list item element.
	// The element has to have either same or smaller indent than given reference indent.
	// This will be the model element which will get nested items (if it has smaller indent) or sibling items (if it has same indent).
	// Keep in mind that such element might not be found, if removed item was the first item.
	const prevModelItem = getSiblingListItem( modelRemoveStartPosition, {
		sameIndent: true,
		smallerIndent: true,
		checkAllSiblings: true,
		indent: nextIndent
	} );

	// Indent of found element or `null` if the element has not been found.
	const prevIndent = prevModelItem ? prevModelItem.getAttribute( 'indent' ) : null;

	let insertPosition;

	if ( !prevModelItem ) {
		// If element has not been found, simply insert lists at the position where the removed item was:
		//
		// Lorem ipsum.
		// 1 --------           <--- this is removed, no previous list item, put nested items in place of removed item.
		//   1.1 --------       <--- this is reference indent.
		//     1.1.1 --------
		//     1.1.2 --------
		//   1.2 --------
		//
		// Becomes:
		//
		// Lorem ipsum.
		// 1.1 --------
		//   1.1.1 --------
		//   1.1.2 --------
		// 1.2 --------
		insertPosition = viewRemoveStartPosition;
	} else if ( prevIndent == nextIndent ) {
		// If element has been found and has same indent as reference indent it means that nested items should
		// become siblings of found element:
		//
		// 1 --------
		//   1.1 --------
		//   1.2 --------       <--- this is `prevModelItem`.
		// 2 --------           <--- this is removed, previous list item has indent same as reference indent.
		//   2.1 --------       <--- this is reference indent, this and 2.2 should become siblings of 1.2.
		//   2.2 --------
		//
		// Becomes:
		//
		// 1 --------
		//   1.1 --------
		//   1.2 --------
		//   2.1 --------
		//   2.2 --------
		const prevViewList = mapper.toViewElement( prevModelItem ).parent;
		insertPosition = __WEBPACK_IMPORTED_MODULE_6__ckeditor_ckeditor5_engine_src_view_position__["a" /* default */].createAfter( prevViewList );
	} else {
		// If element has been found and has smaller indent as reference indent it means that nested items
		// should become nested items of found item:
		//
		// 1 --------           <--- this is `prevModelItem`.
		//   1.1 --------       <--- this is removed, previous list item has indent smaller than reference indent.
		//     1.1.1 --------   <--- this is reference indent, this and 1.1.1 should become nested items of 1.
		//     1.1.2 --------
		//   1.2 --------
		//
		// Becomes:
		//
		// 1 --------
		//   1.1.1 --------
		//   1.1.2 --------
		//   1.2 --------
		//
		// Note: in this case 1.1.1 have indent 2 while 1 have indent 0. In model that should not be possible,
		// because following item may have indent bigger only by one. But this is fixed by postfixer.
		const modelPosition = __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_model_position__["a" /* default */].createAt( prevModelItem, 'end' );
		insertPosition = mapper.toViewPosition( modelPosition );
	}

	insertPosition = positionAfterUiElements( insertPosition );

	// Handle multiple lists. This happens if list item has nested numbered and bulleted lists. Following lists
	// are inserted after the first list (no need to recalculate insertion position for them).
	for ( const child of [ ...viewRemovedItem.getChildren() ] ) {
		if ( child.is( 'ul' ) || child.is( 'ol' ) ) {
			insertPosition = __WEBPACK_IMPORTED_MODULE_9__ckeditor_ckeditor5_engine_src_view_writer__["a" /* default */].move( __WEBPACK_IMPORTED_MODULE_7__ckeditor_ckeditor5_engine_src_view_range__["a" /* default */].createOn( child ), insertPosition ).end;

			mergeViewLists( child, child.nextSibling );
			mergeViewLists( child.previousSibling, child );
		}
	}
}

// Helper function to obtain the first or the last model list item which is in on the same indent level as given `item`.
function _getBoundaryItemOfSameList( item, getFirst ) {
	const indent = item.getAttribute( 'indent' );
	const direction = getFirst ? 'previousSibling' : 'nextSibling';

	let result = item;

	while ( item[ direction ] && item[ direction ].is( 'listItem' ) && item[ direction ].getAttribute( 'indent' ) >= indent ) {
		item = item[ direction ];

		if ( item.getAttribute( 'indent' ) == indent ) {
			result = item;
		}
	}

	return result;
}

// Helper function that for given `view.Position`, returns a `view.Position` that is after all `view.UIElement`s that
// are after given position.
// For example:
// <container:p>foo^<ui:span></ui:span><ui:span></ui:span>bar</contain:p>
// For position ^, a position before "bar" will be returned.
function positionAfterUiElements( viewPosition ) {
	return viewPosition.getLastMatchingPosition( value => value.item.is( 'uiElement' ) );
}


/***/ }),
/* 557 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_containerelement__ = __webpack_require__(46);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module list/viewlistitemelement
 */



/**
 * View element class representing a list item (`<li>`). It extends {@link module:engine/view/containerelement~ContainerElement}
 * and overwrites {@link module:list/viewlistitemelement~ViewListItemElement#getFillerOffset evaluating whether filler offset}
 * is needed.
 *
 * @extends module:engine/view/containerelement~ContainerElement
 */
class ViewListItemElement extends __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_containerelement__["a" /* default */] {
	/**
	 * Creates a `<li>` view item.
	 *
	 * @param {Object|Iterable} [attrs] A collection of attributes.
	 * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children] The list of nodes to be inserted
	 * into the created element.
	 */
	constructor( attrs, children ) {
		super( 'li', attrs, children );

		/**
		 * @inheritDoc
		 */
		this.getFillerOffset = getFillerOffset;
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ViewListItemElement;


// Implementation of getFillerOffset for ViewListItemElements.
//
// @returns {Number|null} Block filler offset or `null` if block filler is not needed.
function getFillerOffset() {
	const hasOnlyLists = !this.isEmpty && ( this.getChild( 0 ).name == 'ul' || this.getChild( 0 ).name == 'ol' );

	return this.isEmpty || hasOnlyLists ? 0 : null;
}


/***/ }),
/* 558 */
/***/ (function(module, exports) {

module.exports = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7 17h10v-1H7v1zM6 4v1h13V4H6zm1 6v1h11v-1H7zM2 2.5c0 .277.223.5.5.5H3v3.5a.499.499 0 1 0 1 0v-4c0-.277-.223-.5-.5-.5h-1c-.277 0-.5.223-.5.5zM2.5 8a.499.499 0 1 0 0 1H4v1H2.5c-.277 0-.5.223-.5.5v2c0 .277.223.5.5.5h2a.499.499 0 1 0 0-1H3v-1h1.5a.46.46 0 0 0 .188-.031.45.45 0 0 0 .28-.281A.461.461 0 0 0 5 10.5v-2a.46.46 0 0 0-.031-.187.45.45 0 0 0-.282-.282.463.463 0 0 0-.125-.03H2.5V8zm2.352 10.853a.493.493 0 0 0 .148-.35v-4.005A.493.493 0 0 0 4.505 14h-2.01a.494.494 0 0 0-.495.5c0 .268.222.5.495.5H4v1H2.495a.494.494 0 0 0-.495.5c0 .268.222.5.495.5H4v1H2.495a.494.494 0 0 0-.495.5c0 .268.222.5.495.5h2.01a.49.49 0 0 0 .351-.146z\" fill=\"#454545\" fill-rule=\"evenodd\"/></svg>"

/***/ }),
/* 559 */
/***/ (function(module, exports) {

module.exports = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6 16v1h10v-1H6zM6 4v1h12V4H6zm0 6v1h11v-1H6zM1 4.5C1 3.672 1.666 3 2.5 3 3.328 3 4 3.666 4 4.5 4 5.328 3.334 6 2.5 6 1.672 6 1 5.334 1 4.5zm0 6C1 9.672 1.666 9 2.5 9c.828 0 1.5.666 1.5 1.5 0 .828-.666 1.5-1.5 1.5-.828 0-1.5-.666-1.5-1.5zm0 6c0-.828.666-1.5 1.5-1.5.828 0 1.5.666 1.5 1.5 0 .828-.666 1.5-1.5 1.5-.828 0-1.5-.666-1.5-1.5z\" fill=\"#454545\" fill-rule=\"evenodd\"/></svg>"

/***/ }),
/* 560 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_commonmark__ = __webpack_require__(561);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_commonmark___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_commonmark__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__renderer_renderer__ = __webpack_require__(576);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_dataprocessor_htmldataprocessor__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_view_domconverter__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_turndown_plugin_gfm__ = __webpack_require__(587);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_turndown__ = __webpack_require__(588);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module markdown-gfm/commonmarkdataprocessor
 */

/* eslint-env browser */








/**
 * This data processor implementation uses CommonMark as input/output data.
 *
 * @implements module:engine/dataprocessor/dataprocessor~DataProcessor
 */
class CommonMarkDataProcessor {
	constructor() {
		this._htmlDP = new __WEBPACK_IMPORTED_MODULE_2__ckeditor_ckeditor5_engine_src_dataprocessor_htmldataprocessor__["a" /* default */]();
		this._domConverter = new __WEBPACK_IMPORTED_MODULE_3__ckeditor_ckeditor5_engine_src_view_domconverter__["a" /* default */]();
	}

	/**
	 * Converts the provided CommonMark string to view tree.
	 *
	 * @param {String} data A CommonMark string.
	 * @returns {module:engine/view/documentfragment~DocumentFragment} The converted view element.
	 */
	toView( data ) {
		const parser = new __WEBPACK_IMPORTED_MODULE_0_commonmark___default.a.Parser();
		const ast = parser.parse( data );
		const renderer = new __WEBPACK_IMPORTED_MODULE_1__renderer_renderer__["a" /* default */]();

		return renderer.render( ast );
	}

	/**
	 * Converts the provided {@link module:engine/view/documentfragment~DocumentFragment} to data format &mdash; in this
	 * case to a CommonMark string.
	 *
	 * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment
	 * @returns {String} CommonMark string.
	 */
	toData( viewFragment ) {
		// Convert view DocumentFragment to DOM DocumentFragment.
		const domFragment = this._domConverter.viewToDom( viewFragment, document );

		// Use Turndown to convert DOM fragment to markdown
		const turndownService = new __WEBPACK_IMPORTED_MODULE_5_turndown__["a" /* default */]( { headingStyle: 'atx' } );
		turndownService.use( __WEBPACK_IMPORTED_MODULE_4_turndown_plugin_gfm__["a" /* gfm */] );
		return turndownService.turndown( domFragment );
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CommonMarkDataProcessor;




/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// commonmark.js - CommomMark in JavaScript
// Copyright (C) 2014 John MacFarlane
// License: BSD3.

// Basic usage:
//
// var commonmark = require('commonmark');
// var parser = new commonmark.Parser();
// var renderer = new commonmark.HtmlRenderer();
// console.log(renderer.render(parser.parse('Hello *world*')));

module.exports.Node = __webpack_require__(163);
module.exports.Parser = __webpack_require__(562);
module.exports.HtmlRenderer = __webpack_require__(574);
module.exports.XmlRenderer = __webpack_require__(575);


/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Node = __webpack_require__(163);
var unescapeString = __webpack_require__(61).unescapeString;
var OPENTAG = __webpack_require__(61).OPENTAG;
var CLOSETAG = __webpack_require__(61).CLOSETAG;

var CODE_INDENT = 4;

var C_TAB = 9;
var C_NEWLINE = 10;
var C_GREATERTHAN = 62;
var C_LESSTHAN = 60;
var C_SPACE = 32;
var C_OPEN_BRACKET = 91;

var InlineParser = __webpack_require__(570);

var reHtmlBlockOpen = [
   /./, // dummy for 0
   /^<(?:script|pre|style)(?:\s|>|$)/i,
   /^<!--/,
   /^<[?]/,
   /^<![A-Z]/,
   /^<!\[CDATA\[/,
   /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|title|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
    new RegExp('^(?:' + OPENTAG + '|' + CLOSETAG + ')\\s*$', 'i')
];

var reHtmlBlockClose = [
   /./, // dummy for 0
   /<\/(?:script|pre|style)>/i,
   /-->/,
   /\?>/,
   />/,
   /\]\]>/
];

var reThematicBreak = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/;

var reMaybeSpecial = /^[#`~*+_=<>0-9-]/;

var reNonSpace = /[^ \t\f\v\r\n]/;

var reBulletListMarker = /^[*+-]/;

var reOrderedListMarker = /^(\d{1,9})([.)])/;

var reATXHeadingMarker = /^#{1,6}(?:[ \t]+|$)/;

var reCodeFence = /^`{3,}(?!.*`)|^~{3,}(?!.*~)/;

var reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;

var reSetextHeadingLine = /^(?:=+|-+)[ \t]*$/;

var reLineEnding = /\r\n|\n|\r/;

// Returns true if string contains only space characters.
var isBlank = function(s) {
    return !(reNonSpace.test(s));
};

var isSpaceOrTab = function(c) {
    return c === C_SPACE || c === C_TAB;
};

var peek = function(ln, pos) {
    if (pos < ln.length) {
        return ln.charCodeAt(pos);
    } else {
        return -1;
    }
};

// DOC PARSER

// These are methods of a Parser object, defined below.

// Returns true if block ends with a blank line, descending if needed
// into lists and sublists.
var endsWithBlankLine = function(block) {
    while (block) {
        if (block._lastLineBlank) {
            return true;
        }
        var t = block.type;
        if (t === 'list' || t === 'item') {
            block = block._lastChild;
        } else {
            break;
        }
    }
    return false;
};

// Add a line to the block at the tip.  We assume the tip
// can accept lines -- that check should be done before calling this.
var addLine = function() {
    if (this.partiallyConsumedTab) {
      this.offset += 1; // skip over tab
      // add space characters:
      var charsToTab = 4 - (this.column % 4);
      this.tip._string_content += (' '.repeat(charsToTab));
    }
    this.tip._string_content += this.currentLine.slice(this.offset) + '\n';
};

// Add block of type tag as a child of the tip.  If the tip can't
// accept children, close and finalize it and try its parent,
// and so on til we find a block that can accept children.
var addChild = function(tag, offset) {
    while (!this.blocks[this.tip.type].canContain(tag)) {
        this.finalize(this.tip, this.lineNumber - 1);
    }

    var column_number = offset + 1; // offset 0 = column 1
    var newBlock = new Node(tag, [[this.lineNumber, column_number], [0, 0]]);
    newBlock._string_content = '';
    this.tip.appendChild(newBlock);
    this.tip = newBlock;
    return newBlock;
};

// Parse a list marker and return data on the marker (type,
// start, delimiter, bullet character, padding) or null.
var parseListMarker = function(parser, container) {
    var rest = parser.currentLine.slice(parser.nextNonspace);
    var match;
    var nextc;
    var spacesStartCol;
    var spacesStartOffset;
    var data = { type: null,
                 tight: true,  // lists are tight by default
                 bulletChar: null,
                 start: null,
                 delimiter: null,
                 padding: null,
                 markerOffset: parser.indent };
    if ((match = rest.match(reBulletListMarker))) {
        data.type = 'bullet';
        data.bulletChar = match[0][0];

    } else if ((match = rest.match(reOrderedListMarker)) &&
                (container.type !== 'paragraph' ||
                 match[1] === '1')) {
        data.type = 'ordered';
        data.start = parseInt(match[1]);
        data.delimiter = match[2];
    } else {
        return null;
    }
    // make sure we have spaces after
    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);
    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {
        return null;
    }

    // if it interrupts paragraph, make sure first line isn't blank
    if (container.type === 'paragraph' && !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {
        return null;
    }

    // we've got a match! advance offset and calculate padding
    parser.advanceNextNonspace(); // to start of marker
    parser.advanceOffset(match[0].length, true); // to end of marker
    spacesStartCol = parser.column;
    spacesStartOffset = parser.offset;
    do {
        parser.advanceOffset(1, true);
        nextc = peek(parser.currentLine, parser.offset);
    } while (parser.column - spacesStartCol < 5 &&
           isSpaceOrTab(nextc));
    var blank_item = peek(parser.currentLine, parser.offset) === -1;
    var spaces_after_marker = parser.column - spacesStartCol;
    if (spaces_after_marker >= 5 ||
        spaces_after_marker < 1 ||
        blank_item) {
        data.padding = match[0].length + 1;
        parser.column = spacesStartCol;
        parser.offset = spacesStartOffset;
        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
            parser.advanceOffset(1, true);
        }
    } else {
        data.padding = match[0].length + spaces_after_marker;
    }
    return data;
};

// Returns true if the two list items are of the same type,
// with the same delimiter and bullet character.  This is used
// in agglomerating list items into lists.
var listsMatch = function(list_data, item_data) {
    return (list_data.type === item_data.type &&
            list_data.delimiter === item_data.delimiter &&
            list_data.bulletChar === item_data.bulletChar);
};

// Finalize and close any unmatched blocks.
var closeUnmatchedBlocks = function() {
    if (!this.allClosed) {
        // finalize any blocks not matched
        while (this.oldtip !== this.lastMatchedContainer) {
            var parent = this.oldtip._parent;
            this.finalize(this.oldtip, this.lineNumber - 1);
            this.oldtip = parent;
        }
        this.allClosed = true;
    }
};

// 'finalize' is run when the block is closed.
// 'continue' is run to check whether the block is continuing
// at a certain line and offset (e.g. whether a block quote
// contains a `>`.  It returns 0 for matched, 1 for not matched,
// and 2 for "we've dealt with this line completely, go to next."
var blocks = {
    document: {
        continue: function() { return 0; },
        finalize: function() { return; },
        canContain: function(t) { return (t !== 'item'); },
        acceptsLines: false
    },
    list: {
        continue: function() { return 0; },
        finalize: function(parser, block) {
            var item = block._firstChild;
            while (item) {
                // check for non-final list item ending with blank line:
                if (endsWithBlankLine(item) && item._next) {
                    block._listData.tight = false;
                    break;
                }
                // recurse into children of list item, to see if there are
                // spaces between any of them:
                var subitem = item._firstChild;
                while (subitem) {
                    if (endsWithBlankLine(subitem) &&
                        (item._next || subitem._next)) {
                        block._listData.tight = false;
                        break;
                    }
                    subitem = subitem._next;
                }
                item = item._next;
            }
        },
        canContain: function(t) { return (t === 'item'); },
        acceptsLines: false
    },
    block_quote: {
        continue: function(parser) {
            var ln = parser.currentLine;
            if (!parser.indented &&
                peek(ln, parser.nextNonspace) === C_GREATERTHAN) {
                parser.advanceNextNonspace();
                parser.advanceOffset(1, false);
                if (isSpaceOrTab(peek(ln, parser.offset))) {
                    parser.advanceOffset(1, true);
                }
            } else {
                return 1;
            }
            return 0;
        },
        finalize: function() { return; },
        canContain: function(t) { return (t !== 'item'); },
        acceptsLines: false
    },
    item: {
        continue: function(parser, container) {
            if (parser.blank) {
                if (container._firstChild == null) {
                    // Blank line after empty list item
                    return 1;
                } else {
                    parser.advanceNextNonspace();
                }
            } else if (parser.indent >=
                       container._listData.markerOffset +
                       container._listData.padding) {
                parser.advanceOffset(container._listData.markerOffset +
                    container._listData.padding, true);
            } else {
                return 1;
            }
            return 0;
        },
        finalize: function() { return; },
        canContain: function(t) { return (t !== 'item'); },
        acceptsLines: false
    },
    heading: {
        continue: function() {
            // a heading can never container > 1 line, so fail to match:
            return 1;
        },
        finalize: function() { return; },
        canContain: function() { return false; },
        acceptsLines: false
    },
    thematic_break: {
        continue: function() {
            // a thematic break can never container > 1 line, so fail to match:
            return 1;
        },
        finalize: function() { return; },
        canContain: function() { return false; },
        acceptsLines: false
    },
    code_block: {
        continue: function(parser, container) {
            var ln = parser.currentLine;
            var indent = parser.indent;
            if (container._isFenced) { // fenced
                var match = (indent <= 3 &&
                    ln.charAt(parser.nextNonspace) === container._fenceChar &&
                    ln.slice(parser.nextNonspace).match(reClosingCodeFence));
                if (match && match[0].length >= container._fenceLength) {
                    // closing fence - we're at end of line, so we can return
                    parser.finalize(container, parser.lineNumber);
                    return 2;
                } else {
                    // skip optional spaces of fence offset
                    var i = container._fenceOffset;
                    while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {
                        parser.advanceOffset(1, true);
                        i--;
                    }
                }
            } else { // indented
                if (indent >= CODE_INDENT) {
                    parser.advanceOffset(CODE_INDENT, true);
                } else if (parser.blank) {
                    parser.advanceNextNonspace();
                } else {
                    return 1;
                }
            }
            return 0;
        },
        finalize: function(parser, block) {
            if (block._isFenced) { // fenced
                // first line becomes info string
                var content = block._string_content;
                var newlinePos = content.indexOf('\n');
                var firstLine = content.slice(0, newlinePos);
                var rest = content.slice(newlinePos + 1);
                block.info = unescapeString(firstLine.trim());
                block._literal = rest;
            } else { // indented
                block._literal = block._string_content.replace(/(\n *)+$/, '\n');
            }
            block._string_content = null; // allow GC
        },
        canContain: function() { return false; },
        acceptsLines: true
    },
    html_block: {
        continue: function(parser, container) {
            return ((parser.blank &&
                     (container._htmlBlockType === 6 ||
                      container._htmlBlockType === 7)) ? 1 : 0);
        },
        finalize: function(parser, block) {
            block._literal = block._string_content.replace(/(\n *)+$/, '');
            block._string_content = null; // allow GC
        },
        canContain: function() { return false; },
        acceptsLines: true
    },
    paragraph: {
        continue: function(parser) {
            return (parser.blank ? 1 : 0);
        },
        finalize: function(parser, block) {
            var pos;
            var hasReferenceDefs = false;

            // try parsing the beginning as link reference definitions:
            while (peek(block._string_content, 0) === C_OPEN_BRACKET &&
                   (pos =
                    parser.inlineParser.parseReference(block._string_content,
                                                       parser.refmap))) {
                block._string_content = block._string_content.slice(pos);
                hasReferenceDefs = true;
            }
            if (hasReferenceDefs && isBlank(block._string_content)) {
                block.unlink();
            }
        },
        canContain: function() { return false; },
        acceptsLines: true
    }
};

// block start functions.  Return values:
// 0 = no match
// 1 = matched container, keep going
// 2 = matched leaf, no more block starts
var blockStarts = [
    // block quote
    function(parser) {
        if (!parser.indented &&
            peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {
            parser.advanceNextNonspace();
            parser.advanceOffset(1, false);
            // optional following space
            if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
                parser.advanceOffset(1, true);
            }
            parser.closeUnmatchedBlocks();
            parser.addChild('block_quote', parser.nextNonspace);
            return 1;
        } else {
            return 0;
        }
    },

    // ATX heading
    function(parser) {
        var match;
        if (!parser.indented &&
            (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {
            parser.advanceNextNonspace();
            parser.advanceOffset(match[0].length, false);
            parser.closeUnmatchedBlocks();
            var container = parser.addChild('heading', parser.nextNonspace);
            container.level = match[0].trim().length; // number of #s
            // remove trailing ###s:
            container._string_content =
                parser.currentLine.slice(parser.offset).replace(/^[ \t]*#+[ \t]*$/, '').replace(/[ \t]+#+[ \t]*$/, '');
            parser.advanceOffset(parser.currentLine.length - parser.offset);
            return 2;
        } else {
            return 0;
        }
    },

    // Fenced code block
    function(parser) {
        var match;
        if (!parser.indented &&
            (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {
            var fenceLength = match[0].length;
            parser.closeUnmatchedBlocks();
            var container = parser.addChild('code_block', parser.nextNonspace);
            container._isFenced = true;
            container._fenceLength = fenceLength;
            container._fenceChar = match[0][0];
            container._fenceOffset = parser.indent;
            parser.advanceNextNonspace();
            parser.advanceOffset(fenceLength, false);
            return 2;
        } else {
            return 0;
        }
    },

    // HTML block
    function(parser, container) {
        if (!parser.indented &&
            peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {
            var s = parser.currentLine.slice(parser.nextNonspace);
            var blockType;

            for (blockType = 1; blockType <= 7; blockType++) {
                if (reHtmlBlockOpen[blockType].test(s) &&
                    (blockType < 7 ||
                     container.type !== 'paragraph')) {
                    parser.closeUnmatchedBlocks();
                    // We don't adjust parser.offset;
                    // spaces are part of the HTML block:
                    var b = parser.addChild('html_block',
                                            parser.offset);
                    b._htmlBlockType = blockType;
                    return 2;
                }
            }
        }

        return 0;

    },

    // Setext heading
    function(parser, container) {
        var match;
        if (!parser.indented &&
            container.type === 'paragraph' &&
                   ((match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine)))) {
            parser.closeUnmatchedBlocks();
            var heading = new Node('heading', container.sourcepos);
            heading.level = match[0][0] === '=' ? 1 : 2;
            heading._string_content = container._string_content;
            container.insertAfter(heading);
            container.unlink();
            parser.tip = heading;
            parser.advanceOffset(parser.currentLine.length - parser.offset, false);
            return 2;
        } else {
            return 0;
        }
    },

    // thematic break
    function(parser) {
        if (!parser.indented &&
            reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {
            parser.closeUnmatchedBlocks();
            parser.addChild('thematic_break', parser.nextNonspace);
            parser.advanceOffset(parser.currentLine.length - parser.offset, false);
            return 2;
        } else {
            return 0;
        }
    },

    // list item
    function(parser, container) {
        var data;

        if ((!parser.indented || container.type === 'list')
                && (data = parseListMarker(parser, container))) {
            parser.closeUnmatchedBlocks();

            // add the list if needed
            if (parser.tip.type !== 'list' ||
                !(listsMatch(container._listData, data))) {
                container = parser.addChild('list', parser.nextNonspace);
                container._listData = data;
            }

            // add the list item
            container = parser.addChild('item', parser.nextNonspace);
            container._listData = data;
            return 1;
        } else {
            return 0;
        }
    },

    // indented code block
    function(parser) {
        if (parser.indented &&
            parser.tip.type !== 'paragraph' &&
            !parser.blank) {
            // indented code
            parser.advanceOffset(CODE_INDENT, true);
            parser.closeUnmatchedBlocks();
            parser.addChild('code_block', parser.offset);
            return 2;
        } else {
            return 0;
        }
     }

];

var advanceOffset = function(count, columns) {
    var currentLine = this.currentLine;
    var charsToTab, charsToAdvance;
    var c;
    while (count > 0 && (c = currentLine[this.offset])) {
        if (c === '\t') {
            charsToTab = 4 - (this.column % 4);
            if (columns) {
                this.partiallyConsumedTab = charsToTab > count;
                charsToAdvance = charsToTab > count ? count : charsToTab;
                this.column += charsToAdvance;
                this.offset += this.partiallyConsumedTab ? 0 : 1;
                count -= charsToAdvance;
            } else {
                this.partiallyConsumedTab = false;
                this.column += charsToTab;
                this.offset += 1;
                count -= 1;
            }
        } else {
            this.partiallyConsumedTab = false;
            this.offset += 1;
            this.column += 1; // assume ascii; block starts are ascii
            count -= 1;
        }
    }
};

var advanceNextNonspace = function() {
    this.offset = this.nextNonspace;
    this.column = this.nextNonspaceColumn;
    this.partiallyConsumedTab = false;
};

var findNextNonspace = function() {
    var currentLine = this.currentLine;
    var i = this.offset;
    var cols = this.column;
    var c;

    while ((c = currentLine.charAt(i)) !== '') {
        if (c === ' ') {
            i++;
            cols++;
        } else if (c === '\t') {
            i++;
            cols += (4 - (cols % 4));
        } else {
            break;
        }
    }
    this.blank = (c === '\n' || c === '\r' || c === '');
    this.nextNonspace = i;
    this.nextNonspaceColumn = cols;
    this.indent = this.nextNonspaceColumn - this.column;
    this.indented = this.indent >= CODE_INDENT;
};

// Analyze a line of text and update the document appropriately.
// We parse markdown text by calling this on each line of input,
// then finalizing the document.
var incorporateLine = function(ln) {
    var all_matched = true;
    var t;

    var container = this.doc;
    this.oldtip = this.tip;
    this.offset = 0;
    this.column = 0;
    this.blank = false;
    this.partiallyConsumedTab = false;
    this.lineNumber += 1;

    // replace NUL characters for security
    if (ln.indexOf('\u0000') !== -1) {
        ln = ln.replace(/\0/g, '\uFFFD');
    }

    this.currentLine = ln;

    // For each containing block, try to parse the associated line start.
    // Bail out on failure: container will point to the last matching block.
    // Set all_matched to false if not all containers match.
    var lastChild;
    while ((lastChild = container._lastChild) && lastChild._open) {
        container = lastChild;

        this.findNextNonspace();

        switch (this.blocks[container.type].continue(this, container)) {
        case 0: // we've matched, keep going
            break;
        case 1: // we've failed to match a block
            all_matched = false;
            break;
        case 2: // we've hit end of line for fenced code close and can return
            this.lastLineLength = ln.length;
            return;
        default:
            throw 'continue returned illegal value, must be 0, 1, or 2';
        }
        if (!all_matched) {
            container = container._parent; // back up to last matching block
            break;
        }
    }

    this.allClosed = (container === this.oldtip);
    this.lastMatchedContainer = container;

    var matchedLeaf = container.type !== 'paragraph' &&
            blocks[container.type].acceptsLines;
    var starts = this.blockStarts;
    var startsLen = starts.length;
    // Unless last matched container is a code block, try new container starts,
    // adding children to the last matched container:
    while (!matchedLeaf) {

        this.findNextNonspace();

        // this is a little performance optimization:
        if (!this.indented &&
            !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {
            this.advanceNextNonspace();
            break;
        }

        var i = 0;
        while (i < startsLen) {
            var res = starts[i](this, container);
            if (res === 1) {
                container = this.tip;
                break;
            } else if (res === 2) {
                container = this.tip;
                matchedLeaf = true;
                break;
            } else {
                i++;
            }
        }

        if (i === startsLen) { // nothing matched
            this.advanceNextNonspace();
            break;
        }
    }

    // What remains at the offset is a text line.  Add the text to the
    // appropriate container.

   // First check for a lazy paragraph continuation:
    if (!this.allClosed && !this.blank &&
        this.tip.type === 'paragraph') {
        // lazy paragraph continuation
        this.addLine();

    } else { // not a lazy continuation

        // finalize any blocks not matched
        this.closeUnmatchedBlocks();
        if (this.blank && container.lastChild) {
            container.lastChild._lastLineBlank = true;
        }

        t = container.type;

        // Block quote lines are never blank as they start with >
        // and we don't count blanks in fenced code for purposes of tight/loose
        // lists or breaking out of lists.  We also don't set _lastLineBlank
        // on an empty list item, or if we just closed a fenced block.
        var lastLineBlank = this.blank &&
            !(t === 'block_quote' ||
              (t === 'code_block' && container._isFenced) ||
              (t === 'item' &&
               !container._firstChild &&
               container.sourcepos[0][0] === this.lineNumber));

        // propagate lastLineBlank up through parents:
        var cont = container;
        while (cont) {
            cont._lastLineBlank = lastLineBlank;
            cont = cont._parent;
        }

        if (this.blocks[t].acceptsLines) {
            this.addLine();
            // if HtmlBlock, check for end condition
            if (t === 'html_block' &&
                container._htmlBlockType >= 1 &&
                container._htmlBlockType <= 5 &&
                reHtmlBlockClose[container._htmlBlockType].test(this.currentLine.slice(this.offset))) {
                this.finalize(container, this.lineNumber);
            }

        } else if (this.offset < ln.length && !this.blank) {
            // create paragraph container for line
            container = this.addChild('paragraph', this.offset);
            this.advanceNextNonspace();
            this.addLine();
        }
    }
    this.lastLineLength = ln.length;
};

// Finalize a block.  Close it and do any necessary postprocessing,
// e.g. creating string_content from strings, setting the 'tight'
// or 'loose' status of a list, and parsing the beginnings
// of paragraphs for reference definitions.  Reset the tip to the
// parent of the closed block.
var finalize = function(block, lineNumber) {
    var above = block._parent;
    block._open = false;
    block.sourcepos[1] = [lineNumber, this.lastLineLength];

    this.blocks[block.type].finalize(this, block);

    this.tip = above;
};

// Walk through a block & children recursively, parsing string content
// into inline content where appropriate.
var processInlines = function(block) {
    var node, event, t;
    var walker = block.walker();
    this.inlineParser.refmap = this.refmap;
    this.inlineParser.options = this.options;
    while ((event = walker.next())) {
        node = event.node;
        t = node.type;
        if (!event.entering && (t === 'paragraph' || t === 'heading')) {
            this.inlineParser.parse(node);
        }
    }
};

var Document = function() {
    var doc = new Node('document', [[1, 1], [0, 0]]);
    return doc;
};

// The main parsing function.  Returns a parsed document AST.
var parse = function(input) {
    this.doc = new Document();
    this.tip = this.doc;
    this.refmap = {};
    this.lineNumber = 0;
    this.lastLineLength = 0;
    this.offset = 0;
    this.column = 0;
    this.lastMatchedContainer = this.doc;
    this.currentLine = "";
    if (this.options.time) { console.time("preparing input"); }
    var lines = input.split(reLineEnding);
    var len = lines.length;
    if (input.charCodeAt(input.length - 1) === C_NEWLINE) {
        // ignore last blank line created by final newline
        len -= 1;
    }
    if (this.options.time) { console.timeEnd("preparing input"); }
    if (this.options.time) { console.time("block parsing"); }
    for (var i = 0; i < len; i++) {
        this.incorporateLine(lines[i]);
    }
    while (this.tip) {
        this.finalize(this.tip, len);
    }
    if (this.options.time) { console.timeEnd("block parsing"); }
    if (this.options.time) { console.time("inline parsing"); }
    this.processInlines(this.doc);
    if (this.options.time) { console.timeEnd("inline parsing"); }
    return this.doc;
};


// The Parser object.
function Parser(options){
    return {
        doc: new Document(),
        blocks: blocks,
        blockStarts: blockStarts,
        tip: this.doc,
        oldtip: this.doc,
        currentLine: "",
        lineNumber: 0,
        offset: 0,
        column: 0,
        nextNonspace: 0,
        nextNonspaceColumn: 0,
        indent: 0,
        indented: false,
        blank: false,
        partiallyConsumedTab: false,
        allClosed: true,
        lastMatchedContainer: this.doc,
        refmap: {},
        lastLineLength: 0,
        inlineParser: new InlineParser(options),
        findNextNonspace: findNextNonspace,
        advanceOffset: advanceOffset,
        advanceNextNonspace: advanceNextNonspace,
        addLine: addLine,
        addChild: addChild,
        incorporateLine: incorporateLine,
        finalize: finalize,
        processInlines: processInlines,
        closeUnmatchedBlocks: closeUnmatchedBlocks,
        parse: parse,
        options: options || {}
    };
}

module.exports = Parser;


/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";




var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";


module.exports = encode;


/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";




/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i, ch, cache = decodeCache[exclude];
  if (cache) { return cache; }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}


// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l, b1, b2, b3, b4, chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

          if (chr < 0x80) {
            result += '\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
            result += '\ufffd\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\ufffd\ufffd\ufffd\ufffd';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\ufffd';
    }

    return result;
  });
}


decode.defaultChars   = ';/?:@&=+$,#';
decode.componentChars = '';


module.exports = decode;


/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

var inverseXML = getInverseObj(__webpack_require__(284)),
    xmlReplacer = getInverseReplacer(inverseXML);

exports.XML = getInverse(inverseXML, xmlReplacer);

var inverseHTML = getInverseObj(__webpack_require__(285)),
    htmlReplacer = getInverseReplacer(inverseHTML);

exports.HTML = getInverse(inverseHTML, htmlReplacer);

function getInverseObj(obj){
	return Object.keys(obj).sort().reduce(function(inverse, name){
		inverse[obj[name]] = "&" + name + ";";
		return inverse;
	}, {});
}

function getInverseReplacer(inverse){
	var single = [],
	    multiple = [];

	Object.keys(inverse).forEach(function(k){
		if(k.length === 1){
			single.push("\\" + k);
		} else {
			multiple.push(k);
		}
	});

	//TODO add ranges
	multiple.unshift("[" + single.join("") + "]");

	return new RegExp(multiple.join("|"), "g");
}

var re_nonASCII = /[^\0-\x7F]/g,
    re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function singleCharReplacer(c){
	return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
}

function astralReplacer(c){
	// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	var high = c.charCodeAt(0);
	var low  = c.charCodeAt(1);
	var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
	return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}

function getInverse(inverse, re){
	function func(name){
		return inverse[name];
	}

	return function(data){
		return data
				.replace(re, func)
				.replace(re_astralSymbols, astralReplacer)
				.replace(re_nonASCII, singleCharReplacer);
	};
}

var re_xmlChars = getInverseReplacer(inverseXML);

function escapeXML(data){
	return data
			.replace(re_xmlChars, singleCharReplacer)
			.replace(re_astralSymbols, astralReplacer)
			.replace(re_nonASCII, singleCharReplacer);
}

exports.escape = escapeXML;


/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

var entityMap = __webpack_require__(285),
    legacyMap = __webpack_require__(567),
    xmlMap    = __webpack_require__(284),
    decodeCodePoint = __webpack_require__(568);

var decodeXMLStrict  = getStrictDecoder(xmlMap),
    decodeHTMLStrict = getStrictDecoder(entityMap);

function getStrictDecoder(map){
	var keys = Object.keys(map).join("|"),
	    replace = getReplacer(map);

	keys += "|#[xX][\\da-fA-F]+|#\\d+";

	var re = new RegExp("&(?:" + keys + ");", "g");

	return function(str){
		return String(str).replace(re, replace);
	};
}

var decodeHTML = (function(){
	var legacy = Object.keys(legacyMap)
		.sort(sorter);

	var keys = Object.keys(entityMap)
		.sort(sorter);

	for(var i = 0, j = 0; i < keys.length; i++){
		if(legacy[j] === keys[i]){
			keys[i] += ";?";
			j++;
		} else {
			keys[i] += ";";
		}
	}

	var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
	    replace = getReplacer(entityMap);

	function replacer(str){
		if(str.substr(-1) !== ";") str += ";";
		return replace(str);
	}

	//TODO consider creating a merged map
	return function(str){
		return String(str).replace(re, replacer);
	};
}());

function sorter(a, b){
	return a < b ? 1 : -1;
}

function getReplacer(map){
	return function replace(str){
		if(str.charAt(1) === "#"){
			if(str.charAt(2) === "X" || str.charAt(2) === "x"){
				return decodeCodePoint(parseInt(str.substr(3), 16));
			}
			return decodeCodePoint(parseInt(str.substr(2), 10));
		}
		return map[str.slice(1, -1)];
	};
}

module.exports = {
	XML: decodeXMLStrict,
	HTML: decodeHTML,
	HTMLStrict: decodeHTMLStrict
};

/***/ }),
/* 567 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"","aacute":"","Acirc":"","acirc":"","acute":"","AElig":"","aelig":"","Agrave":"","agrave":"","amp":"&","AMP":"&","Aring":"","aring":"","Atilde":"","atilde":"","Auml":"","auml":"","brvbar":"","Ccedil":"","ccedil":"","cedil":"","cent":"","copy":"","COPY":"","curren":"","deg":"","divide":"","Eacute":"","eacute":"","Ecirc":"","ecirc":"","Egrave":"","egrave":"","ETH":"","eth":"","Euml":"","euml":"","frac12":"","frac14":"","frac34":"","gt":">","GT":">","Iacute":"","iacute":"","Icirc":"","icirc":"","iexcl":"","Igrave":"","igrave":"","iquest":"","Iuml":"","iuml":"","laquo":"","lt":"<","LT":"<","macr":"","micro":"","middot":"","nbsp":"","not":"","Ntilde":"","ntilde":"","Oacute":"","oacute":"","Ocirc":"","ocirc":"","Ograve":"","ograve":"","ordf":"","ordm":"","Oslash":"","oslash":"","Otilde":"","otilde":"","Ouml":"","ouml":"","para":"","plusmn":"","pound":"","quot":"\"","QUOT":"\"","raquo":"","reg":"","REG":"","sect":"","shy":"","sup1":"","sup2":"","sup3":"","szlig":"","THORN":"","thorn":"","times":"","Uacute":"","uacute":"","Ucirc":"","ucirc":"","Ugrave":"","ugrave":"","uml":"","Uuml":"","uuml":"","Yacute":"","yacute":"","yen":"","yuml":""}

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

var decodeMap = __webpack_require__(569);

module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint){

	if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
		return "\uFFFD";
	}

	if(codePoint in decodeMap){
		codePoint = decodeMap[codePoint];
	}

	var output = "";

	if(codePoint > 0xFFFF){
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}


/***/ }),
/* 569 */
/***/ (function(module, exports) {

module.exports = {"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Node = __webpack_require__(163);
var common = __webpack_require__(61);
var normalizeReference = __webpack_require__(571);

var normalizeURI = common.normalizeURI;
var unescapeString = common.unescapeString;
var fromCodePoint = __webpack_require__(572);
var decodeHTML = __webpack_require__(283).decodeHTML;
__webpack_require__(573); // Polyfill for String.prototype.repeat

// Constants for character codes:

var C_NEWLINE = 10;
var C_ASTERISK = 42;
var C_UNDERSCORE = 95;
var C_BACKTICK = 96;
var C_OPEN_BRACKET = 91;
var C_CLOSE_BRACKET = 93;
var C_LESSTHAN = 60;
var C_BANG = 33;
var C_BACKSLASH = 92;
var C_AMPERSAND = 38;
var C_OPEN_PAREN = 40;
var C_CLOSE_PAREN = 41;
var C_COLON = 58;
var C_SINGLEQUOTE = 39;
var C_DOUBLEQUOTE = 34;

// Some regexps used in inline parser:

var ESCAPABLE = common.ESCAPABLE;
var ESCAPED_CHAR = '\\\\' + ESCAPABLE;

var ENTITY = common.ENTITY;
var reHtmlTag = common.reHtmlTag;

var rePunctuation = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/);

var reLinkTitle = new RegExp(
    '^(?:"(' + ESCAPED_CHAR + '|[^"\\x00])*"' +
        '|' +
        '\'(' + ESCAPED_CHAR + '|[^\'\\x00])*\'' +
        '|' +
        '\\((' + ESCAPED_CHAR + '|[^)\\x00])*\\))');

var reLinkDestinationBraces = new RegExp(
    '^(?:[<](?:[^ <>\\t\\n\\\\\\x00]' + '|' + ESCAPED_CHAR + '|' + '\\\\)*[>])');

var reEscapable = new RegExp('^' + ESCAPABLE);

var reEntityHere = new RegExp('^' + ENTITY, 'i');

var reTicks = /`+/;

var reTicksHere = /^`+/;

var reEllipses = /\.\.\./g;

var reDash = /--+/g;

var reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;

var reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i;

var reSpnl = /^ *(?:\n *)?/;

var reWhitespaceChar = /^[ \t\n\x0b\x0c\x0d]/;

var reWhitespace = /[ \t\n\x0b\x0c\x0d]+/g;

var reUnicodeWhitespaceChar = /^\s/;

var reFinalSpace = / *$/;

var reInitialSpace = /^ */;

var reSpaceAtEndOfLine = /^ *(?:\n|$)/;

var reLinkLabel = new RegExp('^\\[(?:[^\\\\\\[\\]]|' + ESCAPED_CHAR +
  '|\\\\){0,1000}\\]');

// Matches a string of non-special characters.
var reMain = /^[^\n`\[\]\\!<&*_'"]+/m;

var text = function(s) {
    var node = new Node('text');
    node._literal = s;
    return node;
};

// INLINE PARSER

// These are methods of an InlineParser object, defined below.
// An InlineParser keeps track of a subject (a string to be
// parsed) and a position in that subject.

// If re matches at current position in the subject, advance
// position in subject and return the match; otherwise return null.
var match = function(re) {
    var m = re.exec(this.subject.slice(this.pos));
    if (m === null) {
        return null;
    } else {
        this.pos += m.index + m[0].length;
        return m[0];
    }
};

// Returns the code for the character at the current subject position, or -1
// there are no more characters.
var peek = function() {
    if (this.pos < this.subject.length) {
        return this.subject.charCodeAt(this.pos);
    } else {
        return -1;
    }
};

// Parse zero or more space characters, including at most one newline
var spnl = function() {
    this.match(reSpnl);
    return true;
};

// All of the parsers below try to match something at the current position
// in the subject.  If they succeed in matching anything, they
// return the inline matched, advancing the subject.

// Attempt to parse backticks, adding either a backtick code span or a
// literal sequence of backticks.
var parseBackticks = function(block) {
    var ticks = this.match(reTicksHere);
    if (ticks === null) {
        return false;
    }
    var afterOpenTicks = this.pos;
    var matched;
    var node;
    while ((matched = this.match(reTicks)) !== null) {
        if (matched === ticks) {
            node = new Node('code');
            node._literal = this.subject.slice(afterOpenTicks,
                                        this.pos - ticks.length)
                          .trim().replace(reWhitespace, ' ');
            block.appendChild(node);
            return true;
        }
    }
    // If we got here, we didn't match a closing backtick sequence.
    this.pos = afterOpenTicks;
    block.appendChild(text(ticks));
    return true;
};

// Parse a backslash-escaped special character, adding either the escaped
// character, a hard line break (if the backslash is followed by a newline),
// or a literal backslash to the block's children.  Assumes current character
// is a backslash.
var parseBackslash = function(block) {
    var subj = this.subject;
    var node;
    this.pos += 1;
    if (this.peek() === C_NEWLINE) {
        this.pos += 1;
        node = new Node('linebreak');
        block.appendChild(node);
    } else if (reEscapable.test(subj.charAt(this.pos))) {
        block.appendChild(text(subj.charAt(this.pos)));
        this.pos += 1;
    } else {
        block.appendChild(text('\\'));
    }
    return true;
};

// Attempt to parse an autolink (URL or email in pointy brackets).
var parseAutolink = function(block) {
    var m;
    var dest;
    var node;
    if ((m = this.match(reEmailAutolink))) {
        dest = m.slice(1, m.length - 1);
        node = new Node('link');
        node._destination = normalizeURI('mailto:' + dest);
        node._title = '';
        node.appendChild(text(dest));
        block.appendChild(node);
        return true;
    } else if ((m = this.match(reAutolink))) {
        dest = m.slice(1, m.length - 1);
        node = new Node('link');
        node._destination = normalizeURI(dest);
        node._title = '';
        node.appendChild(text(dest));
        block.appendChild(node);
        return true;
    } else {
        return false;
    }
};

// Attempt to parse a raw HTML tag.
var parseHtmlTag = function(block) {
    var m = this.match(reHtmlTag);
    if (m === null) {
        return false;
    } else {
        var node = new Node('html_inline');
        node._literal = m;
        block.appendChild(node);
        return true;
    }
};

// Scan a sequence of characters with code cc, and return information about
// the number of delimiters and whether they are positioned such that
// they can open and/or close emphasis or strong emphasis.  A utility
// function for strong/emph parsing.
var scanDelims = function(cc) {
    var numdelims = 0;
    var char_before, char_after, cc_after;
    var startpos = this.pos;
    var left_flanking, right_flanking, can_open, can_close;
    var after_is_whitespace, after_is_punctuation, before_is_whitespace, before_is_punctuation;

    if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
        numdelims++;
        this.pos++;
    } else {
        while (this.peek() === cc) {
            numdelims++;
            this.pos++;
        }
    }

    if (numdelims === 0) {
        return null;
    }

    char_before = startpos === 0 ? '\n' : this.subject.charAt(startpos - 1);

    cc_after = this.peek();
    if (cc_after === -1) {
        char_after = '\n';
    } else {
        char_after = fromCodePoint(cc_after);
    }

    after_is_whitespace = reUnicodeWhitespaceChar.test(char_after);
    after_is_punctuation = rePunctuation.test(char_after);
    before_is_whitespace = reUnicodeWhitespaceChar.test(char_before);
    before_is_punctuation = rePunctuation.test(char_before);

    left_flanking = !after_is_whitespace &&
            (!after_is_punctuation || before_is_whitespace || before_is_punctuation);
    right_flanking = !before_is_whitespace &&
            (!before_is_punctuation || after_is_whitespace || after_is_punctuation);
    if (cc === C_UNDERSCORE) {
        can_open = left_flanking &&
            (!right_flanking || before_is_punctuation);
        can_close = right_flanking &&
            (!left_flanking || after_is_punctuation);
    } else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
        can_open = left_flanking && !right_flanking;
        can_close = right_flanking;
    } else {
        can_open = left_flanking;
        can_close = right_flanking;
    }
    this.pos = startpos;
    return { numdelims: numdelims,
             can_open: can_open,
             can_close: can_close };
};

// Handle a delimiter marker for emphasis or a quote.
var handleDelim = function(cc, block) {
    var res = this.scanDelims(cc);
    if (!res) {
        return false;
    }
    var numdelims = res.numdelims;
    var startpos = this.pos;
    var contents;

    this.pos += numdelims;
    if (cc === C_SINGLEQUOTE) {
        contents = "\u2019";
    } else if (cc === C_DOUBLEQUOTE) {
        contents = "\u201C";
    } else {
        contents = this.subject.slice(startpos, this.pos);
    }
    var node = text(contents);
    block.appendChild(node);

    // Add entry to stack for this opener
    this.delimiters = { cc: cc,
                        numdelims: numdelims,
                        origdelims: numdelims,
                        node: node,
                        previous: this.delimiters,
                        next: null,
                        can_open: res.can_open,
                        can_close: res.can_close };
    if (this.delimiters.previous !== null) {
        this.delimiters.previous.next = this.delimiters;
    }

    return true;

};

var removeDelimiter = function(delim) {
    if (delim.previous !== null) {
        delim.previous.next = delim.next;
    }
    if (delim.next === null) {
        // top of stack
        this.delimiters = delim.previous;
    } else {
        delim.next.previous = delim.previous;
    }
};

var removeDelimitersBetween = function(bottom, top) {
    if (bottom.next !== top) {
        bottom.next = top;
        top.previous = bottom;
    }
};

var processEmphasis = function(stack_bottom) {
    var opener, closer, old_closer;
    var opener_inl, closer_inl;
    var tempstack;
    var use_delims;
    var tmp, next;
    var opener_found;
    var openers_bottom = [];
    var odd_match = false;

    openers_bottom[C_UNDERSCORE] = stack_bottom;
    openers_bottom[C_ASTERISK] = stack_bottom;
    openers_bottom[C_SINGLEQUOTE] = stack_bottom;
    openers_bottom[C_DOUBLEQUOTE] = stack_bottom;

    // find first closer above stack_bottom:
    closer = this.delimiters;
    while (closer !== null && closer.previous !== stack_bottom) {
        closer = closer.previous;
    }
    // move forward, looking for closers, and handling each
    while (closer !== null) {
        var closercc = closer.cc;
        if (!closer.can_close) {
            closer = closer.next;
        } else {
            // found emphasis closer. now look back for first matching opener:
            opener = closer.previous;
            opener_found = false;
            while (opener !== null && opener !== stack_bottom &&
                   opener !== openers_bottom[closercc]) {
                odd_match = (closer.can_open || opener.can_close) &&
                    (opener.origdelims + closer.origdelims) % 3 === 0;
                if (opener.cc === closer.cc && opener.can_open && !odd_match) {
                    opener_found = true;
                    break;
                }
                opener = opener.previous;
            }
            old_closer = closer;

            if (closercc === C_ASTERISK || closercc === C_UNDERSCORE) {
                if (!opener_found) {
                    closer = closer.next;
                } else {
                    // calculate actual number of delimiters used from closer
                    use_delims =
                      (closer.numdelims >= 2 && opener.numdelims >= 2) ? 2 : 1;

                    opener_inl = opener.node;
                    closer_inl = closer.node;

                    // remove used delimiters from stack elts and inlines
                    opener.numdelims -= use_delims;
                    closer.numdelims -= use_delims;
                    opener_inl._literal =
                        opener_inl._literal.slice(0,
                                                  opener_inl._literal.length - use_delims);
                    closer_inl._literal =
                        closer_inl._literal.slice(0,
                                                  closer_inl._literal.length - use_delims);

                    // build contents for new emph element
                    var emph = new Node(use_delims === 1 ? 'emph' : 'strong');

                    tmp = opener_inl._next;
                    while (tmp && tmp !== closer_inl) {
                        next = tmp._next;
                        tmp.unlink();
                        emph.appendChild(tmp);
                        tmp = next;
                    }

                    opener_inl.insertAfter(emph);

                    // remove elts between opener and closer in delimiters stack
                    removeDelimitersBetween(opener, closer);

                    // if opener has 0 delims, remove it and the inline
                    if (opener.numdelims === 0) {
                        opener_inl.unlink();
                        this.removeDelimiter(opener);
                    }

                    if (closer.numdelims === 0) {
                        closer_inl.unlink();
                        tempstack = closer.next;
                        this.removeDelimiter(closer);
                        closer = tempstack;
                    }

                }

            } else if (closercc === C_SINGLEQUOTE) {
                closer.node._literal = "\u2019";
                if (opener_found) {
                    opener.node._literal = "\u2018";
                }
                closer = closer.next;

            } else if (closercc === C_DOUBLEQUOTE) {
                closer.node._literal = "\u201D";
                if (opener_found) {
                    opener.node.literal = "\u201C";
                }
                closer = closer.next;

            }
            if (!opener_found && !odd_match) {
                // Set lower bound for future searches for openers:
                // We don't do this with odd_match because a **
                // that doesn't match an earlier * might turn into
                // an opener, and the * might be matched by something
                // else.
                openers_bottom[closercc] = old_closer.previous;
                if (!old_closer.can_open) {
                    // We can remove a closer that can't be an opener,
                    // once we've seen there's no matching opener:
                    this.removeDelimiter(old_closer);
                }
            }
        }

    }

    // remove all delimiters
    while (this.delimiters !== null && this.delimiters !== stack_bottom) {
        this.removeDelimiter(this.delimiters);
    }
};

// Attempt to parse link title (sans quotes), returning the string
// or null if no match.
var parseLinkTitle = function() {
    var title = this.match(reLinkTitle);
    if (title === null) {
        return null;
    } else {
        // chop off quotes from title and unescape:
        return unescapeString(title.substr(1, title.length - 2));
    }
};

// Attempt to parse link destination, returning the string or
// null if no match.
var parseLinkDestination = function() {
    var res = this.match(reLinkDestinationBraces);
    if (res === null) {
        // TODO handrolled parser; res should be null or the string
        var savepos = this.pos;
        var openparens = 0;
        var c;
        while ((c = this.peek()) !== -1) {
            if (c === C_BACKSLASH) {
                this.pos += 1;
                if (this.peek() !== -1) {
                    this.pos += 1;
                }
            } else if (c === C_OPEN_PAREN) {
                this.pos += 1;
                openparens += 1;
            } else if (c === C_CLOSE_PAREN) {
                if (openparens < 1) {
                    break;
                } else {
                    this.pos += 1;
                    openparens -= 1;
                }
            } else if (reWhitespaceChar.exec(fromCodePoint(c)) !== null) {
                break;
            } else {
                this.pos += 1;
            }
        }
        res = this.subject.substr(savepos, this.pos - savepos);
        return normalizeURI(unescapeString(res));
    } else {  // chop off surrounding <..>:
        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));
    }
};

// Attempt to parse a link label, returning number of characters parsed.
var parseLinkLabel = function() {
    var m = this.match(reLinkLabel);
    // Note:  our regex will allow something of form [..\];
    // we disallow it here rather than using lookahead in the regex:
    if (m === null || m.length > 1001 || /[^\\]\\\]$/.exec(m)) {
        return 0;
    } else {
        return m.length;
    }
};

// Add open bracket to delimiter stack and add a text node to block's children.
var parseOpenBracket = function(block) {
    var startpos = this.pos;
    this.pos += 1;

    var node = text('[');
    block.appendChild(node);

    // Add entry to stack for this opener
    this.addBracket(node, startpos, false);
    return true;
};

// IF next character is [, and ! delimiter to delimiter stack and
// add a text node to block's children.  Otherwise just add a text node.
var parseBang = function(block) {
    var startpos = this.pos;
    this.pos += 1;
    if (this.peek() === C_OPEN_BRACKET) {
        this.pos += 1;

        var node = text('![');
        block.appendChild(node);

        // Add entry to stack for this opener
        this.addBracket(node, startpos + 1, true);
    } else {
        block.appendChild(text('!'));
    }
    return true;
};

// Try to match close bracket against an opening in the delimiter
// stack.  Add either a link or image, or a plain [ character,
// to block's children.  If there is a matching delimiter,
// remove it from the delimiter stack.
var parseCloseBracket = function(block) {
    var startpos;
    var is_image;
    var dest;
    var title;
    var matched = false;
    var reflabel;
    var opener;

    this.pos += 1;
    startpos = this.pos;

    // get last [ or ![
    opener = this.brackets;

    if (opener === null) {
        // no matched opener, just return a literal
        block.appendChild(text(']'));
        return true;
    }

    if (!opener.active) {
        // no matched opener, just return a literal
        block.appendChild(text(']'));
        // take opener off brackets stack
        this.removeBracket();
        return true;
    }

    // If we got here, open is a potential opener
    is_image = opener.image;

    // Check to see if we have a link/image

    var savepos = this.pos;

    // Inline link?
    if (this.peek() === C_OPEN_PAREN) {
        this.pos++;
        if (this.spnl() &&
            ((dest = this.parseLinkDestination()) !== null) &&
            this.spnl() &&
            // make sure there's a space before the title:
            (reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&
             (title = this.parseLinkTitle()) || true) &&
            this.spnl() &&
            this.peek() === C_CLOSE_PAREN) {
            this.pos += 1;
            matched = true;
        } else {
            this.pos = savepos;
        }
    }

    if (!matched) {

        // Next, see if there's a link label
        var beforelabel = this.pos;
        var n = this.parseLinkLabel();
        if (n > 2) {
            reflabel = this.subject.slice(beforelabel, beforelabel + n);
        } else if (!opener.bracketAfter) {
            // Empty or missing second label means to use the first label as the reference.
            // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.
            reflabel = this.subject.slice(opener.index, startpos);
        }
        if (n === 0) {
            // If shortcut reference link, rewind before spaces we skipped.
            this.pos = savepos;
        }

        if (reflabel) {
            // lookup rawlabel in refmap
            var link = this.refmap[normalizeReference(reflabel)];
            if (link) {
                dest = link.destination;
                title = link.title;
                matched = true;
            }
        }
    }

    if (matched) {
        var node = new Node(is_image ? 'image' : 'link');
        node._destination = dest;
        node._title = title || '';

        var tmp, next;
        tmp = opener.node._next;
        while (tmp) {
            next = tmp._next;
            tmp.unlink();
            node.appendChild(tmp);
            tmp = next;
        }
        block.appendChild(node);
        this.processEmphasis(opener.previousDelimiter);
        this.removeBracket();
        opener.node.unlink();

        // We remove this bracket and processEmphasis will remove later delimiters.
        // Now, for a link, we also deactivate earlier link openers.
        // (no links in links)
        if (!is_image) {
          opener = this.brackets;
          while (opener !== null) {
            if (!opener.image) {
                opener.active = false; // deactivate this opener
            }
            opener = opener.previous;
          }
        }

        return true;

    } else { // no match

        this.removeBracket();  // remove this opener from stack
        this.pos = startpos;
        block.appendChild(text(']'));
        return true;
    }

};

var addBracket = function(node, index, image) {
    if (this.brackets !== null) {
        this.brackets.bracketAfter = true;
    }
    this.brackets = { node: node,
                      previous: this.brackets,
                      previousDelimiter: this.delimiters,
                      index: index,
                      image: image,
                      active: true };
};

var removeBracket = function() {
    this.brackets = this.brackets.previous;
};

// Attempt to parse an entity.
var parseEntity = function(block) {
    var m;
    if ((m = this.match(reEntityHere))) {
        block.appendChild(text(decodeHTML(m)));
        return true;
    } else {
        return false;
    }
};

// Parse a run of ordinary characters, or a single character with
// a special meaning in markdown, as a plain string.
var parseString = function(block) {
    var m;
    if ((m = this.match(reMain))) {
        if (this.options.smart) {
            block.appendChild(text(
                m.replace(reEllipses, "\u2026")
                    .replace(reDash, function(chars) {
                        var enCount = 0;
                        var emCount = 0;
                        if (chars.length % 3 === 0) { // If divisible by 3, use all em dashes
                            emCount = chars.length / 3;
                        } else if (chars.length % 2 === 0) { // If divisible by 2, use all en dashes
                            enCount = chars.length / 2;
                        } else if (chars.length % 3 === 2) { // If 2 extra dashes, use en dash for last 2; em dashes for rest
                            enCount = 1;
                            emCount = (chars.length - 2) / 3;
                        } else { // Use en dashes for last 4 hyphens; em dashes for rest
                            enCount = 2;
                            emCount = (chars.length - 4) / 3;
                        }
                        return "\u2014".repeat(emCount) + "\u2013".repeat(enCount);
                    })));
        } else {
            block.appendChild(text(m));
        }
        return true;
    } else {
        return false;
    }
};

// Parse a newline.  If it was preceded by two spaces, return a hard
// line break; otherwise a soft line break.
var parseNewline = function(block) {
    this.pos += 1; // assume we're at a \n
    // check previous node for trailing spaces
    var lastc = block._lastChild;
    if (lastc && lastc.type === 'text' && lastc._literal[lastc._literal.length - 1] === ' ') {
        var hardbreak = lastc._literal[lastc._literal.length - 2] === ' ';
        lastc._literal = lastc._literal.replace(reFinalSpace, '');
        block.appendChild(new Node(hardbreak ? 'linebreak' : 'softbreak'));
    } else {
        block.appendChild(new Node('softbreak'));
    }
    this.match(reInitialSpace); // gobble leading spaces in next line
    return true;
};

// Attempt to parse a link reference, modifying refmap.
var parseReference = function(s, refmap) {
    this.subject = s;
    this.pos = 0;
    var rawlabel;
    var dest;
    var title;
    var matchChars;
    var startpos = this.pos;

    // label:
    matchChars = this.parseLinkLabel();
    if (matchChars === 0) {
        return 0;
    } else {
        rawlabel = this.subject.substr(0, matchChars);
    }

    // colon:
    if (this.peek() === C_COLON) {
        this.pos++;
    } else {
        this.pos = startpos;
        return 0;
    }

    //  link url
    this.spnl();

    dest = this.parseLinkDestination();
    if (dest === null || dest.length === 0) {
        this.pos = startpos;
        return 0;
    }

    var beforetitle = this.pos;
    this.spnl();
    title = this.parseLinkTitle();
    if (title === null) {
        title = '';
        // rewind before spaces
        this.pos = beforetitle;
    }

    // make sure we're at line end:
    var atLineEnd = true;
    if (this.match(reSpaceAtEndOfLine) === null) {
        if (title === '') {
            atLineEnd = false;
        } else {
            // the potential title we found is not at the line end,
            // but it could still be a legal link reference if we
            // discard the title
            title = '';
            // rewind before spaces
            this.pos = beforetitle;
            // and instead check if the link URL is at the line end
            atLineEnd = this.match(reSpaceAtEndOfLine) !== null;
        }
    }

    if (!atLineEnd) {
        this.pos = startpos;
        return 0;
    }

    var normlabel = normalizeReference(rawlabel);
    if (normlabel === '') {
        // label must contain non-whitespace characters
        this.pos = startpos;
        return 0;
    }

    if (!refmap[normlabel]) {
        refmap[normlabel] = { destination: dest, title: title };
    }
    return this.pos - startpos;
};

// Parse the next inline element in subject, advancing subject position.
// On success, add the result to block's children and return true.
// On failure, return false.
var parseInline = function(block) {
    var res = false;
    var c = this.peek();
    if (c === -1) {
        return false;
    }
    switch(c) {
    case C_NEWLINE:
        res = this.parseNewline(block);
        break;
    case C_BACKSLASH:
        res = this.parseBackslash(block);
        break;
    case C_BACKTICK:
        res = this.parseBackticks(block);
        break;
    case C_ASTERISK:
    case C_UNDERSCORE:
        res = this.handleDelim(c, block);
        break;
    case C_SINGLEQUOTE:
    case C_DOUBLEQUOTE:
        res = this.options.smart && this.handleDelim(c, block);
        break;
    case C_OPEN_BRACKET:
        res = this.parseOpenBracket(block);
        break;
    case C_BANG:
        res = this.parseBang(block);
        break;
    case C_CLOSE_BRACKET:
        res = this.parseCloseBracket(block);
        break;
    case C_LESSTHAN:
        res = this.parseAutolink(block) || this.parseHtmlTag(block);
        break;
    case C_AMPERSAND:
        res = this.parseEntity(block);
        break;
    default:
        res = this.parseString(block);
        break;
    }
    if (!res) {
        this.pos += 1;
        block.appendChild(text(fromCodePoint(c)));
    }

    return true;
};

// Parse string content in block into inline children,
// using refmap to resolve references.
var parseInlines = function(block) {
    this.subject = block._string_content.trim();
    this.pos = 0;
    this.delimiters = null;
    this.brackets = null;
    while (this.parseInline(block)) {
    }
    block._string_content = null; // allow raw string to be garbage collected
    this.processEmphasis(null);
};

// The InlineParser object.
function InlineParser(options){
    return {
        subject: '',
        delimiters: null,  // used by handleDelim method
        brackets: null,
        pos: 0,
        refmap: {},
        match: match,
        peek: peek,
        spnl: spnl,
        parseBackticks: parseBackticks,
        parseBackslash: parseBackslash,
        parseAutolink: parseAutolink,
        parseHtmlTag: parseHtmlTag,
        scanDelims: scanDelims,
        handleDelim: handleDelim,
        parseLinkTitle: parseLinkTitle,
        parseLinkDestination: parseLinkDestination,
        parseLinkLabel: parseLinkLabel,
        parseOpenBracket: parseOpenBracket,
        parseBang: parseBang,
        parseCloseBracket: parseCloseBracket,
        addBracket: addBracket,
        removeBracket: removeBracket,
        parseEntity: parseEntity,
        parseString: parseString,
        parseNewline: parseNewline,
        parseReference: parseReference,
        parseInline: parseInline,
        processEmphasis: processEmphasis,
        removeDelimiter: removeDelimiter,
        options: options || {},
        parse: parseInlines
    };
}

module.exports = InlineParser;


/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* The bulk of this code derives from https://github.com/dmoscrop/fold-case
But in addition to case-folding, we also normalize whitespace.

fold-case is Copyright Mathias Bynens <https://mathiasbynens.be/>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/*eslint-disable  key-spacing, comma-spacing */

var regex = /[ \t\r\n]+|[A-Z\xB5\xC0-\xD6\xD8-\xDF\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u0149\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u017F\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C5\u01C7\u01C8\u01CA\u01CB\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F0-\u01F2\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0345\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03AB\u03B0\u03C2\u03CF-\u03D1\u03D5\u03D6\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F0\u03F1\u03F4\u03F5\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u0587\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E96-\u1E9B\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F50\u1F52\u1F54\u1F56\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1F80-\u1FAF\u1FB2-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD2\u1FD3\u1FD6-\u1FDB\u1FE2-\u1FE4\u1FE6-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2126\u212A\u212B\u2132\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0\uA7B1\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27]|\uD806[\uDCA0-\uDCBF]/g;

var map = {'A':'a','B':'b','C':'c','D':'d','E':'e','F':'f','G':'g','H':'h','I':'i','J':'j','K':'k','L':'l','M':'m','N':'n','O':'o','P':'p','Q':'q','R':'r','S':'s','T':'t','U':'u','V':'v','W':'w','X':'x','Y':'y','Z':'z','\xB5':'\u03BC','\xC0':'\xE0','\xC1':'\xE1','\xC2':'\xE2','\xC3':'\xE3','\xC4':'\xE4','\xC5':'\xE5','\xC6':'\xE6','\xC7':'\xE7','\xC8':'\xE8','\xC9':'\xE9','\xCA':'\xEA','\xCB':'\xEB','\xCC':'\xEC','\xCD':'\xED','\xCE':'\xEE','\xCF':'\xEF','\xD0':'\xF0','\xD1':'\xF1','\xD2':'\xF2','\xD3':'\xF3','\xD4':'\xF4','\xD5':'\xF5','\xD6':'\xF6','\xD8':'\xF8','\xD9':'\xF9','\xDA':'\xFA','\xDB':'\xFB','\xDC':'\xFC','\xDD':'\xFD','\xDE':'\xFE','\u0100':'\u0101','\u0102':'\u0103','\u0104':'\u0105','\u0106':'\u0107','\u0108':'\u0109','\u010A':'\u010B','\u010C':'\u010D','\u010E':'\u010F','\u0110':'\u0111','\u0112':'\u0113','\u0114':'\u0115','\u0116':'\u0117','\u0118':'\u0119','\u011A':'\u011B','\u011C':'\u011D','\u011E':'\u011F','\u0120':'\u0121','\u0122':'\u0123','\u0124':'\u0125','\u0126':'\u0127','\u0128':'\u0129','\u012A':'\u012B','\u012C':'\u012D','\u012E':'\u012F','\u0132':'\u0133','\u0134':'\u0135','\u0136':'\u0137','\u0139':'\u013A','\u013B':'\u013C','\u013D':'\u013E','\u013F':'\u0140','\u0141':'\u0142','\u0143':'\u0144','\u0145':'\u0146','\u0147':'\u0148','\u014A':'\u014B','\u014C':'\u014D','\u014E':'\u014F','\u0150':'\u0151','\u0152':'\u0153','\u0154':'\u0155','\u0156':'\u0157','\u0158':'\u0159','\u015A':'\u015B','\u015C':'\u015D','\u015E':'\u015F','\u0160':'\u0161','\u0162':'\u0163','\u0164':'\u0165','\u0166':'\u0167','\u0168':'\u0169','\u016A':'\u016B','\u016C':'\u016D','\u016E':'\u016F','\u0170':'\u0171','\u0172':'\u0173','\u0174':'\u0175','\u0176':'\u0177','\u0178':'\xFF','\u0179':'\u017A','\u017B':'\u017C','\u017D':'\u017E','\u017F':'s','\u0181':'\u0253','\u0182':'\u0183','\u0184':'\u0185','\u0186':'\u0254','\u0187':'\u0188','\u0189':'\u0256','\u018A':'\u0257','\u018B':'\u018C','\u018E':'\u01DD','\u018F':'\u0259','\u0190':'\u025B','\u0191':'\u0192','\u0193':'\u0260','\u0194':'\u0263','\u0196':'\u0269','\u0197':'\u0268','\u0198':'\u0199','\u019C':'\u026F','\u019D':'\u0272','\u019F':'\u0275','\u01A0':'\u01A1','\u01A2':'\u01A3','\u01A4':'\u01A5','\u01A6':'\u0280','\u01A7':'\u01A8','\u01A9':'\u0283','\u01AC':'\u01AD','\u01AE':'\u0288','\u01AF':'\u01B0','\u01B1':'\u028A','\u01B2':'\u028B','\u01B3':'\u01B4','\u01B5':'\u01B6','\u01B7':'\u0292','\u01B8':'\u01B9','\u01BC':'\u01BD','\u01C4':'\u01C6','\u01C5':'\u01C6','\u01C7':'\u01C9','\u01C8':'\u01C9','\u01CA':'\u01CC','\u01CB':'\u01CC','\u01CD':'\u01CE','\u01CF':'\u01D0','\u01D1':'\u01D2','\u01D3':'\u01D4','\u01D5':'\u01D6','\u01D7':'\u01D8','\u01D9':'\u01DA','\u01DB':'\u01DC','\u01DE':'\u01DF','\u01E0':'\u01E1','\u01E2':'\u01E3','\u01E4':'\u01E5','\u01E6':'\u01E7','\u01E8':'\u01E9','\u01EA':'\u01EB','\u01EC':'\u01ED','\u01EE':'\u01EF','\u01F1':'\u01F3','\u01F2':'\u01F3','\u01F4':'\u01F5','\u01F6':'\u0195','\u01F7':'\u01BF','\u01F8':'\u01F9','\u01FA':'\u01FB','\u01FC':'\u01FD','\u01FE':'\u01FF','\u0200':'\u0201','\u0202':'\u0203','\u0204':'\u0205','\u0206':'\u0207','\u0208':'\u0209','\u020A':'\u020B','\u020C':'\u020D','\u020E':'\u020F','\u0210':'\u0211','\u0212':'\u0213','\u0214':'\u0215','\u0216':'\u0217','\u0218':'\u0219','\u021A':'\u021B','\u021C':'\u021D','\u021E':'\u021F','\u0220':'\u019E','\u0222':'\u0223','\u0224':'\u0225','\u0226':'\u0227','\u0228':'\u0229','\u022A':'\u022B','\u022C':'\u022D','\u022E':'\u022F','\u0230':'\u0231','\u0232':'\u0233','\u023A':'\u2C65','\u023B':'\u023C','\u023D':'\u019A','\u023E':'\u2C66','\u0241':'\u0242','\u0243':'\u0180','\u0244':'\u0289','\u0245':'\u028C','\u0246':'\u0247','\u0248':'\u0249','\u024A':'\u024B','\u024C':'\u024D','\u024E':'\u024F','\u0345':'\u03B9','\u0370':'\u0371','\u0372':'\u0373','\u0376':'\u0377','\u037F':'\u03F3','\u0386':'\u03AC','\u0388':'\u03AD','\u0389':'\u03AE','\u038A':'\u03AF','\u038C':'\u03CC','\u038E':'\u03CD','\u038F':'\u03CE','\u0391':'\u03B1','\u0392':'\u03B2','\u0393':'\u03B3','\u0394':'\u03B4','\u0395':'\u03B5','\u0396':'\u03B6','\u0397':'\u03B7','\u0398':'\u03B8','\u0399':'\u03B9','\u039A':'\u03BA','\u039B':'\u03BB','\u039C':'\u03BC','\u039D':'\u03BD','\u039E':'\u03BE','\u039F':'\u03BF','\u03A0':'\u03C0','\u03A1':'\u03C1','\u03A3':'\u03C3','\u03A4':'\u03C4','\u03A5':'\u03C5','\u03A6':'\u03C6','\u03A7':'\u03C7','\u03A8':'\u03C8','\u03A9':'\u03C9','\u03AA':'\u03CA','\u03AB':'\u03CB','\u03C2':'\u03C3','\u03CF':'\u03D7','\u03D0':'\u03B2','\u03D1':'\u03B8','\u03D5':'\u03C6','\u03D6':'\u03C0','\u03D8':'\u03D9','\u03DA':'\u03DB','\u03DC':'\u03DD','\u03DE':'\u03DF','\u03E0':'\u03E1','\u03E2':'\u03E3','\u03E4':'\u03E5','\u03E6':'\u03E7','\u03E8':'\u03E9','\u03EA':'\u03EB','\u03EC':'\u03ED','\u03EE':'\u03EF','\u03F0':'\u03BA','\u03F1':'\u03C1','\u03F4':'\u03B8','\u03F5':'\u03B5','\u03F7':'\u03F8','\u03F9':'\u03F2','\u03FA':'\u03FB','\u03FD':'\u037B','\u03FE':'\u037C','\u03FF':'\u037D','\u0400':'\u0450','\u0401':'\u0451','\u0402':'\u0452','\u0403':'\u0453','\u0404':'\u0454','\u0405':'\u0455','\u0406':'\u0456','\u0407':'\u0457','\u0408':'\u0458','\u0409':'\u0459','\u040A':'\u045A','\u040B':'\u045B','\u040C':'\u045C','\u040D':'\u045D','\u040E':'\u045E','\u040F':'\u045F','\u0410':'\u0430','\u0411':'\u0431','\u0412':'\u0432','\u0413':'\u0433','\u0414':'\u0434','\u0415':'\u0435','\u0416':'\u0436','\u0417':'\u0437','\u0418':'\u0438','\u0419':'\u0439','\u041A':'\u043A','\u041B':'\u043B','\u041C':'\u043C','\u041D':'\u043D','\u041E':'\u043E','\u041F':'\u043F','\u0420':'\u0440','\u0421':'\u0441','\u0422':'\u0442','\u0423':'\u0443','\u0424':'\u0444','\u0425':'\u0445','\u0426':'\u0446','\u0427':'\u0447','\u0428':'\u0448','\u0429':'\u0449','\u042A':'\u044A','\u042B':'\u044B','\u042C':'\u044C','\u042D':'\u044D','\u042E':'\u044E','\u042F':'\u044F','\u0460':'\u0461','\u0462':'\u0463','\u0464':'\u0465','\u0466':'\u0467','\u0468':'\u0469','\u046A':'\u046B','\u046C':'\u046D','\u046E':'\u046F','\u0470':'\u0471','\u0472':'\u0473','\u0474':'\u0475','\u0476':'\u0477','\u0478':'\u0479','\u047A':'\u047B','\u047C':'\u047D','\u047E':'\u047F','\u0480':'\u0481','\u048A':'\u048B','\u048C':'\u048D','\u048E':'\u048F','\u0490':'\u0491','\u0492':'\u0493','\u0494':'\u0495','\u0496':'\u0497','\u0498':'\u0499','\u049A':'\u049B','\u049C':'\u049D','\u049E':'\u049F','\u04A0':'\u04A1','\u04A2':'\u04A3','\u04A4':'\u04A5','\u04A6':'\u04A7','\u04A8':'\u04A9','\u04AA':'\u04AB','\u04AC':'\u04AD','\u04AE':'\u04AF','\u04B0':'\u04B1','\u04B2':'\u04B3','\u04B4':'\u04B5','\u04B6':'\u04B7','\u04B8':'\u04B9','\u04BA':'\u04BB','\u04BC':'\u04BD','\u04BE':'\u04BF','\u04C0':'\u04CF','\u04C1':'\u04C2','\u04C3':'\u04C4','\u04C5':'\u04C6','\u04C7':'\u04C8','\u04C9':'\u04CA','\u04CB':'\u04CC','\u04CD':'\u04CE','\u04D0':'\u04D1','\u04D2':'\u04D3','\u04D4':'\u04D5','\u04D6':'\u04D7','\u04D8':'\u04D9','\u04DA':'\u04DB','\u04DC':'\u04DD','\u04DE':'\u04DF','\u04E0':'\u04E1','\u04E2':'\u04E3','\u04E4':'\u04E5','\u04E6':'\u04E7','\u04E8':'\u04E9','\u04EA':'\u04EB','\u04EC':'\u04ED','\u04EE':'\u04EF','\u04F0':'\u04F1','\u04F2':'\u04F3','\u04F4':'\u04F5','\u04F6':'\u04F7','\u04F8':'\u04F9','\u04FA':'\u04FB','\u04FC':'\u04FD','\u04FE':'\u04FF','\u0500':'\u0501','\u0502':'\u0503','\u0504':'\u0505','\u0506':'\u0507','\u0508':'\u0509','\u050A':'\u050B','\u050C':'\u050D','\u050E':'\u050F','\u0510':'\u0511','\u0512':'\u0513','\u0514':'\u0515','\u0516':'\u0517','\u0518':'\u0519','\u051A':'\u051B','\u051C':'\u051D','\u051E':'\u051F','\u0520':'\u0521','\u0522':'\u0523','\u0524':'\u0525','\u0526':'\u0527','\u0528':'\u0529','\u052A':'\u052B','\u052C':'\u052D','\u052E':'\u052F','\u0531':'\u0561','\u0532':'\u0562','\u0533':'\u0563','\u0534':'\u0564','\u0535':'\u0565','\u0536':'\u0566','\u0537':'\u0567','\u0538':'\u0568','\u0539':'\u0569','\u053A':'\u056A','\u053B':'\u056B','\u053C':'\u056C','\u053D':'\u056D','\u053E':'\u056E','\u053F':'\u056F','\u0540':'\u0570','\u0541':'\u0571','\u0542':'\u0572','\u0543':'\u0573','\u0544':'\u0574','\u0545':'\u0575','\u0546':'\u0576','\u0547':'\u0577','\u0548':'\u0578','\u0549':'\u0579','\u054A':'\u057A','\u054B':'\u057B','\u054C':'\u057C','\u054D':'\u057D','\u054E':'\u057E','\u054F':'\u057F','\u0550':'\u0580','\u0551':'\u0581','\u0552':'\u0582','\u0553':'\u0583','\u0554':'\u0584','\u0555':'\u0585','\u0556':'\u0586','\u10A0':'\u2D00','\u10A1':'\u2D01','\u10A2':'\u2D02','\u10A3':'\u2D03','\u10A4':'\u2D04','\u10A5':'\u2D05','\u10A6':'\u2D06','\u10A7':'\u2D07','\u10A8':'\u2D08','\u10A9':'\u2D09','\u10AA':'\u2D0A','\u10AB':'\u2D0B','\u10AC':'\u2D0C','\u10AD':'\u2D0D','\u10AE':'\u2D0E','\u10AF':'\u2D0F','\u10B0':'\u2D10','\u10B1':'\u2D11','\u10B2':'\u2D12','\u10B3':'\u2D13','\u10B4':'\u2D14','\u10B5':'\u2D15','\u10B6':'\u2D16','\u10B7':'\u2D17','\u10B8':'\u2D18','\u10B9':'\u2D19','\u10BA':'\u2D1A','\u10BB':'\u2D1B','\u10BC':'\u2D1C','\u10BD':'\u2D1D','\u10BE':'\u2D1E','\u10BF':'\u2D1F','\u10C0':'\u2D20','\u10C1':'\u2D21','\u10C2':'\u2D22','\u10C3':'\u2D23','\u10C4':'\u2D24','\u10C5':'\u2D25','\u10C7':'\u2D27','\u10CD':'\u2D2D','\u1E00':'\u1E01','\u1E02':'\u1E03','\u1E04':'\u1E05','\u1E06':'\u1E07','\u1E08':'\u1E09','\u1E0A':'\u1E0B','\u1E0C':'\u1E0D','\u1E0E':'\u1E0F','\u1E10':'\u1E11','\u1E12':'\u1E13','\u1E14':'\u1E15','\u1E16':'\u1E17','\u1E18':'\u1E19','\u1E1A':'\u1E1B','\u1E1C':'\u1E1D','\u1E1E':'\u1E1F','\u1E20':'\u1E21','\u1E22':'\u1E23','\u1E24':'\u1E25','\u1E26':'\u1E27','\u1E28':'\u1E29','\u1E2A':'\u1E2B','\u1E2C':'\u1E2D','\u1E2E':'\u1E2F','\u1E30':'\u1E31','\u1E32':'\u1E33','\u1E34':'\u1E35','\u1E36':'\u1E37','\u1E38':'\u1E39','\u1E3A':'\u1E3B','\u1E3C':'\u1E3D','\u1E3E':'\u1E3F','\u1E40':'\u1E41','\u1E42':'\u1E43','\u1E44':'\u1E45','\u1E46':'\u1E47','\u1E48':'\u1E49','\u1E4A':'\u1E4B','\u1E4C':'\u1E4D','\u1E4E':'\u1E4F','\u1E50':'\u1E51','\u1E52':'\u1E53','\u1E54':'\u1E55','\u1E56':'\u1E57','\u1E58':'\u1E59','\u1E5A':'\u1E5B','\u1E5C':'\u1E5D','\u1E5E':'\u1E5F','\u1E60':'\u1E61','\u1E62':'\u1E63','\u1E64':'\u1E65','\u1E66':'\u1E67','\u1E68':'\u1E69','\u1E6A':'\u1E6B','\u1E6C':'\u1E6D','\u1E6E':'\u1E6F','\u1E70':'\u1E71','\u1E72':'\u1E73','\u1E74':'\u1E75','\u1E76':'\u1E77','\u1E78':'\u1E79','\u1E7A':'\u1E7B','\u1E7C':'\u1E7D','\u1E7E':'\u1E7F','\u1E80':'\u1E81','\u1E82':'\u1E83','\u1E84':'\u1E85','\u1E86':'\u1E87','\u1E88':'\u1E89','\u1E8A':'\u1E8B','\u1E8C':'\u1E8D','\u1E8E':'\u1E8F','\u1E90':'\u1E91','\u1E92':'\u1E93','\u1E94':'\u1E95','\u1E9B':'\u1E61','\u1EA0':'\u1EA1','\u1EA2':'\u1EA3','\u1EA4':'\u1EA5','\u1EA6':'\u1EA7','\u1EA8':'\u1EA9','\u1EAA':'\u1EAB','\u1EAC':'\u1EAD','\u1EAE':'\u1EAF','\u1EB0':'\u1EB1','\u1EB2':'\u1EB3','\u1EB4':'\u1EB5','\u1EB6':'\u1EB7','\u1EB8':'\u1EB9','\u1EBA':'\u1EBB','\u1EBC':'\u1EBD','\u1EBE':'\u1EBF','\u1EC0':'\u1EC1','\u1EC2':'\u1EC3','\u1EC4':'\u1EC5','\u1EC6':'\u1EC7','\u1EC8':'\u1EC9','\u1ECA':'\u1ECB','\u1ECC':'\u1ECD','\u1ECE':'\u1ECF','\u1ED0':'\u1ED1','\u1ED2':'\u1ED3','\u1ED4':'\u1ED5','\u1ED6':'\u1ED7','\u1ED8':'\u1ED9','\u1EDA':'\u1EDB','\u1EDC':'\u1EDD','\u1EDE':'\u1EDF','\u1EE0':'\u1EE1','\u1EE2':'\u1EE3','\u1EE4':'\u1EE5','\u1EE6':'\u1EE7','\u1EE8':'\u1EE9','\u1EEA':'\u1EEB','\u1EEC':'\u1EED','\u1EEE':'\u1EEF','\u1EF0':'\u1EF1','\u1EF2':'\u1EF3','\u1EF4':'\u1EF5','\u1EF6':'\u1EF7','\u1EF8':'\u1EF9','\u1EFA':'\u1EFB','\u1EFC':'\u1EFD','\u1EFE':'\u1EFF','\u1F08':'\u1F00','\u1F09':'\u1F01','\u1F0A':'\u1F02','\u1F0B':'\u1F03','\u1F0C':'\u1F04','\u1F0D':'\u1F05','\u1F0E':'\u1F06','\u1F0F':'\u1F07','\u1F18':'\u1F10','\u1F19':'\u1F11','\u1F1A':'\u1F12','\u1F1B':'\u1F13','\u1F1C':'\u1F14','\u1F1D':'\u1F15','\u1F28':'\u1F20','\u1F29':'\u1F21','\u1F2A':'\u1F22','\u1F2B':'\u1F23','\u1F2C':'\u1F24','\u1F2D':'\u1F25','\u1F2E':'\u1F26','\u1F2F':'\u1F27','\u1F38':'\u1F30','\u1F39':'\u1F31','\u1F3A':'\u1F32','\u1F3B':'\u1F33','\u1F3C':'\u1F34','\u1F3D':'\u1F35','\u1F3E':'\u1F36','\u1F3F':'\u1F37','\u1F48':'\u1F40','\u1F49':'\u1F41','\u1F4A':'\u1F42','\u1F4B':'\u1F43','\u1F4C':'\u1F44','\u1F4D':'\u1F45','\u1F59':'\u1F51','\u1F5B':'\u1F53','\u1F5D':'\u1F55','\u1F5F':'\u1F57','\u1F68':'\u1F60','\u1F69':'\u1F61','\u1F6A':'\u1F62','\u1F6B':'\u1F63','\u1F6C':'\u1F64','\u1F6D':'\u1F65','\u1F6E':'\u1F66','\u1F6F':'\u1F67','\u1FB8':'\u1FB0','\u1FB9':'\u1FB1','\u1FBA':'\u1F70','\u1FBB':'\u1F71','\u1FBE':'\u03B9','\u1FC8':'\u1F72','\u1FC9':'\u1F73','\u1FCA':'\u1F74','\u1FCB':'\u1F75','\u1FD8':'\u1FD0','\u1FD9':'\u1FD1','\u1FDA':'\u1F76','\u1FDB':'\u1F77','\u1FE8':'\u1FE0','\u1FE9':'\u1FE1','\u1FEA':'\u1F7A','\u1FEB':'\u1F7B','\u1FEC':'\u1FE5','\u1FF8':'\u1F78','\u1FF9':'\u1F79','\u1FFA':'\u1F7C','\u1FFB':'\u1F7D','\u2126':'\u03C9','\u212A':'k','\u212B':'\xE5','\u2132':'\u214E','\u2160':'\u2170','\u2161':'\u2171','\u2162':'\u2172','\u2163':'\u2173','\u2164':'\u2174','\u2165':'\u2175','\u2166':'\u2176','\u2167':'\u2177','\u2168':'\u2178','\u2169':'\u2179','\u216A':'\u217A','\u216B':'\u217B','\u216C':'\u217C','\u216D':'\u217D','\u216E':'\u217E','\u216F':'\u217F','\u2183':'\u2184','\u24B6':'\u24D0','\u24B7':'\u24D1','\u24B8':'\u24D2','\u24B9':'\u24D3','\u24BA':'\u24D4','\u24BB':'\u24D5','\u24BC':'\u24D6','\u24BD':'\u24D7','\u24BE':'\u24D8','\u24BF':'\u24D9','\u24C0':'\u24DA','\u24C1':'\u24DB','\u24C2':'\u24DC','\u24C3':'\u24DD','\u24C4':'\u24DE','\u24C5':'\u24DF','\u24C6':'\u24E0','\u24C7':'\u24E1','\u24C8':'\u24E2','\u24C9':'\u24E3','\u24CA':'\u24E4','\u24CB':'\u24E5','\u24CC':'\u24E6','\u24CD':'\u24E7','\u24CE':'\u24E8','\u24CF':'\u24E9','\u2C00':'\u2C30','\u2C01':'\u2C31','\u2C02':'\u2C32','\u2C03':'\u2C33','\u2C04':'\u2C34','\u2C05':'\u2C35','\u2C06':'\u2C36','\u2C07':'\u2C37','\u2C08':'\u2C38','\u2C09':'\u2C39','\u2C0A':'\u2C3A','\u2C0B':'\u2C3B','\u2C0C':'\u2C3C','\u2C0D':'\u2C3D','\u2C0E':'\u2C3E','\u2C0F':'\u2C3F','\u2C10':'\u2C40','\u2C11':'\u2C41','\u2C12':'\u2C42','\u2C13':'\u2C43','\u2C14':'\u2C44','\u2C15':'\u2C45','\u2C16':'\u2C46','\u2C17':'\u2C47','\u2C18':'\u2C48','\u2C19':'\u2C49','\u2C1A':'\u2C4A','\u2C1B':'\u2C4B','\u2C1C':'\u2C4C','\u2C1D':'\u2C4D','\u2C1E':'\u2C4E','\u2C1F':'\u2C4F','\u2C20':'\u2C50','\u2C21':'\u2C51','\u2C22':'\u2C52','\u2C23':'\u2C53','\u2C24':'\u2C54','\u2C25':'\u2C55','\u2C26':'\u2C56','\u2C27':'\u2C57','\u2C28':'\u2C58','\u2C29':'\u2C59','\u2C2A':'\u2C5A','\u2C2B':'\u2C5B','\u2C2C':'\u2C5C','\u2C2D':'\u2C5D','\u2C2E':'\u2C5E','\u2C60':'\u2C61','\u2C62':'\u026B','\u2C63':'\u1D7D','\u2C64':'\u027D','\u2C67':'\u2C68','\u2C69':'\u2C6A','\u2C6B':'\u2C6C','\u2C6D':'\u0251','\u2C6E':'\u0271','\u2C6F':'\u0250','\u2C70':'\u0252','\u2C72':'\u2C73','\u2C75':'\u2C76','\u2C7E':'\u023F','\u2C7F':'\u0240','\u2C80':'\u2C81','\u2C82':'\u2C83','\u2C84':'\u2C85','\u2C86':'\u2C87','\u2C88':'\u2C89','\u2C8A':'\u2C8B','\u2C8C':'\u2C8D','\u2C8E':'\u2C8F','\u2C90':'\u2C91','\u2C92':'\u2C93','\u2C94':'\u2C95','\u2C96':'\u2C97','\u2C98':'\u2C99','\u2C9A':'\u2C9B','\u2C9C':'\u2C9D','\u2C9E':'\u2C9F','\u2CA0':'\u2CA1','\u2CA2':'\u2CA3','\u2CA4':'\u2CA5','\u2CA6':'\u2CA7','\u2CA8':'\u2CA9','\u2CAA':'\u2CAB','\u2CAC':'\u2CAD','\u2CAE':'\u2CAF','\u2CB0':'\u2CB1','\u2CB2':'\u2CB3','\u2CB4':'\u2CB5','\u2CB6':'\u2CB7','\u2CB8':'\u2CB9','\u2CBA':'\u2CBB','\u2CBC':'\u2CBD','\u2CBE':'\u2CBF','\u2CC0':'\u2CC1','\u2CC2':'\u2CC3','\u2CC4':'\u2CC5','\u2CC6':'\u2CC7','\u2CC8':'\u2CC9','\u2CCA':'\u2CCB','\u2CCC':'\u2CCD','\u2CCE':'\u2CCF','\u2CD0':'\u2CD1','\u2CD2':'\u2CD3','\u2CD4':'\u2CD5','\u2CD6':'\u2CD7','\u2CD8':'\u2CD9','\u2CDA':'\u2CDB','\u2CDC':'\u2CDD','\u2CDE':'\u2CDF','\u2CE0':'\u2CE1','\u2CE2':'\u2CE3','\u2CEB':'\u2CEC','\u2CED':'\u2CEE','\u2CF2':'\u2CF3','\uA640':'\uA641','\uA642':'\uA643','\uA644':'\uA645','\uA646':'\uA647','\uA648':'\uA649','\uA64A':'\uA64B','\uA64C':'\uA64D','\uA64E':'\uA64F','\uA650':'\uA651','\uA652':'\uA653','\uA654':'\uA655','\uA656':'\uA657','\uA658':'\uA659','\uA65A':'\uA65B','\uA65C':'\uA65D','\uA65E':'\uA65F','\uA660':'\uA661','\uA662':'\uA663','\uA664':'\uA665','\uA666':'\uA667','\uA668':'\uA669','\uA66A':'\uA66B','\uA66C':'\uA66D','\uA680':'\uA681','\uA682':'\uA683','\uA684':'\uA685','\uA686':'\uA687','\uA688':'\uA689','\uA68A':'\uA68B','\uA68C':'\uA68D','\uA68E':'\uA68F','\uA690':'\uA691','\uA692':'\uA693','\uA694':'\uA695','\uA696':'\uA697','\uA698':'\uA699','\uA69A':'\uA69B','\uA722':'\uA723','\uA724':'\uA725','\uA726':'\uA727','\uA728':'\uA729','\uA72A':'\uA72B','\uA72C':'\uA72D','\uA72E':'\uA72F','\uA732':'\uA733','\uA734':'\uA735','\uA736':'\uA737','\uA738':'\uA739','\uA73A':'\uA73B','\uA73C':'\uA73D','\uA73E':'\uA73F','\uA740':'\uA741','\uA742':'\uA743','\uA744':'\uA745','\uA746':'\uA747','\uA748':'\uA749','\uA74A':'\uA74B','\uA74C':'\uA74D','\uA74E':'\uA74F','\uA750':'\uA751','\uA752':'\uA753','\uA754':'\uA755','\uA756':'\uA757','\uA758':'\uA759','\uA75A':'\uA75B','\uA75C':'\uA75D','\uA75E':'\uA75F','\uA760':'\uA761','\uA762':'\uA763','\uA764':'\uA765','\uA766':'\uA767','\uA768':'\uA769','\uA76A':'\uA76B','\uA76C':'\uA76D','\uA76E':'\uA76F','\uA779':'\uA77A','\uA77B':'\uA77C','\uA77D':'\u1D79','\uA77E':'\uA77F','\uA780':'\uA781','\uA782':'\uA783','\uA784':'\uA785','\uA786':'\uA787','\uA78B':'\uA78C','\uA78D':'\u0265','\uA790':'\uA791','\uA792':'\uA793','\uA796':'\uA797','\uA798':'\uA799','\uA79A':'\uA79B','\uA79C':'\uA79D','\uA79E':'\uA79F','\uA7A0':'\uA7A1','\uA7A2':'\uA7A3','\uA7A4':'\uA7A5','\uA7A6':'\uA7A7','\uA7A8':'\uA7A9','\uA7AA':'\u0266','\uA7AB':'\u025C','\uA7AC':'\u0261','\uA7AD':'\u026C','\uA7B0':'\u029E','\uA7B1':'\u0287','\uFF21':'\uFF41','\uFF22':'\uFF42','\uFF23':'\uFF43','\uFF24':'\uFF44','\uFF25':'\uFF45','\uFF26':'\uFF46','\uFF27':'\uFF47','\uFF28':'\uFF48','\uFF29':'\uFF49','\uFF2A':'\uFF4A','\uFF2B':'\uFF4B','\uFF2C':'\uFF4C','\uFF2D':'\uFF4D','\uFF2E':'\uFF4E','\uFF2F':'\uFF4F','\uFF30':'\uFF50','\uFF31':'\uFF51','\uFF32':'\uFF52','\uFF33':'\uFF53','\uFF34':'\uFF54','\uFF35':'\uFF55','\uFF36':'\uFF56','\uFF37':'\uFF57','\uFF38':'\uFF58','\uFF39':'\uFF59','\uFF3A':'\uFF5A','\uD801\uDC00':'\uD801\uDC28','\uD801\uDC01':'\uD801\uDC29','\uD801\uDC02':'\uD801\uDC2A','\uD801\uDC03':'\uD801\uDC2B','\uD801\uDC04':'\uD801\uDC2C','\uD801\uDC05':'\uD801\uDC2D','\uD801\uDC06':'\uD801\uDC2E','\uD801\uDC07':'\uD801\uDC2F','\uD801\uDC08':'\uD801\uDC30','\uD801\uDC09':'\uD801\uDC31','\uD801\uDC0A':'\uD801\uDC32','\uD801\uDC0B':'\uD801\uDC33','\uD801\uDC0C':'\uD801\uDC34','\uD801\uDC0D':'\uD801\uDC35','\uD801\uDC0E':'\uD801\uDC36','\uD801\uDC0F':'\uD801\uDC37','\uD801\uDC10':'\uD801\uDC38','\uD801\uDC11':'\uD801\uDC39','\uD801\uDC12':'\uD801\uDC3A','\uD801\uDC13':'\uD801\uDC3B','\uD801\uDC14':'\uD801\uDC3C','\uD801\uDC15':'\uD801\uDC3D','\uD801\uDC16':'\uD801\uDC3E','\uD801\uDC17':'\uD801\uDC3F','\uD801\uDC18':'\uD801\uDC40','\uD801\uDC19':'\uD801\uDC41','\uD801\uDC1A':'\uD801\uDC42','\uD801\uDC1B':'\uD801\uDC43','\uD801\uDC1C':'\uD801\uDC44','\uD801\uDC1D':'\uD801\uDC45','\uD801\uDC1E':'\uD801\uDC46','\uD801\uDC1F':'\uD801\uDC47','\uD801\uDC20':'\uD801\uDC48','\uD801\uDC21':'\uD801\uDC49','\uD801\uDC22':'\uD801\uDC4A','\uD801\uDC23':'\uD801\uDC4B','\uD801\uDC24':'\uD801\uDC4C','\uD801\uDC25':'\uD801\uDC4D','\uD801\uDC26':'\uD801\uDC4E','\uD801\uDC27':'\uD801\uDC4F','\uD806\uDCA0':'\uD806\uDCC0','\uD806\uDCA1':'\uD806\uDCC1','\uD806\uDCA2':'\uD806\uDCC2','\uD806\uDCA3':'\uD806\uDCC3','\uD806\uDCA4':'\uD806\uDCC4','\uD806\uDCA5':'\uD806\uDCC5','\uD806\uDCA6':'\uD806\uDCC6','\uD806\uDCA7':'\uD806\uDCC7','\uD806\uDCA8':'\uD806\uDCC8','\uD806\uDCA9':'\uD806\uDCC9','\uD806\uDCAA':'\uD806\uDCCA','\uD806\uDCAB':'\uD806\uDCCB','\uD806\uDCAC':'\uD806\uDCCC','\uD806\uDCAD':'\uD806\uDCCD','\uD806\uDCAE':'\uD806\uDCCE','\uD806\uDCAF':'\uD806\uDCCF','\uD806\uDCB0':'\uD806\uDCD0','\uD806\uDCB1':'\uD806\uDCD1','\uD806\uDCB2':'\uD806\uDCD2','\uD806\uDCB3':'\uD806\uDCD3','\uD806\uDCB4':'\uD806\uDCD4','\uD806\uDCB5':'\uD806\uDCD5','\uD806\uDCB6':'\uD806\uDCD6','\uD806\uDCB7':'\uD806\uDCD7','\uD806\uDCB8':'\uD806\uDCD8','\uD806\uDCB9':'\uD806\uDCD9','\uD806\uDCBA':'\uD806\uDCDA','\uD806\uDCBB':'\uD806\uDCDB','\uD806\uDCBC':'\uD806\uDCDC','\uD806\uDCBD':'\uD806\uDCDD','\uD806\uDCBE':'\uD806\uDCDE','\uD806\uDCBF':'\uD806\uDCDF','\xDF':'ss','\u0130':'i\u0307','\u0149':'\u02BCn','\u01F0':'j\u030C','\u0390':'\u03B9\u0308\u0301','\u03B0':'\u03C5\u0308\u0301','\u0587':'\u0565\u0582','\u1E96':'h\u0331','\u1E97':'t\u0308','\u1E98':'w\u030A','\u1E99':'y\u030A','\u1E9A':'a\u02BE','\u1E9E':'ss','\u1F50':'\u03C5\u0313','\u1F52':'\u03C5\u0313\u0300','\u1F54':'\u03C5\u0313\u0301','\u1F56':'\u03C5\u0313\u0342','\u1F80':'\u1F00\u03B9','\u1F81':'\u1F01\u03B9','\u1F82':'\u1F02\u03B9','\u1F83':'\u1F03\u03B9','\u1F84':'\u1F04\u03B9','\u1F85':'\u1F05\u03B9','\u1F86':'\u1F06\u03B9','\u1F87':'\u1F07\u03B9','\u1F88':'\u1F00\u03B9','\u1F89':'\u1F01\u03B9','\u1F8A':'\u1F02\u03B9','\u1F8B':'\u1F03\u03B9','\u1F8C':'\u1F04\u03B9','\u1F8D':'\u1F05\u03B9','\u1F8E':'\u1F06\u03B9','\u1F8F':'\u1F07\u03B9','\u1F90':'\u1F20\u03B9','\u1F91':'\u1F21\u03B9','\u1F92':'\u1F22\u03B9','\u1F93':'\u1F23\u03B9','\u1F94':'\u1F24\u03B9','\u1F95':'\u1F25\u03B9','\u1F96':'\u1F26\u03B9','\u1F97':'\u1F27\u03B9','\u1F98':'\u1F20\u03B9','\u1F99':'\u1F21\u03B9','\u1F9A':'\u1F22\u03B9','\u1F9B':'\u1F23\u03B9','\u1F9C':'\u1F24\u03B9','\u1F9D':'\u1F25\u03B9','\u1F9E':'\u1F26\u03B9','\u1F9F':'\u1F27\u03B9','\u1FA0':'\u1F60\u03B9','\u1FA1':'\u1F61\u03B9','\u1FA2':'\u1F62\u03B9','\u1FA3':'\u1F63\u03B9','\u1FA4':'\u1F64\u03B9','\u1FA5':'\u1F65\u03B9','\u1FA6':'\u1F66\u03B9','\u1FA7':'\u1F67\u03B9','\u1FA8':'\u1F60\u03B9','\u1FA9':'\u1F61\u03B9','\u1FAA':'\u1F62\u03B9','\u1FAB':'\u1F63\u03B9','\u1FAC':'\u1F64\u03B9','\u1FAD':'\u1F65\u03B9','\u1FAE':'\u1F66\u03B9','\u1FAF':'\u1F67\u03B9','\u1FB2':'\u1F70\u03B9','\u1FB3':'\u03B1\u03B9','\u1FB4':'\u03AC\u03B9','\u1FB6':'\u03B1\u0342','\u1FB7':'\u03B1\u0342\u03B9','\u1FBC':'\u03B1\u03B9','\u1FC2':'\u1F74\u03B9','\u1FC3':'\u03B7\u03B9','\u1FC4':'\u03AE\u03B9','\u1FC6':'\u03B7\u0342','\u1FC7':'\u03B7\u0342\u03B9','\u1FCC':'\u03B7\u03B9','\u1FD2':'\u03B9\u0308\u0300','\u1FD3':'\u03B9\u0308\u0301','\u1FD6':'\u03B9\u0342','\u1FD7':'\u03B9\u0308\u0342','\u1FE2':'\u03C5\u0308\u0300','\u1FE3':'\u03C5\u0308\u0301','\u1FE4':'\u03C1\u0313','\u1FE6':'\u03C5\u0342','\u1FE7':'\u03C5\u0308\u0342','\u1FF2':'\u1F7C\u03B9','\u1FF3':'\u03C9\u03B9','\u1FF4':'\u03CE\u03B9','\u1FF6':'\u03C9\u0342','\u1FF7':'\u03C9\u0342\u03B9','\u1FFC':'\u03C9\u03B9','\uFB00':'ff','\uFB01':'fi','\uFB02':'fl','\uFB03':'ffi','\uFB04':'ffl','\uFB05':'st','\uFB06':'st','\uFB13':'\u0574\u0576','\uFB14':'\u0574\u0565','\uFB15':'\u0574\u056B','\uFB16':'\u057E\u0576','\uFB17':'\u0574\u056D'};

// Normalize reference label: collapse internal whitespace
// to single space, remove leading/trailing whitespace, case fold.
module.exports = function(string) {
    return string.slice(1, string.length - 1).trim().replace(regex, function($0) {
        // Note: there is no need to check `hasOwnProperty($0)` here.
        // If character not found in lookup table, it must be whitespace.
        return map[$0] || ' ';
    });
};


/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// derived from https://github.com/mathiasbynens/String.fromCodePoint
/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
if (String.fromCodePoint) {
    module.exports = function (_) {
        try {
            return String.fromCodePoint(_);
        } catch (e) {
            if (e instanceof RangeError) {
                return String.fromCharCode(0xFFFD);
            }
            throw e;
        }
    };

} else {

  var stringFromCharCode = String.fromCharCode;
  var floor = Math.floor;
  var fromCodePoint = function() {
      var MAX_SIZE = 0x4000;
      var codeUnits = [];
      var highSurrogate;
      var lowSurrogate;
      var index = -1;
      var length = arguments.length;
      if (!length) {
          return '';
      }
      var result = '';
      while (++index < length) {
          var codePoint = Number(arguments[index]);
          if (
              !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                  codePoint < 0 || // not a valid Unicode code point
                  codePoint > 0x10FFFF || // not a valid Unicode code point
                  floor(codePoint) !== codePoint // not an integer
          ) {
              return String.fromCharCode(0xFFFD);
          }
          if (codePoint <= 0xFFFF) { // BMP code point
              codeUnits.push(codePoint);
          } else { // Astral code point; split in surrogate halves
              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
              codePoint -= 0x10000;
              highSurrogate = (codePoint >> 10) + 0xD800;
              lowSurrogate = (codePoint % 0x400) + 0xDC00;
              codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
          }
      }
      return result;
  };
  module.exports = fromCodePoint;
}


/***/ }),
/* 573 */
/***/ (function(module, exports) {

/*! http://mths.be/repeat v0.2.0 by @mathias */
if (!String.prototype.repeat) {
	(function() {
		'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var repeat = function(count) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			// `ToInteger`
			var n = count ? Number(count) : 0;
			if (n != n) { // better `isNaN`
				n = 0;
			}
			// Account for out-of-bounds indices
			if (n < 0 || n == Infinity) {
				throw RangeError();
			}
			var result = '';
			while (n) {
				if (n % 2 == 1) {
					result += string;
				}
				if (n > 1) {
					string += string;
				}
				n >>= 1;
			}
			return result;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'repeat', {
				'value': repeat,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.repeat = repeat;
		}
	}());
}


/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Renderer = __webpack_require__(286);

var reUnsafeProtocol = /^javascript:|vbscript:|file:|data:/i;
var reSafeDataProtocol = /^data:image\/(?:png|gif|jpeg|webp)/i;

var potentiallyUnsafe = function(url) {
  return reUnsafeProtocol.test(url) &&
      !reSafeDataProtocol.test(url);
};

// Helper function to produce an HTML tag.
function tag(name, attrs, selfclosing) {
  if (this.disableTags > 0) {
    return;
  }
  this.buffer += ('<' + name);
  if (attrs && attrs.length > 0) {
    var i = 0;
    var attrib;
    while ((attrib = attrs[i]) !== undefined) {
      this.buffer += (' ' + attrib[0] + '="' + attrib[1] + '"');
      i++;
    }
  }
  if (selfclosing) {
    this.buffer += ' /';
  }
  this.buffer += '>';
  this.lastOut = '>';
}

function HtmlRenderer(options) {
  options = options || {};
  // by default, soft breaks are rendered as newlines in HTML
  options.softbreak = options.softbreak || '\n';
  // set to "<br />" to make them hard breaks
  // set to " " if you want to ignore line wrapping in source

  this.disableTags = 0;
  this.lastOut = "\n";
  this.options = options;
}

/* Node methods */

function text(node) {
  this.out(node.literal);
}

function softbreak() {
  this.lit(this.options.softbreak);
}

function linebreak() {
  this.tag('br', [], true);
  this.cr();
}

function link(node, entering) {
  var attrs = this.attrs(node);
  if (entering) {
    if (!(this.options.safe && potentiallyUnsafe(node.destination))) {
      attrs.push(['href', this.esc(node.destination, true)]);
    }
    if (node.title) {
      attrs.push(['title', this.esc(node.title, true)]);
    }
    this.tag('a', attrs);
  } else {
    this.tag('/a');
  }
}

function image(node, entering) {
  if (entering) {
    if (this.disableTags === 0) {
      if (this.options.safe && potentiallyUnsafe(node.destination)) {
        this.lit('<img src="" alt="');
      } else {
        this.lit('<img src="' + this.esc(node.destination, true) +
            '" alt="');
      }
    }
    this.disableTags += 1;
  } else {
    this.disableTags -= 1;
    if (this.disableTags === 0) {
      if (node.title) {
        this.lit('" title="' + this.esc(node.title, true));
      }
      this.lit('" />');
    }
  }
}

function emph(node, entering) {
  this.tag(entering ? 'em' : '/em');
}

function strong(node, entering) {
  this.tag(entering ? 'strong' : '/strong');
}

function paragraph(node, entering) {
  var grandparent = node.parent.parent
    , attrs = this.attrs(node);
  if (grandparent !== null &&
    grandparent.type === 'list') {
    if (grandparent.listTight) {
      return;
    }
  }
  if (entering) {
    this.cr();
    this.tag('p', attrs);
  } else {
    this.tag('/p');
    this.cr();
  }
}

function heading(node, entering) {
  var tagname = 'h' + node.level
    , attrs = this.attrs(node);
  if (entering) {
    this.cr();
    this.tag(tagname, attrs);
  } else {
    this.tag('/' + tagname);
    this.cr();
  }
}

function code(node) {
  this.tag('code');
  this.out(node.literal);
  this.tag('/code');
}

function code_block(node) {
  var info_words = node.info ? node.info.split(/\s+/) : []
    , attrs = this.attrs(node);
  if (info_words.length > 0 && info_words[0].length > 0) {
    attrs.push(['class', 'language-' + this.esc(info_words[0], true)]);
  }
  this.cr();
  this.tag('pre');
  this.tag('code', attrs);
  this.out(node.literal);
  this.tag('/code');
  this.tag('/pre');
  this.cr();
}

function thematic_break(node) {
  var attrs = this.attrs(node);
  this.cr();
  this.tag('hr', attrs, true);
  this.cr();
}

function block_quote(node, entering) {
  var attrs = this.attrs(node);
  if (entering) {
    this.cr();
    this.tag('blockquote', attrs);
    this.cr();
  } else {
    this.cr();
    this.tag('/blockquote');
    this.cr();
  }
}

function list(node, entering) {
  var tagname = node.listType === 'bullet' ? 'ul' : 'ol'
    , attrs = this.attrs(node);

  if (entering) {
    var start = node.listStart;
    if (start !== null && start !== 1) {
      attrs.push(['start', start.toString()]);
    }
    this.cr();
    this.tag(tagname, attrs);
    this.cr();
  } else {
    this.cr();
    this.tag('/' + tagname);
    this.cr();
  }
}

function item(node, entering) {
  var attrs = this.attrs(node);
  if (entering) {
    this.tag('li', attrs);
  } else {
    this.tag('/li');
    this.cr();
  }
}

function html_inline(node) {
  if (this.options.safe) {
    this.lit('<!-- raw HTML omitted -->');
  } else {
    this.lit(node.literal);
  }
}

function html_block(node) {
  this.cr();
  if (this.options.safe) {
    this.lit('<!-- raw HTML omitted -->');
  } else {
    this.lit(node.literal);
  }
  this.cr();
}

function custom_inline(node, entering) {
  if (entering && node.onEnter) {
    this.lit(node.onEnter);
  } else if (!entering && node.onExit) {
    this.lit(node.onExit);
  }
}

function custom_block(node, entering) {
  this.cr();
  if (entering && node.onEnter) {
    this.lit(node.onEnter);
  } else if (!entering && node.onExit) {
    this.lit(node.onExit);
  }
  this.cr();
}

/* Helper methods */

function out(s) {
  this.lit(this.esc(s, false));
}

function attrs (node) {
  var att = [];
  if (this.options.sourcepos) {
    var pos = node.sourcepos;
    if (pos) {
      att.push(['data-sourcepos', String(pos[0][0]) + ':' +
        String(pos[0][1]) + '-' + String(pos[1][0]) + ':' +
        String(pos[1][1])]);
    }
  }
  return att;
}

// quick browser-compatible inheritance
HtmlRenderer.prototype = Object.create(Renderer.prototype);

HtmlRenderer.prototype.text = text;
HtmlRenderer.prototype.html_inline = html_inline;
HtmlRenderer.prototype.html_block = html_block;
HtmlRenderer.prototype.softbreak = softbreak;
HtmlRenderer.prototype.linebreak = linebreak;
HtmlRenderer.prototype.link = link;
HtmlRenderer.prototype.image = image;
HtmlRenderer.prototype.emph = emph;
HtmlRenderer.prototype.strong = strong;
HtmlRenderer.prototype.paragraph = paragraph;
HtmlRenderer.prototype.heading = heading;
HtmlRenderer.prototype.code = code;
HtmlRenderer.prototype.code_block = code_block;
HtmlRenderer.prototype.thematic_break = thematic_break;
HtmlRenderer.prototype.block_quote = block_quote;
HtmlRenderer.prototype.list = list;
HtmlRenderer.prototype.item = item;
HtmlRenderer.prototype.custom_inline = custom_inline;
HtmlRenderer.prototype.custom_block = custom_block;

HtmlRenderer.prototype.esc = __webpack_require__(61).escapeXml;

HtmlRenderer.prototype.out = out;
HtmlRenderer.prototype.tag = tag;
HtmlRenderer.prototype.attrs = attrs;

module.exports = HtmlRenderer;


/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Renderer = __webpack_require__(286);

var reXMLTag = /\<[^>]*\>/;

function toTagName(s) {
  return s.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}

function XmlRenderer(options) {
  options = options || {};

  this.disableTags = 0;
  this.lastOut = "\n";

  this.indentLevel = 0;
  this.indent = '  ';

  this.options = options;
}

function render(ast) {

  this.buffer = '';

  var attrs;
  var tagname;
  var walker = ast.walker();
  var event, node, entering;
  var container;
  var selfClosing;
  var nodetype;

  var options = this.options;

  if (options.time) { console.time("rendering"); }

  this.buffer += '<?xml version="1.0" encoding="UTF-8"?>\n';
  this.buffer += '<!DOCTYPE document SYSTEM "CommonMark.dtd">\n';

  while ((event = walker.next())) {
    entering = event.entering;
    node = event.node;
    nodetype = node.type;

    container = node.isContainer;

    selfClosing = nodetype === 'thematic_break'
      || nodetype === 'linebreak'
      || nodetype === 'softbreak';

    tagname = toTagName(nodetype);

    if (entering) {

        attrs = [];

        switch (nodetype) {
          case 'document':
            attrs.push(['xmlns', 'http://commonmark.org/xml/1.0']);
            break;
          case 'list':
            if (node.listType !== null) {
              attrs.push(['type', node.listType.toLowerCase()]);
            }
            if (node.listStart !== null) {
              attrs.push(['start', String(node.listStart)]);
            }
            if (node.listTight !== null) {
              attrs.push(['tight', (node.listTight ? 'true' : 'false')]);
            }
            var delim = node.listDelimiter;
            if (delim !== null) {
              var delimword = '';
              if (delim === '.') {
                delimword = 'period';
              } else {
                delimword = 'paren';
              }
              attrs.push(['delimiter', delimword]);
            }
            break;
          case 'code_block':
            if (node.info) {
              attrs.push(['info', node.info]);
            }
            break;
          case 'heading':
            attrs.push(['level', String(node.level)]);
            break;
          case 'link':
          case 'image':
            attrs.push(['destination', node.destination]);
            attrs.push(['title', node.title]);
            break;
          case 'custom_inline':
          case 'custom_block':
            attrs.push(['on_enter', node.onEnter]);
            attrs.push(['on_exit', node.onExit]);
            break;
          default:
            break;
        }
        if (options.sourcepos) {
          var pos = node.sourcepos;
          if (pos) {
            attrs.push(['sourcepos', String(pos[0][0]) + ':' +
              String(pos[0][1]) + '-' + String(pos[1][0]) + ':' +
              String(pos[1][1])]);
          }
        }

        this.cr();
        this.out(this.tag(tagname, attrs, selfClosing));
        if (container) {
          this.indentLevel += 1;
        } else if (!container && !selfClosing) {
          var lit = node.literal;
          if (lit) {
            this.out(this.esc(lit));
          }
          this.out(this.tag('/' + tagname));
        }
    } else {
      this.indentLevel -= 1;
      this.cr();
      this.out(this.tag('/' + tagname));
    }
  }
  if (options.time) { console.timeEnd("rendering"); }
  this.buffer += '\n';
  return this.buffer;
}

function out(s) {
  if(this.disableTags > 0) {
    this.buffer += s.replace(reXMLTag, '');
  }else{
    this.buffer += s;
  }
  this.lastOut = s;
}

function cr() {
  if(this.lastOut !== '\n') {
    this.buffer += '\n';
    this.lastOut = '\n';
    for(var i = this.indentLevel; i > 0; i--) {
      this.buffer += this.indent;
    }
  }
}

// Helper function to produce an XML tag.
function tag(name, attrs, selfclosing) {
  var result = '<' + name;
  if(attrs && attrs.length > 0) {
    var i = 0;
    var attrib;
    while ((attrib = attrs[i]) !== undefined) {
      result += ' ' + attrib[0] + '="' + this.esc(attrib[1]) + '"';
      i++;
    }
  }
  if(selfclosing) {
    result += ' /';
  }
  result += '>';
  return result;
}

// quick browser-compatible inheritance
XmlRenderer.prototype = Object.create(Renderer.prototype);

XmlRenderer.prototype.render = render;
XmlRenderer.prototype.out = out;
XmlRenderer.prototype.cr = cr;
XmlRenderer.prototype.tag = tag;
XmlRenderer.prototype.esc = __webpack_require__(61).escapeXml;

module.exports = XmlRenderer;


/***/ }),
/* 576 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_documentfragment__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__handlers__ = __webpack_require__(577);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */




class Renderer {
	render( ast ) {
		const walker = ast.walker();
		let event;
		let currentParent = null;

		while ( ( event = walker.next() ) ) {
			const node = event.node;
			const type = node.type;
			const isEntering = event.entering;
			const handler = __WEBPACK_IMPORTED_MODULE_1__handlers__["a" /* default */][ type ];

			// Skip nodes which we do not handle.
			if ( !handler ) {
				if ( isEntering ) {
					walker.resumeAt( node, false );
				}

				continue;
			} else {
				if ( isEntering ) {
					const newNode = handler( node, event, walker );

					if ( currentParent ) {
						currentParent.appendChildren( newNode );
					}

					if ( node.isContainer ) {
						currentParent = newNode;
					}
				} else {
					if ( currentParent.parent ) {
						currentParent = currentParent.parent;
					}
				}
			}
		}

		return currentParent || new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_documentfragment__["a" /* default */]();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Renderer;



/***/ }),
/* 577 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__document__ = __webpack_require__(578);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paragraph__ = __webpack_require__(579);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__block_quote__ = __webpack_require__(580);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__text__ = __webpack_require__(581);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__strong__ = __webpack_require__(582);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__emph__ = __webpack_require__(583);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__image__ = __webpack_require__(584);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__link__ = __webpack_require__(585);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__heading__ = __webpack_require__(586);
/* eslint-disable camelcase */
/* Need snake_case to match nodes in CM AST */











/* harmony default export */ __webpack_exports__["a"] = ({
	document: __WEBPACK_IMPORTED_MODULE_0__document__["a" /* default */],
	paragraph: __WEBPACK_IMPORTED_MODULE_1__paragraph__["a" /* default */],
	block_quote: __WEBPACK_IMPORTED_MODULE_2__block_quote__["a" /* default */],
	text: __WEBPACK_IMPORTED_MODULE_3__text__["a" /* default */],
	strong: __WEBPACK_IMPORTED_MODULE_4__strong__["a" /* default */],
	emph: __WEBPACK_IMPORTED_MODULE_5__emph__["a" /* default */],
	image: __WEBPACK_IMPORTED_MODULE_6__image__["a" /* default */],
	link: __WEBPACK_IMPORTED_MODULE_7__link__["a" /* default */],
	heading: __WEBPACK_IMPORTED_MODULE_8__heading__["a" /* default */]
});


/***/ }),
/* 578 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseDocument;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_documentfragment__ = __webpack_require__(70);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */



function parseDocument() {
	return new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_documentfragment__["a" /* default */]();
}


/***/ }),
/* 579 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseParagraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__ = __webpack_require__(9);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */



function parseParagraph() {
	return new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__["a" /* default */]( 'p' );
}


/***/ }),
/* 580 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseBlockQuote;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__ = __webpack_require__(9);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */



function parseBlockQuote() {
	return new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__["a" /* default */]( 'blockquote' );
}


/***/ }),
/* 581 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseText;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_text__ = __webpack_require__(21);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */



function parseText( node ) {
	return new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_text__["a" /* default */]( node.literal );
}


/***/ }),
/* 582 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseStrong;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__ = __webpack_require__(9);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */



function parseStrong() {
	return new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__["a" /* default */]( 'strong' );
}


/***/ }),
/* 583 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseEmph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__ = __webpack_require__(9);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */



function parseEmph() {
	return new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__["a" /* default */]( 'i' );
}


/***/ }),
/* 584 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseImage;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__ = __webpack_require__(9);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */



function parseImage( node, event, walker ) {
	const image = new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__["a" /* default */]( 'img', { src: node.destination } );
	const figure = new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__["a" /* default */]( 'figure', { class: 'image' }, image );

	const child = node.firstChild;

	// Parse text inside image and put it into alt.
	if ( child && child.type == 'text' ) {
		image.setAttribute( 'alt', child.literal );

		walker.resumeAt( child, false );
	}

	return figure;
}


/***/ }),
/* 585 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseLink;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_text__ = __webpack_require__(21);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */




function parseLink( node, event, walker ) {
	const link = new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__["a" /* default */]( 'a', { href: node.destination } );
	const child = node.firstChild;
	const text = new __WEBPACK_IMPORTED_MODULE_1__ckeditor_ckeditor5_engine_src_view_text__["a" /* default */]( '' );

	// Parse text inside image and put it into alt.
	if ( child && child.type == 'text' ) {
		text.data = child.literal;

		walker.resumeAt( child, false );
	}

	link.appendChildren( text );
	return link;
}


/***/ }),
/* 586 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseHeading;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__ = __webpack_require__(9);
/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */



function parseHeading( node ) {
	return new __WEBPACK_IMPORTED_MODULE_0__ckeditor_ckeditor5_engine_src_view_element__["a" /* default */]( 'h' + node.level );
}


/***/ }),
/* 587 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return gfm; });
/* unused harmony export highlightedCodeBlock */
/* unused harmony export strikethrough */
/* unused harmony export tables */
/* unused harmony export taskListItems */
var highlightRegExp = /highlight-(?:text|source)-([a-z0-9]+)/;

function highlightedCodeBlock (turndownService) {
  turndownService.addRule('highlightedCodeBlock', {
    filter: function (node) {
      var firstChild = node.firstChild;
      return (
        node.nodeName === 'DIV' &&
        highlightRegExp.test(node.className) &&
        firstChild &&
        firstChild.nodeName === 'PRE'
      )
    },
    replacement: function (content, node, options) {
      var className = node.className || '';
      var language = (className.match(highlightRegExp) || [null, ''])[1];

      return (
        '\n\n' + options.fence + language + '\n' +
        node.firstChild.textContent +
        '\n' + options.fence + '\n\n'
      )
    }
  });
}

function strikethrough (turndownService) {
  turndownService.addRule('strikethrough', {
    filter: ['del', 's', 'strike'],
    replacement: function (content) {
      return '~' + content + '~'
    }
  });
}

var indexOf = Array.prototype.indexOf;
var every = Array.prototype.every;
var rules = {};

rules.tableCell = {
  filter: ['th', 'td'],
  replacement: function (content, node) {
    return cell(content, node)
  }
};

rules.tableRow = {
  filter: 'tr',
  replacement: function (content, node) {
    var borderCells = '';
    var alignMap = { left: ':--', right: '--:', center: ':-:' };

    if (isHeadingRow(node)) {
      for (var i = 0; i < node.childNodes.length; i++) {
        var border = '---';
        var align = (
          node.childNodes[i].getAttribute('align') || ''
        ).toLowerCase();

        if (align) border = alignMap[align] || border;

        borderCells += cell(border, node.childNodes[i]);
      }
    }
    return '\n' + content + (borderCells ? '\n' + borderCells : '')
  }
};

rules.table = {
  filter: 'table',
  replacement: function (content) {
    // Ensure there are no blank lines
    content = content.replace('\n\n', '\n');
    return '\n\n' + content + '\n\n'
  }
};

rules.tableSection = {
  filter: ['thead', 'tbody', 'tfoot'],
  replacement: function (content) {
    return content
  }
};

// A tr is a heading row if:
// - the parent is a THEAD
// - or if its the first child of the TABLE or the first TBODY (possibly
//   following a blank THEAD)
// - and every cell is a TH
function isHeadingRow (tr) {
  var parentNode = tr.parentNode;
  return (
    parentNode.nodeName === 'THEAD' ||
    (
      parentNode.firstChild === tr &&
      (parentNode.nodeName === 'TABLE' || isFirstTbody(parentNode)) &&
      every.call(tr.childNodes, function (n) { return n.nodeName === 'TH' })
    )
  )
}

function isFirstTbody (element) {
  var previousSibling = element.previousSibling;
  return (
    element.nodeName === 'TBODY' && (
      !previousSibling ||
      (
        previousSibling.nodeName === 'THEAD' &&
        /^\s*$/i.test(previousSibling.textContent)
      )
    )
  )
}

function cell (content, node) {
  var index = indexOf.call(node.parentNode.childNodes, node);
  var prefix = ' ';
  if (index === 0) prefix = '| ';
  return prefix + content + ' |'
}

function tables (turndownService) {
  for (var key in rules) turndownService.addRule(key, rules[key]);
}

function taskListItems (turndownService) {
  turndownService.addRule('taskListItems', {
    filter: function (node) {
      return node.type === 'checkbox' && node.parentNode.nodeName === 'LI'
    },
    replacement: function (content, node) {
      return (node.checked ? '[x]' : '[ ]') + ' '
    }
  });
}

function gfm (turndownService) {
  turndownService.use([
    highlightedCodeBlock,
    strikethrough,
    tables,
    taskListItems
  ]);
}




/***/ }),
/* 588 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function extend (destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key)) destination[key] = source[key];
    }
  }
  return destination
}

function repeat (character, count) {
  return Array(count + 1).join(character)
}

var blockElements = [
  'address', 'article', 'aside', 'audio', 'blockquote', 'body', 'canvas',
  'center', 'dd', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption',
  'figure', 'footer', 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
  'header', 'hgroup', 'hr', 'html', 'isindex', 'li', 'main', 'menu', 'nav',
  'noframes', 'noscript', 'ol', 'output', 'p', 'pre', 'section', 'table',
  'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'ul'
];

function isBlock (node) {
  return blockElements.indexOf(node.nodeName.toLowerCase()) !== -1
}

var voidElements = [
  'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input',
  'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'
];

function isVoid (node) {
  return voidElements.indexOf(node.nodeName.toLowerCase()) !== -1
}

var voidSelector = voidElements.join();
function hasVoid (node) {
  return node.querySelector && node.querySelector(voidSelector)
}

var rules = {};

rules.paragraph = {
  filter: 'p',

  replacement: function (content) {
    return '\n\n' + content + '\n\n'
  }
};

rules.lineBreak = {
  filter: 'br',

  replacement: function (content, node, options) {
    return options.br + '\n'
  }
};

rules.heading = {
  filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],

  replacement: function (content, node, options) {
    var hLevel = Number(node.nodeName.charAt(1));

    if (options.headingStyle === 'setext' && hLevel < 3) {
      var underline = repeat((hLevel === 1 ? '=' : '-'), content.length);
      return (
        '\n\n' + content + '\n' + underline + '\n\n'
      )
    } else {
      return '\n\n' + repeat('#', hLevel) + ' ' + content + '\n\n'
    }
  }
};

rules.blockquote = {
  filter: 'blockquote',

  replacement: function (content) {
    content = content.replace(/^\n+|\n+$/g, '');
    content = content.replace(/^/gm, '> ');
    return '\n\n' + content + '\n\n'
  }
};

rules.list = {
  filter: ['ul', 'ol'],

  replacement: function (content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === 'LI' && parent.lastElementChild === node) {
      return '\n' + content
    } else {
      return '\n\n' + content + '\n\n'
    }
  }
};

rules.listItem = {
  filter: 'li',

  replacement: function (content, node, options) {
    content = content
      .replace(/^\n+/, '') // remove leading newlines
      .replace(/\n+$/, '\n') // replace trailing newlines with just a single one
      .replace(/\n/gm, '\n    '); // indent
    var prefix = options.bulletListMarker + '   ';
    var parent = node.parentNode;
    if (parent.nodeName === 'OL') {
      var start = parent.getAttribute('start');
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start ? Number(start) + index : index + 1) + '.  ';
    }
    return (
      prefix + content + (node.nextSibling && !/\n$/.test(content) ? '\n' : '')
    )
  }
};

rules.indentedCodeBlock = {
  filter: function (node, options) {
    return (
      options.codeBlockStyle === 'indented' &&
      node.nodeName === 'PRE' &&
      node.firstChild &&
      node.firstChild.nodeName === 'CODE'
    )
  },

  replacement: function (content, node, options) {
    return (
      '\n\n    ' +
      node.firstChild.textContent.replace(/\n/g, '\n    ') +
      '\n\n'
    )
  }
};

rules.fencedCodeBlock = {
  filter: function (node, options) {
    return (
      options.codeBlockStyle === 'fenced' &&
      node.nodeName === 'PRE' &&
      node.firstChild &&
      node.firstChild.nodeName === 'CODE'
    )
  },

  replacement: function (content, node, options) {
    var className = node.firstChild.className || '';
    var language = (className.match(/language-(\S+)/) || [null, ''])[1];

    return (
      '\n\n' + options.fence + language + '\n' +
      node.firstChild.textContent +
      '\n' + options.fence + '\n\n'
    )
  }
};

rules.horizontalRule = {
  filter: 'hr',

  replacement: function (content, node, options) {
    return '\n\n' + options.hr + '\n\n'
  }
};

rules.inlineLink = {
  filter: function (node, options) {
    return (
      options.linkStyle === 'inlined' &&
      node.nodeName === 'A' &&
      node.getAttribute('href')
    )
  },

  replacement: function (content, node) {
    var href = node.getAttribute('href');
    var title = node.title ? ' "' + node.title + '"' : '';
    return '[' + content + '](' + href + title + ')'
  }
};

rules.referenceLink = {
  filter: function (node, options) {
    return (
      options.linkStyle === 'referenced' &&
      node.nodeName === 'A' &&
      node.getAttribute('href')
    )
  },

  replacement: function (content, node, options) {
    var href = node.getAttribute('href');
    var title = node.title ? ' "' + node.title + '"' : '';
    var replacement;
    var reference;

    switch (options.linkReferenceStyle) {
      case 'collapsed':
        replacement = '[' + content + '][]';
        reference = '[' + content + ']: ' + href + title;
        break
      case 'shortcut':
        replacement = '[' + content + ']';
        reference = '[' + content + ']: ' + href + title;
        break
      default:
        var id = this.references.length + 1;
        replacement = '[' + content + '][' + id + ']';
        reference = '[' + id + ']: ' + href + title;
    }

    this.references.push(reference);
    return replacement
  },

  references: [],

  append: function (options) {
    var references = '';
    if (this.references.length) {
      references = '\n\n' + this.references.join('\n') + '\n\n';
      this.references = []; // Reset references
    }
    return references
  }
};

rules.emphasis = {
  filter: ['em', 'i'],

  replacement: function (content, node, options) {
    if (!content.trim()) return ''
    return options.emDelimiter + content + options.emDelimiter
  }
};

rules.strong = {
  filter: ['strong', 'b'],

  replacement: function (content, node, options) {
    if (!content.trim()) return ''
    return options.strongDelimiter + content + options.strongDelimiter
  }
};

rules.code = {
  filter: function (node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings;

    return node.nodeName === 'CODE' && !isCodeBlock
  },

  replacement: function (content) {
    if (!content.trim()) return ''

    var delimiter = '`';
    var leadingSpace = '';
    var trailingSpace = '';
    var matches = content.match(/`+/gm);
    if (matches) {
      if (/^`/.test(content)) leadingSpace = ' ';
      if (/`$/.test(content)) trailingSpace = ' ';
      while (matches.indexOf(delimiter) !== -1) delimiter = delimiter + '`';
    }

    return delimiter + leadingSpace + content + trailingSpace + delimiter
  }
};

rules.image = {
  filter: 'img',

  replacement: function (content, node) {
    var alt = node.alt || '';
    var src = node.getAttribute('src') || '';
    var title = node.title || '';
    var titlePart = title ? ' "' + title + '"' : '';
    return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : ''
  }
};

/**
 * Manages a collection of rules used to convert HTML to Markdown
 */

function Rules (options) {
  this.options = options;
  this._keep = [];
  this._remove = [];

  this.blankRule = {
    replacement: options.blankReplacement
  };

  this.keepReplacement = options.keepReplacement;

  this.defaultRule = {
    replacement: options.defaultReplacement
  };

  this.array = [];
  for (var key in options.rules) this.array.push(options.rules[key]);
}

Rules.prototype = {
  add: function (key, rule) {
    this.array.unshift(rule);
  },

  keep: function (filter) {
    this._keep.unshift({
      filter: filter,
      replacement: this.keepReplacement
    });
  },

  remove: function (filter) {
    this._remove.unshift({
      filter: filter,
      replacement: function () {
        return ''
      }
    });
  },

  forNode: function (node) {
    if (node.isBlank) return this.blankRule
    var rule;

    if ((rule = findRule(this.array, node, this.options))) return rule
    if ((rule = findRule(this._keep, node, this.options))) return rule
    if ((rule = findRule(this._remove, node, this.options))) return rule

    return this.defaultRule
  },

  forEach: function (fn) {
    for (var i = 0; i < this.array.length; i++) fn(this.array[i], i);
  }
};

function findRule (rules, node, options) {
  for (var i = 0; i < rules.length; i++) {
    var rule = rules[i];
    if (filterValue(rule, node, options)) return rule
  }
  return void 0
}

function filterValue (rule, node, options) {
  var filter = rule.filter;
  if (typeof filter === 'string') {
    if (filter === node.nodeName.toLowerCase()) return true
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true
  } else if (typeof filter === 'function') {
    if (filter.call(rule, node, options)) return true
  } else {
    throw new TypeError('`filter` needs to be a string, array, or function')
  }
}

/**
 * The collapseWhitespace function is adapted from collapse-whitespace
 * by Luc Thevenard.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Luc Thevenard <lucthevenard@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * collapseWhitespace(options) removes extraneous whitespace from an the given element.
 *
 * @param {Object} options
 */
function collapseWhitespace (options) {
  var element = options.element;
  var isBlock = options.isBlock;
  var isVoid = options.isVoid;
  var isPre = options.isPre || function (node) {
    return node.nodeName === 'PRE'
  };

  if (!element.firstChild || isPre(element)) return

  var prevText = null;
  var prevVoid = false;

  var prev = null;
  var node = next(prev, element, isPre);

  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) { // Node.TEXT_NODE or Node.CDATA_SECTION_NODE
      var text = node.data.replace(/[ \r\n\t]+/g, ' ');

      if ((!prevText || / $/.test(prevText.data)) &&
          !prevVoid && text[0] === ' ') {
        text = text.substr(1);
      }

      // `text` might be empty at this point.
      if (!text) {
        node = remove(node);
        continue
      }

      node.data = text;

      prevText = node;
    } else if (node.nodeType === 1) { // Node.ELEMENT_NODE
      if (isBlock(node) || node.nodeName === 'BR') {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, '');
        }

        prevText = null;
        prevVoid = false;
      } else if (isVoid(node)) {
        // Avoid trimming space around non-block, non-BR void elements.
        prevText = null;
        prevVoid = true;
      }
    } else {
      node = remove(node);
      continue
    }

    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }

  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, '');
    if (!prevText.data) {
      remove(prevText);
    }
  }
}

/**
 * remove(node) removes the given node from the DOM and returns the
 * next node in the sequence.
 *
 * @param {Node} node
 * @return {Node} node
 */
function remove (node) {
  var next = node.nextSibling || node.parentNode;

  node.parentNode.removeChild(node);

  return next
}

/**
 * next(prev, current, isPre) returns the next node in the sequence, given the
 * current and previous nodes.
 *
 * @param {Node} prev
 * @param {Node} current
 * @param {Function} isPre
 * @return {Node}
 */
function next (prev, current, isPre) {
  if ((prev && prev.parentNode === current) || isPre(current)) {
    return current.nextSibling || current.parentNode
  }

  return current.firstChild || current.nextSibling || current.parentNode
}

/*
 * Set up window for Node.js
 */

var root = (typeof window !== 'undefined' ? window : {});

/*
 * Parsing HTML strings
 */

function canParseHTMLNatively () {
  var Parser = root.DOMParser;
  var canParse = false;

  // Adapted from https://gist.github.com/1129031
  // Firefox/Opera/IE throw errors on unsupported types
  try {
    // WebKit returns null on unsupported types
    if (new Parser().parseFromString('', 'text/html')) {
      canParse = true;
    }
  } catch (e) {}

  return canParse
}

function createHTMLParser () {
  var Parser = function () {};

  {
    var JSDOM = __webpack_require__(589).JSDOM;
    Parser.prototype.parseFromString = function (string) {
      return new JSDOM(string).window.document
    };
  }
  return Parser
}

var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();

function RootNode (input) {
  var root;
  if (typeof input === 'string') {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + '</x-turndown>',
      'text/html'
    );
    root = doc.getElementById('turndown-root');
  } else {
    root = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root,
    isBlock: isBlock,
    isVoid: isVoid
  });

  return root
}

var _htmlParser;
function htmlParser () {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser
}

function Node (node) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName.toLowerCase() === 'code' || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node);
  return node
}

function isBlank (node) {
  return (
    ['A', 'TH', 'TD'].indexOf(node.nodeName) === -1 &&
    /^\s*$/i.test(node.textContent) &&
    !isVoid(node) &&
    !hasVoid(node)
  )
}

function flankingWhitespace (node) {
  var leading = '';
  var trailing = '';

  if (!node.isBlock) {
    var hasLeading = /^[ \r\n\t]/.test(node.textContent);
    var hasTrailing = /[ \r\n\t]$/.test(node.textContent);

    if (hasLeading && !isFlankedByWhitespace('left', node)) {
      leading = ' ';
    }
    if (hasTrailing && !isFlankedByWhitespace('right', node)) {
      trailing = ' ';
    }
  }

  return { leading: leading, trailing: trailing }
}

function isFlankedByWhitespace (side, node) {
  var sibling;
  var regExp;
  var isFlanked;

  if (side === 'left') {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }

  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked
}

var reduce = Array.prototype.reduce;
var leadingNewLinesRegExp = /^\n*/;
var trailingNewLinesRegExp = /\n*$/;

function TurndownService (options) {
  if (!(this instanceof TurndownService)) return new TurndownService(options)

  var defaults = {
    rules: rules,
    headingStyle: 'setext',
    hr: '* * *',
    bulletListMarker: '*',
    codeBlockStyle: 'indented',
    fence: '```',
    emDelimiter: '_',
    strongDelimiter: '**',
    linkStyle: 'inlined',
    linkReferenceStyle: 'full',
    br: '  ',
    blankReplacement: function (content, node) {
      return node.isBlock ? '\n\n' : ''
    },
    keepReplacement: function (content, node) {
      return node.isBlock ? '\n\n' + node.outerHTML + '\n\n' : node.outerHTML
    },
    defaultReplacement: function (content, node) {
      return node.isBlock ? '\n\n' + content + '\n\n' : content
    }
  };
  this.options = extend({}, defaults, options);
  this.rules = new Rules(this.options);
}

TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */

  turndown: function (input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + ' is not a string, or an element/document/fragment node.'
      )
    }

    if (input === '') return ''

    var output = process.call(this, new RootNode(input));
    return postProcess.call(this, output)
  },

  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */

  use: function (plugin) {
    if (Array.isArray(plugin)) {
      for (var i = 0; i < plugin.length; i++) this.use(plugin[i]);
    } else if (typeof plugin === 'function') {
      plugin(this);
    } else {
      throw new TypeError('plugin must be a Function or an Array of Functions')
    }
    return this
  },

  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */

  addRule: function (key, rule) {
    this.rules.add(key, rule);
    return this
  },

  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */

  keep: function (filter) {
    this.rules.keep(filter);
    return this
  },

  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */

  remove: function (filter) {
    this.rules.remove(filter);
    return this
  },

  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */

  escape: function (string) {
    return (
      string
        // Escape backslash escapes!
        .replace(/\\(\S)/g, '\\\\$1')

        // Escape headings
        .replace(/^(#{1,6} )/gm, '\\$1')

        // Escape hr
        .replace(/^([-*_] *){3,}$/gm, function (match, character) {
          return match.split(character).join('\\' + character)
        })

        // Escape ol bullet points
        .replace(/^(\W* {0,3})(\d+)\. /gm, '$1$2\\. ')

        // Escape ul bullet points
        .replace(/^([^\\\w]*)[*+-] /gm, function (match) {
          return match.replace(/([*+-])/g, '\\$1')
        })

        // Escape blockquote indents
        .replace(/^(\W* {0,3})> /gm, '$1\\> ')

        // Escape em/strong *
        .replace(/\*+(?![*\s\W]).+?\*+/g, function (match) {
          return match.replace(/\*/g, '\\*')
        })

        // Escape em/strong _
        .replace(/_+(?![_\s\W]).+?_+/g, function (match) {
          return match.replace(/_/g, '\\_')
        })

        // Escape code _
        .replace(/`+(?![`\s\W]).+?`+/g, function (match) {
          return match.replace(/`/g, '\\`')
        })

        // Escape link brackets
        .replace(/[\[\]]/g, '\\$&') // eslint-disable-line no-useless-escape
    )
  }
};

/**
 * Reduces a DOM node down to its Markdown string equivalent
 * @private
 * @param {HTMLElement} parentNode The node to convert
 * @returns A Markdown representation of the node
 * @type String
 */

function process (parentNode) {
  var self = this;
  return reduce.call(parentNode.childNodes, function (output, node) {
    node = new Node(node);

    var replacement = '';
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self, node);
    }

    return join(output, replacement)
  }, '')
}

/**
 * Appends strings as each rule requires and trims the output
 * @private
 * @param {String} output The conversion output
 * @returns A trimmed version of the ouput
 * @type String
 */

function postProcess (output) {
  var self = this;
  this.rules.forEach(function (rule) {
    if (typeof rule.append === 'function') {
      output = join(output, rule.append(self.options));
    }
  });

  return output.replace(/^[\t\r\n]+/, '').replace(/[\t\r\n\s]+$/, '')
}

/**
 * Converts an element node to its Markdown equivalent
 * @private
 * @param {HTMLElement} node The node to convert
 * @returns A Markdown representation of the node
 * @type String
 */

function replacementForNode (node) {
  var rule = this.rules.forNode(node);
  var content = process.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing) content = content.trim();
  return (
    whitespace.leading +
    rule.replacement(content, node, this.options) +
    whitespace.trailing
  )
}

/**
 * Determines the new lines between the current output and the replacement
 * @private
 * @param {String} output The current conversion output
 * @param {String} replacement The string to append to the output
 * @returns The whitespace to separate the current output and the replacement
 * @type String
 */

function separatingNewlines (output, replacement) {
  var newlines = [
    output.match(trailingNewLinesRegExp)[0],
    replacement.match(leadingNewLinesRegExp)[0]
  ].sort();
  var maxNewlines = newlines[newlines.length - 1];
  return maxNewlines.length < 2 ? maxNewlines : '\n\n'
}

function join (string1, string2) {
  var separator = separatingNewlines(string1, string2);

  // Remove trailing/leading newlines and replace with separator
  string1 = string1.replace(trailingNewLinesRegExp, '');
  string2 = string2.replace(leadingNewLinesRegExp, '');

  return string1 + separator + string2
}

/**
 * Determines whether an input can be converted
 * @private
 * @param {String|HTMLElement} input Describe this parameter
 * @returns Describe what it returns
 * @type String|Object|Array|Boolean|Number
 */

function canConvert (input) {
  return (
    input != null && (
      typeof input === 'string' ||
      (input.nodeType && (
        input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11
      ))
    )
  )
}

/* harmony default export */ __webpack_exports__["a"] = (TurndownService);


/***/ }),
/* 589 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })
/******/ ]);